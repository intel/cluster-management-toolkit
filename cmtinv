#! /bin/sh
# vim: filetype=python
# pylint: disable-next=anomalous-backslash-in-string,line-too-long
''''eval version=$( ls /usr/bin/python3.* | grep '.*[0-9]$' | sort -nr -k2 -t. | head -n1 ) && version=${version##/usr/bin/python3.} && [ ${version} ] && [ ${version} -ge 8 ] && exec /usr/bin/python3.${version} "$0" "$@" || exec /usr/bin/env python3 "$0" "$@"' #'''
__doc__ = "The above hack is to handle distros that don't have /usr/bin/python3 point to the latest version of python3 they provide"
# Requires: python3 (>= 3.8)
# Requires: python3-natsort
#
# Copyright the Cluster Management Toolkit for Kubernetes contributors.
# SPDX-License-Identifier: MIT

"""
This program is used to query or modify the Ansible inventory

For usage, see:
	cmtinv help
"""

import errno
import os
from pathlib import Path, PurePath
import re
import sys
from typing import cast, Dict, List, Optional, Tuple
try:
	import yaml
except ModuleNotFoundError:  # pragma: no cover
	sys.exit("ModuleNotFoundError: Could not import yaml; you may need to (re-)run `cmt-install` or `pip3 install PyYAML`; aborting.")

try:
	from natsort import natsorted
except ModuleNotFoundError:  # pragma: no cover
	sys.exit("ModuleNotFoundError: Could not import natsort; you may need to (re-)run `cmt-install` or `pip3 install natsort`; aborting.")

from cmttypes import deep_get, deep_get_with_fallback, DictPath, FilePath, FilePathAuditError, ProgrammingError, UnknownError
from cmtpaths import ANSIBLE_PLAYBOOK_DIR, HOMEDIR, SSH_DIR
from cmtpaths import DEFAULT_THEME_FILE, KUBE_CONFIG_FILE

import cmtio
import cmtio_yaml

from commandparser import parse_commandline

from ansible_helper import ansible_configuration, ansible_get_inventory_pretty, ansible_get_inventory_dict, ansible_get_groups
from ansible_helper import ansible_get_groups_by_host, ansible_get_hosts_by_group, ansible_add_hosts
from ansible_helper import ansible_remove_hosts, ansible_remove_groups, ansible_set_vars
from ansible_helper import ansible_set_hostvars, ansible_set_groupvars, ansible_unset_hostvars
from ansible_helper import ansible_unset_groupvars, ansible_create_groups, ansible_ping, ansible_print_play_results, ansible_run_playbook_on_selection
from ansible_helper import ANSIBLE_INVENTORY

import cmtlib
from cmtlib import read_cmtconfig

import checks

from ansithemeprint import ANSIThemeString, ansithemeprint, ansithemestring_join_tuple_list

import about
PROGRAMDESCRIPTION = "Query or modify the host inventory"
PROGRAMAUTHORS = "Written by David Weinehall."

def set_host_vars(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Set host-specific variables

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): Comma-separated list of key:value pairs, followed by comma-separated list of hosts
		Returns:
			0
	"""

	del options

	hostvars = []

	hosts = args[1].split(",")
	keyvals = args[0].split(",")

	for keyval in keyvals:
		try:
			key, value = keyval.split(":")
		except ValueError:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": Setting a variable requires a ", "default"),
					ANSIThemeString("KEY", "argument"),
					ANSIThemeString(":", "separator"),
					ANSIThemeString("VALUE ", "argument"),
					ANSIThemeString("pair.", "default")], stderr = True)
			print()
			ansithemeprint([ANSIThemeString("Try “", "default"),
					ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME} ", "programname"),
					ANSIThemeString("help", "command"),
					ANSIThemeString("“ for more information.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		hostvars.append((key, value))

	# Set vars
	if len(hostvars) > 0:
		retval = ansible_set_hostvars(inventory = ANSIBLE_INVENTORY, hosts = hosts, hostvars = hostvars)
		if not retval:
			raise ProgrammingError(f"Failed to set vars for hosts {hosts}")

	return 0

def set_group_vars(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Set group-specific variables

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): Comma-separated list of key:value pairs, followed by comma-separated list of groups
		Returns:
			0
	"""

	del options

	groupvars = []

	groups = args[1].split(",")
	keyvals = args[0].split(",")

	for keyval in keyvals:
		try:
			key, value = keyval.split(":")
		except ValueError:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": Setting a variable requires a ", "default"),
					ANSIThemeString("KEY", "argument"),
					ANSIThemeString(":", "separator"),
					ANSIThemeString("VALUE ", "argument"),
					ANSIThemeString("pair.", "default")], stderr = True)
			print()
			ansithemeprint([ANSIThemeString("Try “", "default"),
					ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME} ", "programname"),
					ANSIThemeString("help", "command"),
					ANSIThemeString("“ for more information.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		groupvars.append((key, value))

	# Set vars
	if len(groupvars) > 0:
		retval = ansible_set_groupvars(inventory = ANSIBLE_INVENTORY, groups = groups, groupvars = groupvars)
		if not retval:
			raise ProgrammingError(f"Failed to set vars for groups {groups}")

	return 0

def set_global_vars(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Set global variables

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): Comma-separated list of key:value pairs
		Returns:
			Return value from set_group_vars()
	"""

	return set_group_vars(options = options, args = [args[0], "all"])

def unset_host_vars(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Unset host-specific variables

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): Comma-separated list of keys, followed by comma-separated list of hosts
		Returns:
			0
	"""

	del options

	hosts = args[1].split(",")
	hostvars = args[0].split(",")

	# Unset vars
	if len(hostvars) > 0:
		retval = ansible_unset_hostvars(inventory = ANSIBLE_INVENTORY, hosts = hosts, hostvars = hostvars)
		if not retval:
			raise ProgrammingError(f"Failed to unset vars for hosts {hosts}")

	return 0

def unset_group_vars(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Unset group-specific variables

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): Comma-separated list of keys, followed by comma-separated list of groups
		Returns:
			0
	"""

	del options

	groups = args[1].split(",")
	groupvars = args[0].split(",")

	# Unset vars
	if len(groupvars) > 0:
		retval = ansible_unset_groupvars(inventory = ANSIBLE_INVENTORY, groups = groups, groupvars = groupvars)
		if not retval:
			raise ProgrammingError(f"Failed to unset vars for groups {groups}")

	return 0

def unset_global_vars(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Unset global variables

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): Comma-separated list of keys
		Returns:
			Return value from unset_group_vars()
	"""
	return unset_group_vars(options = options, args = [args[0], "all"])

def add_groups(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Add groups

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Comma-separated list of groups
		Returns:
			0
	"""

	groupvars = []

	groups = args[0].split(",")

	# We should not try to add "all" (it may cause unexpected issues with variables)
	if "all" in groups:
		ansithemeprint([ANSIThemeString("Warning", "warning"),
				ANSIThemeString(": Ignoring attempt to add group “", "default"),
				ANSIThemeString("all", "argument"),
				ANSIThemeString("“.", "default")], stderr = True)
		groups.remove("all")
		if len(groups) == 0:
			return 0

	for opt, optarg in options:
		if opt == "--vars":
			tmp = optarg.split(",")
			for var in tmp:
				key, value = var.split(":")
				groupvars.append((key, value))

	# Add the groups
	retval = ansible_create_groups(inventory = ANSIBLE_INVENTORY, groups = groups)

	if not retval:
		raise ProgrammingError(f"Failed to add {groups} to inventory")

	# Set vars
	if len(groupvars) > 0:
		retval = ansible_set_groupvars(inventory = ANSIBLE_INVENTORY, groups = groups, groupvars = groupvars)
		if not retval:
			raise ProgrammingError(f"Failed to set vars {groupvars} for groups {groups}")

	return 0

def add_hosts(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Add hosts

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Comma-separated list of hosts
		Returns:
			0
	"""

	groups = []
	hostvars = []

	hosts = args[0].split(",")

	if len(args) > 1:
		groups = args[1].split(",")

	for opt, optarg in options:
		if opt == "--vars":
			tmp = optarg.split(",")
			for var in tmp:
				key, value = var.split(":")
				hostvars.append((key, value))
		elif opt == "--groups":
			if len(groups) > 0:
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": Invalid option; “", "default"),
						ANSIThemeString(f"{opt}", "option"),
						ANSIThemeString("“ cannot be used with ", "default"),
						ANSIThemeString("HOST", "argument"),
						ANSIThemeString(",", "separator"),
						ANSIThemeString("... ", "argument"),
						ANSIThemeString("GROUP", "argument"),
						ANSIThemeString(",", "separator"),
						ANSIThemeString("... ", "argument"),
						ANSIThemeString("syntax.", "default")], stderr = True)
				print()
				ansithemeprint([ANSIThemeString("Try “", "default"),
						ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME} ", "programname"),
						ANSIThemeString("help", "command"),
						ANSIThemeString("“ for more information.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
			groups = optarg.split(",")

	retval = True
	# Add the host to every specified group
	if len(groups) == 0:
		retval = ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = hosts, skip_all = False)

		if not retval:
			raise ProgrammingError(f"Failed to add {hosts}")
	else:
		group = ""

		for group in groups:
			retval = ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = hosts, group = group, skip_all = False)

		if not retval:
			raise ProgrammingError(f"Failed to add {hosts} to group {group}")

	# Set vars
	if len(hostvars) > 0:
		retval = ansible_set_hostvars(inventory = ANSIBLE_INVENTORY, hosts = hosts, hostvars = hostvars)
		if not retval:
			raise ProgrammingError(f"Failed to set vars for hosts {hosts}")

	return 0

def format_members(group: str, members: List[str]) -> List[ANSIThemeString]:
	"""
	Format a list of group members as a themearray

		Parameters:
			group (str): The name of the group
			members (list[str]): A list of hostnames
		Returns:
			formatted (list[ANSIThemeString]): A themearray
	"""

	formatted = [ANSIThemeString(f"{group}: ", "default")]
	i = 0
	for i, member in enumerate(members):
		if i < len(members) - 1:
			formatted += [ANSIThemeString(member, "yaml_key"),
				      ANSIThemeString(", ", "separator")]
		else:
			formatted += [ANSIThemeString(member, "yaml_key")]

	return formatted

def remove_groups(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Remove groups

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Comma-separated list of groups
		Returns:
			0
	"""

	extrahosts = []
	forceneeded = False
	force = False

	groups = args[0].split(",")

	for opt, _optarg in options:
		if opt == "--force":
			force = True

	if "all" in groups:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": The group “", "default"),
				ANSIThemeString("all", "argument"),
				ANSIThemeString("“ cannot be removed.", "default")], stderr = True)
		print()
		ansithemeprint([ANSIThemeString("Try “", "default"),
				ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME} ", "programname"),
				ANSIThemeString("help", "command"),
				ANSIThemeString("“ for more information.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for group in groups:
		grouphosts = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, group)
		if len(grouphosts) > 0:
			forceneeded = True
			extrahosts.append((group, grouphosts))

	if forceneeded and not force:
		if forceneeded:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": The following groups are non-empty:", "default")])
			for group, hosts in extrahosts:
				ansithemeprint(format_members(group, hosts))
		print()
		ansithemeprint([ANSIThemeString("Removing groups that still contain hosts requires specifying “", "default"),
				ANSIThemeString("--force", "option"),
				ANSIThemeString("“.", "default")], stderr = True)
		print()
		ansithemeprint([ANSIThemeString("Try “", "default"),
				ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME} ", "programname"),
				ANSIThemeString("help", "command"),
				ANSIThemeString("“ for more information.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	retval = ansible_remove_groups(inventory = ANSIBLE_INVENTORY, groups = groups, force = force)

	if not retval:
		raise ProgrammingError(f"Failed to remove {groups}")

	return 0

def get_cluster_name() -> Optional[str]:
	"""
	Return the name of the cluster
		Returns:
			cluster_name (str): On success
			None (None): On failure
	"""

	try:
		d1 = cmtio_yaml.secure_read_yaml(KUBE_CONFIG_FILE)
	except FileNotFoundError:
		return None

	current_context = d1.get("current-context", None)
	if current_context is None:
		return None

	cluster_name = None

	for context in d1.get("contexts", []):
		if context.get("name", "") == current_context:
			cluster_name = context["context"].get("cluster", None)
			break

	return cluster_name

def rebuild_inventory(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Build an inventory based on information from Kubernetes

		Parameters:
			options (list[(opt, optarg)]): A list of opt, optarg
			args (list[str]): Unused
		Returns:
			0
	"""

	del args

	force = False

	for opt, _optarg in options:
		if opt == "--force":
			force = True

	# Is there a pre-existing inventory?
	if Path(ANSIBLE_INVENTORY).is_file() and not force:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Overwriting an existing inventory requires specifying “", "default"),
				ANSIThemeString("--force", "option"),
				ANSIThemeString("“.", "default")], stderr = True)
		print()
		ansithemeprint([ANSIThemeString("Try “", "default"),
				ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME} ", "programname"),
				ANSIThemeString("help", "command"),
				ANSIThemeString("“ for more information.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# We ideally want to iterate over all clusters here, but for now we only import the current-context
	from kubernetes_helper import KubernetesHelper  # pylint: disable=import-outside-toplevel
	cluster_name = get_cluster_name()
	if cluster_name is None:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Could not obtain cluster name; do you have a cluster available? Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
	if status != 200:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": API-server returned ", "default"),
				ANSIThemeString(f"{status}", "errorvalue"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)
	if vlist is None:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": API-server did not return any data", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for node in vlist:
		roles = kh.get_node_roles(cast(Dict, node))
		if "control-plane" in roles:
			groups = ["all", "controlplane", cluster_name]
		else:
			groups = ["all", "nodes", cluster_name]

		group = ""
		hosts = [deep_get(node, DictPath("metadata#name"))]
		retval = True
		for group in groups:
			retval = ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = hosts, group = group, skip_all = False)

		if not retval:
			raise ProgrammingError(f"Failed to add {hosts} to group {group}")

	# Finally import the hostkey into authorized_keys
	pubkey = None

	try:
		tmp = cmtio.secure_read_string(FilePath(str(PurePath(SSH_DIR).joinpath("id_ecdsa.pub"))))
	except FilePathAuditError as e:
		# We cannot import non-existing hostkeys...
		if "SecurityStatus.DOES_NOT_EXIST" in str(e):
			tmp = None

	if tmp is not None:
		tmplines = tmp.splitlines()
		pubkey = tmplines[0]

	if pubkey is None or len(pubkey) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Failed to read ", "default"),
				ANSIThemeString(f"{HOMEDIR}/.ssh/id_ecdsa.pub", "path"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	values = {
		"authorized_keys": [pubkey],
	}
	ansible_set_vars(ANSIBLE_INVENTORY, "all", values)

	return 0

def remove_hosts(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Remove hosts

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Comma-separated list of hosts
		Returns:
			0
	"""

	groups = ["all"]
	extragroups = []
	forceneeded = False
	force = False

	hosts = args[0].split(",")

	if len(args) > 1:
		groups = args[1].split(",")

		# This returns a YAML tree with the inventory of nodes
		inventory_dict = ansible_get_inventory_dict()

		# If the hosts are only members of "all"
		# (or are not in the inventory at all),
		# it is OK to remove them without --force.
		#
		# All hosts are members of the groups "all";
		# this means that if len(hostgroups) > 1
		# we have auxilliary groups and --force is needed.
		for host in hosts:
			hostgroups = ansible_get_groups_by_host(inventory_dict, host)
			if len(hostgroups) > 1:
				forceneeded = True
				hostgroups.remove("all")
				extragroups.append((host, hostgroups))

	for opt, _optarg in options:
		if opt == "--force":
			force = True

	if "all" in groups and forceneeded and (not force or len(groups) > 1):
		if forceneeded:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": The following hosts are parts of other groups than “", "default"),
					ANSIThemeString("all", "argument"),
					ANSIThemeString("“:", "default")])
			for host, groups in extragroups:
				ansithemeprint(format_members(host, groups))
		print()
		ansithemeprint([ANSIThemeString("Removing hosts from “", "default"),
				ANSIThemeString("all", "argument"),
				ANSIThemeString("“ requires specifying “", "default"),
				ANSIThemeString("--force", "option"),
				ANSIThemeString("“", "default")], stderr = True)
		ansithemeprint([ANSIThemeString("unless “", "default"),
				ANSIThemeString("all", "argument"),
				ANSIThemeString("“ is the only group or the hosts are not members of other groups.", "default")], stderr = True)
		print()
		ansithemeprint([ANSIThemeString("Try “", "default"),
				ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME} ", "programname"),
				ANSIThemeString("help", "command"),
				ANSIThemeString("“ for more information.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	retval = True

	# If groups is ["all"] and "force" is specified we need to substitute ["all"] for a list of all groups
	if groups == ["all"]:
		groups = ansible_get_groups(inventory = ANSIBLE_INVENTORY)

	for group in groups:
		retval = ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = hosts, group = group)

		if not retval:
			raise ProgrammingError(f"Failed to remove {hosts} to group {group}")

	return 0

def inventory(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Show the inventory

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Comma-separated list of groups (optional)
		Returns:
			0
	"""

	color = "auto"

	include_groupvars = False
	include_hostvars = False

	for opt, optarg in options:
		if opt == "--color":
			color = optarg
		elif opt == "--include-vars":
			include_groupvars = True
			include_hostvars = True

	groups = None

	if args is not None and len(args) > 0:
		groups = args[0].split(",")

	for item in ansible_get_inventory_pretty(groups = groups, highlight = True, include_groupvars = include_groupvars, include_hostvars = include_hostvars):
		ansithemeprint(cast(list, item), color = color)

	return 0

# pylint: disable-next=unused-argument
def list_groups(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	List groups

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Unused
		Returns:
			0
	"""

	color = "auto"

	# Valid formats:
	# default = Normal output format (default)
	# csv = Comma-separated values
	# ssv = Space-separated values
	# tsv = Tab-separated values
	output_format = "default"

	include_groupvars = False

	for opt, optarg in options:
		if opt == "--color":
			color = optarg
		elif opt == "--format":
			output_format = optarg
		elif opt == "--include-vars":
			include_groupvars = True

	if output_format != "default":
		separator = ""
		if output_format == "csv":
			separator = ","
		elif output_format == "ssv":
			separator = " "
		elif output_format == "tsv":
			separator = "\t"

		d = ansible_get_inventory_dict()
		sorted_groups = cast(List[str], natsorted(d.keys()))
		ansithemeprint(ansithemestring_join_tuple_list(sorted_groups, formatting = "hostname", separator = ANSIThemeString(separator, "separator")), color = color)
	else:
		for item in ansible_get_inventory_pretty(groups = None, highlight = True, include_groupvars = include_groupvars, include_hosts = False):
			ansithemeprint(cast(list, item), color = color)

	return 0

# pylint: disable-next=unused-argument
def list_hosts(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	List hosts

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Unused
		Returns:
			0
	"""

	color = "auto"

	# Valid formats:
	# default = Normal output format (default)
	# csv = Comma-separated values
	# ssv = Space-separated values
	# tsv = Tab-separated values
	output_format = "default"

	include_hostvars = False

	for opt, optarg in options:
		if opt == "--color":
			color = optarg
		elif opt == "--format":
			output_format = optarg
		elif opt == "--include-vars":
			include_hostvars = True


	groups = ["all"]

	if output_format != "default":
		separator = ""
		if output_format == "csv":
			separator = ","
		elif output_format == "ssv":
			separator = " "
		elif output_format == "tsv":
			separator = "\t"

		d = ansible_get_inventory_dict()
		hosts = set()
		for group in groups:
			for host in deep_get(d, DictPath(f"{group}#hosts"), []):
				hosts.add(host)
		sorted_hosts = cast(List[str], natsorted(list(hosts)))
		ansithemeprint(ansithemestring_join_tuple_list(sorted_hosts, formatting = "hostname", separator = ANSIThemeString(separator, "separator")), color = color)
	else:
		for item in ansible_get_inventory_pretty(groups = groups, highlight = True, include_hostvars = include_hostvars):
			ansithemeprint(cast(list, item), color = color)

	return 0

def populate_playbooks() -> Dict:
	"""
	Populate the list of playbooks runnable from the command line

		Returns:
			(dict): The dict of playbooks
	"""
	playbook_dirs = []
	playbooks = {}

	local_playbook_dirs = deep_get(cmtlib.cmtconfig, DictPath("Ansible#local_playbooks"), [])
	for playbook_dir in local_playbook_dirs:
		# Substitute {HOME}/ for {HOMEDIR}
		if playbook_dir.startswith(("{HOME}/", "{HOME}\\")):
			playbook_dir = FilePath(str(PurePath(HOMEDIR).joinpath(playbook_dir[len('{HOME}/'):])))
		# Skip non-existing playbook paths
		if not os.path.isdir(playbook_dir):
			continue
		playbook_dirs.append(playbook_dir)
	playbook_dirs.append(ANSIBLE_PLAYBOOK_DIR)

	yaml_regex = re.compile(r"^(.*)\.ya?ml$")

	# This should be moved to ansible_helper and generalised to be usable both in cmu and cmtinv
	for playbook_dir in playbook_dirs:
		for playbook_path in Path(playbook_dir).iterdir():
			if playbook_path.name.startswith(("~", ".")):
				continue

			tmp = yaml_regex.match(playbook_path.name)
			if tmp is None:
				continue

			playbookname = str(tmp[1])

			if playbookname in playbooks:
				continue

			description = None

			try:
				d = cmtio_yaml.secure_read_yaml(FilePath(str(playbook_path)), directory_is_symlink = True)
			except yaml.YAMLError:
				# This entry could not be parsed; add a dummy entry
				playbooks[playbookname] = {
					"description": playbook_path,
					"playbook": str(playbook_path),
					"category": "__INVALID__",
					"comments": "Failed to parse (Not valid YAML)",
				}
				continue

			# Empty files are used to disable playbooks completely
			if d is None or len(d) == 0:
				playbooks[playbookname] = {
					"description": playbook_path,
					"playbook": str(playbook_path),
					"category": "__DISABLED__",
				}
				continue

			if not isinstance(d, list):
				# This entry could not be parsed; add a dummy entry
				playbooks[playbookname] = {
					"description": playbook_path,
					"playbook": str(playbook_path),
					"category": "__INVALID__",
					"comments": "Failed to parse (Not a list of plays)",
				}
				continue

			description = deep_get(d[0], DictPath("vars#metadata#description"))

			# Ignore all playbooks that lack a description;
			# typically they are internal playbooks
			if description is None:
				continue

			playbooktypes = deep_get_with_fallback(d[0], [DictPath("vars#metadata#playbook_types"), DictPath("vars#metadata#playbook-types")], [])
			description = deep_get(d[0], DictPath("vars#metadata#description"))
			category = deep_get(d[0], DictPath("vars#metadata#category"), "Uncategorized")
			readonly = deep_get_with_fallback(d[0], [DictPath("vars#metadata#read_only"), DictPath("vars#metadata#read-only")], False)
			comments = deep_get(d[0], DictPath("vars#metadata#comments"), "")

			if "cmtinv" not in playbooktypes:
				continue

			playbooks[playbookname] = {
				"description": description,
				"playbook": str(playbook_path),
				"category": category,
				"comments": comments,
				"read_only": readonly,
			}

	return playbooks

# pylint: disable-next=unused-argument
def list_playbooks(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	List playbooks

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Unused
		Returns:
			0
	"""

	color = "auto"

	# Valid formats:
	# default = Normal output format (default)
	# csv = Comma-separated values
	# ssv = Space-separated values
	# tsv = Tab-separated values
	output_format = "default"

	for opt, optarg in options:
		if opt == "--color":
			color = optarg
		elif opt == "--format":
			output_format = optarg

	if output_format != "default":
		separator = ""
		if output_format == "csv":
			separator = ","
		elif output_format == "ssv":
			separator = " "
		elif output_format == "tsv":
			separator = "\t"

	playbooks = populate_playbooks()

	if output_format == "default":
		headers = ["Name:", "Description:", "Category:", "Read Only:"]
		rows = []

		maxlengths = []
		for header in headers:
			maxlengths.append(len(header))

		for playbook, data in playbooks.items():
			name = playbook
			description = deep_get(data, DictPath("description"), "<unset>")
			category = deep_get(data, DictPath("category"), "<unset>")
			read_only = str(deep_get(data, DictPath("read_only"), False))
			if category in ("__DISABLED__", "__INVALID__"):
				continue
			rows.append([name, description, category, read_only])
		for row in rows:
			for i, field in enumerate(row):
				maxlengths[i] = max(maxlengths[i], len(field))

		header_array = []
		for i, header in enumerate(headers):
			header_array.append(ANSIThemeString(header, "header"))
			header_array.append(ANSIThemeString("".ljust(maxlengths[i] - len(header) + 2), "default"))
		ansithemeprint(header_array)
		for row in rows:
			row_array = []
			for i, field in enumerate(row):
				row_array.append(ANSIThemeString(field, "default"))
				row_array.append(ANSIThemeString("".ljust(maxlengths[i] - len(field) + 2), "default"))
			ansithemeprint(row_array)
	else:
		ansithemeprint(ansithemestring_join_tuple_list(list(playbooks), formatting = "default", separator = ANSIThemeString(separator, "separator")), color = color)

	return 0


# pylint: disable-next=unused-argument
def run_playbook(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Run playbook on host(s) or group(s)
	A well-formed inventory should not have groups with the same name as any of the hosts,
	thus mixing group and host names should be OK; but if there are overlaps the group
	are prioritised over the hostname

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Unused
		Returns:
			0
	"""

	verbose = False

	for opt, _optarg in options:
		if opt == "--verbose":
			verbose = True

	playbook = args[0]
	groups_or_hosts = args[1].split(",")
	selection = []
	_all = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")
	for group_or_host in groups_or_hosts:
		# First check if there's a group by this name
		hosts = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, group_or_host)
		# If the group is empty let's try to see if it is a host
		if len(hosts) == 0:
			if group_or_host in _all:
				selection.append(group_or_host)
			else:
				ansithemeprint([ANSIThemeString("Warning", "warning"),
						ANSIThemeString(": Skipping unknown host or group “", "default"),
						ANSIThemeString(group_or_host, "argument"),
						ANSIThemeString("“", "default")], stderr = True)
		else:
			selection += hosts
	# Eliminate duplicates
	selection = list(set(selection))

	if len(selection) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No valid hosts or groups specified; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	playbooks = populate_playbooks()
	if playbook not in playbooks:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": “", "default"),
				ANSIThemeString(f"{playbook}", "argument"),
				ANSIThemeString("“ is not a valid playbook; use “", "default"),
				ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" list-playbooks", "command"),
				ANSIThemeString("“ to list valid playbooks.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if deep_get(playbooks, DictPath(f"{playbook}#category"), "") in ("__DISABLED__", "__INVALID__"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": The playbook “", "default"),
				ANSIThemeString(f"{playbook}", "argument"),
				ANSIThemeString("“ is either disabled or invalid; use “", "default"),
				ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" list-playbooks", "command"),
				ANSIThemeString("“ to list valid playbooks.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	playbook_path = deep_get(playbooks, DictPath(f"{playbook}#playbook"), "")
	retval, ansible_results = ansible_run_playbook_on_selection(playbook_path, selection = selection, verbose = verbose)
	if verbose:
		ansithemeprint([ANSIThemeString("", "default")])

	ansible_print_play_results(retval, ansible_results, verbose = verbose)

	return 0

def ping(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Ping hosts or groups of hosts
	Default: ping all hosts
	A well-formed inventory should not have groups with the same name as any of the hosts,
	thus mixing group and host names should be OK; but if there are overlaps the group
	are prioritised over the hostname

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): list of hosts or groups (optional)
		Returns:
			0
	"""

	del options

	hoststatuses = []

	if args is not None and len(args) > 0:
		groups_or_hosts = args[0].split(",")
		selection = []
		_all = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")
		for group_or_host in groups_or_hosts:
			# First check if there's a group by this name
			hosts = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, group_or_host)
			# If the group is empty let's try to see if it is a host
			if len(hosts) == 0:
				if group_or_host in _all:
					selection.append(group_or_host)
				else:
					ansithemeprint([ANSIThemeString("Warning", "warning"),
							ANSIThemeString(": Skipping unknown host or group “", "default"),
							ANSIThemeString(group_or_host, "argument"),
							ANSIThemeString("“", "default")], stderr = True)
			else:
				selection += hosts
		# Eliminate duplicates
		selection = list(set(selection))
	else:
		selection = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")

	if len(selection) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No valid hosts or groups specified; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	print("Please stand by, attempting to ping hosts")
	print()

	output = ansible_ping(selection = selection)

	if output is None or len(output) == 0:
		raise UnknownError("Internal error; ansible -m ping failed")

	maxlen = 0

	# This needs to be improved; if there's a message we need to tell the difference
	# between "Permission denied" and "No route to host"
	for (host, status) in cast(List[Tuple[str, str]], natsorted(output)):
		maxlen = max(len(host), maxlen)
		status_group = "error"

		if status == "SUCCESS":
			status_group = "success"
		elif status == "COULD NOT RESOLVE":
			status_group = "critical"
		elif status == "MISSING INTERPRETER?":
			status_group = "warning"
		elif status in ("UNKNOWN", "UNKNOWN ERROR"):
			status_group = "unknown"

		hoststatuses.append((host, status, status_group))

	header = "Hostname:"

	maxlen = max(maxlen, len(header))

	if len(hoststatuses) > 0:
		ansithemeprint([ANSIThemeString(header, "header"),
				ANSIThemeString(f"{''.ljust(maxlen - len(header))}  ", "default"),
				ANSIThemeString("Status:", "header")])

		for hostname, status, status_group in hoststatuses:
			ansithemeprint([ANSIThemeString(f"{hostname.ljust(maxlen)}  ", "default"),
					ANSIThemeString(f"{status}", status_group)])

	return 0

COMMANDLINE = {
	"Add Groups": {
		"command": ["add-group", "add-groups"],
		"values": [ANSIThemeString("GROUP", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Add ", "description"),
				ANSIThemeString("GROUP", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" to inventory", "description")],
		"options": {
			"--vars": {
				"values": [ANSIThemeString("KEY", "argument"),
					   ANSIThemeString(":", "separator"),
					   ANSIThemeString("VALUE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Set these group variables", "description")],
				"requires_arg": True,
				"validation": {
					"validator": "regex",
					# The key is limited, the value is free-form
					"regex": r"^[a-z_][a-z0-9_]*:.+$",
					"list_separator": ",",
				},
			},
		},
		"required_args": [
			{
				"name": "groups",
				"string": [ANSIThemeString("GROUP", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z_][a-z0-9_]*$",
					"list_separator": ",",
				},
			},
		],
		"callback": add_groups,
	},
	"Add Hosts to Inventory": {
		"command": ["add-host", "add-hosts"],
		"values": [ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Add ", "description"),
				ANSIThemeString("HOST", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" to inventory", "description")],
		"options": {
			"--groups": {
				"values": [ANSIThemeString("GROUP", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Add the hosts to these groups", "description")],
				"requires_arg": True,
				"validation": {
					"validator": "regex",
					# The key is limited, the value is free-form
					"regex": r"^[a-z_][a-z0-9_]*$",
					"list_separator": ",",
				},
			},
			"--vars": {
				"values": [ANSIThemeString("KEY", "argument"),
					   ANSIThemeString(":", "separator"),
					   ANSIThemeString("VALUE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Set these host variables", "description")],
				"requires_arg": True,
				"validation": {
					"validator": "regex",
					# The key is limited, the value is free-form
					"regex": r"^[a-z_][a-z0-9_]*:.+$",
					"list_separator": ",",
				},
			},
		},
		"required_args": [
			{
				"name": "hosts",
				"string": [ANSIThemeString("HOST", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "hostname_or_ip",
					"list_separator": ",",
				},
			},
		],
		"optional_args": [
			{
				"name": "groups",
				"string": [ANSIThemeString("GROUP", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z_][a-z0-9_]*$",
					"list_separator": ",",
				},
			},
		],
		"callback": add_hosts,
	},
	# This is purely for the benefit of the helptext generator
	"Add Hosts to Groups": {
		"command": ["add-host", "add-hosts"],
		"values": [ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("... ", "argument"),
			   ANSIThemeString("GROUP", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Add ", "description"),
				ANSIThemeString("HOST", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" to ", "description"),
				ANSIThemeString("GROUP", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
	},
	"Inventory": {
		"command": ["inventory", "inv"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("GROUP", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Show inventory, optionally limited to ", "description"),
				ANSIThemeString("GROUP", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"options": {
			"--color": {
				"values": [ANSIThemeString("WHEN", "argument")],
				"description": [ANSIThemeString("WHEN should the output use ANSI-colors", "description")],
				"extended_description": [
					[ANSIThemeString("Valid arguments are: ", "description")],
					[ANSIThemeString("always", "argument"),
					 ANSIThemeString(" (always color the output)", "description")],
					[ANSIThemeString("auto", "argument"),
					 ANSIThemeString(" (color the output when outputting", "description")],
					[ANSIThemeString("to a terminal)", "description")],
					[ANSIThemeString("never", "argument"),
					 ANSIThemeString(" (never color the output)", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": [
						"always",
						"auto",
						"never",
					],
				},
			},
			"--include-vars": {
				"description": [ANSIThemeString("Show variables", "description")],
			},
		},
		"optional_args": [
			{
				"name": "groups",
				"string": [ANSIThemeString("GROUP", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z_][a-z0-9_]*$",
					"list_separator": ",",
				},
			},
		],
		"callback": inventory,
	},
	"List Hosts": {
		"command": ["list-hosts"],
		"description": [ANSIThemeString("List all hosts", "description")],
		"options": {
			"--color": {
				"values": [ANSIThemeString("WHEN", "argument")],
				"description": [ANSIThemeString("WHEN should the output use ANSI-colors", "description")],
				"extended_description": [
					[ANSIThemeString("Valid arguments are: ", "description")],
					[ANSIThemeString("always", "argument"),
					 ANSIThemeString(" (always color the output)", "description")],
					[ANSIThemeString("auto", "argument"),
					 ANSIThemeString(" (color the output when outputting", "description")],
					[ANSIThemeString("to a terminal)", "description")],
					[ANSIThemeString("never", "argument"),
					 ANSIThemeString(" (never color the output)", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": [
						"always",
						"auto",
						"never",
					],
				},
			},
			"--format": {
				"values": [ANSIThemeString("FORMAT", "argument")],
				"description": [ANSIThemeString("Format the output as ", "description"),
						ANSIThemeString("FORMAT", "description")],
				"extended_description": [
					[ANSIThemeString("Valid formats are: ", "description")],
					[ANSIThemeString("default", "argument"),
					 ANSIThemeString(" (inventory in tree format)", "description")],
					[ANSIThemeString("csv", "argument"),
					 ANSIThemeString(" (comma-separated values)", "description")],
					[ANSIThemeString("ssv", "argument"),
					 ANSIThemeString(" (space-separated values)", "description")],
					[ANSIThemeString("tsv", "argument"),
					 ANSIThemeString(" (tab-separated values)", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": [
						"default",
						"csv",
						"ssv",
						"tsv",
					],
				},
			},
			"--include-vars": {
				"description": [ANSIThemeString("Show host variables", "description")],
			},
		},
		"callback": list_hosts,
	},
	"List Groups": {
		"command": ["list-groups"],
		"description": [ANSIThemeString("List all groups", "description")],
		"options": {
			"--color": {
				"values": [ANSIThemeString("WHEN", "argument")],
				"description": [ANSIThemeString("WHEN should the output use ANSI-colors", "description")],
				"extended_description": [
					[ANSIThemeString("Valid arguments are: ", "description")],
					[ANSIThemeString("always", "argument"),
					 ANSIThemeString(" (always color the output)", "description")],
					[ANSIThemeString("auto", "argument"),
					 ANSIThemeString(" (color the output when outputting", "description")],
					[ANSIThemeString("to a terminal)", "description")],
					[ANSIThemeString("never", "argument"),
					 ANSIThemeString(" (never color the output)", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": [
						"always",
						"auto",
						"never",
					],
				},
			},
			"--format": {
				"values": [ANSIThemeString("FORMAT", "argument")],
				"description": [ANSIThemeString("Format the output as ", "description"),
						ANSIThemeString("FORMAT", "description")],
				"extended_description": [
					[ANSIThemeString("Valid formats are: ", "description")],
					[ANSIThemeString("default", "argument"),
					 ANSIThemeString(" (inventory in tree format)", "description")],
					[ANSIThemeString("csv", "argument"),
					 ANSIThemeString(" (comma-separated values)", "description")],
					[ANSIThemeString("ssv", "argument"),
					 ANSIThemeString(" (space-separated values)", "description")],
					[ANSIThemeString("tsv", "argument"),
					 ANSIThemeString(" (tab-separated values)", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": [
						"default",
						"csv",
						"ssv",
						"tsv",
					],
				},
			},
			"--include-vars": {
				"description": [ANSIThemeString("Show group variables", "description")],
			},
		},
		"callback": list_groups,
	},
	"Ping": {
		"command": ["ping"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("GROUP/HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Ansible ping ", "description"),
				ANSIThemeString("GROUP", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" or ", "description"),
				ANSIThemeString("HOST", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" (Default: “", "description"),
				ANSIThemeString("all", "argument"),
				ANSIThemeString("“)", "description")],
		"optional_args": [
			{
				"name": "groups_or_hosts",
				"string": [ANSIThemeString("[", "separator"),
					   ANSIThemeString("GROUP/HOST", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("]", "separator")],
				"validation": {
					"validator": "hostname_or_ip",
				},
			},
		],
		"callback": ping,
	},
	"Rebuild Inventory": {
		"command": ["rebuild-inventory"],
		"description": [ANSIThemeString("Create inventory for an existing Kubernetes cluster", "description")],
		"extended_description": [
			[ANSIThemeString("In cases where the cluster has not been created", "description")],
			[ANSIThemeString("using ", "description"),
			 ANSIThemeString(f"{about.PROGRAM_SUITE_NAME}", "programname"),
			 ANSIThemeString(" this command can be used to build", "description")],
			[ANSIThemeString("a barebones inventory.", "description")],
			[ANSIThemeString("Note", "note"),
			 ANSIThemeString(": This requires a running cluster", "description")],
		],
		"options": {
			"--force": {
				"description": [ANSIThemeString("Allow an ", "description"),
					        ANSIThemeString("existing", "emphasis"),
						ANSIThemeString(" inventory to be overwritten", "description")],
			},
		},
		"callback": rebuild_inventory,
	},
	"Remove Groups": {
		"command": ["remove-group", "remove-groups"],
		"values": [ANSIThemeString("GROUP", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Remove ", "description"),
				ANSIThemeString("GROUP", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" from inventory", "description")],
		"extended_description": [
			[ANSIThemeString("Note", "note"),
			 ANSIThemeString(": Removing the group “", "description"),
			 ANSIThemeString("all", "argument"),
			 ANSIThemeString("“ is not permitted", "description")],
		],
		"options": {
			"--force": {
				"description": [ANSIThemeString("Allow removal of ", "description"),
						ANSIThemeString("non-empty", "emphasis"),
						ANSIThemeString(" groups", "description")],
			},
		},
		"required_args": [
			{
				"name": "groups",
				"string": [ANSIThemeString("GROUP", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z_][a-z0-9_]*$",
					"list_separator": ",",
				},
			},
		],
		"callback": remove_groups,
	},
	"Remove Hosts from ALL Groups": {
		"command": ["remove-host", "remove-hosts"],
		"values": [ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("... ", "argument"),
			   ANSIThemeString("all", "argument")],
		"description": [ANSIThemeString("Remove ", "description"),
				ANSIThemeString("HOST", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" from inventory", "description")],
		"options": {
			"--force": {
				"description": [ANSIThemeString("Allow ", "description"),
						ANSIThemeString("complete", "emphasis"),
						ANSIThemeString(" removal of hosts from inventory", "description")],
			},
		},
		"required_args": [
			{
				"name": "hosts",
				"string": [ANSIThemeString("HOST", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "hostname_or_ip",
					"list_separator": ",",
				},
			},
			{
				"name": "groups",
				"string": [ANSIThemeString("GROUP", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z_][a-z0-9_]*$",
					"list_separator": ",",
				},
			},
		],
		"callback": remove_hosts,
	},
	# This is purely for the benefit of the helptext generator
	"Remove Hosts": {
		"command": ["remove-host", "remove-hosts"],
		"values": [ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("... ", "argument"),
			   ANSIThemeString("GROUP", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Remove ", "description"),
				ANSIThemeString("HOST", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" from ", "description"),
				ANSIThemeString("GROUP", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
	},
	"List Playbooks": {
		"command": ["list-playbooks"],
		"description": [ANSIThemeString("List available playbooks", "description")],
		"options": {
			"--color": {
				"values": [ANSIThemeString("WHEN", "argument")],
				"description": [ANSIThemeString("WHEN should the output use ANSI-colors", "description")],
				"extended_description": [
					[ANSIThemeString("Valid arguments are: ", "description")],
					[ANSIThemeString("always", "argument"),
					 ANSIThemeString(" (always color the output)", "description")],
					[ANSIThemeString("auto", "argument"),
					 ANSIThemeString(" (color the output when outputting", "description")],
					[ANSIThemeString("to a terminal)", "description")],
					[ANSIThemeString("never", "argument"),
					 ANSIThemeString(" (never color the output)", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": [
						"always",
						"auto",
						"never",
					],
				},
			},
			"--format": {
				"values": [ANSIThemeString("FORMAT", "argument")],
				"description": [ANSIThemeString("Format the output as ", "description"),
						ANSIThemeString("FORMAT", "description")],
				"extended_description": [
					[ANSIThemeString("Valid formats are: ", "description")],
					[ANSIThemeString("default", "argument"),
					 ANSIThemeString(" (default format)", "description")],
					[ANSIThemeString("csv", "argument"),
					 ANSIThemeString(" (comma-separated values)", "description")],
					[ANSIThemeString("ssv", "argument"),
					 ANSIThemeString(" (space-separated values)", "description")],
					[ANSIThemeString("tsv", "argument"),
					 ANSIThemeString(" (tab-separated values)", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": [
						"default",
						"csv",
						"ssv",
						"tsv",
					],
				},
			},
		},
		"callback": list_playbooks,
	},
	"Run Playbook": {
		"command": ["run"],
		"values": [ANSIThemeString("PLAYBOOK ", "argument"),
			   ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("GROUP", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Run playbook on ", "description"),
				ANSIThemeString("HOST", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" or ", "description"),
				ANSIThemeString("GROUP", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"options": {
			"--verbose": {
				"description": [ANSIThemeString("Be more verbose", "description")],
			},
		},
		"required_args": [
			{
				"name": "playbook",
				"string": [ANSIThemeString("PLAYBOOK", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z0-9][a-z0-9_-]*[a-z0-9]$",
				},
			},
			{
				"name": "hosts_or_groups",
				"string": [ANSIThemeString("HOST", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("|", "argument"),
					   ANSIThemeString("GROUP", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z_][a-z0-9_-]*$",
					"list_separator": ",",
				},
			},
		],
		"callback": run_playbook,
	},
	"Set Global Variables": {
		"command": ["set-var", "set-vars"],
		"values": [ANSIThemeString("KEY", "argument"),
			   ANSIThemeString(":", "separator"),
			   ANSIThemeString("VALUE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Set global ", "description"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString(":", "separator"),
				ANSIThemeString("VALUE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"extended_description": [
			[ANSIThemeString("Setting global variables is equivalent to setting", "description")],
			[ANSIThemeString("variables for the group “", "description"),
			 ANSIThemeString("all", "argument"),
			 ANSIThemeString("“", "description")],
		],
		"required_args": [
			{
				"name": "global_vars",
				"string": [ANSIThemeString("KEY", "argument"),
					   ANSIThemeString(":", "separator"),
					   ANSIThemeString("VALUE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					# The key is limited, the value is free-form
					"regex": r"^[a-z_][a-z0-9_]*:.+$",
					"list_separator": ",",
				},
			},
		],
		"callback": set_global_vars,
	},
	"Set Group Variables": {
		"command": ["set-group-var", "set-group-vars"],
		"values": [ANSIThemeString("KEY", "argument"),
			   ANSIThemeString(":", "separator"),
			   ANSIThemeString("VALUE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("... ", "argument"),
			   ANSIThemeString("GROUP", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Set ", "description"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString(":", "separator"),
				ANSIThemeString("VALUE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" for ", "description"),
				ANSIThemeString("GROUP", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"required_args": [
			{
				"name": "group_vars",
				"string": [ANSIThemeString("KEY", "argument"),
					   ANSIThemeString(":", "separator"),
					   ANSIThemeString("VALUE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					# The key is limited, the value is free-form
					"regex": r"^[a-z_][a-z0-9_]*:.+$",
					"list_separator": ",",
				},
			},
			{
				"name": "groups",
				"string": [ANSIThemeString("GROUP", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z_][a-z0-9_]*$",
					"list_separator": ",",
				},
			},
		],
		"callback": set_group_vars,
	},
	"Set Host Variables": {
		"command": ["set-host-var", "set-host-vars"],
		"values": [ANSIThemeString("KEY", "argument"),
			   ANSIThemeString(":", "separator"),
			   ANSIThemeString("VALUE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("... ", "argument"),
			   ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Set ", "description"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString(":", "separator"),
				ANSIThemeString("VALUE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" for ", "description"),
				ANSIThemeString("HOST", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"required_args": [
			{
				"name": "host_vars",
				"string": [ANSIThemeString("KEY", "argument"),
					   ANSIThemeString(":", "separator"),
					   ANSIThemeString("VALUE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					# The key is limited, the value is free-form
					"regex": r"^[a-z_][a-z0-9_]*:.+$",
					"list_separator": ",",
				},
			},
			{
				"name": "hosts",
				"string": [ANSIThemeString("HOST", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "hostname_or_ip",
					"list_separator": ",",
				},
			},
		],
		"callback": set_host_vars,
	},
	"Unset Global Variables": {
		"command": ["unset-var", "unset-vars"],
		"values": [ANSIThemeString("KEY", "argument")],
		"description": [ANSIThemeString("Unset global ", "description"),
				ANSIThemeString("KEY", "argument")],
		"extended_description": [
			[ANSIThemeString("Unsetting global variables is equivalent to", "description")],
			[ANSIThemeString("unsetting variables for the group “", "description"),
			 ANSIThemeString("all", "argument"),
			 ANSIThemeString("“", "description")],
		],
		"required_args": [
			{
				"name": "global_vars",
				"string": [ANSIThemeString("KEY", "argument"),
					   ANSIThemeString(":", "separator"),
					   ANSIThemeString("VALUE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z_][a-z0-9_]*$",
					"list_separator": ",",
				},
			},
		],
		"callback": unset_global_vars,
	},
	"Unset Group Variables": {
		"command": ["unset-group-var", "unset-group-vars"],
		"values": [ANSIThemeString("KEY ", "argument"),
			   ANSIThemeString("GROUP", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Unset ", "description"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString(" for ", "description"),
				ANSIThemeString("GROUP", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"required_args": [
			{
				"name": "group_vars",
				"string": [ANSIThemeString("KEY", "argument"),
					   ANSIThemeString(":", "separator"),
					   ANSIThemeString("VALUE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z_][a-z0-9_]*$",
					"list_separator": ",",
				},
			},
			{
				"name": "groups",
				"string": [ANSIThemeString("GROUP", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z_][a-z0-9_]*$",
					"list_separator": ",",
				},
			},
		],
		"callback": unset_group_vars,
	},
	"Unset Host Variables": {
		"command": ["unset-host-var", "unset-host-vars"],
		"values": [ANSIThemeString("KEY ", "argument"),
			   ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Unset ", "description"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString(" for ", "description"),
				ANSIThemeString("HOST", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"required_args": [
			{
				"name": "host_vars",
				"string": [ANSIThemeString("KEY", "argument"),
					   ANSIThemeString(":", "separator"),
					   ANSIThemeString("VALUE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z_][a-z0-9_]*$",
					"list_separator": ",",
				},
			},
			{
				"name": "hosts",
				"string": [ANSIThemeString("HOST", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"validation": {
					"validator": "hostname_or_ip",
					"list_separator": ",",
				},
			},
		],
		"callback": unset_host_vars,
	},
	"spacer1": {
		"command": [""],
		"description": [ANSIThemeString("", "default")],
	},
}

def main() -> int:
	"""
	Main function for the program
	"""

	# Before doing anything else, make sure that the user is not running as root
	if os.geteuid() == 0:
		sys.exit("CRITICAL: This program should not be run as the root user; aborting.")

	# Then initialise the configuration file
	read_cmtconfig()

	command, options, args = parse_commandline(about.INVENTORY_PROGRAM_NAME, about.INVENTORY_PROGRAM_VERSION, PROGRAMDESCRIPTION, PROGRAMAUTHORS, sys.argv,
						   COMMANDLINE, default_command = "inventory", theme = DEFAULT_THEME_FILE)

	for key, value in options:
		if key == "__commandname" and value in ("help", "version"):
			break
	else:
		checks.check_netrc_permissions(verbose = False, exit_on_error = True, quiet_on_ok = True)

	# Used by the ansible module
	ansible_configuration["ansible_forks"] = deep_get(cmtlib.cmtconfig, DictPath("Ansible#forks"), 10)
	ansible_configuration["ansible_user"] = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_user"))
	ansible_configuration["ansible_password"] = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_password"))
	ansible_configuration["disable_strict_host_key_checking"] = deep_get(cmtlib.cmtconfig, DictPath("Nodes#disablestricthostkeychecking"), False)

	return command(options, args)

if __name__ == "__main__":
	main()
