#! /usr/bin/env python3
# Requires: python3 (>= 3.6)
import errno
import os
from pathlib import Path
import shutil
import subprocess
from subprocess import PIPE, STDOUT
import sys
import yaml

from iktlib import execute_command_with_response

from commandparser import parse_commandline
from iktprint import iktprint, iktinput, init_iktprint

HOMEDIR = str(Path.home())
BINDIR = f"{HOMEDIR}/bin"
IKTDIR = f"{HOMEDIR}/.ikt"
DEPLOYMENTDIR = f"{IKTDIR}/deployments"
THEME_DIRNAME = "themes"
THEMEDIR = f"{IKTDIR}/{THEME_DIRNAME}"
ANSIBLE_DIR = f"{IKTDIR}/ansible"
ANSIBLE_PLAYBOOK_DIRNAME = "playbooks"
ANSIBLE_LOG_DIR = f"{ANSIBLE_DIR}/logs"
IKT_HOOKS_DIR = f"{IKTDIR}/hooks"
PARSER_DIRNAME = "parsers"
VIEW_DIRNAME = "views"

IKT_CONFIG_FILENAME = "ikt.yaml"
IKT_CONFIG_FILE = f"{IKTDIR}/{IKT_CONFIG_FILENAME}"
IKT_CONFIG_FILE_DIR = f"{IKTDIR}/{IKT_CONFIG_FILENAME}.d"

THEME_PATH = f"{THEME_DIRNAME}/default.yaml"
init_iktprint(THEME_PATH)

import about
PROGRAMDESCRIPTION = "Setup Intel Kubernetes Toolkit"
PROGRAMAUTHORS = "Written by David Weinehall."

def mkdir_if_not_exists(dir, verbose = False):
	if verbose == True:
		iktprint([("mkdir ", "programname"), (f"{dir}", "path")])
	if not os.path.exists(dir):
		os.mkdir(dir)

def copy_if_not_exists(src, dst, verbose = False):
	if verbose == True:
		iktprint([("cp ", "programname"), (f"{src} ", "path"), (f"{dst}", "path")])
	if not os.path.exists(dst):
		shutil.copy2(src, dst)

def replace_symlink(src, dst, verbose = False):
	if verbose == True:
		iktprint([("ln ", "programname"), ("-s ", "option"), (f"{src} ", "path"), (f"{dst}", "path")])
	if os.path.islink(dst):
		os.remove(dst)
	os.symlink(src, dst)

directories = [
	BINDIR,
	IKTDIR,
	DEPLOYMENTDIR,
	ANSIBLE_DIR,
	ANSIBLE_LOG_DIR,
	IKT_CONFIG_FILE_DIR,
	IKT_HOOKS_DIR,
	f"{IKT_HOOKS_DIR}/pre-upgrade.d",
	f"{IKT_HOOKS_DIR}/post-upgrade.d",
]

def create_directories(verbose = False):
	for directory in directories:
		mkdir_if_not_exists(directory, verbose = verbose)

executable_symlinks = [
	# Python
	(f"{os.getcwd()}/iktadm", f"{BINDIR}/iktadm"),
	(f"{os.getcwd()}/iktinv", f"{BINDIR}/iktinv"),
	(f"{os.getcwd()}/ikt", f"{BINDIR}/ikt"),
	(f"{os.getcwd()}/iku", f"{BINDIR}/iku"),
]

misc_symlinks = [
	(f"{os.getcwd()}/{ANSIBLE_PLAYBOOK_DIRNAME}", f"{IKTDIR}/{ANSIBLE_PLAYBOOK_DIRNAME}"),
	(f"{os.getcwd()}/{THEME_DIRNAME}", f"{IKTDIR}/{THEME_DIRNAME}"),
	(f"{os.getcwd()}/{PARSER_DIRNAME}", f"{IKTDIR}/{PARSER_DIRNAME}"),
	(f"{os.getcwd()}/{VIEW_DIRNAME}", f"{IKTDIR}/{VIEW_DIRNAME}")
]

def create_symlinks(verbose = False):
	for src, dst in misc_symlinks:
		replace_symlink(src, dst)

	for src, dst in executable_symlinks:
		replace_symlink(src, dst)

configuration_files = [
	(IKT_CONFIG_FILENAME, IKT_CONFIG_FILE)
]

def copy_configuration_files(verbose = False):
	for src, dst in configuration_files:
		copy_if_not_exists(src, dst, verbose = verbose)

packages_with_pip_fallback = {
	"python3-ansible-runner": "ansible-runner",
}

packages = [
	"ansible",
	"python3-natsort",
	"python3-openssl",
	"python3-paramiko",
	"python3-pip",
	"python3-ujson",
	"python3-urllib3",
	"sshpass",
]

def install_software(packages, verbose = False):
	args = ["/usr/bin/sudo", "/usr/bin/apt-get", "install"] + packages
	subprocess.call(args)

def install_software_with_pip_fallback(packages, verbose = False):
	pkgs = set()
	fallbacks = set()

	args = ["/usr/bin/apt-cache", "madison"] + list(packages.keys())
	response = execute_command_with_response(args)
	split_response = response.splitlines()

	for line in split_response:
		_pkg = line.split(' ', 1)
		if _pkg[0] in packages.keys() and _pkg[0] not in pkgs:
			pkgs.add(_pkg[0])

	for pkg, fallback in packages.items():
		if pkg not in pkgs:
			fallbacks.add(fallback)

	if len(pkgs) > 0:
		args = ["/usr/bin/sudo", "/usr/bin/apt-get", "install"] + list(pkgs)
		subprocess.call(args)

	if len(fallbacks) > 0:
		args = ["/usr/bin/pip3", "install"] + list(fallbacks)
		subprocess.call(args)

def install(options = [], args = None):
	verbose = False
	install_dependencies = True
	confirm = True

	for opt, optarg in options:
		if opt == "--verbose":
			verbose = True
		elif opt == "--no-dependencies":
			install_dependencies = False
		elif opt == "-Y":
			confirm = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	if confirm == True:
		iktprint([("Important:", "warning"), (" The following actions will be taken that will modify the system:", "default")])
		iktprint([("\n• ", "separator"), (f"Create the following new directories", "action")])
		for name in directories:
			iktprint([(f"    {name}", "path")])
		iktprint([("\n• ", "separator"), ("Install the following configuration files:", "action")])
		for src, dst in configuration_files:
			iktprint([(f"     {dst}", "path")])
		iktprint([("\n• ", "separator"), (f"Create the following symlinks", "action")])
		for src, dst in misc_symlinks:
			iktprint([(f"    {src}", "path"), (" ⇨ ", "emphasis"), (f"{dst}", "path")])
		for src, dst in executable_symlinks:
			iktprint([(f"    {src}", "path"), (" ⇨ ", "emphasis"), (f"{dst}", "path")])

		if install_dependencies == True:
			iktprint([("\n• ", "separator"), ("Install the following system software:", "action")])
			iktprint([("  Note:", "warning"), (" this requires sudo permissions", "emphasis")])
			for pkg in packages:
				iktprint([(f"    {pkg}", "path")])

		retval = iktinput([("\nInstall ", "default"), ("iKT", "programname"), ("? [y/", "default"), ("N", "emphasis"), ("]: ", "default")])
		if retval.lower() not in ["y", "yes"]:
			iktprint([("\nAborting:", "error"), (" User stopped installation.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	create_directories(verbose = verbose)
	copy_configuration_files(verbose = verbose)
	create_symlinks(verbose = verbose)

	if install_dependencies == True:
		install_software(packages, verbose = verbose)
		install_software_with_pip_fallback(packages_with_pip_fallback, verbose = verbose)

commandline = {
	# Default command
	"__default": {
		"command": ["__default"],
		"description": [("", "")],
		"options": {
			"--verbose": {
				"description": [("Be more verbose", "description")],
			},
			"--no-dependencies": {
				"description": [("Do not install dependencies", "description")],
			},
			"-Y": {
				"description": [("Do not ask for confirmation before performing actions", "description")],
			},
		},
		"min_args": 0,
		"max_args": 0,
		"callback": install,
	},
	"spacer1": {
		"command": [""],
		"description": [("", "")],
	},
}

def main():
	global verbose

	command, options, args = parse_commandline(about.install_program_name, about.install_program_version, PROGRAMDESCRIPTION, PROGRAMAUTHORS, sys.argv, commandline, default_command = "__default", theme = THEME_PATH)

	return command(options, args)

if __name__ == "__main__":
	main()
