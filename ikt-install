#! /usr/bin/env python3
# Requires: python3 (>= 3.6)

"""
This program installs Intel Kubernetes Toolkit
(and optionally its dependencies)

For usage, see:
	./ikt-install help
"""

import errno
import os
from pathlib import Path
import subprocess
import sys
from typing import List, Tuple

from ikttypes import ANSIThemeString, FilePath
from iktpaths import BINDIR, HOMEDIR, IKTDIR, DEPLOYMENT_DIR, ANSIBLE_DIR, ANSIBLE_LOG_DIR, IKT_CONFIG_FILE_DIR, IKT_HOOKS_DIR
from iktpaths import ANSIBLE_PLAYBOOK_DIR, IKT_CONFIG_FILE, PARSER_DIR, THEME_DIR, VIEW_DIR
from iktpaths import ANSIBLE_PLAYBOOK_DIRNAME, IKT_CONFIG_FILENAME, PARSER_DIRNAME, THEME_DIRNAME, VIEW_DIRNAME

from iktio import copy_if_not_exists, mkdir_if_not_exists, replace_symlink
from iktlib import execute_command_with_response

from commandparser import parse_commandline
from iktprint import iktprint, iktinput

import about
PROGRAMDESCRIPTION = "Setup Intel Kubernetes Toolkit"
PROGRAMAUTHORS = "Written by David Weinehall."


DIRECTORIES = [
	(BINDIR, 0o755),
	(IKTDIR, 0o755),
	(DEPLOYMENT_DIR, 0o755),
	(ANSIBLE_DIR, 0o755),
	(ANSIBLE_LOG_DIR, 0o755),
	(IKT_CONFIG_FILE_DIR, 0o755),
	(IKT_HOOKS_DIR, 0o755),
	(FilePath(os.path.join(IKT_HOOKS_DIR, "pre-upgrade.d")), 0o755),
	(FilePath(os.path.join(IKT_HOOKS_DIR, "post-upgrade.d")), 0o755),
]

EXECUTABLE_SYMLINKS = [
	# These are Python scripts
	(FilePath(os.path.join(os.getcwd(), "iktadm")), FilePath(os.path.join(BINDIR, "iktadm"))),
	(FilePath(os.path.join(os.getcwd(), "iktinv")), FilePath(os.path.join(BINDIR, "iktinv"))),
	(FilePath(os.path.join(os.getcwd(), "ikt")), FilePath(os.path.join(BINDIR, "ikt"))),
	(FilePath(os.path.join(os.getcwd(), "iku")), FilePath(os.path.join(BINDIR, "iku"))),
]

MISC_SYMLINKS = [
	(FilePath(os.path.join(os.getcwd(), ANSIBLE_PLAYBOOK_DIRNAME)), ANSIBLE_PLAYBOOK_DIR),
	(FilePath(os.path.join(os.getcwd(), THEME_DIRNAME)), THEME_DIR),
	(FilePath(os.path.join(os.getcwd(), PARSER_DIRNAME)), PARSER_DIR),
	(FilePath(os.path.join(os.getcwd(), VIEW_DIRNAME)), VIEW_DIR)
]

PACKAGES_WITH_PIP_FALLBACK = {
	"python3-ansible-runner": "ansible-runner",
}

PACKAGES_WITHOUT_FALLBACK = [
	"ansible",
	"python3-natsort",
	"python3-openssl",
	"python3-paramiko",
	"python3-pip",
	"python3-ujson",
	"python3-urllib3",
	"sshpass",
]

CONFIGURATION_FILES = [
	(IKT_CONFIG_FILENAME, IKT_CONFIG_FILE, 0o644)
]

def create_directories(directories, verbose: bool = False) -> None:
	"""
	Batch create directories
	If a directory already exists it is silently ignored

		Parameters:
			directories (list[str]): A list of directories (full path) to create
			verbose (bool): Be more verbose
	"""

	for directory, permissions in directories:
		mkdir_if_not_exists(directory, permissions = permissions, verbose = verbose)

def create_symlinks(symlinks, verbose: bool = False) -> None:
	"""
	Batch create symlinks
	If a symlink already exists it is *replaced*

		Parameters:
			symlinks (list[(str, str)]): A list of symlinks (full path) to create; (src, dst)
			verbose (bool): Be more verbose
	"""

	for src, dst in symlinks:
		replace_symlink(src, dst, verbose = verbose)

def copy_files(files, verbose: bool = False) -> None:
	"""
	Batch copy files
	If a file already exists it is silently ignored

		Parameters:
			files (list[(str, str)]): A list of files (full path) to copy; (src, dst)
			verbose (bool): Be more verbose
	"""

	for src, dst, permissions in files:
		copy_if_not_exists(src, dst, verbose = verbose, permissions = permissions)

def install_software(packages, verbose: bool = False) -> None:
	"""
	Batch install Debian packages

		Parameters:
			packages (list[str]): A list of packages to install
			verbose (bool): Unused
	"""

	del verbose
	args = ["/usr/bin/sudo", "/usr/bin/apt-get", "install"] + packages
	_retval = subprocess.run(args, check = False).returncode

def install_software_with_pip_fallback(packages, verbose: bool = False, dryrun: bool = False) -> Tuple[List[str], List[str]]:
	"""
	Batch install Debian packages with pip fallback
	This function tries to install a Python module from a Debian package;
	if that package doesn't exist it installs the pip version of the module instead

		Parameters:
			packages (list[(str, str)]): A list of packages to install (pkg, fallback)
			verbose (bool): Unused
		Returns:
			(pkgs, fallbacks):
				pkgs (list[str]): Packages that were, or would be, installed as Debian packages
				fallbacks (list[str]): Packages that were, or would be, installed using pip
	"""

	del verbose

	pkgs = set()
	fallbacks = set()

	args = ["/usr/bin/apt-cache", "madison"] + list(packages.keys())
	response = execute_command_with_response(args)
	split_response = response.splitlines()

	for line in split_response:
		_pkg = line.split(' ', 1)
		if _pkg[0] in packages.keys() and _pkg[0] not in pkgs:
			pkgs.add(_pkg[0])

	for pkg, fallback in packages.items():
		if pkg not in pkgs:
			fallbacks.add(fallback)

	if len(pkgs) > 0 and dryrun == False:
		args = ["/usr/bin/sudo", "/usr/bin/apt-get", "install"] + list(pkgs)
		_retval = subprocess.run(args, check = False).returncode

	if len(fallbacks) > 0 and dryrun == False:
		args = ["/usr/bin/pip3", "install"] + list(fallbacks)
		_retval = subprocess.run(args, check = False).returncode

	return list(pkgs), list(fallbacks)

def install(options, args) -> None:
	"""
	Create directories, install configuration files, create symlinks,
	and optionally install packages necessary to run iKT
	"""

	del args

	verbose: bool = False
	install_dependencies: bool = True
	confirm: bool = True
	allow_fallback: bool = True

	for opt, _optarg in options:
		if opt == "--verbose":
			verbose = True
		elif opt == "--no-dependencies":
			install_dependencies = False
		elif opt == "--no-fallback":
			allow_fallback = False
		elif opt == "-Y":
			confirm = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	if confirm == True:
		iktprint([ANSIThemeString("Important:", "warning"), ANSIThemeString(" The following actions will be taken that will modify the system:", "default")])
		pkgs: List[str] = []
		pkgs_fallback: List[str] = []

		if install_dependencies == True:
			pkgs, pkgs_fallback = install_software_with_pip_fallback(PACKAGES_WITH_PIP_FALLBACK, dryrun = True)
			iktprint([ANSIThemeString("\n• ", "separator"), ANSIThemeString("Install the following system software:", "action")])
			iktprint([ANSIThemeString("  Note", "warning"), ANSIThemeString(": This requires sudo permissions", "emphasis")])
			for pkg in PACKAGES_WITHOUT_FALLBACK + pkgs:
				iktprint([ANSIThemeString(f"    {pkg}", "path")])
			for pkg in pkgs_fallback:
				iktprint([ANSIThemeString(f"    {pkg}", "path"), ANSIThemeString(" (Using package from PIP)", "emphasis")])

		iktprint([ANSIThemeString("\n• ", "separator"), ANSIThemeString("Create the following new directories:", "action")])
		for name, _permissions in DIRECTORIES:
			iktprint([ANSIThemeString(f"    {name}", "path")])
		iktprint([ANSIThemeString("\n• ", "separator"), ANSIThemeString("Install the following configuration files:", "action")])
		for src, dst, _permissions in CONFIGURATION_FILES:
			iktprint([ANSIThemeString(f"     {dst}", "path")])
		iktprint([ANSIThemeString("\n• ", "separator"), ANSIThemeString("Create the following symlinks:", "action")])
		for src, dst in MISC_SYMLINKS:
			iktprint([ANSIThemeString(f"    {src}", "path"), ANSIThemeString(" ⇨ ", "emphasis"), ANSIThemeString(f"{dst}", "path")])
		for src, dst in EXECUTABLE_SYMLINKS:
			iktprint([ANSIThemeString(f"    {src}", "path"), ANSIThemeString(" ⇨ ", "emphasis"), ANSIThemeString(f"{dst}", "path")])

		if install_dependencies == True and allow_fallback == False and len(pkgs_fallback) > 0:
			iktprint([ANSIThemeString("\n", "default"), ANSIThemeString("Error", "error"),
				  ANSIThemeString(": Installation would require fallback to PIP, but “", "default"),
				  ANSIThemeString("--no-fallback", "option"),
				  ANSIThemeString("“ was specified; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)

		retval = iktinput([ANSIThemeString("\nInstall ", "default"), ANSIThemeString("iKT", "programname"),
				   ANSIThemeString("? [y/", "default"), ANSIThemeString("N", "emphasis"), ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([ANSIThemeString("\nAborting:", "error"), ANSIThemeString(" User stopped installation.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	if install_dependencies == True:
		install_software_with_pip_fallback(PACKAGES_WITH_PIP_FALLBACK, verbose = verbose)
		install_software(PACKAGES_WITHOUT_FALLBACK, verbose = verbose)

	create_directories(directories = DIRECTORIES, verbose = verbose)
	copy_files(files = CONFIGURATION_FILES, verbose = verbose)
	create_symlinks(symlinks = MISC_SYMLINKS + EXECUTABLE_SYMLINKS, verbose = verbose)

COMMANDLINE = {
	# Default command
	"__global_options": {
		"command": ["__global_options"],
		"description": [ANSIThemeString("", "")],
		"options": {
			"--no-dependencies": {
				"description": [ANSIThemeString("Do not install dependencies", "description")],
			},
			"--no-fallback": {
				"description": [ANSIThemeString("Do not use Python packages from PIP if no system package exist", "description")],
			},
			"--verbose": {
				"description": [ANSIThemeString("Be more verbose", "description")],
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation before performing actions", "description")],
			},
		},
	},
	"__default": {
		"command": ["__default"],
		"description": [ANSIThemeString("", "")],
		"min_args": 0,
		"max_args": 0,
		"callback": install,
	},
	"spacer1": {
		"command": [""],
		"description": [ANSIThemeString("", "")],
	},
}

def main() -> None:
	"""
	Main function for the program
	"""

	# Before doing anything else, make sure that the user isn't running as root
	if os.geteuid() == 0:
		sys.exit("CRITICAL: This program should not be run as the root user; aborting.")

	homepath = Path(HOMEDIR)
	path_stat = homepath.stat()
	path_permissions = path_stat.st_mode & 0o777

	if path_permissions & 0o002:
		sys.exit(f"CRITICAL: The destination directory {HOMEDIR} is world-writable; aborting.")

	command, options, args = parse_commandline(about.INSTALL_PROGRAM_NAME, about.INSTALL_PROGRAM_VERSION, PROGRAMDESCRIPTION, PROGRAMAUTHORS, sys.argv,
						   COMMANDLINE, default_command = "__default", theme = FilePath(os.path.join(os.getcwd(), "themes", "default.yaml")))

	return command(options, args)

if __name__ == "__main__":
	main()
