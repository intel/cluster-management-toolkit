#! /usr/bin/env python3
# Requires: python3 (>= 3.6)
import os
from pathlib import Path
import shutil
import subprocess
from subprocess import PIPE, STDOUT
import sys
import yaml

from commandparser import parse_commandline
from iktprint import iktprint, init_iktprint

HOMEDIR = str(Path.home())
BINDIR = f"{HOMEDIR}/bin"
IKTDIR = f"{HOMEDIR}/.ikt"
DEPLOYMENTDIR = f"{IKTDIR}/deployments"
THEME_DIRNAME = "themes"
THEMEDIR = f"{IKTDIR}/{THEME_DIRNAME}"
ANSIBLE_DIR = f"{IKTDIR}/ansible"
ANSIBLE_PLAYBOOK_DIRNAME = "playbooks"
ANSIBLE_LOG_DIR = f"{ANSIBLE_DIR}/logs"
IKT_HOOKS_DIR = f"{IKTDIR}/hooks"
PARSER_DIRNAME = "parsers"
VIEW_DIRNAME = "views"

IKT_CONFIG_FILENAME = "ikt.yaml"
IKT_CONFIG_FILE = f"{IKTDIR}/{IKT_CONFIG_FILENAME}"
IKT_CONFIG_FILE_DIR = f"{IKTDIR}/{IKT_CONFIG_FILENAME}.d"

THEME_PATH = f"{THEME_DIRNAME}/default.yaml"
init_iktprint(THEME_PATH)

import about
PROGRAMDESCRIPTION = "Setup Intel Kubernetes Toolkit"
PROGRAMAUTHORS = "Written by David Weinehall."

def mkdir_if_not_exists(dir, verbose = False):
	if verbose == True:
		iktprint([("mkdir ", "programname"), (f"{dir}", "path")])
	if not os.path.exists(dir):
		os.mkdir(dir)

def copy_if_not_exists(src, dst, verbose = False):
	if verbose == True:
		iktprint([("cp ", "programname"), (f"{src} ", "path"), (f"{dst}", "path")])
	if not os.path.exists(dst):
		shutil.copy2(src, dst)

def replace_symlink(src, dst, verbose = False):
	if verbose == True:
		iktprint([("ln ", "programname"), ("-s ", "option"), (f"{src} ", "path"), (f"{dst}", "path")])
	if os.path.islink(dst):
		os.remove(dst)
	os.symlink(src, dst)

directories = [
	BINDIR,
	IKTDIR,
	DEPLOYMENTDIR,
	ANSIBLE_DIR,
	ANSIBLE_LOG_DIR,
	IKT_CONFIG_FILE_DIR,
	IKT_HOOKS_DIR,
	f"{IKT_HOOKS_DIR}/pre-upgrade.d",
	f"{IKT_HOOKS_DIR}/post-upgrade.d",
]

def create_directories(verbose = False):
	for directory in directories:
		mkdir_if_not_exists(directory, verbose = verbose)

commands = [
	# Python
	"iktadm",
	"iktinv",
	"ikt",
	"iku",
]

def create_symlinks(verbose = False):
	replace_symlink(f"{os.getcwd()}/{ANSIBLE_PLAYBOOK_DIRNAME}", f"{IKTDIR}/{ANSIBLE_PLAYBOOK_DIRNAME}")
	replace_symlink(f"{os.getcwd()}/{THEME_DIRNAME}", f"{IKTDIR}/{THEME_DIRNAME}")
	replace_symlink(f"{os.getcwd()}/{PARSER_DIRNAME}", f"{IKTDIR}/{PARSER_DIRNAME}")
	replace_symlink(f"{os.getcwd()}/{VIEW_DIRNAME}", f"{IKTDIR}/{VIEW_DIRNAME}")

	for filename in commands:
		replace_symlink(f"{os.getcwd()}/{filename}", f"{BINDIR}/{filename}")

def copy_configuration_files(verbose = False):
	copy_if_not_exists(IKT_CONFIG_FILENAME, IKT_CONFIG_FILE, verbose = verbose)

packages_with_pip_fallback = {
	"python3-ansible-runner": "ansible-runner",
}

packages = [
	"ansible",
	"python3-natsort",
	"python3-openssl",
	"python3-paramiko",
	"python3-pip",
	"python3-ujson",
	"python3-urllib3",
	"sshpass",
]

# This executes a command with the output captured
def execute_command_with_response(args):
	result = subprocess.run(args, stdout = PIPE, stderr = STDOUT, check = False)
	return result.stdout.decode("utf-8")

def install_software(packages, verbose = False):
	args = ["/usr/bin/sudo", "/usr/bin/apt-get", "install"] + packages
	subprocess.call(args)

def install_software_with_pip_fallback(packages, verbose = False):
	pkgs = set()
	fallbacks = set()

	args = ["/usr/bin/apt-cache", "madison"] + list(packages.keys())
	response = execute_command_with_response(args)
	split_response = response.splitlines()

	for line in split_response:
		_pkg = line.split(' ', 1)
		if _pkg[0] in packages.keys() and _pkg[0] not in pkgs:
			pkgs.add(_pkg[0])

	for pkg, fallback in packages.items():
		if pkg not in pkgs:
			fallbacks.add(fallback)

	if len(pkgs) > 0:
		args = ["/usr/bin/sudo", "/usr/bin/apt-get", "install"] + list(pkgs)
		subprocess.call(args)

	if len(fallbacks) > 0:
		args = ["/usr/bin/pip3", "install"] + list(fallbacks)
		subprocess.call(args)

def install(options = [], args = None):
	verbose = False
	install_dependencies = True

	for opt, optarg in options:
		if opt == "--verbose":
			verbose = True
		elif opt == "--no-dependencies":
			install_dependencies = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	create_directories(verbose = verbose)
	copy_configuration_files(verbose = verbose)
	create_symlinks(verbose = verbose)

	if install_dependencies == True:
		install_software(packages, verbose = verbose)
		install_software_with_pip_fallback(packages_with_pip_fallback, verbose = verbose)

commandline = {
	# Global option
	"__verbose": {
		"command": [""],
		"description": [("", "")],
		"options": {
			"--verbose": {
				"description": [("Be more verbose", "description")],
			},
			"--no-dependencies": {
				"description": [("Do not install dependencies", "description")],
			},
		},
		"min_args": 0,
		"max_args": 0,
		"callback": install,
	},
	# Default command
	"__default": {
		"command": ["__default"],
		"description": [("", "")],
		"options": {
			"--no-dependencies": {
				"description": [("Do not install dependencies", "description")],
			},
		},
		"min_args": 0,
		"max_args": 0,
		"callback": install,
	},
	"spacer1": {
		"command": [""],
		"description": [("", "")],
	},
}

def main():
	global verbose

	command, options, args = parse_commandline(about.install_program_name, about.install_program_version, PROGRAMDESCRIPTION, PROGRAMAUTHORS, sys.argv, commandline, default_command = "__default", theme = THEME_PATH)

	return command(options, args)

if __name__ == "__main__":
	main()
