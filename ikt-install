#! /usr/bin/env python3
# Requires: python3 (>= 3.6)

"""
This program installs Intel Kubernetes Toolkit
(and optionally its dependencies)

For usage, see:
	./ikt-install help
"""

import errno
import os
import subprocess
import sys
import typing # pylint: disable=unused-import

from ikttypes import FilePath
from iktpaths import BINDIR, IKTDIR, DEPLOYMENT_DIR, ANSIBLE_DIR, ANSIBLE_LOG_DIR, IKT_CONFIG_FILE_DIR, IKT_HOOKS_DIR
from iktpaths import ANSIBLE_PLAYBOOK_DIR, IKT_CONFIG_FILE, PARSER_DIR, THEME_DIR, VIEW_DIR
from iktpaths import DEFAULT_THEME_FILE
from iktpaths import ANSIBLE_PLAYBOOK_DIRNAME, IKT_CONFIG_FILENAME, PARSER_DIRNAME, THEME_DIRNAME, VIEW_DIRNAME

from iktio import copy_if_not_exists, mkdir_if_not_exists, replace_symlink
from iktlib import execute_command_with_response

from commandparser import parse_commandline
from iktprint import iktprint, iktinput

import about
PROGRAMDESCRIPTION = "Setup Intel Kubernetes Toolkit"
PROGRAMAUTHORS = "Written by David Weinehall."


DIRECTORIES = [
	BINDIR,
	IKTDIR,
	DEPLOYMENT_DIR,
	ANSIBLE_DIR,
	ANSIBLE_LOG_DIR,
	IKT_CONFIG_FILE_DIR,
	IKT_HOOKS_DIR,
	FilePath(os.path.join(IKT_HOOKS_DIR, "pre-upgrade.d")),
	FilePath(os.path.join(IKT_HOOKS_DIR, "post-upgrade.d")),
]

EXECUTABLE_SYMLINKS = [
	# Python
	(FilePath(os.path.join(os.getcwd(), "iktadm")), FilePath(os.path.join(BINDIR, "iktadm"))),
	(FilePath(os.path.join(os.getcwd(), "iktinv")), FilePath(os.path.join(BINDIR, "iktinv"))),
	(FilePath(os.path.join(os.getcwd(), "ikt")), FilePath(os.path.join(BINDIR, "ikt"))),
	(FilePath(os.path.join(os.getcwd(), "iku")), FilePath(os.path.join(BINDIR, "iku"))),
]

MISC_SYMLINKS = [
	(FilePath(os.path.join(os.getcwd(), ANSIBLE_PLAYBOOK_DIRNAME)), ANSIBLE_PLAYBOOK_DIR),
	(FilePath(os.path.join(os.getcwd(), THEME_DIRNAME)), THEME_DIR),
	(FilePath(os.path.join(os.getcwd(), PARSER_DIRNAME)), PARSER_DIR),
	(FilePath(os.path.join(os.getcwd(), VIEW_DIRNAME)), VIEW_DIR)
]

PACKAGES_WITH_PIP_FALLBACK = {
	"python3-ansible-runner": "ansible-runner",
}

PACKAGES_WITHOUT_FALLBACK = [
	"ansible",
	"python3-natsort",
	"python3-openssl",
	"python3-paramiko",
	"python3-pip",
	"python3-ujson",
	"python3-urllib3",
	"sshpass",
]

CONFIGURATION_FILES = [
	(IKT_CONFIG_FILENAME, IKT_CONFIG_FILE)
]

def create_directories(directories, verbose: bool = False):
	"""
	Batch create directories
	If a directory already exists it is silently ignored

		Parameters:
			directories (list[str]): A list of directories (full path) to create
			verbose (bool): Be more verbose
	"""

	for directory in directories:
		mkdir_if_not_exists(directory, verbose = verbose)

def create_symlinks(symlinks, verbose: bool = False):
	"""
	Batch create symlinks
	If a symlink already exists it is *replaced*

		Parameters:
			symlinks (list[(str, str)]): A list of symlinks (full path) to create; (src, dst)
			verbose (bool): Be more verbose
	"""

	for src, dst in symlinks:
		replace_symlink(src, dst, verbose = verbose)

def copy_files(files, verbose: bool = False):
	"""
	Batch copy files
	If a file already exists it is silently ignored

		Parameters:
			files (list[(str, str)]): A list of files (full path) to copy; (src, dst)
			verbose (bool): Be more verbose
	"""

	for src, dst in files:
		copy_if_not_exists(src, dst, verbose = verbose)

def install_software(packages, verbose: bool = False):
	"""
	Batch install Debian packages

		Parameters:
			packages (list[str]): A list of packages to install
			verbose (bool): Unused
	"""

	del verbose
	args = ["/usr/bin/sudo", "/usr/bin/apt-get", "install"] + packages
	subprocess.call(args)

def install_software_with_pip_fallback(packages, verbose: bool = False, dryrun: bool = False):
	"""
	Batch install Debian packages with pip fallback
	This function tries to install a Python module from a Debian package;
	if that package doesn't exist it installs the pip version of the module instead

		Parameters:
			packages (list[(str, str)]): A list of packages to install (pkg, fallback)
			verbose (bool): Unused
	"""

	del verbose

	pkgs = set()
	fallbacks = set()

	args = ["/usr/bin/apt-cache", "madison"] + list(packages.keys())
	response = execute_command_with_response(args)
	split_response = response.splitlines()

	for line in split_response:
		_pkg = line.split(' ', 1)
		if _pkg[0] in packages.keys() and _pkg[0] not in pkgs:
			pkgs.add(_pkg[0])

	for pkg, fallback in packages.items():
		if pkg not in pkgs:
			fallbacks.add(fallback)

	if len(pkgs) > 0 and dryrun == False:
		args = ["/usr/bin/sudo", "/usr/bin/apt-get", "install"] + list(pkgs)
		subprocess.call(args)

	if len(fallbacks) > 0 and dryrun == False:
		args = ["/usr/bin/pip3", "install"] + list(fallbacks)
		subprocess.call(args)

	return list(pkgs), list(fallbacks)

def install(options, args):
	"""
	Create directories, install configuration files, create symlinks,
	and optionally install packages necessary to run iKT
	"""

	del args

	verbose: bool = False
	install_dependencies: bool = True
	confirm: bool = True
	allow_fallback: bool = True

	for opt, _optarg in options:
		if opt == "--verbose":
			verbose = True
		elif opt == "--no-dependencies":
			install_dependencies = False
		elif opt == "--no-fallback":
			allow_fallback = False
		elif opt == "-Y":
			confirm = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	if confirm == True:
		iktprint([("Important:", "warning"), (" The following actions will be taken that will modify the system:", "default")])
		pkgs = []
		pkgs_fallback = []

		if install_dependencies == True:
			pkgs, pkgs_fallback = install_software_with_pip_fallback(PACKAGES_WITH_PIP_FALLBACK, dryrun = True)
			iktprint([("\n• ", "separator"), ("Install the following system software:", "action")])
			iktprint([("  Note:", "warning"), (" this requires sudo permissions", "emphasis")])
			for pkg in PACKAGES_WITHOUT_FALLBACK + pkgs:
				iktprint([(f"    {pkg}", "path")])
			for pkg in pkgs_fallback:
				iktprint([(f"    {pkg}", "path"), (" (Using package from PIP)", "emphasis")])

		iktprint([("\n• ", "separator"), ("Create the following new directories:", "action")])
		for name in DIRECTORIES:
			iktprint([(f"    {name}", "path")])
		iktprint([("\n• ", "separator"), ("Install the following configuration files:", "action")])
		for src, dst in CONFIGURATION_FILES:
			iktprint([(f"     {dst}", "path")])
		iktprint([("\n• ", "separator"), ("Create the following symlinks:", "action")])
		for src, dst in MISC_SYMLINKS:
			iktprint([(f"    {src}", "path"), (" ⇨ ", "emphasis"), (f"{dst}", "path")])
		for src, dst in EXECUTABLE_SYMLINKS:
			iktprint([(f"    {src}", "path"), (" ⇨ ", "emphasis"), (f"{dst}", "path")])

		if install_dependencies == True and allow_fallback == False and len(pkgs_fallback) > 0:
			iktprint([("\n", "default"), ("Error:", "error"),
				  (" Installation would require fallback to PIP, but “", "default"),
				  ("--no-fallback", "option"),
				  ("“ was specified; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)

		retval = iktinput([("\nInstall ", "default"), ("iKT", "programname"), ("? [y/", "default"), ("N", "emphasis"), ("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([("\nAborting:", "error"), (" User stopped installation.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	if install_dependencies == True:
		install_software_with_pip_fallback(PACKAGES_WITH_PIP_FALLBACK, verbose = verbose)
		install_software(PACKAGES_WITHOUT_FALLBACK, verbose = verbose)

	create_directories(directories = DIRECTORIES, verbose = verbose)
	copy_files(files = CONFIGURATION_FILES, verbose = verbose)
	create_symlinks(symlinks = MISC_SYMLINKS + EXECUTABLE_SYMLINKS, verbose = verbose)

COMMANDLINE = {
	# Default command
	"__global_options": {
		"command": ["__global_options"],
		"description": [("", "")],
		"options": {
			"--no-dependencies": {
				"description": [("Do not install dependencies", "description")],
			},
			"--no-fallback": {
				"description": [("Do not use Python packages from PIP if no system package exist", "description")],
			},
			"--verbose": {
				"description": [("Be more verbose", "description")],
			},
			"-Y": {
				"description": [("Do not ask for confirmation before performing actions", "description")],
			},
		},
	},
	"__default": {
		"command": ["__default"],
		"description": [("", "")],
		"min_args": 0,
		"max_args": 0,
		"callback": install,
	},
	"spacer1": {
		"command": [""],
		"description": [("", "")],
	},
}

def main():
	"""
	Main function for the program
	"""

	# Before doing anything else, make sure that the user isn't running as root
	if os.geteuid() == 0:
		sys.exit("CRITICAL: This program should not be run as the root user; aborting.")

	command, options, args = parse_commandline(about.INSTALL_PROGRAM_NAME, about.INSTALL_PROGRAM_VERSION, PROGRAMDESCRIPTION, PROGRAMAUTHORS,
						   sys.argv, COMMANDLINE, default_command = "__default", theme = DEFAULT_THEME_FILE)

	return command(options, args)

if __name__ == "__main__":
	main()
