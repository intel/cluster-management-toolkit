#! /bin/sh
# vim: filetype=python
''''eval version=$( ls /usr/bin | grep 'python3\.[0-9]*$' | sed -e 's/.*\.\([0-9]*\)$/\1/' | sort -nr | head -n1 ) && [ ${version} ] && [ ${version} -ge 8 ] && exec /usr/bin/python3.${version} "$0" "$@" || exec /usr/bin/env python3 "$0" "$@"' #'''
__doc__ = "The above hack is to handle distros that don't have /usr/bin/python3 point to the latest version of python3 they provide"
# Requires: python3 (>= 3.8)
# Requires: python3-natsort
# Requires: python3-paramiko

# pylint: disable=line-too-long

"""
This program is used to install, upgrade and uninstall control planes for Kubernetes clusters,
and to perform various other administrative tasks

For usage, see:
	cmtadm help
"""

import errno
from getpass import getuser
from glob import glob
import grp
import os
from pathlib import Path, PurePath
import pwd
import re
import shutil
import socket
import subprocess
import sys
import tempfile
from typing import Callable, cast, Dict, List, Optional, Set, Tuple, Union

try:
	from natsort import natsorted
except ModuleNotFoundError:
	sys.exit("ModuleNotFoundError: You probably need to install python3-natsort; did you forget to run cmt-install?")

from cmttypes import deep_get, DictPath, FilePath, FilePathAuditError, SecurityChecks, SecurityPolicy, SecurityStatus
from cmtpaths import BASH_COMPLETION_BASE_DIR, BASH_COMPLETION_DIR, BINDIR, HOMEDIR, SSH_DIR, SSH_KEYGEN_BIN_PATH, SSH_KEYGEN_ARGS
from cmtpaths import DEPLOYMENT_DIR, CMT_HOOKS_DIR
from cmtpaths import ANSIBLE_PLAYBOOK_DIR, ANSIBLE_INVENTORY
from cmtpaths import DEFAULT_THEME_FILE, CMT_CONFIG_FILE, CMT_INSTALLATION_INFO_FILE, KUBE_CONFIG_DIR, KUBE_CONFIG_FILE

from commandparser import parse_commandline

from ansible_helper import ansible_configuration, ansible_get_inventory_dict, ansible_set_vars
from ansible_helper import ansible_run_playbook_on_selection, ansible_add_hosts, ansible_get_hosts_by_group, get_playbook_path
from ansible_helper import ansible_print_play_results, populate_playbooks_from_paths

import cmtio
from cmtio import check_path, execute_command, execute_command_with_response, join_securitystatus_set, secure_mkdir
from cmtio import secure_read_string, secure_rm, secure_which, secure_write_string
from cmtio_yaml import secure_read_yaml, secure_write_yaml
from networkio import download_files, scan_and_add_ssh_keys

import cmtlib
from cmtlib import check_deb_versions, identify_distro, read_cmtconfig

import kubernetes_helper

from ansithemeprint import ANSIThemeString, ansithemeinput, ansithemeinput_password, ansithemeprint
from ansithemeprint import themearray_override_formatting

import checks

import about
PROGRAMDESCRIPTION = "Setup or teardown a Kubernetes cluster"
PROGRAMAUTHORS = "Written by David Weinehall."

DEFAULT_CNI = "cilium"
DEFAULT_POD_NETWORK_CIDR = "10.244.0.0/16"

no_password = False

cri_data: Dict = {
	"containerd": {
		"socket": "unix:///run/containerd/containerd.sock",
	},
	"cri-o": {
		"socket": "unix:///run/crio/crio.sock",
	},
	"docker-shim": {
		"socket": "unix:///run/dockershim.sock",
	}
}

prepare_targets: Dict = {
	"kubeadm": {
		"pretty_name": [("kubeadm", "programname"), (" (default)", "default")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_passwordless_ansible.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("install_packages.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_control_plane.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("add_kubernetes_repo.yaml"))),
		],
		"deb_packages": [
		],
	},
	"localhost": {
		"pretty_name": [("host system", "programname")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_passwordless_ansible.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("add_kubernetes_repo.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("install_packages.yaml"))),
		],
		"deb_packages": [
			"ansible",
		],
		"suse_packages": [
			"ansible",
		],
	},
	"rke2": {
		"pretty_name": [("kubeadm", "programname"), (" (default)", "default")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_passwordless_ansible.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("install_packages.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_control_plane.yaml"))),
		],
		"deb_packages": [
		],
	},
}

setup_control_plane_targets: Dict = {
	"kubeadm": {
		"pretty_name": [("kubeadm", "programname"), (" (default)", "default")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("install_packages.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_setup_control_plane.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("fetch_kube_config.yaml"))),
		],
		"deb_packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
			"kubernetes-cni",
		],
		"deb_packages_held": [
			"kubeadm",
			"kubectl",
			"kubelet",
		],
		"extra_values": {
		},
	},
	"localhost": {
		"pretty_name": [("host system", "programname")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("install_packages.yaml"))),
		],
		"deb_packages": [
			"kubectl",
		],
		"deb_packages_held": [
			"kubectl",
		],
		"suse_packages": [
			"kubectl",
		],
		"suse_packages_held": [
			"kubectl",
		],
	},
	"rke2": {
		"pretty_name": [("RKE2", "programname")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("rke2_setup_control_plane.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("fetch_kube_config.yaml"))),
		],
		"extra_values": {
		},
	},
}

upgrade_control_plane_targets: Dict = {
	"kubeadm": {
		"pretty_name": [("kubeadm", "programname"), (" (default)", "default")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_upgrade_control_plane.yaml"))),
		],
		"extra_values": {
		},
	},
	"localhost": {
		"pretty_name": [("host system", "programname")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("install_packages.yaml"))),
		],
		"deb_packages": [
			"kubectl",
		],
		"deb_packages_held": [
			"kubectl",
		],
	},
	"rke2": {
		"pretty_name": [("RKE2", "programname")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("rke2_upgrade_control_plane.yaml"))),
		],
		"extra_values": {
		},
	},
}

teardown_control_plane_targets: Dict = {
	"kubeadm": {
		"pretty_name": [("kubeadm", "programname"), (" (default)", "default")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("teardown_cni.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_teardown_control_plane.yaml"))),
		],
	},
	"rke2": {
		"pretty_name": [("RKE2", "programname")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("rke2_teardown_control_plane.yaml"))),
		],
	},
}

purge_control_plane_targets: Dict = {
	"kubeadm": {
		"pretty_name": [("kubeadm", "programname"), (" (default)", "default")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_purge.yaml"))),
		],
		"deb_packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
			"kubernetes-cni",
		],
		"deb_packages_held": [
			"kubeadm",
			"kubectl",
			"kubelet",
		],
	},
	"rke2": {
		"pretty_name": [("rke2", "programname")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("rke2_purge.yaml"))),
		],
	},
}

def get_control_plane_version(controlplane: str, k8s_distro: str) -> str:
	version = None

	if k8s_distro == "rke2":
		# This will only work for running clusters
		from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
		kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

		vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
		if status != 200:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": API-server returned ", "default"),
					ANSIThemeString(f"{status}", "errorvalue"),
					ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		if vlist is None:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": API-server did not return any data", "default")], stderr = True)
			sys.exit(errno.EINVAL)

		for node in vlist:
			name = deep_get(node, DictPath("metadata#name"))
			if name == controlplane:
				version = deep_get(node, DictPath("status#nodeInfo#kubeletVersion"))
				break
	else:
		# For kubeadm we try to use the package version
		get_versions_path = get_playbook_path(FilePath("get_versions.yaml"))
		retval, ansible_results = ansible_run_playbook_on_selection(get_versions_path, selection = [controlplane])

		if len(ansible_results) == 0:
			raise ValueError(f"Error: Failed to get package versions from {controlplane} (retval: {retval}); aborting.")

		k8s_distro = "<unknown>"
		version = "<unknown>"

		for result in deep_get(ansible_results, DictPath(controlplane), []):
			if deep_get(result, DictPath("task"), "") == "Package versions":
				tmp = deep_get(result, DictPath("msg_lines"), [])
				break

		if len(tmp) == 0:
			raise ValueError(f"Error: Received empty version data from {controlplane} (retval: {retval}); aborting.")

		# Safe
		package_version_regex = re.compile(r"^(.*?): (.*)")

		for line in tmp:
			tmp2 = package_version_regex.match(line)
			if tmp2 is None:
				continue
			package = tmp2[1]
			package_version = tmp2[2]
			if package == "kubeadm":
				version = package_version
				break

	return version

def rebuild_installation_info(state: Optional[str] = None) -> None:
	"""
	If the installation info file does not exist, but a cluster already exists and is part of the inventory,
	this function will try to rebuild the installation info file

		Parameters:
			state (str): The installation state
	"""

	k8s_distro = None
	controlplane = None
	cri = "<none>"

	controlplanes = __selection_control_planes()
	if controlplanes is None or len(controlplanes) == 0:
		ansithemeprint([ANSIThemeString("", "default")])
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": No control plane defined in inventory; cannot rebuild installation info. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# This will only work for running clusters
	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
	if status != 200:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": API-server returned ", "default"),
				ANSIThemeString(f"{status}", "errorvalue"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)
	if vlist is None:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": API-server did not return any data", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for node in vlist:
		name = deep_get(node, DictPath("metadata#name"))
		node_roles = kh.get_node_roles(cast(Dict, node))
		if "control-plane" in node_roles or "master" in node_roles:
			controlplane = name
			cri = deep_get(node, DictPath("status#nodeInfo#containerRuntimeVersion"), "")
			if cri is not None:
				cri = cri.split(":")[0]
			ipaddresses = []
			for address in deep_get(node, DictPath("status#addresses")):
				if deep_get(address, DictPath("type"), "") == "InternalIP":
					ipaddresses.append(deep_get(address, DictPath("address")))
			tmp_k8s_distro = None
			minikube_name = deep_get(node, DictPath("metadata#labels#minikube.k8s.io/name"), "")
			labels = deep_get(node, DictPath("metadata#labels"), {})
			images = deep_get(node, DictPath("status#images"), [])
			for image in images:
				names = deep_get(image, DictPath("names"), [])
				for name in names:
					if "openshift-crc-cluster" in name:
						tmp_k8s_distro = "crc"
						break
				if tmp_k8s_distro is not None:
					break
			if minikube_name != "":
				tmp_k8s_distro = "minikube"
			elif deep_get(labels, DictPath("microk8s.io/cluster"), False) == True:
				tmp_k8s_distro = "microk8s"
			else:
				managed_fields = deep_get(node, DictPath("metadata#managedFields"), [])
				for managed_field in managed_fields:
					manager = deep_get(managed_field, DictPath("manager"), "")
					if manager == "rke2":
						tmp_k8s_distro = "rke2"
						break
					if manager == "k0s":
						tmp_k8s_distro = "k0s"
						break
					if manager == "k3s":
						tmp_k8s_distro = "k3s"
						break
					if manager == "kubeadm":
						tmp_k8s_distro = "kubeadm"
						break
			if tmp_k8s_distro is not None:
				if k8s_distro is not None:
					ansithemeprint([ANSIThemeString("Critical", "critical"),
							ANSIThemeString(": The control planes are reporting conflicting Kubernetes distros; aborting.", "default")], stderr = True)
					sys.exit(errno.EINVAL)
				else:
					k8s_distro = tmp_k8s_distro
			controlplanes.append((name, ipaddresses))

	version = get_control_plane_version(controlplane = controlplane, k8s_distro = k8s_distro)

	if version is None or len(version) == 0:
		ansithemeprint([ANSIThemeString("", "default")])
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Failed to get Kubernetes version; currently only kubeadm and RKE2 are supported. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	cluster_name = get_cluster_name()
	pod_network_cidr = kh.get_pod_network_cidr()
	cnis = kh.identify_cni()
	if len(cnis) == 1:
		cni = cnis[0][0]
	else:
		cni = "<unknown>"

	update_installation_info(installation_target = cluster_name, cluster_name = cluster_name, distro = k8s_distro, version = version, requested_version = "<none>",
				 state = state, phase = "<none>", phase_skiplist = [], cni = cni, cri = cri, pod_network_cidr = pod_network_cidr)

def get_installation_info(cluster_name: Optional[str] = None) -> Dict:
	"""
	Return installation info for a cluster, or prepares a new entry if no entry exists yet

		Parameters:
			cluster_name (str): The name of the cluster to get information for
		Returns:
			info (dict): A dictionary with information about a cluster
	"""

	info = None

	# We are OK with the file not existing
	checks = [
		SecurityChecks.PARENT_RESOLVES_TO_SELF,
		SecurityChecks.OWNER_IN_ALLOWLIST,
		SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
		SecurityChecks.PERMISSIONS,
		SecurityChecks.PARENT_PERMISSIONS,
		SecurityChecks.IS_FILE,
	]

	try:
		info = secure_read_yaml(CMT_INSTALLATION_INFO_FILE, checks = checks)
	except FileNotFoundError:
		pass

	if info is None or info.get("installation_target") is None or (info.get("installation_target") is not None and cluster_name is not None and cluster_name not in info):
		if info is None:
			info = {}
		info["installation_target"] = cluster_name
		info[cluster_name] = {
			"distro": "<none>",
			"version": "<none>",
			"requested_version": "<none>",
			"state": "<none>",
			"phase": "<none>",
			"phase_skiplist": [],
			"cni": "<none>",
			"pod_network_cidr": "<none>",
			"cri": "<none>",
		}
	elif info.get("installation_target") is None and cluster_name is not None:
		# Old format file; transition it
		tmpinfo = info.copy()
		tmpinfo.pop("cluster_name")
		info = {}
		info["installation_target"] = cluster_name
		info[cluster_name] = tmpinfo

	return info

# pylint: disable-next=too-many-arguments
def update_installation_info(installation_target: Optional[str] = None, cluster_name: Optional[str] = None,
			     distro: Optional[str] = None, version: Optional[str] = None, requested_version: Optional[str] = None,
			     state: Optional[str] = None, phase: Optional[Union[int, str]] = None, phase_skiplist: Optional[List[str]] = None,
			     cni: Optional[str] = None, pod_network_cidr: Optional[str] = None, cri: Optional[str] = None,
			     control_planes: Optional[List[str]] = None) -> Dict:
	"""
	Update installation info for a cluster

		Parameters:
			installation_target (str): The installation info entry to use
			cluster_name (str): The name of the cluster to update information for
			distro (str): The distribution used during installation (currently the only supported distro is kubeadm)
			version (str): The current version of Kubernetes
			requested_version (str): The requested version of Kubernetes
			state (str): The installation state
			phase (str): The installation phase
			phase_skiplist (list[str]): A list of phases to skip
			cni (str): The CNI to use
			pod_network_cidr (str): The CIDR to use for the pod network
			cri (str): The CRI to use
			control_planes ([str]): A list of the control planes
		Returns:
			info (dict): The updated installation info
	"""

	info = get_installation_info(cluster_name = cluster_name)

	if cluster_name is None:
		cluster_name = info.get("installation_target")

	if installation_target is not None:
		info["installation_target"] = installation_target
	elif info.get("installation_target") is None:
		info["installation_target"] = cluster_name

	if distro is not None:
		info[cluster_name]["distro"] = distro
	if version is not None:
		info[cluster_name]["version"] = version
	if requested_version is not None:
		info[cluster_name]["requested_version"] = requested_version
	if state is not None:
		info[cluster_name]["state"] = state
	if phase is not None:
		info[cluster_name]["phase"] = phase
	if phase_skiplist is not None:
		info[cluster_name]["phase_skiplist"] = phase_skiplist
	if cni is not None:
		info[cluster_name]["cni"] = cni
	if pod_network_cidr is not None:
		info[cluster_name]["pod_network_cidr"] = pod_network_cidr
	if cri is not None:
		info[cluster_name]["cri"] = cri
	if control_planes is not None:
		info[cluster_name]["control_planes"] = control_planes

	secure_write_yaml(CMT_INSTALLATION_INFO_FILE, info, sort_keys = False)

	return info

def check_and_print_status(retval: bool) -> None:
	"""
	A wrapper that prints OK if retval is True
	and NOT OK and aborts if retval is False
		Parameters:
			retval (bool): True on success, False on failure
	"""

	if retval == True:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

def patch_cni_calico(cni_path: FilePath, pod_network_cidr: str) -> None:
	"""
	Patch the configuration for Calico

		Parameters:
			cni_path (FilePath): The path to the CNI configuration to patch
			pod_network_cidr (str): The CIDR for the pod network
	"""

	violations = check_path(cni_path)
	if violations != [SecurityStatus.OK]:
		violations_joined = join_securitystatus_set(",", set(violations))
		raise FilePathAuditError(f"Violated rules: {violations_joined}", path = cni_path)

	# Ideally we should patch this using a round-trip capable YAML parser,
	# such as ruamel
	sedstr = fr's#cidr: 192.168.0.0/16$#cidr: {pod_network_cidr}#'
	args = ["/usr/bin/sed", "-i", "-e", sedstr, cni_path]
	check_and_print_status(execute_command(args))

def patch_cni_canal(cni_path: FilePath, pod_network_cidr: str) -> None:
	"""
	Patch the configuration for Canal

		Parameters:
			cni_path (FilePath): The path to the CNI configuration to patch
			pod_network_cidr (str): The CIDR for the pod network
	"""

	violations = check_path(cni_path)
	if violations != [SecurityStatus.OK]:
		violations_joined = join_securitystatus_set(",", set(violations))
		raise FilePathAuditError(f"Violated rules: {violations_joined}", path = cni_path)

	# Ideally we should patch this using a round-trip capable YAML parser,
	# such as ruamel
	sedstr = fr's#^\(.*"\)Network": "10.244.0.0/16"\(,.*\)$#\1Network:": "{pod_network_cidr}"\2#'
	args = ["/usr/bin/sed", "-i", "-e", sedstr, cni_path]
	check_and_print_status(execute_command(args))

def patch_cni_flannel(cni_path: FilePath, pod_network_cidr: str) -> None:
	"""
	Patch the configuration for Flannel

		Parameters:
			cni_path (FilePath): The path to the CNI configuration to patch
			pod_network_cidr (str): The CIDR for the pod network
	"""

	violations = check_path(cni_path)
	if violations != [SecurityStatus.OK]:
		violations_joined = join_securitystatus_set(",", set(violations))
		raise FilePathAuditError(f"Violated rules: {violations_joined}", path = cni_path)

	# Ideally we should patch this using a round-trip capable YAML parser,
	# such as ruamel
	sedstr = fr's#^\(.*"\)Network": "10.244.0.0/16",$#\1Network:": "{pod_network_cidr}",#'
	args = ["/usr/bin/sed", "-i", "-e", sedstr, cni_path]
	check_and_print_status(execute_command(args))

def patch_cni_weave(cni_path: FilePath, pod_network_cidr: str) -> None:
	"""
	Patch the configuration for Weave

		Parameters:
			cni_path (FilePath): The path to the CNI configuration to patch
			pod_network_cidr (str): The CIDR for the pod network
	"""

	violations = check_path(cni_path)
	if violations != [SecurityStatus.OK]:
		violations_joined = join_securitystatus_set(",", set(violations))
		raise FilePathAuditError(f"Violated rules: {violations_joined}", path = cni_path)

	# Ideally we should patch this using a round-trip capable YAML parser,
	# such as ruamel
	sedstr_remove_existing = r'/^                - name: IPALLOC_RANGE$/,+1d'
	args = ["/usr/bin/sed", "-i", "-e", sedstr_remove_existing, cni_path]
	execute_command(args)

	sedstr_add_new = fr's#^\(.*\)\(- name: INIT_CONTAINER\)$#\1- name: IPALLOC_RANGE\n\1  value: {pod_network_cidr}\n\1\2#'
	args = ["/usr/bin/sed", "-i", "-e", sedstr_add_new, cni_path]
	check_and_print_status(execute_command(args))

def get_github_version(url: str, version_regex: str) -> List[str]:
	"""
	Given a github repository find the latest released version

		Parameters:
			url (str): The github API URL to check for latest version
			version_regex (str): A regex
		Returns:
			version ([str]): A list of version number elements, or None in case of failure
	"""

	version: List[str] = []

	if url is not None:
		with tempfile.TemporaryDirectory() as td:
			check_and_print_status(download_files(td, [(url, "release.yaml", None, None)], permissions = 0o600))
			tmp = secure_read_yaml(FilePath(f"{td}/release.yaml"))
			result = deep_get(tmp, DictPath("tag_name"), "")
			versionoutput = result.splitlines()
			_version_regex = re.compile(version_regex)
			for line in versionoutput:
				tmp = _version_regex.match(line)
				if tmp is not None:
					version = list(tmp.groups())
					break

	return version

# XXX: We should convert all of cni_data to use this format instead,
#      and move all of this code to a separate file to allow it to be used both from cmu and cmtadm
cni_upgrade_data = {
	"calico": {
		"executable": {
			"candidate_version_function": get_github_version,
			"candidate_version_url": "https://api.github.com/repos/projectcalico/calico/releases/latest",
			# Safe
			"candidate_version_regex": r"(v)(\d+)(\.)(\d+)(\.)(\d+)$",
			"version_command": ["kubectl", "calico", "version"],
			# Safe
			"version_regex": r"^Client Version:\s+(v)(\d+)(\.)(\d+)(\.)(\d+)$",
			"urls": [
				{
					"url": "https://github.com/projectcalico/calico/releases/download/<<<version>>>/calicoctl-linux-<<<arch>>>",
					"checksum_url": "https://github.com/projectcalico/calico/releases/download/<<<version>>>/SHA256SUMS",
					"checksum_type": "sha256",
					"filename": "kubectl-calico",
				}
			]
		},
		"CNI": {
			"candidate_version_function": get_github_version,
			"candidate_version_url": "https://api.github.com/repos/projectcalico/calico/releases/latest",
			# Safe
			"candidate_version_regex": r"(v)(\d+)(\.)(\d+)(\.)(\d+)$",
			"urls": [
				{
					"url": "https://raw.githubusercontent.com/projectcalico/calico/<<<version>>>/manifests/tigera-operator.yaml",
					"filename": "tigera-operator-<<<version>>>.yaml",
				}, {
					"url": "https://raw.githubusercontent.com/projectcalico/calico/<<<version>>>/manifests/custom-resources.yaml",
					"filename": "calico-custom-resources-<<<version>>>.yaml",
					"patch": patch_cni_calico,
				}
			]
		}
	},
	"cilium": {
		"executable": {
			"version_command": ["cilium", "--context", "<<<context>>>", "version"],
			# Safe
			"version_regex": r"^cilium-cli: (v)(\d+)(\.)(\d+)(\.)(\d+) .*$",
			"candidate_version_url": "https://raw.githubusercontent.com/cilium/cilium-cli/master/stable.txt",
			# Safe
			"candidate_version_regex": r"(v)(\d+)(\.)(\d+)(\.)(\d+)$",
			"urls": [
				{
					"url": "https://github.com/cilium/cilium-cli/releases/download/<<<version>>>/cilium-linux-<<<arch>>>.tar.gz",
					"checksum_url": "https://github.com/cilium/cilium-cli/releases/download/<<<version>>>/cilium-linux-<<<arch>>>.tar.gz.sha256sum",
					"checksum_type": "sha256",
					"filename": "cilium",
				}
			],
		},
		"CNI": {
			"version_command": ["cilium", "--context", "<<<context>>>", "version"],
			# Safe
			"version_regex": r"^cilium image \(running\): (v)(\d+)(\.)(\d+)(\.)(\d+)$",
			"candidate_version_command": ["cilium", "--context", "<<<context>>>", "version"],
			# Safe
			"candidate_version_regex": r"^cilium image \(default\): (v)(\d+)(\.)(\d+)(\.)(\d+)$",
			"upgrade": ["cilium", "--context", "<<<context>>>", "upgrade"],
			"install": ["cilium", "--context", "<<<context>>>", "install"],
		}
	}
}

cni_data = {
	"antrea": {
		"url": "https://raw.githubusercontent.com/antrea-io/antrea/main/build/yamls/antrea.yml",
		"type": "yaml",
		"filename": "antrea.yaml",
	},
	"calico": {
		"url": "https://docs.projectcalico.org/manifests/calico.yaml",
		"type": "yaml",
		"filename": "calico.yaml",
	},
	"canal": {
		"url": "https://raw.githubusercontent.com/projectcalico/calico/v3.25.1/manifests/canal-etcd.yaml",
		"type": "yaml",
		"filename": "canal.yaml",
		"patch": patch_cni_canal,
	},
	"cilium": {
		"version_url": "https://raw.githubusercontent.com/cilium/cilium-cli/master/stable.txt",
		"url": "https://github.com/cilium/cilium-cli/releases/download/<<<version>>>/cilium-linux-<<<arch>>>.tar.gz",
		"checksum_url": "https://github.com/cilium/cilium-cli/releases/download/<<<version>>>/cilium-linux-<<<arch>>>.tar.gz.sha256sum",
		"checksum_type": "sha256",
		"type": "installer",
		"filename": "cilium",
		"command": ["cilium", "--context", "<<<context>>>", "install"]
	},
	"flannel": {
		"url": "https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml",
		"type": "yaml",
		"filename": "flannel.yaml",
		"patch": patch_cni_flannel,
	},
	"kube-router": {
		"url": "https://raw.githubusercontent.com/cloudnativelabs/kube-router/master/daemonset/kubeadm-kuberouter.yaml",
		"type": "yaml",
		"filename": "kube-router.yaml",
	},
	"weave": {
		"url": "https://github.com/weaveworks/weave/releases/download/v2.8.1/weave-daemonset-k8s-1.11.yaml",
		"type": "yaml",
		"filename": "weave.yaml",
		"patch": patch_cni_weave,
	},
}

def substitute_string(string: str, substitutions: Dict) -> str:
	"""
	Substitutes substrings in a string

		Parameters:
			string (str): The string to perform substitutions on
			substitutions (dict): A dict where key is the substring to match against, and value is the replacement for that substring
		Returns:
			string (str): The string with substitutions performed
	"""

	for key, value in substitutions.items():
		if string is None or value is None:
			continue
		string = string.replace(key, value)
	return string

def substitute_list(strlist: List[str], substitutions: Dict) -> List[str]:
	"""
	Substitutes substrings in all strings in a list

		Parameters:
			string (list[str]): A list with the strings to perform substitutions on
			substitutions (dict): A dict where key is the substring to match against, and value is the replacement for that substring
		Returns:
			list[str]: The list of strings with substitutions performed
	"""

	for key, value in substitutions.items():
		strlist = [s.replace(key, value) for s in strlist]
	return strlist

def check_version_from_url(url: str, version_regex: str) -> List[str]:
	"""
	Given a URL download a text file and treat the first line that matches version_regex as a version number

		Parameters:
			url (str): A URL
			version_regex (str): A regex
		Returns:
			version (str): The version number, or None in case of failure
	"""

	version: List[str] = []

	if url is not None:
		with tempfile.TemporaryDirectory() as td:
			check_and_print_status(download_files(td, [(url, "version.txt", None, None)], permissions = 0o600))
			tmp = secure_read_string(FilePath(f"{td}/version.txt"))
			versionoutput = tmp.splitlines()
			_version_regex = re.compile(version_regex)
			for line in versionoutput:
				tmp_match = _version_regex.match(cast(str, line))
				if tmp_match is not None:
					version = list(tmp_match.groups())
					break
	return version

def check_version_from_executable(command: FilePath, args: List[str], version_regex: str) -> List[str]:
	"""
	Given a path to an executable, the arguments needed to show version information,
	and a version_regex, return the executable version

		Parameters:
			command (str): A path to an executable
			args ([str]): A list of arguments necessary to show version information
			version_regex (str): A regex
		Returns:
			version ([str]): A list of version number elements, or None in case of failure
	"""

	version: List[str] = []

	security_policy = SecurityPolicy.ALLOWLIST_RELAXED
	fallback_allowlist = ["/bin", "/sbin", "/usr/bin", "/usr/sbin", "/usr/local/bin", "/usr/local/sbin", f"{HOMEDIR}/bin"]

	try:
		cpath = cmtio.secure_which(command, fallback_allowlist = fallback_allowlist, security_policy = security_policy)
	except FileNotFoundError:
		cpath = None

	if cpath is not None:
		result = execute_command_with_response([cpath] + args)

		if result is not None:
			versionoutput = result.splitlines()
			_version_regex = re.compile(version_regex)
			for line in versionoutput:
				tmp = _version_regex.match(line)
				if tmp is not None:
					version = list(tmp.groups())
					break
	return version

def __upgrade_cni(cni: str, upgradetype: str, context: str, pod_network_cidr: str) -> None:
	"""
	A helper that is used when upgrading a CNI; it can either upgrade the CNI itself or a helper executable

		Parameters:
			cni (str): The CNI to upgrade
			upgradetype (str): Valid options CNI, executable
			context (str): The cluster context
			pod_network_cidr (str): The CIDR of the pod network
	"""

	if upgradetype not in ("CNI", "executable"):
		raise ValueError(f"Unknown upgradetype {upgradetype}; this is a programming error.")

	# FIXME: for now we hardcode this
	arch = "amd64"
	version_command = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#version_command"))
	version_command_regex = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#version_regex"))
	candidate_version_url = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#candidate_version_url"))
	candidate_version_command = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#candidate_version_command"))
	candidate_version_function = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#candidate_version_function"))
	candidate_version_regex = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#candidate_version_regex"))
	install_command = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#install"))
	upgrade_command = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#upgrade"))

	version_substitutions = {
		"<<<arch>>>": arch,
		"<<<context>>>": context,
	}

	version = []
	if version_command is not None:
		ansithemeprint([ANSIThemeString("\n• ", "separator"),
				ANSIThemeString(f"Checking {upgradetype} version", "action")])
		version = check_version_from_executable(version_command[0],
							substitute_list(version_command[1:], version_substitutions), version_command_regex)
	candidate_version = []
	if candidate_version_url is not None:
		ansithemeprint([ANSIThemeString("\n• ", "separator"),
				ANSIThemeString(f"Checking {upgradetype} candidate version", "action")])
		if candidate_version_function is not None:
			candidate_version = candidate_version_function(candidate_version_url, candidate_version_regex)
		else:
			candidate_version = check_version_from_url(substitute_string(candidate_version_url, version_substitutions), candidate_version_regex)
	elif candidate_version_command is not None:
		ansithemeprint([ANSIThemeString("\n• ", "separator"),
				ANSIThemeString(f"Checking {upgradetype} candidate version", "action")])
		candidate_version = check_version_from_executable(candidate_version_command[0],
								  substitute_list(candidate_version_command[1:], version_substitutions),
								  candidate_version_regex)

	if "urls" in deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}")):
		# pylint: disable-next=too-many-boolean-expressions
		if (version is None or len(version) == 0) or version is not None and (candidate_version is None or len(candidate_version) == 0) or version < candidate_version:
			new_version = "".join(candidate_version)

			ansithemeprint([ANSIThemeString("\n• ", "separator"),
					ANSIThemeString(f"Downloading {upgradetype} ", "action"),
					ANSIThemeString(f"{new_version}", "version")])

			substitutions = {
				"<<<version>>>": new_version,
				"<<<arch>>>": arch,
				"<<<context>>>": context,
			}

			kubectl_path = secure_which(FilePath("/usr/bin/kubectl"), fallback_allowlist = [])
			if upgradetype == "CNI":
				secure_mkdir(DEPLOYMENT_DIR)
				directory = FilePath(str(PurePath(DEPLOYMENT_DIR).joinpath("cni")))
				permissions = 0o644
			elif upgradetype == "executable":
				directory = BINDIR
				permissions = 0o755
			secure_mkdir(directory)

			for url in deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#urls"), []):
				download_url = deep_get(url, DictPath("url"), "")
				checksum_url = deep_get(url, DictPath("checksum_url"), None)
				checksum_type = deep_get(url, DictPath("checksum_type"), None)
				filename = deep_get(url, DictPath("filename"), "")

				download_url = substitute_string(download_url, substitutions)
				checksum_url = substitute_string(checksum_url, substitutions)
				filename = substitute_string(filename, substitutions)

				check_and_print_status(download_files(directory, [(download_url, filename, checksum_url, checksum_type)], permissions = permissions))

				if upgradetype == "CNI":
					new_path = FilePath(str(PurePath(directory).joinpath(filename)))
					patch_cni_call = deep_get(url, DictPath("patch"))
					if patch_cni_call is not None:
						patch_cni_call(new_path, pod_network_cidr)
					execute_command_with_response([kubectl_path, "apply", "--server-side", "-f", new_path])
		else:
			ansithemeprint([ANSIThemeString("No newer version available.", "default")])
	elif install_command is not None and version is None or len(version) == 0:
		new_version = "".join(candidate_version)

		ansithemeprint([ANSIThemeString("\n• ", "separator"),
				ANSIThemeString(f"Installing {upgradetype} ", "action"),
				ANSIThemeString(f"{new_version}", "version")])

		substitutions = {
			"<<<version>>>": new_version,
			"<<<arch>>>": arch,
			"<<<context>>>": context,
		}
		check_and_print_status(execute_command(substitute_list(install_command, substitutions)))
	elif upgrade_command is not None:
		if version is None or version < candidate_version:
			new_version = "".join(candidate_version)

			ansithemeprint([ANSIThemeString("\n• ", "separator"),
					ANSIThemeString(f"Upgrading {upgradetype} to ", "action"),
					ANSIThemeString(f"{new_version}", "version")])

			substitutions = {
				"<<<version>>>": new_version,
				"<<<arch>>>": arch,
				"<<<context>>>": context,
			}
			check_and_print_status(execute_command(substitute_list(upgrade_command, substitutions)))
		else:
			ansithemeprint([ANSIThemeString("No newer version available.", "default")])

# pylint: disable-next=unused-argument
def setup_cni(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Install and configure the specified CNI

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): The CNI to install and configure (optional; if not specified the default CNI will be used)
	"""

	confirm = True

	for opt, _optarg in options:
		if opt == "-Y":
			confirm = False

	if not Path(CMT_INSTALLATION_INFO_FILE).is_file():
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Could not find reliable installation information. Aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	cni = installation_info[cluster_name]["cni"]
	pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]
	admin_name = f"kubernetes-admin+{cluster_name}"
	context_name = f"{admin_name}@{cluster_name}"

	if cni not in ("", "<none>", "<unknown>"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": The cluster already has a CNI installed; aborting.", "default")], stderr = True)
		sys.exit(errno.EEXIST)

	if len(args) == 0:
		ansithemeprint([ANSIThemeString("Note", "note"),
				ANSIThemeString(": No CNI specified; defaulting to ", "default"),
				ANSIThemeString(f"{DEFAULT_CNI}", "programname"),
				ANSIThemeString(".", "default")], stderr = True)
		cni = DEFAULT_CNI
	else:
		cni = args[0]

	if confirm == True:
		retval = ansithemeinput([ANSIThemeString("\nSetup CNI (", "default"),
					 ANSIThemeString(f"{cni}", "argument"),
					 ANSIThemeString(")? [y/", "default"),
					 ANSIThemeString("N", "emphasis"),
					 ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting:", "error"),
					ANSIThemeString(" User stopped CNI setup.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	ansithemeprint([ANSIThemeString("\n[Installing and configuring CNI]", "phase")])
	result = __setup_cni(cni, pod_network_cidr, context_name, cluster_name)
	if result == True:
		update_installation_info(cluster_name = cluster_name, cni = cni)

# pylint: disable-next=unused-argument
def teardown_cni(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Teardown the CNI

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Unused
	"""

	confirm = True

	for opt, _optarg in options:
		if opt == "-Y":
			confirm = False

	if not Path(CMT_INSTALLATION_INFO_FILE).is_file():
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Could not find reliable installation information. Aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	cni = installation_info[cluster_name]["cni"]
	if cni in ("", "<none>", "<unknown>"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No CNI installed; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	directory = FilePath(str(PurePath(DEPLOYMENT_DIR).joinpath("cni")))
	cni_filename = deep_get(cni_data, DictPath(f"{cni}#filename"))
	if cni_filename is None:
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": No data found for CNI. This is most likely a programming error; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	cni_path = FilePath(str(PurePath(directory).joinpath(cni_filename)))

	security_violations = check_path(cni_path)

	if security_violations != [SecurityStatus.OK]:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": The CNI deployment file is either missing or unsafe to use; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	all_nodes_in_cluster = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, cluster_name)
	if len(all_nodes_in_cluster) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": The inventory for this cluster does not contain any hosts; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if confirm == True:
		input_retval = ansithemeinput([ANSIThemeString("\nUninstall CNI (", "default"),
					       ANSIThemeString(f"{cni}", "argument"),
					       ANSIThemeString(")? [y/", "default"),
					       ANSIThemeString("N", "emphasis"),
					       ANSIThemeString("]: ", "default")])
		if input_retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting:", "error"),
					ANSIThemeString(" User stopped CNI removal.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	ansithemeprint([ANSIThemeString("\n[Removing CNI and configuration]", "phase")])

	# OK, we have a path to the CNI; this should be enough to remove it
	kubectl_path = secure_which(FilePath("/usr/bin/kubectl"), fallback_allowlist = [])
	execute_command_with_response([kubectl_path, "delete", "-f", cni_path])

	uninstall_cni_playbooks = [
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("teardown_cni.yaml"))),
	]
	playbooks = populate_playbooks_from_paths(uninstall_cni_playbooks)

	retval = run_playbooks(playbooks = playbooks, hosts = all_nodes_in_cluster)
	if retval == True:
		ansithemeprint([ANSIThemeString("OK", "ok")])
		update_installation_info(cluster_name = cluster_name, cni = "<none>")
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

# pylint: disable-next=unused-argument
def upgrade_cni(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Upgrade the specified CNI to the latest version

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): The CNI to upgrade (optional; if not specified the CNI will be taken from installation_info.yaml)
	"""

	kh = None
	pod_network_cidr = None

	if len(args) > 0:
		cni = args[0]
	else:
		installation_info = get_installation_info()
		cluster_name = installation_info["installation_target"]
		cni = installation_info[cluster_name]["cni"]
		pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]

	if pod_network_cidr is None:
		# If we have a running cluster and we are upgrading by CNI rather than through installation info we need to get the Pod CIDR
		# by some other means; try this. If this fails we give up.
		from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
		kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)
		pod_network_cidr = kh.get_pod_network_cidr()
		if pod_network_cidr is None:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": Could not identify Pod network CIDR; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOTSUP)

	if cni in ("", "<none>", "<unknown>"):
		if kh is None:
			from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
			kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)
		tmp_cni = kh.identify_cni()
		if len(tmp_cni) == 0:
			cni = "<unknown>"
		elif len(tmp_cni) > 1:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": Could not uniquely identify the CNI; multiple potential candidates identified; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		else:
			cni = tmp_cni[0][0]

	install_cni = False
	action_str = "Upgrading"
	for opt, _optarg in options:
		if opt == "install":
			install_cni = True
			action_str = "Installing"

	if cni not in cni_upgrade_data:
		ansithemeprint([ANSIThemeString(f"{action_str} ", "default"),
				ANSIThemeString(f"{cni}", "command"),
				ANSIThemeString(" is currently not supported; exiting.", "default")])
		sys.exit(errno.ENOTSUP)

	kubectl_path = secure_which(FilePath("/usr/bin/kubectl"), fallback_allowlist = [])
	context_name = execute_command_with_response([kubectl_path, "config", "current-context"]).splitlines()[0]

	if install_cni == True:
		ansithemeprint([ANSIThemeString("\n[Installing CNI]", "phase")])
	else:
		ansithemeprint([ANSIThemeString("\n[Upgrading CNI]", "phase")])

	__upgrade_cni(cni, "executable", context_name, pod_network_cidr)
	__upgrade_cni(cni, "CNI", context_name, pod_network_cidr)

	if install_cni == True:
		ansithemeprint([ANSIThemeString("\nCNI installation successful", "success")])
	else:
		ansithemeprint([ANSIThemeString("\nCNI upgrade successful", "success")])

def __setup_cni(cni: str, pod_network_cidr: str, context_name: str, cluster_name: str) -> bool:
	"""
	Setup a CNI

		Parameters:
			cni (str): The CNI to configure and install
			pod_network_cidr (str): The CIDR of the pod network
			context_name (str): The name of the cluster context
			cluster_name (str): The name of the cluster
		Returns:
			result (bool): True on success, False on failure
	"""

	pass_cni = []

	installation_info = get_installation_info()
	cluster_name = deep_get(installation_info, DictPath("installation_target"))
	installation_info_cni = deep_get(installation_info, DictPath(f"{cluster_name}#cni"))
	if installation_info_cni is None or installation_info_cni == "<none>":
		pass_cni = [cni]

	if cni == "none":
		ansithemeprint([ANSIThemeString("Note", "note"),
				ANSIThemeString(": ", "default"),
				ANSIThemeString("none", "argument"),
				ANSIThemeString(" specified; skipping CNI installation.", "default")], stderr = True)
		return True

	if cni not in cni_data and cni not in cni_upgrade_data:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default"),
				ANSIThemeString(f"{cni}", "argument"),
				ANSIThemeString(" is not a valid/supported CNI; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if cni in cni_upgrade_data:
		from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
		kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

		# upgrade_cni doesn't take a context, so we need to set the current context before calling it,
		# otherwise we might end up performing the changes on the wrong cluster
		if not kh.set_context(name = context_name, unchanged_is_success = True):
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": Failed to change to context ", "default"),
					ANSIThemeString(f"{context_name}", "hostname"),
					ANSIThemeString(" for cluster ", "default"),
					ANSIThemeString(f"{cluster_name}", "hostname"),
					ANSIThemeString("; cannot install/upgrade CNI; skipping.", "default")])
			return False

		# Don't pass CNI as an argument here; installation_info contains that information during installation.
		# upgrade_cni() will assume that the cluster is functional if run with a CNI, and thus tries to get
		# all information from the cluster. This will most likely fail during installation, since the cluster
		# hasn't started fully yet and thus cannot provide the necessary information
		upgrade_cni(options = [("install", "")], args = pass_cni)
		# FIXME
		return True

	version_url = deep_get(cni_data, DictPath(f"{cni}#version_url"))
	version_regex = deep_get(cni_data, DictPath(f"{cni}#version_regex"))

	version = check_version_from_url(version_url, version_regex)

	url = deep_get(cni_data, DictPath(f"{cni}#url"))
	if url is None:
		raise ValueError(f"URL for {cni} is empty; this is a programming error.")

	checksum_url = deep_get(cni_data, DictPath(f"{cni}#checksum_url"))
	checksum_type = deep_get(cni_data, DictPath(f"{cni}#checksum_type"))

	# FIXME: for now we hardcode this
	arch = "amd64"
	substitutions = {
		"<<<version>>>": "".join(version),
		"<<<arch>>>": arch,
	}

	url = substitute_string(url, substitutions)
	checksum_url = substitute_string(checksum_url, substitutions)

	filename = deep_get(cni_data, DictPath(f"{cni}#filename"))
	patch_cni = deep_get(cni_data, DictPath(f"{cni}#patch"), None)
	filetype = deep_get(cni_data, DictPath(f"{cni}#type"))
	if filetype is None:
		raise ValueError(f"type for {cni} is missing; this is a programming error.")
	if filetype == "yaml":
		secure_mkdir(DEPLOYMENT_DIR)
		directory = FilePath(os.path.join(DEPLOYMENT_DIR, "cni"))
		permissions = 0o644
	elif filetype == "installer":
		directory = BINDIR
		permissions = 0o755
	secure_mkdir(directory)

	check_and_print_status(download_files(directory, [(url, filename, checksum_url, checksum_type)], permissions = permissions))

	cni_path = f"{directory}/{filename}"

	if patch_cni is not None:
		ansithemeprint([ANSIThemeString("\n• ", "separator"),
				ANSIThemeString("Patching “", "action"),
				ANSIThemeString(f"{cni}", "argument"),
				ANSIThemeString("“ configuration", "action")])
		patch_cni(cni_path, pod_network_cidr)

	if filetype == "yaml":
		args = ["/usr/bin/kubectl", "apply", "--server-side", "--context=<<<context>>>", "-f", cni_path]
	elif filetype == "installer":
		args = deep_get(cni_data, DictPath(f"{cni}#command"))

	substitutions = {
		"<<<cluster>>>": cluster_name,
		"<<<context>>>": context_name,
	}

	result = execute_command(substitute_list(args, substitutions))
	check_and_print_status(result)
	return result

def check_for_ssh_key() -> bool:
	"""
	Check whether there's an existing public ssh key on the system already

		Returns:
			retval (bool): True if a key exists, False if no key exists
	"""

	retval = False
	files = [file for file in glob(os.path.join(HOMEDIR, ".ssh", "*.pub")) if os.path.isfile(file)]
	for file in files:
		if os.path.isfile(file) and os.path.isfile(file[:-len(".pub")]):
			retval = True
			break
	return retval

def create_ssh_key() -> bool:
	"""
	Create a new ssh key (ECDSA-P521 format)

		Returns:
			retval (bool): True on success, False on failure
	"""

	if not os.path.exists(f"{HOMEDIR}/.ssh/id_ecdsa"):
		args = [SSH_KEYGEN_BIN_PATH] + SSH_KEYGEN_ARGS + ["-f", f"{SSH_DIR}/id_ecdsa"]
		retval = execute_command(args)
	else:
		retval = True
	return retval

def add_ssh_keys_to_authorized_keys() -> bool:
	"""
	Add all public keys for this host to authorized keys on this host;
	in other words, make the host able to SSH to itself

		Returns:
			retval (bool): True on success, False on failure
	"""

	retval = False

	# Since we run create_ssh_key() before this task we can safely assume that .ssh/ exists
	for path in Path(SSH_DIR).iterdir():
		if not path.name.endswith(".pub"):
			continue

		tmp = secure_read_string(FilePath(str(path)))
		if tmp is not None:
			tmplines = tmp.splitlines()
			pubkey = cast(str, tmplines[0])
			if len(pubkey) == 0:
				continue

		exists = False

		authorized_keys_path = FilePath(str(PurePath(SSH_DIR).joinpath("authorized_keys")))

		try:
			tmp = secure_read_string(authorized_keys_path)
			if tmp is not None and len(tmp) > 0:
				for line in tmp:
					if line == pubkey[0]:
						exists = True
						break
		except FilePathAuditError as e:
			if "SecurityStatus.DOES_NOT_EXIST" in str(e):
				pass

		if exists == False:
			secure_write_string(authorized_keys_path, f"{pubkey}\n", write_mode = "a")

		# We've added at least one public key
		retval = True

	return retval

# pylint: disable-next=unused-argument
def __task_check_and_create_ssh_key(installation_info: Dict) -> None:
	"""
	An installer task that checks whether the system has an ssh-key,
	and creates one if not

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	# FIXME
	confirm = True

	if check_for_ssh_key() == False:
		if confirm:
			retval = ansithemeinput([ANSIThemeString("Warning", "warning"),
						 ANSIThemeString(": No ssh key found in ", "default"),
						 ANSIThemeString(f"{HOMEDIR}/.ssh", "path"),
						 ANSIThemeString("; create one now? (No will abort the installation) [y/", "default"),
						 ANSIThemeString("N", "emphasis"),
						 ANSIThemeString("]: ", "default")])
			if retval.lower() not in ("y", "yes"):
				ansithemeprint([ANSIThemeString("\nAborting:", "error"),
						ANSIThemeString(" No ssh key available.", "default")], stderr = True)
				sys.exit(errno.ENOENT)
		check_and_print_status(create_ssh_key())

# pylint: disable-next=unused-argument
def __task_scan_and_add_ssh_keys(installation_info: Dict) -> None:
	"""
	An installer task that scans all specified control planes for public ssh keys
	and adds them to known hosts

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	controlplanes = get_control_planes()
	hosts = [controlplane[0] for controlplane in controlplanes]
	hosts += [f"{controlplane[0]}.local" for controlplane in controlplanes]
	hosts += [
		"localhost",
	]

	scan_and_add_ssh_keys(hosts)

# pylint: disable-next=unused-argument
def __task_add_ssh_keys_to_inventory(installation_info: Dict) -> None:
	"""
	An installer task that adds SSH keys to the Ansible inventory

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	pubkey = None
	d = ansible_get_inventory_dict()
	__vars = deep_get(d, DictPath("all#vars"), {})
	__authorized_keys = deep_get(__vars, DictPath("authorized_keys"), [])
	found_key = False

	for path in Path(SSH_DIR).iterdir():
		if not str(path).endswith(".pub"):
			continue

		tmp = secure_read_string(FilePath(str(path)))
		if tmp is not None:
			tmplines = tmp.splitlines()
			pubkey = tmplines[0]

		if tmp is None or len(pubkey) == 0:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": Failed to read a key from ", "default"),
					ANSIThemeString(str(path), "path"),
					ANSIThemeString("; skipping.", "default")], stderr = True)
			continue

		if pubkey not in __authorized_keys:
			__authorized_keys.append(pubkey)

		found_key = True

	if found_key == False:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Could not find a valid public key in ", "default"),
				ANSIThemeString(SSH_DIR, "path"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	__vars["authorized_keys"] = __authorized_keys
	ansible_set_vars(ANSIBLE_INVENTORY, "all", __vars)

# pylint: disable-next=unused-argument
def __task_check_and_add_ssh_keys_to_authorized_keys(installation_info: Dict) -> None:
	"""
	An installer task that adds SSH keys to authorized keys

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	add_ssh_keys_to_authorized_keys()

def install_ansible_posix() -> bool:
	"""
	Install ansible-posix using ansible-galaxy; this is necessary on systems
	where the version of Ansible is too old to support certain actions.

		Returns:
			(bool): True on success, False on failure
	"""

	# Old versions of ansible-galaxy does not have the list command;
	# if it does not work we just assume that ansible.posix is missing
	args = ["/usr/bin/ansible-galaxy", "collection", "list"]
	result = execute_command_with_response(args)

	if "COLLECTION_ACTION: invalid choice" in result or "ansible.posix" not in result:
		http_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), "")
		https_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), "")
		no_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), "")
		env = {
			"http_proxy": http_proxy,
			"https_proxy": https_proxy,
			"no_proxy": no_proxy,
		}
		args = ["/usr/bin/ansible-galaxy", "collection", "install", "ansible.posix"]
		return execute_command(args, env = env)

	return True

# pylint: disable-next=unused-argument
def __task_check_and_install_ansible_posix(installation_info: Dict) -> None:
	"""
	An installer task that installs ansible-posix

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	check_and_print_status(install_ansible_posix())

def update_apt_cache() -> bool:
	"""
	Update the APT cache

		Returns:
			True on success, False on failure
	"""

	sudo_path = cmtio.secure_which(FilePath("sudo"), fallback_allowlist = ["/bin", "/usr/bin"], security_policy = SecurityPolicy.ALLOWLIST_STRICT)
	apt_get_path = cmtio.secure_which(FilePath("apt-get"), fallback_allowlist = ["/bin", "/usr/bin"], security_policy = SecurityPolicy.ALLOWLIST_STRICT)
	args = [sudo_path, apt_get_path, "update"]
	return execute_command(args)

def deb_compare_versions(current_version: str, candidate_version: str) -> bool:
	"""
	Compare two package versions

		Returns:
			True if current version < candidate version, else False
	"""

	args = ["/usr/bin/dpkg", "--compare-versions", current_version, "lt", candidate_version]
	return execute_command(args, comparison = 1)

def __get_theme(string: str, default: str) -> str:
	"""
	Return the suitable format reference for a particular string

		Parameters:
			string (str): A string to return the format reference for
			default (str): The default format reference to use if there's no matching translation
		Returns:
			theme (str): A format reference
	"""

	translation = {
		"<none>": "none",
		"<unknown>": "unknown",
	}
	return translation.get(string, default)

def check_versions(deb_packages: List[str], version_checks: List[Tuple[str, List[str], str]]) -> Tuple[List[Tuple[str, str, str, List[str]]], List[Tuple[str, str, str, List[str]]]]:
	"""
	Check versions for all relevant software

		Parameters:
			deb_packages (list[str]): A list of debian packages
			version_checks (list[(software, args, regex)]): A list of component, the command needed to check its version, and a regex to extract the version number
		Returns:
			(deb_versions, other_versions): A tuple of utput from check_deb_versions(), (software, installed_version, "")
	"""

	other_versions: List[Tuple[str, str, str, List[str]]] = []

	# First check all Debian versions
	deb_versions = check_deb_versions(deb_packages)

	# Now check versions that need special checks
	for version_check in version_checks:
		tmp_software: str = version_check[0]
		args = version_check[1]
		regex = version_check[2]

		try:
			response = execute_command_with_response(args)
		except FileNotFoundError:
			other_versions.append((tmp_software, "<none>", "", []))
			continue
		except subprocess.CalledProcessError:
			other_versions.append((tmp_software, "<unknown>", "", []))
			continue

		if regex is None:
			tmp_installed_version = response
		else:
			tmp_match = re.match(regex, response)
			if tmp_match is not None:
				tmp_installed_version = tmp_match[1]
			else:
				tmp_installed_version = "<none>"
		other_versions.append((tmp_software, tmp_installed_version, "", []))

	# Finally, display the gathered version information; find the longest string of each type
	# Create lists of header + all values belonging to that header, and get the length of the longest element
	slen = len(max(["Software:"] + [tmp[0] for tmp in deb_versions + other_versions], key = len))
	ilen = len(max(["Installed Version:"] + [tmp[1] for tmp in deb_versions + other_versions], key = len))

	# Print a header
	ansithemeprint([ANSIThemeString("Software:", "header"),
			ANSIThemeString(f"{''.ljust(slen - len('Software:') + 2)}", "default"),
			ANSIThemeString("Installed Version:", "header"),
			ANSIThemeString(f"{''.ljust(ilen - len('Installed Version:') + 2)}", "default"),
			ANSIThemeString("Candidate Version:", "header")])
	for software, installed_version, candidate_version, _ in cast(Tuple[str, str, str, List[str]], natsorted(deb_versions)):
		iformat = __get_theme(installed_version, "version")
		cformat = __get_theme(candidate_version, "version")
		ansithemeprint([ANSIThemeString(f"{software.ljust(slen + 2)}", "default"),
				ANSIThemeString(f"{installed_version.ljust(ilen + 2)}", iformat),
				ANSIThemeString(f"{candidate_version}", cformat)])
	print()
	for software, installed_version, candidate_version, _ in cast(Tuple[str, str, str, List[str]], natsorted(other_versions)):
		iformat = __get_theme(installed_version, "version")
		cformat = __get_theme(candidate_version, "version")
		ansithemeprint([ANSIThemeString(f"{software.ljust(slen + 2)}", "default"),
				ANSIThemeString(f"{installed_version.ljust(ilen + 2)}", iformat),
				ANSIThemeString(f"{candidate_version}", cformat)])

	return deb_versions, other_versions

# pylint: disable-next=unused-argument
def run_playbook(playbookpath: FilePath, hosts: List[str], extra_values: Optional[Dict] = None, quiet: bool = False) -> Tuple[int, Dict]:
	"""
	Run a playbook

		Parameters:
			playbookpath (FilePath): A path to the playbook to run
			hosts (list[str]): A list of hosts to run the playbook on
			extra_values (dict): A dict of values to set before running the playbook
			quiet (bool): Should the results of the run be printed?
		Returns:
			retval (int): The return value from ansible_run_playbook_on_selection()
			ansible_results (dict): A dict with the results from the run
	"""

	# Set necessary Ansible keys before running playbooks
	http_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), "")
	if http_proxy is None:
		http_proxy = ""
	https_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), "")
	if https_proxy is None:
		https_proxy = ""
	no_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), "")
	if no_proxy is None:
		no_proxy = ""
	insecure_registries = deep_get(cmtlib.cmtconfig, DictPath("Docker#insecure_registries"), [])
	registry_mirrors = deep_get(cmtlib.cmtconfig, DictPath("Containerd#registry_mirrors"), [])
	retval = 0

	use_proxy = "no"
	if len(http_proxy) > 0 or len(https_proxy) > 0:
		use_proxy = "yes"

	if extra_values is None:
		extra_values = {}

	values = {
		"http_proxy": http_proxy,
		"https_proxy": https_proxy,
		"no_proxy": no_proxy,
		"insecure_registries": insecure_registries,
		"registry_mirrors": registry_mirrors,
		"use_proxy": use_proxy,
	}
	merged_values = { **values, **extra_values }

	retval, ansible_results = ansible_run_playbook_on_selection(playbookpath, selection = hosts, values = merged_values)

	if quiet == False:
		ansible_print_play_results(retval, ansible_results)

	return retval, ansible_results

def run_playbooks(playbooks: List[Tuple[List[ANSIThemeString], FilePath]], hosts: Optional[List[str]] = None, extra_values: Optional[Dict] = None) -> bool:
	"""
	Run a set of playbooks

		Parameters:
			playbooks (list[(description (list[ANSIThemeString]), playbookpath (FilePath))]): A list of playbooks
			hosts (list[str]): The hosts to run the playbooks on
			extra_values (dict): Variables to set before running the playbooks
		Returns:
			True on success, False on failure
	"""

	if len(playbooks) == 0 or hosts is None:
		return True

	for string, playbookpath in playbooks:
		ansithemeprint(string)
		retval, _ansible_results = run_playbook(playbookpath, hosts = hosts, extra_values = extra_values)

		# We do not want to continue executing playbooks if the first one failed
		if retval != 0:
			break

	return retval == 0

def __playbook_paths_from_path(playbook_path: FilePath) -> List[FilePath]:
	"""
	Scan a directory and return a list of playbook paths

		Parameters:
			playbook_path (str): A path to a directory
		Returns:
			list[FilePath]: A list of paths
	"""

	if playbook_path is None:
		raise ValueError("No path passed to __playbook_paths_from_path(); this is a programming error.")

	playbook_paths = []

	# Populate list of playbooks
	for path in Path(playbook_path).iterdir():
		# Do not process backups, etc.
		if path.name.startswith(("~", ".")):
			continue
		if not path.name.endswith((".yml", ".yaml")):
			continue
		playbook_paths.append(FilePath(str(path)))

	return playbook_paths

# Add all playbooks in the directory
def populate_playbooks_from_dir(path: FilePath) -> List[Tuple[List[ANSIThemeString], FilePath]]:
	"""
	Populate a playbook list from path

		Parameters:
			paths (FilePath): A directory to populate playbooks from
		Returns:
			list[(description, playbookpath)]: A playbook list for use with run_playbooks()
	"""

	playbook_paths = __playbook_paths_from_path(path)

	return populate_playbooks_from_paths(playbook_paths)

# pylint: disable-next=unused-argument
def __task_request_ansible_password(installation_info: Optional[Dict]) -> None:
	"""
	An installer task that requests the ansible password

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	# Check whether ansible_password is defined or not
	if deep_get(ansible_configuration, DictPath("ansible_password")) is None and no_password == False:
		ansithemeprint([ANSIThemeString("Attention", "warning"),
				ANSIThemeString(": To be able to run playbooks you need to provide the ansible/ssh password.", "default")])
		ansithemeprint([ANSIThemeString("Since the systems will be reconfigured to use passwordless sudo and ssh keys this is a one-time thing.\n", "default")])
		ansithemeprint([ANSIThemeString("Note", "note"),
				ANSIThemeString(": If the remote host is already configured for passwordless sudo and allows for login using a pre-generated SSH-key you can use “", "default"),
				ANSIThemeString("--no-password", "option"),
				ANSIThemeString("“ to bypass this check.", "default")])
		ansible_password = ansithemeinput_password([ANSIThemeString("\nPassword: ", "default")])
		if len(ansible_password) == 0:
			ansithemeprint([ANSIThemeString("\nError", "error"),
					ANSIThemeString(": Empty password; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		else:
			ansible_configuration["ansible_password"] = ansible_password

def __run_playbooks_on_selection(playbooks: List[Tuple[List[ANSIThemeString], FilePath]], selection: List[str], extra_values: Optional[Dict] = None) -> None:
	"""
	A helper that runs a playbook list on a selection

		Parameters:
			playbooks (list[(description, playbookpath)]): A playbook list
			selection (list[str]): A list of hosts
			extra_values (dict): A dict of values to set before running the playbook
	"""

	check_and_print_status(run_playbooks(playbooks, hosts = selection, extra_values = extra_values))

def __selection_control_planes() -> List[str]:
	"""
	Return a selection with all control planes

		Returns:
			(list[str]): A list of control planes
	"""

	__controlplanes = get_control_planes(fail_on_empty = False)
	return [controlplane[0] for controlplane in __controlplanes]

def __selection_localhost() -> List[str]:
	"""
	Returns a list with the hostname of localhost

		Returns:
			(list[str]): A list with the hostname of localhost
	"""

	return [socket.gethostname()]

# pylint: disable-next=unused-argument
def __task_run_preparation_playbooks_on_localhost(installation_info: Dict) -> None:
	"""
	An installer task that runs preparation playbooks on localhost

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	os_distro = identify_distro()
	selection = __selection_localhost()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], prepare_targets["localhost"]["playbooks"]))

	if os_distro == "debian":
		packages = deep_get(prepare_targets, DictPath("localhost#deb_packages"), [])
		held_packages = deep_get(prepare_targets, DictPath("localhost#deb_packages_held"), [])
	elif os_distro == "suse":
		packages = deep_get(prepare_targets, DictPath("localhost#suse_packages"), [])
		held_packages = deep_get(prepare_targets, DictPath("localhost#suse_packages_held"), [])

	extra_values = {
		"packages": packages,
		"held_packages": held_packages,
		"ansible_become_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
		"ansible_ssh_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

def __task_run_preparation_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs preparation playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	k8s_distro = installation_info[cluster_name]["distro"]
	os_distro = identify_distro()
	selection = __selection_control_planes()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], prepare_targets[k8s_distro]["playbooks"]))

	if os_distro == "debian":
		packages = deep_get(prepare_targets, DictPath(f"{k8s_distro}#deb_packages"), [])
		held_packages = deep_get(prepare_targets, DictPath(f"{k8s_distro}#deb_packages_held"), [])
	elif os_distro == "suse":
		packages = deep_get(prepare_targets, DictPath(f"{k8s_distro}#suse_packages"), [])
		held_packages = deep_get(prepare_targets, DictPath(f"{k8s_distro}#suse_packages_held"), [])

	extra_values = {
		"packages": packages,
		"held_packages": held_packages,
		"ansible_become_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
		"ansible_ssh_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

# pylint: disable-next=unused-argument
def __task_setup_bash_completion(installation_info: Dict) -> None:
	"""
	An installer task that sets up bash completion

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	secure_mkdir(FilePath(str(PurePath(HOMEDIR).joinpath(".local"))), verbose = True)
	secure_mkdir(FilePath(str(PurePath(HOMEDIR).joinpath(".local", "share"))), verbose = True)
	secure_mkdir(BASH_COMPLETION_BASE_DIR, verbose = True)
	secure_mkdir(BASH_COMPLETION_DIR, verbose = True)

	args = ["/usr/bin/kubectl", "completion", "bash"]
	result = execute_command_with_response(args)
	secure_write_string(FilePath(str(PurePath(BASH_COMPLETION_DIR).joinpath("kubectl"))), result)

def get_cluster_name() -> Optional[str]:
	"""
	Return the name of the cluster

		Returns:
			cluster_name (str): The name of the cluster
	"""
	try:
		d1 = secure_read_yaml(KUBE_CONFIG_FILE)
	except FileNotFoundError:
		return None

	current_context = d1.get("current-context", None)
	if current_context is None:
		return None

	cluster_name = None

	for context in d1.get("contexts", []):
		if context.get("name", "") == current_context:
			cluster_name = context["context"].get("cluster", None)
			break

	return cluster_name

def __task_run_setup_playbooks_on_localhost(installation_info: Dict) -> None:
	"""
	An installer task that runs playbooks on localhost

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]
	os_distro = identify_distro()
	selection = __selection_localhost()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], setup_control_plane_targets["localhost"]["playbooks"]))

	if os_distro == "debian":
		packages = deep_get(setup_control_plane_targets, DictPath("localhost#deb_packages"), [])
		held_packages = deep_get(setup_control_plane_targets, DictPath("localhost#deb_packages_held"), [])
	elif os_distro == "suse":
		packages = deep_get(setup_control_plane_targets, DictPath("localhost#suse_packages"), [])
		held_packages = deep_get(setup_control_plane_targets, DictPath("localhost#suse_packages_held"), [])

	extra_values = {
		"cluster_name": cluster_name,
		"pod_network_cidr": pod_network_cidr,
		"packages": packages,
		"held_packages": held_packages,
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

def __task_run_setup_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	k8s_distro = installation_info[cluster_name]["distro"]
	os_distro = identify_distro()
	pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]
	selection = __selection_control_planes()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], setup_control_plane_targets[k8s_distro]["playbooks"]))
	cri = installation_info[cluster_name]["cri"]
	cri_socket = deep_get(cri_data[cri], DictPath("socket"))
	extra_values_setup = deep_get(setup_control_plane_targets[k8s_distro], DictPath("extra_values"), {})

	if os_distro == "debian":
		packages = deep_get(setup_control_plane_targets, DictPath(f"{k8s_distro}#deb_packages"), [])
		held_packages = deep_get(setup_control_plane_targets, DictPath(f"{k8s_distro}#deb_packages_held"), [])
	elif os_distro == "suse":
		packages = deep_get(setup_control_plane_targets, DictPath(f"{k8s_distro}#suse_packages"), [])
		held_packages = deep_get(setup_control_plane_targets, DictPath(f"{k8s_distro}#suse_packages_held"), [])

	if k8s_distro == "rke2":
		cri_socket = cri_socket[len("unix://"):]

	extra_values = {
		"cluster_name": cluster_name,
		"pod_network_cidr": pod_network_cidr,
		"cri_socket": cri_socket,
		"packages": packages,
		"held_packages": held_packages,
		**extra_values_setup,
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

def __task_import_kubeconfig(installation_info: Dict) -> None:
	"""
	An installer task that merges a Kube config into ~/.kube/config

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	control_plane_name = __selection_control_planes()[0]
	cluster_name = installation_info["installation_target"]
	config_file_name = FilePath(f"{HOMEDIR}/.kube/config.{cluster_name}")
	admin_name = f"kubernetes-admin+{cluster_name}"
	context_name = f"{admin_name}@{cluster_name}"

	# This read must not fail, so no exceptions
	d2 = secure_read_yaml(config_file_name)

	# This file will not exist if this is the first cluster
	checks = [
		SecurityChecks.PARENT_RESOLVES_TO_SELF,
		SecurityChecks.OWNER_IN_ALLOWLIST,
		SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
		SecurityChecks.PERMISSIONS,
		SecurityChecks.PARENT_PERMISSIONS,
		SecurityChecks.IS_FILE,
	]

	try:
		d1 = secure_read_yaml(KUBE_CONFIG_FILE, checks = checks)
	except FileNotFoundError:
		d1 = dict(d2)
		# We will be renaming things anyway, so instead of using a lot of special casing below we just empty
		# these fields
		d1["clusters"] = []
		d1["contexts"] = []
		d1["current-context"] = context_name
		d1["users"] = []

	for cluster in d1["clusters"]:
		if cluster_name == cluster["name"]:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": A cluster named ", "default"),
					ANSIThemeString(cluster_name, "hostname"),
					ANSIThemeString(" already exists in ", "default"),
					ANSIThemeString(f"{HOMEDIR}/.kube/config", "path"),
					ANSIThemeString("; manual merge is necessary.", "default")], stderr = True)
			return

	for user in d1["users"]:
		if admin_name == user["name"]:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": A user named ", "default"),
					ANSIThemeString(admin_name, "hostname"),
					ANSIThemeString(" already exists in ", "default"),
					ANSIThemeString(f"{HOMEDIR}/.kube/config", "path"),
					ANSIThemeString("; manual merge is necessary.", "default")], stderr = True)
			return

	for context in d1["contexts"]:
		if context_name == context["name"]:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": A context named ", "default"),
					ANSIThemeString(context_name, "hostname"),
					ANSIThemeString(" already exists in ", "default"),
					ANSIThemeString(f"{HOMEDIR}/.kube/config", "path"),
					ANSIThemeString("; manual merge is necessary.", "default")], stderr = True)
			return

	cad = d2["clusters"][0]["cluster"].get("certificate-authority-data")
	server = d2["clusters"][0]["cluster"]["server"]

	insecure_skip_tls_verify = d2["clusters"][0]["cluster"].get("insecure-skip-tls-verify")
	cluster = {
		"cluster": {
			"server": server,
		},
		"name": cluster_name,
	}
	if cad is not None:
		cluster["cluster"]["certificate-authority-data"] = cad
	if insecure_skip_tls_verify is not None:
		cluster["cluster"]["insecure-skip-tls-verify"] = insecure_skip_tls_verify

	d1["clusters"].append(cluster)

	context = {
		"context": {
			"cluster": cluster_name,
			"user": admin_name,
		},
		"name": context_name,
	}
	d1["contexts"].append(context)

	ccd = d2["users"][0]["user"].get("client-certificate-data")
	ckd = d2["users"][0]["user"].get("client-key-data")
	token = d2["users"][0]["user"].get("token")
	user = {
		"user": {
		},
		"name": admin_name,
	}
	if ccd is not None:
		user["user"]["client-certificate-data"] = ccd
	if ckd is not None:
		user["user"]["client-key-data"] = ckd
	if token is not None:
		user["user"]["token"] = token

	d1["users"].append(user)

	secure_write_yaml(KUBE_CONFIG_FILE, d1, permissions = 0o600, sort_keys = False)

	check_and_print_status(True)

def __task_adjust_kubeconfig_server_address(installation_info: Dict) -> None:
	"""
	An installer task that replaces localhost for the real IP-address of the API-server

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	control_plane_name = __selection_control_planes()[0]
	cluster_name = installation_info["installation_target"]
	config_file_name = FilePath(f"{HOMEDIR}/.kube/config.{cluster_name}")

	try:
		d = secure_read_yaml(KUBE_CONFIG_FILE)
	except FileNotFoundError:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Could not open ", "default"),
				ANSIThemeString(f"{KUBE_CONFIG_FILE}", "path"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	for i, cluster in enumerate(deep_get(d, DictPath("clusters"), [])):
		if deep_get(cluster, DictPath("name"), "") == cluster_name:
			# Is this cluster a localhost?
			server = deep_get(cluster, DictPath("cluster#server"), "")
			if server.startswith("https://127") or server == "::1":
				tmp = re.match(r"^(https://)([^:]+)(:.*)", server)
				if tmp is None:
					ansithemeprint([ANSIThemeString("Error", "error"),
							ANSIThemeString(": Failed to extract server address.", "default")])
					ansithemeprint([ANSIThemeString("This is probably a programming error", "default"),
							ANSIThemeString("; aborting.", "default")], stderr = True)
					sys.exit(errno.EINVAL)

				prefix = tmp[1]
				server_address = tmp[2]
				server_port_and_path = tmp[3]

				# Try to figure out the internal IP of the control plane
				from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
				kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

				obj = kh.get_ref_by_kind_name_namespace(("Node", ""), control_plane_name, "")
				if obj is None:
					ansithemeprint([ANSIThemeString("Error", "error"),
							ANSIThemeString(": Could not find control plane ", "default"),
							ANSIThemeString(f"{control_plane_name}", "hostname"),
							ANSIThemeString("; aborting.", "default")], stderr = True)
					sys.exit(errno.ENOENT)
				addresses = deep_get(obj, DictPath("status#addresses"), [])
				internal_ip = None
				for address in addresses:
					address_type = deep_get(address, DictPath("type"), "")
					if address_type == "InternalIP":
						internal_ip = deep_get(address, DictPath("address"), "")
						break
				if internal_ip is not None and len(internal_ip) > 0 and internal_ip != server_address:
					d["clusters"][i]["cluster"]["server"] = f"{prefix}{internal_ip}{server_port_and_path}"

	secure_write_yaml(KUBE_CONFIG_FILE, d, permissions = 0o600, sort_keys = False)

def __task_setup_cni(installation_info: Dict) -> None:
	"""
	An installer task that sets up a CNI

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	cni = installation_info[cluster_name]["cni"]
	pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]
	admin_name = f"kubernetes-admin+{cluster_name}"
	context_name = f"{admin_name}@{cluster_name}"

	# If everything is successful so far we deploy the pod network
	__setup_cni(cni, pod_network_cidr, context_name, cluster_name)

# pylint: disable-next=unused-argument
def __task_drain_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that drains control plains

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	controlplanes = __selection_control_planes()

	# Check if there is an API-server running that will listen to our request;
	# drain is issued during teardown--so if we are resuming a teardown the cluster
	# might already be partially deconfigured
	# XXX: This should be done on the control plane(s), not on localhost
	args = ["/usr/bin/sudo", "/usr/bin/lsof", "-i", "-P", "-n"]
	response = execute_command_with_response(args)
	running = False
	for line in response.splitlines():
		if "6443 (LISTEN)" in line:
			running = True
			break
	if running == False:
		check_and_print_status(True)
		return

	kubectl_major_version, kubectl_minor_version, _kubectl_git_version, _server_major_version, _server_minor_version, _server_git_version = kubernetes_helper.kubectl_get_version()

	# Build the drain command line based on what version of kubectl is installed
	args = ["/usr/bin/kubectl", "drain", "--ignore-daemonsets"]
	if kubectl_major_version >= 1 and kubectl_minor_version >= 20:
		args.append("--delete-emptydir-data")
	else:
		args.append("--delete-local-data")
	if kubectl_major_version >= 1 and kubectl_minor_version >= 18:
		args.append("--disable-eviction")

	for controlplane in controlplanes:
		check_and_print_status(execute_command(args + [controlplane]))

# pylint: disable-next=unused-argument
def __task_uncordon_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that uncordons control planes

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	controlplanes = __selection_control_planes()

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for controlplane in controlplanes:
		ansithemeprint([ANSIThemeString(f"  {controlplane}:", "hostname")])
		message, status = kh.uncordon_node(controlplane)
		if status in (200, 204):
			ansithemeprint([ANSIThemeString("    Uncordoned", "success")])
			print(message)
		elif status == 42503:
			ansithemeprint([ANSIThemeString("\n  ", "default"),
					ANSIThemeString("Critical", "critical"),
					ANSIThemeString(": Cluster not available; aborting", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			ansithemeprint([ANSIThemeString("\n  ", "default"),
					ANSIThemeString("Critical", "critical"),
					ANSIThemeString(": API call returned error:", "default")], stderr = True)
			ansithemeprint([ANSIThemeString(f"    {message}", "error")], stderr = True)
			sys.exit(errno.EINVAL)

# pylint: disable-next=unused-argument
def __task_run_preupgrade_playbooks_on_localhost(installation_info: Dict) -> None:
	"""
	An installer task that runs pre-upgrade playbooks on localhost

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	cluster_name = installation_info["installation_target"]
	k8s_distro = installation_info[cluster_name]["distro"]
	os_distro = identify_distro()
	selection = __selection_localhost()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], upgrade_control_plane_targets["localhost"]["playbooks"]))

	if os_distro == "debian":
		packages = deep_get(upgrade_control_plane_targets, DictPath(f"{k8s_distro}#deb_packages"), [])
		held_packages = deep_get(upgrade_control_plane_targets, DictPath(f"{k8s_distro}#deb_packages_held"), [])
	elif os_distro == "suse":
		packages = deep_get(upgrade_control_plane_targets, DictPath(f"{k8s_distro}#suse_packages"), [])
		held_packages = deep_get(upgrade_control_plane_targets, DictPath(f"{k8s_distro}#suse_packages_held"), [])

	extra_values = {
		"packages": packages,
		"held_packages": held_packages,
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

# pylint: disable-next=unused-argument
def __task_run_preupgrade_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs pre-upgrade playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	selection = __selection_control_planes()
	paths = __playbook_paths_from_path(FilePath(str(PurePath(CMT_HOOKS_DIR).joinpath("pre-upgrade.d"))))
	playbooks = populate_playbooks_from_paths(paths)

	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = {})

# Run upgrade playbooks on control planes
def __task_run_upgrade_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs upgrade playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	k8s_distro = installation_info[cluster_name]["distro"]
	os_distro = identify_distro()
	pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]
	requested_version = installation_info[cluster_name]["requested_version"]
	selection = __selection_control_planes()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], upgrade_control_plane_targets[k8s_distro]["playbooks"]))
	cri = installation_info[cluster_name]["cri"]
	cri_socket = deep_get(cri_data[cri], DictPath("socket"))
	extra_values_upgrade = deep_get(upgrade_control_plane_targets[k8s_distro], DictPath("extra_values"), {})

	if os_distro == "debian":
		packages = deep_get(upgrade_control_plane_targets, DictPath(f"{k8s_distro}#deb_packages"), [])
		held_packages = deep_get(upgrade_control_plane_targets, DictPath(f"{k8s_distro}#deb_packages_held"), [])
	elif os_distro == "suse":
		packages = deep_get(upgrade_control_plane_targets, DictPath(f"{k8s_distro}#suse_packages"), [])
		held_packages = deep_get(upgrade_control_plane_targets, DictPath(f"{k8s_distro}#suse_packages_held"), [])

	extra_values = {
		"cluster_name": cluster_name,
		"pod_network_cidr": pod_network_cidr,
		"cri_socket": cri_socket,
		"packages": packages,
		"held_packages": held_packages,
		"requested_control_plane_k8s_version": requested_version,
		**extra_values_upgrade,
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

# pylint: disable-next=unused-argument
def __task_run_postupgrade_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs post-upgrade playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	selection = __selection_control_planes()
	paths = __playbook_paths_from_path(FilePath(str(PurePath(CMT_HOOKS_DIR).joinpath("post-upgrade.d"))))
	playbooks = populate_playbooks_from_paths(paths)

	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = {})

# pylint: disable-next=unused-argument
def __task_verify_that_cluster_has_no_nodes(installation_info: Dict) -> None:
	"""
	An installer task that verifies that no non-control plane nodes remain in the cluster

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	node_statuses, _kh = __get_node_info()

	if node_statuses is not None:
		for node in node_statuses:
			if "control-plane" not in node["roles"]:
				ansithemeprint([ANSIThemeString("\nPlease delete all nodes (except the ", "warning"),
						ANSIThemeString("control plane", "emphasis"),
						ANSIThemeString(") from the cluster before attempting a teardown.", "warning")])
				sys.exit(errno.EAGAIN)

	ansithemeprint([ANSIThemeString("OK", "ok")])

# Run teardown playbooks on control planes
def __task_run_teardown_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs teardown playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	k8s_distro = installation_info[cluster_name]["distro"]
	selection = __selection_control_planes()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], teardown_control_plane_targets[k8s_distro]["playbooks"]))

	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = {})

def __task_remove_kubeconfig(installation_info: Dict) -> None:
	"""
	An installer task that removes a cluster configuration from ~/.kube/config

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	if not Path(KUBE_CONFIG_DIR).is_dir():
		check_and_print_status(True)
		return

	cluster_name = installation_info["installation_target"]
	admin_name = f"kubernetes-admin+{cluster_name}"
	context_name = f"{admin_name}@{cluster_name}"
	d1 = None

	if os.path.exists(f"{HOMEDIR}/.kube/config.{cluster_name}"):
		os.remove(f"{HOMEDIR}/.kube/config.{cluster_name}")

	try:
		d1 = secure_read_yaml(KUBE_CONFIG_FILE)

		# This is not perfect--there might be leftover users and contexts belonging to this cluster;
		# but we better not go on a killing spree--better leave cruft behind than remove everything.
		for i in range(0, len(d1["clusters"])):
			if d1["clusters"][i].get("name") == cluster_name:
				d1["clusters"].pop(i)
				break
		for i in range(0, len(d1["users"])):
			if d1["users"][i].get("name") == admin_name:
				d1["users"].pop(i)
				break
		for i in range(0, len(d1["contexts"])):
			if d1["contexts"][i].get("name") == context_name:
				d1["contexts"].pop(i)
				break
	except FileNotFoundError:
		pass

	# If there's no cluster left, remove the config completely
	if d1 is None or len(d1["clusters"]) == 0:
		secure_rm(KUBE_CONFIG_FILE, ignore_non_existing = True)

		_dir = os.listdir(f"{HOMEDIR}/.kube")
		try:
			_dir.remove("cache")
		except ValueError:
			pass
		try:
			_dir.remove("http-cache")
		except ValueError:
			pass

		# If there's nothing else than the cache subdirectories in .kube, remove .kube too
		if len(_dir) == 0:
			shutil.rmtree(f"{HOMEDIR}/.kube")
	else:
		# Set the context to the first remaining context, if any
		if len(d1["contexts"]) > 0:
			d1["current-context"] = d1["contexts"][0]["name"]

		secure_write_yaml(KUBE_CONFIG_FILE, d1, permissions = 0o600, sort_keys = False)

	check_and_print_status(True)

# Run purge playbooks on control planes
def __task_run_purge_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs purge playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	k8s_distro = installation_info[cluster_name]["distro"]
	os_distro = identify_distro()
	selection = __selection_control_planes()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], purge_control_plane_targets[k8s_distro]["playbooks"]))

	if os_distro == "debian":
		packages = deep_get(purge_control_plane_targets, DictPath(f"{k8s_distro}#deb_packages"), [])
		held_packages = deep_get(purge_control_plane_targets, DictPath(f"{k8s_distro}#deb_packages_held"), [])
	elif os_distro == "suse":
		packages = deep_get(purge_control_plane_targets, DictPath(f"{k8s_distro}#suse_packages"), [])
		held_packages = deep_get(purge_control_plane_targets, DictPath(f"{k8s_distro}#suse_packages_held"), [])

	extra_values = {
		"packages": packages,
		"held_packages": held_packages,
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

def __validate_task_index(tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]], phase: Union[str, int]) -> int:
	"""
	Helper that validates the installer task index
		Parameters:
			tasks (list[tasks]): A list of tasks
			phase (int): An integer index
		Returns:
			phase (int): The integer index on success; exits if the task is out of range
	"""

	try:
		phase = int(phase)
	except ValueError as e:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default"),
				ANSIThemeString("TASK", "argument"),
				ANSIThemeString(f" needs to be an integer index in the range [0, {len(tasks) - 1}]. Aborting.", "default")], stderr = True)
		sys.exit(f"Exception: {e}")

	if phase < 0 or phase >= len(tasks):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default"),
				ANSIThemeString("TASK", "argument"),
				ANSIThemeString(f" needs to be in the range [0, {len(tasks) - 1}]. Aborting.", "default")], stderr = True)
		sys.exit(errno.ERANGE)
	return phase

def __list_phases(phases: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]], start_phase: Optional[int] = 0, phase_skiplist: Optional[List] = None) -> None:
	"""
	Helper that lists installation phases
	"""

	if start_phase is None or start_phase == "<none>":
		start_phase = 0
	if phase_skiplist is None:
		phase_skiplist = []

	for i, phase in enumerate(phases):
		if i < start_phase or i in phase_skiplist:
			tmp = [ANSIThemeString(f"{str(i).rjust(2)}: ", "skip")]
			override_formatting = "skip"
		else:
			tmp = [ANSIThemeString(f"{str(i).rjust(2)}: ", "emphasis")]
			override_formatting = None
		tmp += themearray_override_formatting(phase[0], override_formatting)
		ansithemeprint(tmp)

def __expand_index_list(index_list: str) -> Set[int]:
	indexes = set()

	for index in index_list.split(","):
		try:
			if "-" in index:
				tmp_first, tmp_last = index.split("-")
				first = int(tmp_first)
				last = int(tmp_last)
			else:
				first = int(index)
				last = first
		except ValueError as e:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default"),
					ANSIThemeString(f"{index}", "argument"),
					ANSIThemeString(" is not an integer or range of integers. Aborting.", "default")], stderr = True)
			sys.exit(f"Exception: {e}")
		for i in range(first, last + 1):
			indexes.add(i)
	return indexes

def __format_none(string: Optional[str], fmt: str) -> ANSIThemeString:
	if string is None or string == "<none>":
		__string = ANSIThemeString("<none>", "none")
	else:
		__string = ANSIThemeString(string, fmt)
	return __string

prepare_tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]] = [
	([ANSIThemeString("Check for ssh host key and create if needed", "action")], __task_check_and_create_ssh_key),
	([ANSIThemeString("Add ssh keys for localhost and the control plane(s) to ", "action"),
	  ANSIThemeString(f"{HOMEDIR}/.ssh/known_hosts", "path")], __task_scan_and_add_ssh_keys),
	([ANSIThemeString("Add public ssh keys to ", "action"),
	  ANSIThemeString(f"{HOMEDIR}/.ssh/authorized_keys", "path")], __task_check_and_add_ssh_keys_to_authorized_keys),
	([ANSIThemeString("Add public ssh keys to inventory", "action")], __task_add_ssh_keys_to_inventory),
	([ANSIThemeString("Request the ansible password if necessary", "action")], __task_request_ansible_password),
	([ANSIThemeString("Install ", "action"),
	  ANSIThemeString("ansible.posix", "programname"),
	  ANSIThemeString(" if necessary", "action")], __task_check_and_install_ansible_posix),
	([ANSIThemeString("Run playbooks on ", "action"),
	  ANSIThemeString("localhost", "hostname")], __task_run_preparation_playbooks_on_localhost),
	([ANSIThemeString("Run playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_preparation_playbooks_on_control_planes),
]

__setup_kubeadm_control_plane_tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]] = [
	([ANSIThemeString("Run playbooks on ", "action"),
	  ANSIThemeString("localhost", "hostname")], __task_run_setup_playbooks_on_localhost),
	([ANSIThemeString("Setup ", "action"),
	  ANSIThemeString("bash completion", "emphasis"),
	  ANSIThemeString(" for ", "action"),
	  ANSIThemeString("kubectl", "programname")], __task_setup_bash_completion),
	([ANSIThemeString("Run playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_setup_playbooks_on_control_planes),
	([ANSIThemeString("Import kubeconfig", "action")], __task_import_kubeconfig),
	([ANSIThemeString("Setup ", "action"),
	  ANSIThemeString("Container Network Interface (CNI)", "action")], __task_setup_cni),
]

__setup_rke2_control_plane_tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]] = [
	([ANSIThemeString("Run playbooks on ", "action"),
	  ANSIThemeString("localhost", "hostname")], __task_run_setup_playbooks_on_localhost),
	([ANSIThemeString("Setup ", "action"),
	  ANSIThemeString("bash completion", "emphasis"),
	  ANSIThemeString(" for ", "action"),
	  ANSIThemeString("kubectl", "programname")], __task_setup_bash_completion),
	([ANSIThemeString("Run playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_setup_playbooks_on_control_planes),
	([ANSIThemeString("Import kubeconfig", "action")], __task_import_kubeconfig),
	([ANSIThemeString("Adjust kubeconfig server-address (if necessary)", "action")], __task_adjust_kubeconfig_server_address),
	([ANSIThemeString("Setup ", "action"),
	  ANSIThemeString("Container Network Interface (CNI)", "action")], __task_setup_cni),
]

setup_control_plane_tasks = __setup_kubeadm_control_plane_tasks

upgrade_control_plane_tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]] = [
	([ANSIThemeString("Drain the ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_drain_control_planes),
	([ANSIThemeString("Run pre-upgrade playbooks on ", "action"),
	  ANSIThemeString("localhost", "hostname")], __task_run_preupgrade_playbooks_on_localhost),
	([ANSIThemeString("Run pre-upgrade playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_preupgrade_playbooks_on_control_planes),
	([ANSIThemeString("Run upgrade playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_upgrade_playbooks_on_control_planes),
	([ANSIThemeString("Run post-upgrade playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_postupgrade_playbooks_on_control_planes),
	([ANSIThemeString("Uncordon the ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_uncordon_control_planes),
]

teardown_control_plane_tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]] = [
	([ANSIThemeString("Verify that only ", "action"),
	  ANSIThemeString("control planes", "hostname"),
	  ANSIThemeString(" remain in the cluster", "action")], __task_verify_that_cluster_has_no_nodes),
	([ANSIThemeString("Drain the ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_drain_control_planes),
	([ANSIThemeString("Run teardown playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_teardown_playbooks_on_control_planes),
	([ANSIThemeString("Remove kube config", "action")], __task_remove_kubeconfig),
]

purge_control_plane_tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]] = [
	([ANSIThemeString("Run purge playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_purge_playbooks_on_control_planes),
]

def run_tasks(tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]], phase: int, phase_skiplist: Set[int], final_state: str) -> None:
	"""
	Run tasks

		Parameters:
			tasks list[(themestring, task)]: A list of tasks containing tuples of describing the task (in form of a themestr) and a function reference
			phase (int): The installation phase
			phase_skiplist (set(phase)): A set of phases to skip
			final_state (str): The state to set if the task completes successfully
	"""

	installation_info = get_installation_info()

	if not isinstance(phase, int):
		phase = 0

	for i in range(phase, len(tasks)):
		ansithemeprint([ANSIThemeString("\n• ", "separator")] + tasks[i][0])
		if i not in set(phase_skiplist):
			tasks[i][1](installation_info)
		if i < len(tasks) - 1:
			installation_info = update_installation_info(phase = i)
		else:
			update_installation_info(state = final_state, phase = "<done>")

def __find_requested_version(k8s_distro: str, version: Optional[str] = None) -> str:
	"""
	Based on a provided version, try to find a matching package;
	Passing None will give the latest version, passing major, minor will give the latest patch revision of that version.
	Passing an exact version will give that version.

		Parameters:
			k8s_distro (str): Currently only kubeadm and rke2 are supported
			version (str): The requested version string or version substring
		Returns:
			requested_version (str): The best matching package version
	"""

	requested_version = None

	if k8s_distro == "kubeadm":
		# If version is an exact match for a package version, use it.
		# If version is a match for a package version with the package revision ("-nn") removed, use the latest matching package revision.
		# If no version is specified, use the latest package revision.
		versions = check_deb_versions(["kubeadm"])

		if len(versions) == 0:
			ansithemeprint([ANSIThemeString("Critical", "critical"),
					ANSIThemeString(": No candidate version for ", "default"),
					ANSIThemeString("kubeadm", "programname"),
					ANSIThemeString(" available; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		elif version is not None:
			# The list is sorted in falling order, so the first match is the one we want, since that's the newest package revision.
			for package_version in versions[0][3]:
				if package_version.split("-")[0] == version:
					requested_version = package_version
					break
				if package_version.split(".")[0] + "." + package_version.split(".")[1] == version:
					requested_version = package_version
					break
				if version.split(".")[0] == version and package_version.split(".")[0] == version:
					requested_version = package_version
					break
		else:
			requested_version = versions[0][2]
			if len(requested_version) == 0:
				requested_version = versions[0][1]

		if requested_version is None:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": Could not find a matching kubeadm package for version ", "default"),
					ANSIThemeString(f"{version}", "version"),
					ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
	elif k8s_distro == "rke2":
		if version is None or version == "<none>":
			return "latest"

		# FIXME: we could fetch the channel file from upstream to get the version list, but for now we just accept any version
		tmp = re.match(r"^v?(\d+\.\d+).*", version)
		if tmp is not None:
			requested_version = tmp[1]
	else:
		raise ValueError(f"No support for distro {k8s_distro} implemented")

	if k8s_distro == "kubeadm":
		_major, minor, _patchrev = requested_version.split(".")
	else:
		_major, minor = requested_version.split(".")
		requested_version = f"v{requested_version}"

	if int(minor) < 15:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Kubernetes versions older than ", "default"),
				ANSIThemeString("1.15", "version"),
				ANSIThemeString(" are not supported by ", "default"),
				ANSIThemeString(f"{about.PROGRAM_SUITE_NAME}", "programname"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)
	elif int(minor) < 18:
		ansithemeprint([ANSIThemeString("Warning", "warning"),
				ANSIThemeString(": Kubernetes versions older than ", "default"),
				ANSIThemeString("1.18", "version"),
				ANSIThemeString(" are not fully supported by ", "default"),
				ANSIThemeString(f"{about.PROGRAM_SUITE_NAME}", "programname"),
				ANSIThemeString(". Some features may be missing or completely broken.", "default")], stderr = True)
	elif int(minor) < 21 and k8s_distro == "rke2":
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": RKE2 versions older than ", "default"),
				ANSIThemeString("1.21", "version"),
				ANSIThemeString(" are not supported by ", "default"),
				ANSIThemeString(f"{about.PROGRAM_SUITE_NAME}", "programname"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	return requested_version

def prepare_installation(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Install and configure pre-requisites for a control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	global no_password # pylint: disable=global-statement
	confirm = True

	# We do not need a cluster name for --list-tasks, so check this first of all
	if "--list-tasks" in (tmp[0] for tmp in options):
		__list_phases(prepare_tasks)
		sys.exit(0)
	elif len(args) == 0:
		ansithemeprint([ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString(": “", "default"),
				ANSIThemeString("prepare", "command"),
				ANSIThemeString("“ requires at least 1 arguments.", "default")], stderr = True)
		ansithemeprint([ANSIThemeString("Try “", "default"),
				ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME} ", "programname"),
				ANSIThemeString("help", "command"),
				ANSIThemeString("“ for more information.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# Always require the user to specify the name of the cluster to operate against, even when resuming prepare;
	# this avoids a lot of hairy corner-cases and attempts to figure out what cluster the user intended to operate against
	cluster_name = args[0]

	installation_info = get_installation_info(cluster_name = cluster_name)
	k8s_distro = "kubeadm"
	os_distro = identify_distro()
	requested_version = installation_info[cluster_name]["requested_version"]
	state = installation_info[cluster_name]["state"]
	phase: Union[str, int] = installation_info[cluster_name]["phase"]
	phase_skiplist = set(installation_info[cluster_name]["phase_skiplist"])

	if state is not None and state not in ("<none>", "preparing", "prepared", "torn_down"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Invalid installation state; the system cannot be in a configured or semi-configured state when running prepare; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if phase == "<none>" or state in ("prepared", "torn_down") and phase == "<done>":
		phase = 0

	hostname = socket.gethostname()

	# default options
	installation_info = update_installation_info(cluster_name = cluster_name, distro = k8s_distro, requested_version = requested_version, state = "preparing", phase = phase)

	__controlplanes = get_control_planes(fail_on_empty = False)
	controlplanes = [controlplane[0] for controlplane in __controlplanes]
	if len(controlplanes) == 0 and "--control-plane" not in (tmp[0] for tmp in options):
		retval = ansithemeinput([ANSIThemeString("\nWarning", "warning"),
					 ANSIThemeString(": No control plane defined in the inventory; do you want to add ", "default"),
					 ANSIThemeString(f"{hostname}", "hostname"),
					 ANSIThemeString(" as control plane? (No will abort the installation) [y/", "default"),
					 ANSIThemeString("N", "emphasis"),
					 ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting:", "error"),
					ANSIThemeString(" No available control plane in inventory.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = [hostname], group = "controlplane", skip_all = False)
		ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = [hostname], group = cluster_name, skip_all = True)

	for opt, optarg in options:
		if opt == "--control-plane":
			ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = [optarg], group = "controlplane", skip_all = False)
			ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = [optarg], group = cluster_name, skip_all = True)
		elif opt == "--no-password":
			no_password = True
		elif opt == "--start-at-task":
			phase = __validate_task_index(prepare_tasks, optarg)
			if "--skip-tasks" not in options:
				phase_skiplist = set()
		elif opt == "--skip-tasks":
			skip_phases = __expand_index_list(optarg)
			for __phase in skip_phases:
				__validate_task_index(prepare_tasks, __phase)
			phase_skiplist = set(skip_phases)
		elif opt == "--resume":
			if phase is None or phase == "<none>":
				phase = 0
			elif phase == "<done>":
				ansithemeprint([ANSIThemeString("Warning", "warning"),
						ANSIThemeString(": Ignoring request to resume a completed preparation. Exiting.", "default")], stderr = True)
				sys.exit(0)

			else:
				phase = __validate_task_index(prepare_tasks, phase)
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "-Y":
			confirm = False

	if len(args) > 1:
		requested_version = args[1]

		if "=" in requested_version:
			k8s_distro, requested_version = requested_version.split("=")
			if k8s_distro not in ("kubeadm", "rke2"):
				ansithemeprint([ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
						ANSIThemeString(": “", "default"),
						ANSIThemeString(f"{k8s_distro}", "option"),
						ANSIThemeString("“ is not a supported Kubernetes distribution.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

	if os_distro == "suse":
		k8s_distro = "rke2"

	installation_info = update_installation_info(cluster_name = cluster_name, distro = k8s_distro, phase = phase, phase_skiplist = list(phase_skiplist))

	show_configuration(action = "Preparing cluster:", tasks = prepare_tasks)

	if confirm == True:
		retval = ansithemeinput([ANSIThemeString("\nStart control plane preparation? [y/", "default"),
					 ANSIThemeString("N", "emphasis"),
					 ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting:", "error"),
					ANSIThemeString(" User stopped control plane preparation.", "default")], stderr = True)
			os.remove(CMT_INSTALLATION_INFO_FILE)
			sys.exit(errno.EINTR)

	ansithemeprint([ANSIThemeString("\n[Preparing localhost and control plane(s)]", "phase")])

	run_tasks(tasks = prepare_tasks, phase = cast(int, phase), phase_skiplist = phase_skiplist, final_state = "prepared")

	# Adjust the kube* packages for the control plane(s) and localhost to match the requested cluster version if necessary;
	# we could not do this before since the apt repository was not available then
	if requested_version is not None:
		requested_version = __find_requested_version(k8s_distro, requested_version)
	else:
		requested_version = __find_requested_version(k8s_distro)

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Updating installation information", "action")])

	ansithemeprint([ANSIThemeString("   Requested version: ", "action"),
			ANSIThemeString(requested_version, "version")])
	update_installation_info(requested_version = requested_version)

	ansithemeprint([ANSIThemeString("\nControl plane preparation successful", "success")])
	print("\nNext step:")
	ansithemeprint([ANSIThemeString("• ", "separator"),
			ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
			ANSIThemeString(" setup-control-plane ", "command"),
			ANSIThemeString("[", "separator"),
			ANSIThemeString("CNI", "argument"),
			ANSIThemeString("]", "separator"),
			ANSIThemeString(" [", "separator"),
			ANSIThemeString("POD_NETWORK_CIDR", "argument"),
			ANSIThemeString("]", "separator")])
	ansithemeprint([ANSIThemeString("\nSee “", "separator"),
			ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
			ANSIThemeString(" help", "command"),
			ANSIThemeString("“ for more information about valid ", "default"),
			ANSIThemeString("CNI", "argument"),
			ANSIThemeString(" options.\n", "default")])

def import_cluster(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Import an existing cluster to the CMT Ansible inventory

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	global no_password # pylint: disable=global-statement

	# default options
	confirm = True

	for opt, _optarg in options:
		if opt == "-Y":
			confirm = False
		elif opt == "--no-password":
			no_password = True

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)
	clusters = kh.list_clusters()
	available_clusters = [tmp[0] for tmp in clusters]

	pad = len("Cluster:")
	match = False
	for cluster_name, context in clusters:
		if len(args) > 0 and cluster_name not in args[0].split(","):
			continue
		pad = max(len(cluster_name), pad)
		match = True

	if len(args) > 0:
		for cluster in args[0].split(","):
			if cluster not in available_clusters and match == True:
				ansithemeprint([ANSIThemeString("Warning", "warning"),
						ANSIThemeString(": Ignoring non-existing cluster ", "default"),
						ANSIThemeString(cluster, "hostname"),
						ANSIThemeString("\n", "default")], stderr = True)

	if match == False:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No matching clusters found; available clusters are:", "default")], stderr = True)
		for cluster in available_clusters:
			ansithemeprint([ANSIThemeString("• ", "separator"),
					ANSIThemeString(cluster, "hostname")])
		ansithemeprint([ANSIThemeString("\nAborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	ansithemeprint([ANSIThemeString("Cluster:", "header"),
			ANSIThemeString("".ljust(pad + 2 - len("Cluster:")), "default"),
			ANSIThemeString("Context:", "header")])
	for cluster_name, context in clusters:
		if len(args) > 0 and cluster_name not in args[0]:
			continue
		ansithemeprint([ANSIThemeString(cluster_name, "hostname"),
				ANSIThemeString("".ljust(pad + 2 - len(cluster_name)), "default"),
				ANSIThemeString(context, "default")])

	if confirm == True:
		input_retval = ansithemeinput([ANSIThemeString("\nImport the following clusters? [y/", "default"),
					       ANSIThemeString("N", "emphasis"),
					       ANSIThemeString("]: ", "default")])

		if input_retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting:", "error"),
					ANSIThemeString(" User stopped cluster import.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	ansithemeprint([ANSIThemeString("\n[Importing cluster(s)]", "phase")])

	# Since the clusters might use different versions of Kubernetes
	# we always install the latest kubectl on localhost, so no need to adjust version

	contexts = kh.list_contexts()
	current_context = None
	for ctx in contexts:
		if ctx[0]:
			current_context = ctx[1]

	for cluster_name, context in clusters:
		if len(args) > 0 and cluster_name not in args[0]:
			continue

		if not kh.set_context(name = context, unchanged_is_success = True):
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": Failed to change to context ", "default"),
					ANSIThemeString(f"{context}", "hostname"),
					ANSIThemeString(" for cluster ", "default"),
					ANSIThemeString(f"{cluster_name}", "hostname"),
					ANSIThemeString("; skipping.", "default")])
			continue

		vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
		if status != 200:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": API-server returned ", "default"),
					ANSIThemeString(f"{status}", "errorvalue"),
					ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		if vlist is None:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": API-server did not return any data", "default")], stderr = True)
			sys.exit(errno.EINVAL)

		controlplanes = []
		controlplane = None

		for node in vlist:
			node_name = deep_get(node, DictPath("metadata#name"))
			node_roles = kh.get_node_roles(cast(Dict, node))
			if "control-plane" in node_roles:
				controlplanes.append(node_name)
				if controlplane is None:
					controlplane = node_name

		if controlplane is None:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": Could not find a control plane for the cluster ", "default"),
					ANSIThemeString(cluster_name, "hostname"),
					ANSIThemeString("; aborting.", "default")], stderr = True)
			# Remember to restore current-context
			kh.set_context(name = current_context)
			sys.exit(errno.ENOENT)

		__task_request_ansible_password(None)

		extra_values = {
			"ansible_become_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
			"ansible_ssh_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
		}

		install_ansible_posix()

		retval, ansible_results = run_playbook(FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_passwordless_ansible.yaml"))),
						       hosts = [controlplane], extra_values = extra_values, quiet = True)
		if retval != 0:
			break

		tmp_cni = kh.identify_cni()
		if len(tmp_cni) != 1:
			cni = "<unknown>"
		else:
			cni = tmp_cni[0][0]

		pod_network_cidr = kh.get_pod_network_cidr()
		if pod_network_cidr is None:
			pod_network_cidr = "<unknown>"

		get_versions_path = get_playbook_path(FilePath("get_versions.yaml"))
		retval, ansible_results = ansible_run_playbook_on_selection(get_versions_path, selection = [controlplane])

		if len(ansible_results) == 0:
			raise ValueError(f"Error: Failed to get package versions from {controlplane} (retval: {retval}); aborting.")

		k8s_distro = "<unknown>"
		version = "<unknown>"

		for result in deep_get(ansible_results, DictPath(controlplane), []):
			if deep_get(result, DictPath("task"), "") == "Package versions":
				tmp = deep_get(result, DictPath("msg_lines"), [])
				break

		if len(tmp) == 0:
			raise ValueError(f"Error: Received empty version data from {controlplane} (retval: {retval}); aborting.")

		# Safe
		package_version_regex = re.compile(r"^(.*?): (.*)")

		for line in tmp:
			tmp2 = package_version_regex.match(line)
			if tmp2 is None:
				continue
			package = tmp2[1]
			version = tmp2[2]
			if package == "kubeadm":
				k8s_distro = "kubeadm"
				update_installation_info(cluster_name = cluster_name, distro = k8s_distro, version = version, requested_version = "<none>", cni = cni, state = "installed", phase = "<none>", pod_network_cidr = pod_network_cidr, control_planes = controlplanes)
				break
		if k8s_distro == "<unknown>":
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": Failed to import cluster ", "default"),
					ANSIThemeString(f"{cluster_name}", "hostname"),
					ANSIThemeString("; could not identify distro; skipping.", "default")])

	kh.set_context(name = current_context)

	ansithemeprint([ANSIThemeString("\nCluster import successful", "success")])

# pylint: disable-next=unused-argument
def check_for_updates(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Check whether there are newer versions of packages that are related to the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	# default options
	update_cache = True

	for opt, _optarg in options:
		if opt == "--no-cache-update":
			update_cache = False

	ansithemeprint([ANSIThemeString("\n[Checking for software updates]", "phase")])

	if update_cache == True:
		ansithemeprint([ANSIThemeString("\n• ", "separator"),
				ANSIThemeString("Updating APT cache", "action")])
		check_and_print_status(update_apt_cache())

	deb_packages = [
		"ansible",
		"containerd",
		"containerd.io",
		"cri-o",
		"cri-tools",
		"kubeadm",
		"kubectl",
		"kubelet",
		"kubernetes-cni",
		"kubernetes-client",
		"kubernetes-master",
		"kubernetes-node",
		"docker.io",
		"docker-ce",
		"python3-ansible-runner",
		"python3-natsort",
		"python3-openssl",
		"python3-paramiko",
		"python3-pip",
		"python3-ujson",
		"python3-urllib3",
		"runc",
	]

	version_checks: List = []

	print()
	check_versions(deb_packages, version_checks)
	print()

def show_configuration(action: str = "", tasks: Optional[List] = None) -> None:
	"""
	Show cluster configuration
	"""

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	k8s_distro = installation_info[cluster_name]["distro"]
	version = installation_info[cluster_name]["version"]
	requested_version = installation_info[cluster_name]["requested_version"]
	cni = installation_info[cluster_name]["cni"]
	pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]
	cri = installation_info[cluster_name]["cri"]

	controlplanes = get_control_planes()

	http_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), "")
	if http_proxy is not None and http_proxy == "":
		http_proxy = None
	http_proxy_env = os.getenv("http_proxy")
	if http_proxy_env is not None and http_proxy_env == "":
		http_proxy_env = None
	https_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), "")
	if https_proxy is not None and https_proxy == "":
		https_proxy = None
	https_proxy_env = os.getenv("https_proxy")
	if https_proxy_env is not None and https_proxy_env == "":
		https_proxy_env = None
	no_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), "")
	if no_proxy is not None and no_proxy == "":
		no_proxy = None
	no_proxy_env = os.getenv("no_proxy")
	if no_proxy_env is not None and no_proxy_env == "":
		no_proxy_env = None

	if len(action) > 0:
		ansithemeprint([ANSIThemeString(action, "emphasis")])

	ansithemeprint([ANSIThemeString("\n[Summary]", "phase")])
	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Configuration:", "action")])
	ansithemeprint([ANSIThemeString("        Cluster Name: ", "action"),
			ANSIThemeString(f"{cluster_name}", "hostname")])
	ansithemeprint([ANSIThemeString("        Distribution: ", "action"),
			ANSIThemeString(f"{k8s_distro}", "programname")])
	ansithemeprint([ANSIThemeString("   Installed Version: ", "action"),
			__format_none(version, "version")])
	if requested_version is not None and requested_version != "<none>":
		ansithemeprint([ANSIThemeString("   Requested Version: ", "action"),
				__format_none(requested_version, "version")])
	if cni is not None and cni != "<none>":
		ansithemeprint([ANSIThemeString("                 CNI: ", "action"),
				ANSIThemeString(f"{cni}", "programname")])
	if pod_network_cidr is not None and pod_network_cidr != "<none>":
		ansithemeprint([ANSIThemeString("    Pod Network CIDR: ", "action"),
				ANSIThemeString(f"{pod_network_cidr}", "emphasis")])
	if cri is not None and cri != "<none>":
		ansithemeprint([ANSIThemeString("                 CRI: ", "action"),
				ANSIThemeString(f"{cri}", "programname")])
	ansithemeprint([ANSIThemeString("          HTTP Proxy: ", "action"),
			__format_none(http_proxy, "url"),
			ANSIThemeString(" (", "default"),
			ANSIThemeString(f"{CMT_CONFIG_FILE}", "path"),
			ANSIThemeString(")", "default")])
	ansithemeprint([ANSIThemeString("          HTTP Proxy: ", "action"),
			__format_none(http_proxy_env, "url"),
			ANSIThemeString(" (Environment)", "default")])
	ansithemeprint([ANSIThemeString("         HTTPS Proxy: ", "action"),
			__format_none(https_proxy, "url"),
			ANSIThemeString(" (", "default"),
			ANSIThemeString(f"{CMT_CONFIG_FILE}", "path"),
			ANSIThemeString(")", "default")])
	ansithemeprint([ANSIThemeString("         HTTPS Proxy: ", "action"),
			__format_none(https_proxy_env, "url"),
			ANSIThemeString(" (Environment)", "default")])
	ansithemeprint([ANSIThemeString("            No Proxy: ", "action"),
			__format_none(no_proxy, "url"),
			ANSIThemeString(" (", "default"),
			ANSIThemeString(f"{CMT_CONFIG_FILE}", "path"),
			ANSIThemeString(")", "default")])
	ansithemeprint([ANSIThemeString("            No Proxy: ", "action"),
			__format_none(no_proxy_env, "url"),
			ANSIThemeString(" (Environment)", "default")])
	if len(controlplanes) > 0:
		ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Control Plane(s):", "action")])
		for controlplane in controlplanes:
			ansithemeprint([ANSIThemeString("            Hostname: ", "action"),
					ANSIThemeString(f"{controlplane[0]} ", "emphasis"),
					ANSIThemeString("(", "default"),
					ANSIThemeString(f"{controlplane[1]}", "emphasis"),
					ANSIThemeString(")", "default")])

	if tasks is not None:
		ansithemeprint([ANSIThemeString("", "default")])
		ansithemeprint([ANSIThemeString("Pending tasks (", "action"),
				ANSIThemeString("Dimmed", "skip"),
				ANSIThemeString(" tasks are either skipped or completed):\n", "action")])

		phase = installation_info[cluster_name]["phase"]
		phase_skiplist = installation_info[cluster_name]["phase_skiplist"]
		__list_phases(tasks, start_phase = phase, phase_skiplist = phase_skiplist)

def setup_control_plane(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Setup a control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	confirm = True
	override_cni = False

	installation_info = get_installation_info()

	cluster_name = installation_info["installation_target"]
	k8s_distro = installation_info[cluster_name]["distro"]

	if k8s_distro == "kubeadm":
		setup_control_plane_tasks = __setup_kubeadm_control_plane_tasks
	elif k8s_distro == "rke2":
		setup_control_plane_tasks = __setup_rke2_control_plane_tasks

	if "--list-tasks" in (tmp[0] for tmp in options):
		__list_phases(setup_control_plane_tasks)
		sys.exit(0)

	os_distro = identify_distro()
	requested_version = installation_info[cluster_name]["requested_version"]
	state = installation_info[cluster_name]["state"]
	phase: Union[str, int] = installation_info[cluster_name]["phase"]
	phase_skiplist = set(installation_info[cluster_name]["phase_skiplist"])
	cni = installation_info[cluster_name]["cni"]
	pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]

	if state is not None and state in ("installed", "upgrading", "tearing_down", "torn_down", "purging"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Invalid installation state; there is a partial or full installation already; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)
	elif state is None or state in ("<none>", "preparing"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": The system is not prepared for installation yet; run ", "default"),
				ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" prepare", "command"),
				ANSIThemeString(" before continuing. Aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if state == "prepared":
		phase = 0

	cri = None
	enable_dra = False

	for opt, optarg in options:
		if opt == "--start-at-task":
			phase = __validate_task_index(setup_control_plane_tasks, optarg)
			if "--skip-tasks" not in options:
				phase_skiplist = set()
		elif opt == "--skip-tasks":
			skip_phases = __expand_index_list(optarg)
			for __phase in skip_phases:
				__validate_task_index(setup_control_plane_tasks, __phase)
			phase_skiplist = set(skip_phases)
		elif opt == "--resume":
			if phase is None or phase == "<none>":
				phase = 0
			elif phase == "<done>":
				ansithemeprint([ANSIThemeString("Warning", "warning"),
						ANSIThemeString(": Ignoring request to resume a completed installation. Exiting.", "default")], stderr = True)
				sys.exit(0)

			phase = __validate_task_index(setup_control_plane_tasks, phase)
		elif opt == "--cri":
			if optarg in ("docker-shim", "containerd", "cri-o"):
				cri = optarg
			else:
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": Unknown CRI “", "default"),
						ANSIThemeString(optarg, "argument"),
						ANSIThemeString("“ specified; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
		elif opt == "--override-cni":
			override_cni = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--enable-dra":
			enable_dra = True
		elif opt == "-Y":
			confirm = False

	if enable_dra:
		setup_control_plane_targets[k8s_distro]["extra_values"] = {
			"api_server_feature_gates": "DynamicResourceAllocation=true",
			"api_server_runtime_config_api_alpha_enabled": "true",
			"controller_manager_feature_gates": "DynamicResourceAllocation=true",
			"scheduler_feature_gates": "DynamicResourceAllocation=true",
			"kubelet_feature_gates": "{ DynamicResourceAllocation: true }",
			"kubeproxy_feature_gates": "{ DynamicResourceAllocation: true }",
		}

		# Override the feature-gate format if the parameters are passed via command-line;
		# e.g. when using RKE2
		if k8s_distro == "rke2":
			setup_control_plane_targets[k8s_distro]["extra_values"]["kubelet_feature_gates"] = "DynamicResourceAllocation=true"
			setup_control_plane_targets[k8s_distro]["extra_values"]["kubeproxy_feature_gates"] = "DynamicResourceAllocation=true"
	else:
		setup_control_plane_targets[k8s_distro]["extra_values"] = {
			"api_server_feature_gates": "",
			"api_server_runtime_config_api_alpha_enabled": "false",
			"controller_manager_feature_gates": "",
			"kubelet_feature_gates": "{}",
			"kubeproxy_feature_gates": "{}",
			"scheduler_feature_gates": "",
		}

		# Override the feature-gate format if the parameters are passed via command-line;
		# e.g. when using RKE2
		if k8s_distro == "rke2":
			setup_control_plane_targets[k8s_distro]["extra_values"]["kubelet_feature_gates"] = ""
			setup_control_plane_targets[k8s_distro]["extra_values"]["kubeproxy_feature_gates"] = ""

	if k8s_distro == "kubeadm":
		requested_major, requested_minor, _rest = requested_version.split(".")

		if int(requested_minor) < 23:
			cluster_configuration_api_version = "kubeadm.k8s.io/v1beta2"
			init_configuration_api_version = "kubeadm.k8s.io/v1beta2"
		else:
			cluster_configuration_api_version = "kubeadm.k8s.io/v1beta3"
			init_configuration_api_version = "kubeadm.k8s.io/v1beta3"

		setup_control_plane_targets[k8s_distro]["extra_values"]["cluster_configuration_api_version"] = cluster_configuration_api_version
		setup_control_plane_targets[k8s_distro]["extra_values"]["init_configuration_api_version"] = init_configuration_api_version
	elif k8s_distro == "rke2":
		requested_major, requested_minor = requested_version[1:].split(".")

		# Add requested_version to extra_values;
		# for rke2 this is either vX.YY or latest
		setup_control_plane_targets["rke2"]["extra_values"]["requested_version"] = requested_version

		# For now at least we disable the cloud controller
		rke2_disable_cloud_controller = True
		setup_control_plane_targets["rke2"]["extra_values"]["disable_cloud_controller"] = rke2_disable_cloud_controller
		# Disable canal since we install the CNI separately
		rke2_disabled_options_list = ["rke2-canal"]
		setup_control_plane_targets["rke2"]["extra_values"]["disabled_options_list"] = rke2_disabled_options_list

	# Add major/minor to extra_values
	setup_control_plane_targets[k8s_distro]["extra_values"]["kubernetes_major_minor_version"] = f"{requested_major}.{requested_minor}"

	if cri is None:
		if k8s_distro == "rke2":
			cri = "containerd"
		elif int(requested_minor) < 24:
			cri = "docker-shim"
		elif enable_dra == True:
			cri = "cri-o"
		else:
			cri = "containerd"
	else:
		if k8s_distro == "rke2":
			if cri == "docker-shim":
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": CRI cannot be “", "default"),
						ANSIThemeString("docker-shim", "argument"),
						ANSIThemeString("“ for ", "default"),
						ANSIThemeString("RKE2", "argument"),
						ANSIThemeString("; aborting.", "default")], stderr = True)
				sys.exit(errno.ENOTSUP)
		elif int(requested_minor) >= 24 and cri == "docker-shim":
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": CRI cannot be “", "default"),
					ANSIThemeString("docker-shim", "argument"),
					ANSIThemeString("“ for ", "default"),
					ANSIThemeString("Kubernetes ", "programname"),
					ANSIThemeString(">= ", "default"),
					ANSIThemeString("1.24", "version"),
					ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOTSUP)

	installation_info = update_installation_info(cri = cri)

	# Add the CRI to the setup playbooks for the control plane;
	# the list is short enough that doing prepend isn't a performance issue
	if k8s_distro == "kubeadm":
		if cri == "docker-shim":
			setup_control_plane_targets["kubeadm"]["playbooks"].insert(0, FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("setup_docker.io.yaml"))))
		elif cri == "containerd":
			setup_control_plane_targets["kubeadm"]["playbooks"].insert(0, FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("setup_containerd.yaml"))))
		elif cri == "cri-o":
			setup_control_plane_targets["kubeadm"]["playbooks"].insert(0, FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("setup_cri-o.yaml"))))
	else:
		if cri == "containerd":
			setup_control_plane_targets["rke2"]["playbooks"].insert(0, FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("setup_containerd.yaml"))))
		elif cri == "cri-o":
			setup_control_plane_targets["rke2"]["playbooks"].insert(0, FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("setup_cri-o.yaml"))))

	if cni is None or cni == "<none>":
		if k8s_distro == "rke2":
			default_cni = "canal"
		else:
			default_cni = DEFAULT_CNI
		if len(args) == 0:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": No CNI specified; defaulting to ", "default"),
					ANSIThemeString(f"{default_cni}", "programname"),
					ANSIThemeString(".", "default")], stderr = True)
			cni = default_cni
		elif cni != args[0]:
			cni = args[0]
	else:
		new_cni = cni
		if len(args) > 0:
			new_cni = args[0]

		if new_cni != cni:
			if override_cni == False:
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": Installation was previous initiated with ", "default"),
						ANSIThemeString(f"{cni}", "programname"),
						ANSIThemeString(" as CNI; ", "default"),
						ANSIThemeString("you can attempt to override this by using ", "default"),
						ANSIThemeString("--override-cni", "option"),
						ANSIThemeString(", but success is not guaranteed. Aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
			else:
				ansithemeprint([ANSIThemeString("Warning", "warning"),
						ANSIThemeString(": Installation was previous initiated with ", "default"),
						ANSIThemeString(f"{cni}", "programname"),
						ANSIThemeString(" as CNI, ", "default"),
						ANSIThemeString("but ", "default"),
						ANSIThemeString("--override-cni", "option"),
						ANSIThemeString(" was specified; continuing installation.", "default")], stderr = True)
		cni = new_cni

	if cni != "none" and cni not in cni_data and cni not in cni_upgrade_data:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default"),
				ANSIThemeString(f"{cni}", "argument"),
				ANSIThemeString(" is not a valid/supported CNI; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(args) > 1:
		new_pod_network_cidr = args[1]
	else:
		new_pod_network_cidr = DEFAULT_POD_NETWORK_CIDR
	if pod_network_cidr == "<none>" or pod_network_cidr == new_pod_network_cidr or phase == 0:
		pod_network_cidr = new_pod_network_cidr
	else:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Installation was previously initiated with ", "default"),
				ANSIThemeString(f"{pod_network_cidr}", "emphasis"),
				ANSIThemeString(" as Pod Network CIDR;\n", "default"),
				ANSIThemeString("changing this value in the middle of installation is not supported. Aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	update_installation_info(cni = cni, pod_network_cidr = pod_network_cidr, state = "installing", phase = phase, phase_skiplist = list(phase_skiplist))

	show_configuration(action = "Setting up control plane:", tasks = setup_control_plane_tasks)

	if confirm == True:
		retval = ansithemeinput([ANSIThemeString("\nStart installation? [y/", "default"),
					 ANSIThemeString("N", "emphasis"),
					 ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting:", "error"),
					ANSIThemeString(" User stopped installation.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	ansithemeprint([ANSIThemeString("\n[Setting up control plane]", "phase")])

	if k8s_distro == "kubeadm":
		setup_control_plane_targets["localhost"]["deb_packages"].remove("kubectl")
		setup_control_plane_targets["localhost"]["deb_packages"].append(f"kubectl={requested_version}")
		setup_control_plane_targets["kubeadm"]["deb_packages"].remove("kubectl")
		setup_control_plane_targets["kubeadm"]["deb_packages"].append(f"kubectl={requested_version}")
		setup_control_plane_targets["kubeadm"]["deb_packages"].remove("kubeadm")
		setup_control_plane_targets["kubeadm"]["deb_packages"].append(f"kubeadm={requested_version}")
		setup_control_plane_targets["kubeadm"]["deb_packages"].remove("kubelet")
		setup_control_plane_targets["kubeadm"]["deb_packages"].append(f"kubelet={requested_version}")

	run_tasks(tasks = setup_control_plane_tasks, phase = cast(int, phase), phase_skiplist = phase_skiplist, final_state = "installed")
	update_installation_info(version = requested_version)

	ansithemeprint([ANSIThemeString("\nControl plane setup successful", "success")])
	ansithemeprint([ANSIThemeString("\nNote:", "note")])
	ansithemeprint([ANSIThemeString("If this is an RKE2 installation you may need to substitute ", "default"),
			ANSIThemeString("127.0.0.1", "hostname")])
	ansithemeprint([ANSIThemeString("in ", "default"),
			ANSIThemeString(f"{KUBE_CONFIG_FILE}", "path"),
			ANSIThemeString(" with the real IP-address of this host.\n", "default")])

def __get_node_info(kh: Optional[kubernetes_helper.KubernetesHelper] = None) -> Tuple[List[Dict], kubernetes_helper.KubernetesHelper]:
	if not Path(KUBE_CONFIG_FILE).is_file():
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Could not find ", "default"),
				ANSIThemeString(f"{KUBE_CONFIG_FILE}", "path"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# The reason for importing inside the function is to avoid slow startup
	# when we do not use the Kubernetes helper
	if kh is None:
		from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
		kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	# If kh is *still* None here something has gone wrong. It is time to exit.
	if kh is None:
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Failed to initialise connection to API-server; do you have a running cluster? Aborting.", "default")], stderr = True)
		sys.exit(errno.ENXIO)

	node_statuses = []

	vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
	if status != 200:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": API-server returned ", "default"),
				ANSIThemeString(f"{status}", "errorvalue"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)
	if vlist is None:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": API-server did not return any data", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for node in vlist:
		node_name = deep_get(node, DictPath("metadata#name"))
		node_schedulable = not deep_get(node, DictPath("spec#unschedulable"), False)
		node_roles = kh.get_node_roles(cast(Dict, node))
		node_taints = deep_get(node, DictPath("spec#taints"), [])
		node_statuses.append({
			"name": node_name,
			"schedulable": node_schedulable,
			"roles": node_roles,
			"taints": node_taints,
		})

	return node_statuses, kh

def get_control_planes(fail_on_empty: bool = True) -> List[Tuple[str, str]]:
	"""
	Get a list of control planes defined in the inventory

		Parameters:
			fail_on_empty (bool): If True the action will fail if no control planes are defined in the inventory
		Returns:
			control_planes (list[hostname, ip]): A list of control planes
				hostname (str): The hostname
				ip (str): The IP-address
	"""

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	if cluster_name is None:
		cluster_name = get_cluster_name()
	inventory = ansible_get_inventory_dict()
	__controlplanes = deep_get(inventory, DictPath("controlplane#hosts"), {})
	__clusterhosts = deep_get(inventory, DictPath(f"{cluster_name}#hosts"), {})
	controlplanes = []
	if len(__controlplanes) == 0 and fail_on_empty == True:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No control plane(s) defined in the inventory; rebuilding the inventory using “", "default"),
				ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME} ", "programname"),
				ANSIThemeString("rebuild-inventory", "command"),
				ANSIThemeString("“ might help. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)
	if len(__clusterhosts) == 0 and fail_on_empty == True:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": The cluster ", "default"),
				ANSIThemeString(f"{cluster_name}", "hostname"),
				ANSIThemeString(" has no hosts in the inventory; rebuilding the inventory using “", "default"),
				ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME} ", "programname"),
				ANSIThemeString("rebuild-inventory", "command"),
				ANSIThemeString("“ might help. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	for controlplane in __controlplanes:
		# Only include control planes belonging to this cluster
		if controlplane not in __clusterhosts:
			continue
		ip = socket.gethostbyname(controlplane)
		controlplanes.append((controlplane, ip))
	return controlplanes

# pylint: disable-next=unused-argument
def teardown_control_plane(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Teardown an existing control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	confirm = True

	# We do not need a cluster name for --list-tasks, so check this first of all
	if "--list-tasks" in (tmp[0] for tmp in options):
		__list_phases(teardown_control_plane_tasks)
		sys.exit(0)

	if not Path(CMT_INSTALLATION_INFO_FILE).is_file():
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Could not find reliable installation information. Aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	k8s_distro = installation_info[cluster_name]["distro"]
	state = installation_info[cluster_name]["state"]
	phase: Union[str, int] = installation_info[cluster_name]["phase"]
	phase_skiplist = set(installation_info[cluster_name]["phase_skiplist"])

	if k8s_distro is None or k8s_distro == "<none>":
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Could not find reliable installation information. Aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if state is None:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Cannot determine installation state; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)
	elif state in ("preparing", "prepared", "torn_down"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": The system has no installed cluster; try ", "default"),
				ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" purge-control-plane", "command"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# If phase is "<done>" it's a holdover from a previous state
	if phase == "<done>":
		phase = 0

	for opt, optarg in options:
		if opt == "--start-at-task":
			phase = __validate_task_index(teardown_control_plane_tasks, optarg)
			if "--skip-tasks" not in options:
				phase_skiplist = set()
		elif opt == "--skip-tasks":
			skip_phases = __expand_index_list(optarg)
			for __phase in skip_phases:
				__validate_task_index(teardown_control_plane_tasks, __phase)
			phase_skiplist = set(skip_phases)
		elif opt == "--resume":
			if phase is None or phase == "<none>":
				phase = 0
			elif phase == "<done>":
				ansithemeprint([ANSIThemeString("Warning", "warning"),
						ANSIThemeString(": Ignoring request to resume a completed teardown. Exiting.", "default")], stderr = True)
				sys.exit(0)

			phase = __validate_task_index(teardown_control_plane_tasks, phase)
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "-Y":
			confirm = False

	installation_info = update_installation_info(state = "tearing_down", phase = phase, phase_skiplist = list(phase_skiplist))
	show_configuration(action = "Tearing down control plane", tasks = teardown_control_plane_tasks)

	if confirm == True:
		retval = ansithemeinput([ANSIThemeString("\nStart teardown? [y/", "default"),
					 ANSIThemeString("N", "emphasis"),
					 ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting:", "error"),
					ANSIThemeString(" User stopped teardown.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	ansithemeprint([ANSIThemeString("\n[Tearing down cluster]", "phase")])

	installation_info = update_installation_info(state = "tearing_down", phase = 0)

	run_tasks(tasks = teardown_control_plane_tasks, phase = cast(int, phase), phase_skiplist = phase_skiplist, final_state = "torn_down")
	ansithemeprint([ANSIThemeString("\nCluster teardown successful", "success")])

# pylint: disable-next=unused-argument
def purge_control_plane(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Purge an existing control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	confirm = True

	# We do not need a cluster name for --list-tasks, so check this first of all
	if "--list-tasks" in (tmp[0] for tmp in options):
		__list_phases(purge_control_plane_tasks)
		sys.exit(0)

	if not Path(CMT_INSTALLATION_INFO_FILE).is_file():
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Could not find reliable installation information. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	state = installation_info[cluster_name]["state"]
	phase: Union[str, int] = installation_info[cluster_name]["phase"]
	phase_skiplist = set(installation_info[cluster_name]["phase_skiplist"])

	if state is None or state not in ("prepared", "torn_down", "purging"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Invalid installation state; there's no prepared or torn down cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# If phase is "<done>" it's a holdover from a previous state
	if len(options) == 0 or phase == "<done>":
		phase = 0

	for opt, optarg in options:
		if opt == "--start-at-task":
			phase = __validate_task_index(purge_control_plane_tasks, optarg)
			if "--skip-tasks" not in options:
				phase_skiplist = set()
		elif opt == "--skip-tasks":
			skip_phases = __expand_index_list(optarg)
			for __phase in skip_phases:
				__validate_task_index(purge_control_plane_tasks, __phase)
			phase_skiplist = set(skip_phases)
		elif opt == "--resume":
			if phase is None or phase == "<none>":
				phase = 0
			elif phase == "<done>":
				ansithemeprint([ANSIThemeString("Warning", "warning"),
						ANSIThemeString(": Ignoring request to resume a completed purge. Exiting.", "default")], stderr = True)
				sys.exit(0)

			phase = __validate_task_index(purge_control_plane_tasks, phase)
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "-Y":
			confirm = False

	installation_info = update_installation_info(state = "purging", phase = phase, phase_skiplist = list(phase_skiplist))
	show_configuration(action = "Purging control plane:", tasks = purge_control_plane_tasks)

	if confirm == True:
		retval = ansithemeinput([ANSIThemeString("\nStart purge? [y/", "default"),
					 ANSIThemeString("N", "emphasis"),
					 ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting:", "error"),
					ANSIThemeString(" User stopped purge.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	ansithemeprint([ANSIThemeString("\n\n[Purging cluster configuration and software]", "phase")])

	# If we are purging the control plane we want to leave kubectl behind; if we have a setup with multiple
	# control planes and we run this from one of them, then kubectl will remain on the other two.
	if __selection_localhost() == __selection_control_planes():
		purge_control_plane_targets["kubeadm"]["deb_packages"].remove("kubectl")
		purge_control_plane_targets["kubeadm"]["deb_packages_held"].remove("kubectl")

	installation_info = update_installation_info(state = "purging", phase = 0)

	run_tasks(tasks = purge_control_plane_tasks, phase = cast(int, phase), phase_skiplist = phase_skiplist, final_state = "purged")
	secure_rm(CMT_INSTALLATION_INFO_FILE, ignore_non_existing = True)

	ansithemeprint([ANSIThemeString("\nCluster purge successful", "success")])

	ansithemeprint([ANSIThemeString("\nNote", "note"),
			ANSIThemeString(": It is recommended to reboot the control plane(s) after purging the cluster\n", "default")])

def upgrade_control_plane(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Upgrade a control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	confirm = True

	# default options
	update_cache = True
	allow_reinstall = False
	requested_version = None

	# We do not need a cluster name for --list-tasks or --override, so check this first of all
	if "--list-tasks" in (tmp[0] for tmp in options):
		__list_phases(upgrade_control_plane_tasks)
		sys.exit(0)
	elif "--override" in (tmp[0] for tmp in options):
		if Path(CMT_INSTALLATION_INFO_FILE).is_file():
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": Overriding ", "default"),
					ANSIThemeString(f"{CMT_INSTALLATION_INFO_FILE}", "path"),
					ANSIThemeString("; this may cause issues.", "default")], stderr = True)
		else:
			ansithemeprint([ANSIThemeString("Note", "note"),
					ANSIThemeString(": ", "default"),
					ANSIThemeString(f"{CMT_INSTALLATION_INFO_FILE}", "path"),
					ANSIThemeString(" does not exist; rebuilding.", "default")])
		rebuild_installation_info(state = "upgrading")

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	os_distro = identify_distro()
	k8s_distro = installation_info[cluster_name]["distro"]
	version = installation_info[cluster_name]["version"]
	requested_version = installation_info[cluster_name]["requested_version"]
	state = installation_info[cluster_name]["state"]
	phase: Union[str, int] = installation_info[cluster_name]["phase"]
	phase_skiplist = set(installation_info[cluster_name]["phase_skiplist"])

	if state is None or state == "<none>":
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Unknown installation state; if you believe this is OK (such as when upgrading a cluster not installed using ", "default"),
				ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" you can try using the “", "default"),
				ANSIThemeString("--override", "option"),
				ANSIThemeString("“ option; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if state in ("preparing", "prepared", "installing", "tearing_down", "torn_down", "purging"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Invalid installation state; Kubernetes does not seems to be fully installed; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if state in ("installed", "upgraded"):
		phase = 0

	if len(args) > 0:
		requested_version = __find_requested_version(k8s_distro, args[0])
	else:
		requested_version = __find_requested_version(k8s_distro)

	for opt, optarg in options:
		if opt == "--start-at-task":
			phase = __validate_task_index(upgrade_control_plane_tasks, optarg)
			if "--skip-tasks" not in options:
				phase_skiplist = set()
		elif opt == "--skip-tasks":
			skip_phases = __expand_index_list(optarg)
			for __phase in skip_phases:
				__validate_task_index(upgrade_control_plane_tasks, __phase)
			phase_skiplist = set(skip_phases)
		elif opt == "--resume":
			if phase is None or phase == "<none>":
				phase = 0
			elif phase == "<done>":
				ansithemeprint([ANSIThemeString("Warning", "warning"),
						ANSIThemeString(": Ignoring request to resume a completed upgrade. Exiting.", "default")], stderr = True)
				sys.exit(0)

			phase = __validate_task_index(upgrade_control_plane_tasks, phase)
		elif opt == "--no-cache-update":
			update_cache = False
		elif opt == "--reinstall":
			allow_reinstall = True
		elif opt in ("--override", "--list-tasks"):
			continue
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "-Y":
			confirm = False

	# XXX: How do we check that nodes are drained? We can check whether they are cordoned
	node_status, _kh = __get_node_info()

	if node_status is None:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No ", "default"),
				ANSIThemeString(f"{HOMEDIR}/.kube/config", "path"),
				ANSIThemeString(" available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if os_distro == "debian" and update_cache == True:
		ansithemeprint([ANSIThemeString("\n• ", "separator"),
				ANSIThemeString("Updating APT cache", "action")])
		check_and_print_status(update_apt_cache())

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Running sanity checks", "action")])

	if k8s_distro == "kubeadm":
		deb_versions = check_deb_versions(["kubeadm"])

		if len(deb_versions) == 0:
			ansithemeprint([ANSIThemeString("Critical", "critical"),
					ANSIThemeString(": No candidate version for ", "default"),
					ANSIThemeString("kubeadm", "programname"),
					ANSIThemeString(" available; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)

		if requested_version is not None:
			if requested_version not in deb_versions[0][3]:
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": The requested version ", "default"),
						ANSIThemeString(f"{requested_version}", "version"),
						ANSIThemeString(" is not available; aborting.", "default")], stderr = True)
				sys.exit(errno.ENOENT)
			elif requested_version == version:
				if allow_reinstall == False:
					ansithemeprint([ANSIThemeString("Warning", "warning"),
							ANSIThemeString(": The requested version ", "default"),
							ANSIThemeString(f"{requested_version}", "version"),
							ANSIThemeString(" is already installed; to reinstall use the option “", "default"),
							ANSIThemeString("--reinstall", "option"),
							ANSIThemeString("“.", "default")], stderr = True)
					sys.exit(errno.EINVAL)
			elif deb_compare_versions(version, requested_version) == True:
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": The requested version ", "default"),
						ANSIThemeString(f"{requested_version}", "version"),
						ANSIThemeString(" is older than than the installed version ", "default"),
						ANSIThemeString(f"{deb_versions[0][1]}", "version"),
						ANSIThemeString(". Downgrades are not supported; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
		else:
			requested_version = deb_versions[0][2]
			if len(requested_version) == 0 or requested_version == "<none>":
				ansithemeprint([ANSIThemeString("Note", "note"),
						ANSIThemeString(": The latest version ", "default"),
						ANSIThemeString(f"{deb_versions[0][1]}", "version"),
						ANSIThemeString(" is already installed.", "default")])
				sys.exit(0)

		# Is this an major, minor, or patchrev upgrade?
		installed_version_tuple = version.split(".")
		requested_version_tuple = requested_version.split(".")

		upgrade_type = None

		if installed_version_tuple[0] != requested_version_tuple[0]:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": Upgrades between ", "default"),
					ANSIThemeString("MAJOR", "emphasis"),
					ANSIThemeString(" versions is currently not supported (installed version: ", "default"),
					ANSIThemeString(f"{deb_versions[0][1]}", "version"),
					ANSIThemeString(", requested version: ", "default"),
					ANSIThemeString(f"{requested_version}", "version"),
					ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOTSUP)
		elif installed_version_tuple[1] != requested_version_tuple[1]:
			if int(requested_version_tuple[1]) - int(installed_version_tuple[1]) > 1:
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": Skipping ", "default"),
						ANSIThemeString("MINOR", "emphasis"),
						ANSIThemeString(" versions is not supported, please perform the following upgrades sequentially:", "default")], stderr = True)
				minor_versions: Dict = {}
				for version in reversed(deb_versions[0][3]):
					version_tuple = version.split(".")
					major_minor = f"{version_tuple[0]}.{version_tuple[1]}"
					if int(version_tuple[1]) > int(installed_version_tuple[1]) and int(version_tuple[1]) <= int(requested_version_tuple[1]) and (major_minor not in minor_versions or minor_versions[major_minor] < version_tuple[2]):
						minor_versions[major_minor] = version_tuple[2].split("-")[0]
				for version, minor_version in minor_versions.items():
					ansithemeprint([ANSIThemeString("• ", "separator"),
							ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
							ANSIThemeString(" upgrade-control-plane", "command"),
							ANSIThemeString(f" {version}.{minor_version}", "version")])
				sys.exit(errno.EINVAL)
			else:
				upgrade_type = "minor"
		else:
			upgrade_type = "patchrev"

		# If this is an upgrade to a new patchrev the cluster does not have to be drained
		if upgrade_type == "minor":
			schedulable_count = 0
			nodes_to_drain = []
			for node in node_status:
				if node["schedulable"] == False:
					continue

				if "control-plane" in node["roles"]:
					continue

				if schedulable_count == 0:
					ansithemeprint([ANSIThemeString("\nError", "error"),
							ANSIThemeString(": The following nodes need to be drained; aborting.", "default")])
				schedulable_count += 1
				ansithemeprint([ANSIThemeString("• ", "separator"),
						ANSIThemeString(f"{node['name']}", "emphasis")])
				nodes_to_drain.append(node['name'])

			if schedulable_count > 0:
				ansithemeprint([ANSIThemeString("\nThis can be achieved with: “", "default"),
						ANSIThemeString("kubectl ", "programname"),
						ANSIThemeString("drain ", "command"),
						ANSIThemeString("--ignore-daemonsets --delete-emptydir-data ", "option"),
						ANSIThemeString(f"{' '.join(nodes_to_drain)}", "url"),
						ANSIThemeString("“", "default")])
				sys.exit(errno.EBUSY)

		requested_major, requested_minor, _rest = requested_version.split(".")

		if int(requested_minor) < 23:
			cluster_configuration_api_version = "kubeadm.k8s.io/v1beta2"
			init_configuration_api_version = "kubeadm.k8s.io/v1beta2"
		else:
			cluster_configuration_api_version = "kubeadm.k8s.io/v1beta3"
			init_configuration_api_version = "kubeadm.k8s.io/v1beta3"

		upgrade_control_plane_targets[k8s_distro]["extra_values"] = {
			"cluster_configuration_api_version": cluster_configuration_api_version,
			"init_configuration_api_version": init_configuration_api_version,
			# Add major/minor to extra_values
			"kubernetes_major_minor_version": f"{requested_major}.{requested_minor}",
		}

		# Adjust package version for localhost
		upgrade_control_plane_targets["localhost"]["deb_packages"].remove("kubectl")
		upgrade_control_plane_targets["localhost"]["deb_packages"].append(f"kubectl={requested_version}")
	elif k8s_distro == "rke2":
		# Add requested_version to extra_values;
		# for rke2 this is either vX.YY or latest
		upgrade_control_plane_targets["rke2"]["extra_values"]["requested_version"] = requested_version

	installation_info = update_installation_info(state = "upgrading", requested_version = requested_version, phase = 0)

	# If we got here all the sanity checks were successful
	ansithemeprint([ANSIThemeString("OK", "ok")])

	show_configuration(action = "Upgrading control plane:", tasks = upgrade_control_plane_tasks)

	if confirm == True:
		retval = ansithemeinput([ANSIThemeString("\nStart upgrade? [y/", "default"),
					 ANSIThemeString("N", "emphasis"),
					 ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting:", "error"),
					ANSIThemeString(" User stopped upgrade.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	ansithemeprint([ANSIThemeString("\n[Upgrading control plane]", "phase")])

	run_tasks(tasks = upgrade_control_plane_tasks, phase = cast(int, phase), phase_skiplist = phase_skiplist, final_state = "upgraded")
	values = {
		"control_plane_k8s_version": requested_version,
	}
	ansible_set_vars(ANSIBLE_INVENTORY, "all", values)
	update_installation_info(version = requested_version)

	ansithemeprint([ANSIThemeString("\nControl plane upgrade successful", "success")])

# pylint: disable-next=unused-argument
def taint_control_plane(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Taint a control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	node_statuses, kh = __get_node_info()

	if node_statuses is None:
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Failed to get node information; do you have a running cluster? Aborting.", "default")], stderr = True)
		sys.exit(errno.ENXIO)

	first = True

	for node in node_statuses:
		if "control-plane" in node["roles"] and (len(args) == 0 or node["name"] in args):
			if first == True:
				ansithemeprint([ANSIThemeString("Tainting control plane(s):", "header")])
				first = False
			ansithemeprint([ANSIThemeString(node["name"], "hostname")])
			_message, status = kh.taint_node(node["name"], node["taints"], ("node-role.kubernetes.io/control-plane", None, None, "NoSchedule"))
			if status == 304:
				ansithemeprint([ANSIThemeString("  Not modified", "none")])
			elif status == 200:
				ansithemeprint([ANSIThemeString("  Tainted", "success")])
			else:
				ansithemeprint([ANSIThemeString("  Failed to modify taint", "error"),
						ANSIThemeString(f"; HTTP error {status}; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

		if "master" in node["roles"] and (len(args) == 0 or node["name"] in args):
			if first == True:
				ansithemeprint([ANSIThemeString("Tainting control plane(s):", "header")])
				first = False
			ansithemeprint([ANSIThemeString(node["name"], "hostname")])
			_message, status = kh.taint_node(node["name"], node["taints"], ("node-role.kubernetes.io/master", None, None, "NoSchedule"))
			if status == 304:
				ansithemeprint([ANSIThemeString("  Not modified", "none")])
			elif status == 200:
				ansithemeprint([ANSIThemeString("  Tainted", "success")])
			else:
				ansithemeprint([ANSIThemeString("  Failed to modify taint", "error"),
						ANSIThemeString(f"; HTTP error {status}; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

	if first == True:
		ansithemeprint([ANSIThemeString("Warning", "warning"),
				ANSIThemeString(": No matching control planes found. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

# pylint: disable-next=unused-argument
def untaint_control_plane(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Untaint a control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	node_statuses, kh = __get_node_info()

	if node_statuses is None:
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Failed to get node information; do you have a running cluster? Aborting.", "default")], stderr = True)
		sys.exit(errno.ENXIO)

	first = True

	for node in node_statuses:
		if "control-plane" in node["roles"] and (len(args) == 0 or node["name"] in args):
			if first == True:
				ansithemeprint([ANSIThemeString("Untainting control plane(s):", "header")])
				first = False
			ansithemeprint([ANSIThemeString(node["name"], "hostname")])
			_message, status = kh.taint_node(node["name"], node["taints"], ("node-role.kubernetes.io/control-plane", None, None, None))
			if status == 304:
				ansithemeprint([ANSIThemeString("  Not modified", "none")])
			elif status == 200:
				ansithemeprint([ANSIThemeString("  Untainted", "success")])
			else:
				ansithemeprint([ANSIThemeString("  Failed to modify taint", "error"),
						ANSIThemeString(f"; HTTP error {status}; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

		if "master" in node["roles"] and (len(args) == 0 or node["name"] in args):
			if first == True:
				ansithemeprint([ANSIThemeString("Untainting control plane(s):", "header")])
				first = False
			ansithemeprint([ANSIThemeString(node["name"], "hostname")])
			_message, status = kh.taint_node(node["name"], node["taints"], ("node-role.kubernetes.io/master", None, None, None))
			if status == 304:
				ansithemeprint([ANSIThemeString("  Not modified", "none")])
			elif status == 200:
				ansithemeprint([ANSIThemeString("  Untainted", "success")])
			else:
				ansithemeprint([ANSIThemeString("  Failed to modify taint", "error"),
						ANSIThemeString(f"; HTTP error {status}; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

	if first == True:
		ansithemeprint([ANSIThemeString("Warning", "warning"),
				ANSIThemeString(": No matching control planes found. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

# pylint: disable=unused-argument,redefined-outer-name
def run_checks(checks: List[Dict], **kwargs) -> bool:
	"""
	Run a batch of checks, and output the result.
	The checks can return 4 different severities; critical, error, warning, and note.

		Parameters:
			checks (list[dict]): A list with all checks to run
		Return:
			clean_run (bool): True if nothing higher than "note" was returned, False otherwise
	"""

	critical: int = 0
	error: int = 0
	warning: int = 0
	note: int = 0
	skip: int = 0

	user = ""
	cluster_name = ""
	kubeconfig: Dict = {}

	for check in checks:
		preconditions = deep_get(check, DictPath("preconditions"), [])
		if "user" in preconditions and len(user) == 0:
			user = getuser()
		if "clusterinfo" in preconditions and len(kubeconfig) == 0:
			if not Path(KUBE_CONFIG_DIR).is_dir():
				ansithemeprint([ANSIThemeString(deep_get(check, DictPath("description"), ""), "phase")])
				ansithemeprint([ANSIThemeString("  Warning:", "warning"),
						ANSIThemeString(f" {KUBE_CONFIG_DIR} ", "path"),
						ANSIThemeString("does not exist; most likely there's no cluster; skipping.\n", "default")], stderr = True)
				skip += 1
				continue
			if not Path(KUBE_CONFIG_FILE).is_file():
				ansithemeprint([ANSIThemeString(deep_get(check, DictPath("description"), ""), "phase")])
				ansithemeprint([ANSIThemeString("  Warning:", "warning"),
						ANSIThemeString(f" {KUBE_CONFIG_FILE} ", "path"),
						ANSIThemeString("does not exist; most likely there's no cluster; skipping.\n", "default")], stderr = True)
				skip += 1
				continue
			kubeconfig = secure_read_yaml(KUBE_CONFIG_FILE)
			cluster_name = cast(str, get_cluster_name())

		call = deep_get(check, DictPath("call"))
		if call is not None:
			critical, error, warning, note = call(cluster_name, kubeconfig, cmtlib.cmtconfig, user, critical, error, warning, note, **kwargs)

	ansithemeprint([ANSIThemeString("Summary:", "header")])
	ansithemeprint([ANSIThemeString("Critical", "critical"),
			ANSIThemeString(f": {critical}", "error")])
	ansithemeprint([ANSIThemeString(f"  Errors: {error}", "error")])
	ansithemeprint([ANSIThemeString(f"Warnings: {warning}", "warning")])
	ansithemeprint([ANSIThemeString(f" Skipped: {skip}", "emphasis")])
	ansithemeprint([ANSIThemeString(f"   Notes: {note}", "note")])

	return critical + error + warning == 0

security_audit_checks = [
	{
		"description": "Check whether strict host key checking has been disabled",
		"call": checks.check_security_disable_strict_host_key_checking,
	},
	{
		"description": "Check for insecure kubeconfig options",
		"call": checks.check_insecure_kube_config_options,
		"preconditions": [
			"clusterinfo",
		],
	}, {
		"description": "Check for insecure file permissions",
		"call": checks.check_file_permissions,
		"preconditions": [
			"user",
		],
	},
]

# pylint: disable-next=unused-argument
def audit(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Run security audit checks

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	usergroup = ""

	for opt, optarg in options:
		if opt == "--usergroup":
			usergroup = optarg

	kwargs = {
		"usergroup": usergroup
	}

	clean_run = run_checks(security_audit_checks, **kwargs)

	if clean_run:
		ansithemeprint([ANSIThemeString("\nImportant", "emphasis"),
				ANSIThemeString(":", "default")])
		ansithemeprint([ANSIThemeString(f"  {about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" audit", "command"),
				ANSIThemeString(" currently only checks for a very limited set of issues;", "default")])
		ansithemeprint([ANSIThemeString("  a perfect score is not a guarantee that your installation is secure.", "default")])
	elif len(usergroup) == 0:
		# Get the username and group for the user;
		# if they match it's highly likely that the system
		# is configured to use usergroups
		uid = os.getuid()
		username = pwd.getpwuid(uid).pw_name
		gid = pwd.getpwuid(uid).pw_gid
		groupname = grp.getgrgid(gid).gr_name

		ansithemeprint([ANSIThemeString("\nNote", "emphasis"),
				ANSIThemeString(":", "default"),
				ANSIThemeString(" the username for the current user “", "default"),
				ANSIThemeString(f"{username}", "argument"),
				ANSIThemeString("“ is the same", "default")])
		ansithemeprint([ANSIThemeString("as its primary group name. This may be an indication ", "default"),
				ANSIThemeString("that the system", "default")])
		ansithemeprint([ANSIThemeString("is configured to use usergroups; if you're seeing warnings related", "default")])
		ansithemeprint([ANSIThemeString("to file permissions this ", "default"),
				ANSIThemeString("might", "emphasis"),
				ANSIThemeString(" be the cause; if you know (or think) that", "default")])
		ansithemeprint([ANSIThemeString("the system is configured with usergroups you can try:\n", "default")])
		ansithemeprint([ANSIThemeString(f"  {about.ADMIN_PROGRAM_NAME} ", "programname"),
				ANSIThemeString("audit ", "command"),
				ANSIThemeString("--usergroup ", "option"),
				ANSIThemeString(f"{username}", "argument")])
		ansithemeprint([ANSIThemeString("\nto see if that resolves the warnings.", "default")])

preflight_checks = [
	{
		"description": "Check whether the user can sudo without a password on localhost",
		"call": checks.check_sudo_configuration,
		"preconditions": [
			"user",
		],
	}, {
		"description": "Check whether SSH known_hosts hashing is enabled on localhost",
		"call": checks.check_known_hosts_hashing,
	}, {
		"description": "Check control plane for suitability",
		"call": checks.check_control_plane,
	}
]

def preflight_check(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Run preflight checks before creating a new cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	global no_password # pylint: disable=global-statement

	for opt, _optarg in options:
		if opt == "--no-password":
			no_password = True

	control_planes = [args[0]]

	ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = control_planes, skip_all = False)

	__task_request_ansible_password(None)

	clean_run = run_checks(preflight_checks, hosts = control_planes)

	if clean_run:
		ansithemeprint([ANSIThemeString("\nImportant", "emphasis"),
				ANSIThemeString(":", "default")])
		ansithemeprint([ANSIThemeString(f"  {about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" preflight-check", "command"),
				ANSIThemeString(" currently only checks for a very limited set of issues;", "default")])
		ansithemeprint([ANSIThemeString("  a perfect score is not a guarantee that installation will succeed.", "default")])

troubleshoot_checks = [
	# First start with the really basic: does the cluster respond?
	# Check no_proxy, perhaps?
	{
		"description": "Check whether client / server versions match",
		"call": checks.check_client_server_version_match,
		"preconditions": [
			"clusterinfo",
		],
	}, {
		"description": "Check kubelet and kube-proxy versions",
		"call": checks.check_kubelet_and_kube_proxy_versions,
		"preconditions": [
			"clusterinfo",
		],
	}, {
		"description": "Check required pods and their statuses",
		"call": checks.check_running_pods,
	},
	# Check kube-controller-manager, kube-scheduler, and cloud-controller-manager;
	# they should match, but can be up to one version older,
	# but must not be newer

	# check whether role bindings and cluster role bindings refer to non-existing roles/cluster roles
]

# pylint: disable-next=unused-argument
def troubleshoot(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Troubleshoot issues in the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	clean_run = run_checks(troubleshoot_checks)

	if clean_run:
		ansithemeprint([ANSIThemeString("\nImportant", "emphasis"),
				ANSIThemeString(":", "default")])
		ansithemeprint([ANSIThemeString(f"  {about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" troubleshoot", "command"),
				ANSIThemeString(" currently only checks for a very limited set of issues;", "default")])
		ansithemeprint([ANSIThemeString("  a perfect score is not a guarantee that your cluster is problem free.", "default")])

COMMANDLINE = {
	"Check Versions": {
		"command": ["check-versions", "cv"],
		"description": [ANSIThemeString("Update the package cache and show software versions", "description")],
		"extended_description": [
			[ANSIThemeString("Note", "note"),
			 ANSIThemeString(": some of the listed software may not be", "description")],
			[ANSIThemeString("relevant to the configuration in use", "description")],
		],
		"options": {
			"--no-cache-update": {
				"description": [ANSIThemeString("Do not update the APT cache", "description")],
			},
		},
		"callback": check_for_updates,
	},
	"Import Cluster": {
		"command": ["import-cluster"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("CLUSTER_NAME", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString(f"Import existing cluster(s) for use with {about.PROGRAM_SUITE_NAME}", "description")],
		"extended_description": [
			[ANSIThemeString("If ", "description"),
			 ANSIThemeString("CLUSTER_NAME", "argument"),
			 ANSIThemeString(",", "separator"),
			 ANSIThemeString("...", "argument"),
			 ANSIThemeString(" is not specified", "description")],
			[ANSIThemeString("all clusters in ", "description"),
			 ANSIThemeString(f"{HOMEDIR}/.kube/config", "path")],
			[ANSIThemeString("will be imported", "description")],
		],
		"options": {
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation", "description")],
			},
			"--no-password": {
				"description": [ANSIThemeString("Do not prompt for a password", "description")],
				"extended_description": [
					[ANSIThemeString("Use this if the hosts you are importing", "description")],
					[ANSIThemeString("are already configured for login using an SSH key", "description")],
				],
			},
		},
		"optional_args": [
			{
				"name": "clustername",
				"string": [ANSIThemeString("CLUSTER_NAME", "argument")],
				"validation": {
					"validator": "hostname",
					"list_separator": ",",
				},
			},
		],
		"callback": import_cluster,
	},
	"Prepare Installation": {
		"command": ["prepare"],
		"values": [ANSIThemeString("CLUSTER_NAME", "argument"),
			   ANSIThemeString(" [[", "separator"),
			   ANSIThemeString("KUBERNETES_DISTRO", "argument"),
			   ANSIThemeString("=]", "separator"),
			   ANSIThemeString("KUBERNETES_VERSION", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Install and configure pre-requisites", "description")],
		"extended_description": [
			[ANSIThemeString("Run this before ", "description"),
			 ANSIThemeString("setup-control-plane", "command"),
			 ANSIThemeString(".", "description")],
			[ANSIThemeString("If ", "description"),
			 ANSIThemeString("KUBERNETES_VERSION", "argument"),
			 ANSIThemeString(" is not specified", "description")],
			[ANSIThemeString("the newest available version will be used.", "description")],
			[ANSIThemeString("Supported versions for ", "description"),
			 ANSIThemeString("KUBERNETES_DISTRO", "argument"),
			 ANSIThemeString(" are:", "description")],
			[ANSIThemeString("kubeadm", "argument"),
			 ANSIThemeString(" (default on ", "description"),
			 ANSIThemeString("Debian", "programname"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("Ubuntu", "programname"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("Red Hat", "programname"),
			 ANSIThemeString(")", "description")],
			[ANSIThemeString("rke2", "argument"),
			 ANSIThemeString(" (default on ", "description"),
			 ANSIThemeString("SUSE", "programname"),
			 ANSIThemeString(")", "description")],
			[ANSIThemeString("Note", "note"),
			 ANSIThemeString(": currently ", "description"),
			 ANSIThemeString("rke2", "argument"),
			 ANSIThemeString(" is the only supported", "description")],
			[ANSIThemeString("option on ", "description"),
			 ANSIThemeString("SUSE", "programname")],
		],
		"options": {
			"--control-plane": {
				"values": [ANSIThemeString("HOST", "argument")],
				"extended_description": [
					[ANSIThemeString("Note", "note"),
					 ANSIThemeString(": if possible ", "description"),
					 ANSIThemeString("HOST", "argument"),
					 ANSIThemeString(" should be a resolvable", "description")],
					[ANSIThemeString("hostname; using an IP-address may cause issues", "description")],
				],
				"description": [ANSIThemeString("Use ", "description"),
						ANSIThemeString("HOST", "argument"),
						ANSIThemeString(" as control plane ", "description")],
				"requires_arg": True,
				"validation": {
					"validator": "hostname_or_ip",
				},
			},
			"--resume": {
				"description": [ANSIThemeString("Resume preparation", "description")],
				"extended_description": [
					[ANSIThemeString("This can be used to resume operations", "description")],
					[ANSIThemeString("if preparation was aborted", "description")],
				],
			},
			"--start-at-task": {
				"values": [ANSIThemeString("TASK", "argument")],
				"description": [ANSIThemeString("Start at ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" instead of running all tasks", "description")],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (0, None),
				},
			},
			"--skip-tasks": {
				"values": [ANSIThemeString("TASK", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Skip ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(",", "separator"),
						ANSIThemeString("...", "argument")],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (0, None),
					"list_separator": ",",
				},
			},
			"--list-tasks": {
				"description": [ANSIThemeString("List valid values for ", "description"),
						ANSIThemeString("TASK", "argument")],
				"extended_description": [
					       [ANSIThemeString("List valid values to use with ", "description"),
						ANSIThemeString("--start-at-task", "option")],
					       [ANSIThemeString("and ", "description"),
						ANSIThemeString("--skip-tasks", "option")],
				],
			},
			"--no-password": {
				"description": [ANSIThemeString("Do not prompt for a password", "description")],
				"extended_description": [
					[ANSIThemeString("Use this if the hosts you are preparing", "description")],
					[ANSIThemeString("are already configured for login using an SSH key", "description")],
				],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs", "description")],
				"extended_description": [
					       [ANSIThemeString("The logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
				],
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation", "description")],
			},
		},
		"required_args": [
			{
				"name": "clustername",
				"string": [ANSIThemeString("CLUSTER_NAME", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z_][a-z0-9_]*$",
				},
			},
		],
		"optional_args": [
			{
				"name": "version",
				"string": [ANSIThemeString("KUBERNETES_VERSION", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^(kubeadm=|rke2=v?|)\d+\.\d+(\.\d+-\d+|\.\d+|)$"
				},
			},
		],
		"callback": prepare_installation,
	},
	"Setup Control Plane": {
		"command": ["setup-control-plane"],
		"values": [
			ANSIThemeString("[", "separator"),
			ANSIThemeString("CNI", "argument"),
			ANSIThemeString("]", "separator"),
			ANSIThemeString(" [", "separator"),
			ANSIThemeString("POD_NETWORK_CIDR", "argument"),
			ANSIThemeString("]", "separator"),
		],
		"description": [ANSIThemeString("Setup and launch the control plane", "description")],
		"extended_description": [
			[ANSIThemeString("Valid options for CNI", "description")],
			[ANSIThemeString("(Container Network Interface, aka Pod Network): ", "description")],
			[ANSIThemeString("antrea", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("calico", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("canal", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("cilium", "argument"),
			 ANSIThemeString(",", "separator")],
			[ANSIThemeString("flannel", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("kube-router", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("weave", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("none", "argument")],
			[ANSIThemeString("By default ", "description"),
			 ANSIThemeString("cilium", "argument"),
			 ANSIThemeString(" will be used as CNI", "description")],
			[ANSIThemeString("and ", "description"),
			 ANSIThemeString("10.244.0.0/16", "argument"),
			 ANSIThemeString(" will be used as pod network CIDR.", "description")],
			[ANSIThemeString("If you wish to postpone the choice of CNI", "description")],
			[ANSIThemeString("you can specify ", "description"),
			 ANSIThemeString("none", "argument")],
		],
		"options": {
			"--resume": {
				"description": [ANSIThemeString("Resume setup", "description")],
				"extended_description": [
					[ANSIThemeString("This can be used to resume operations", "description")],
					[ANSIThemeString("if control plane setup was aborted", "description")],
				],
			},
			"--start-at-task": {
				"values": [ANSIThemeString("TASK", "argument")],
				"description": [ANSIThemeString("Start at ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" instead of running all tasks", "description")],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (0, None),
				},
			},
			"--skip-tasks": {
				"values": [ANSIThemeString("TASK", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Skip ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(",", "separator"),
						ANSIThemeString("...", "argument")],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (0, None),
					"list_separator": ",",
				},
			},
			"--list-tasks": {
				"description": [ANSIThemeString("List valid values for ", "description"),
						ANSIThemeString("TASK", "argument")],
				"extended_description": [
					       [ANSIThemeString("List valid values to use with ", "description"),
						ANSIThemeString("--start-at-task", "option")],
					       [ANSIThemeString("and ", "description"),
						ANSIThemeString("--skip-tasks", "option")],
				],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs", "description")],
				"extended_description": [
					       [ANSIThemeString("The logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
				],
			},
			"--cri": {
				"values": [ANSIThemeString("CRI", "argument")],
				"description": [ANSIThemeString("Use ", "description"),
						ANSIThemeString("CRI", "argument"),
						ANSIThemeString(" instead of the default CRI", "description")],
				"extended_description": [
					[ANSIThemeString("Valid options for CRI", "description")],
					[ANSIThemeString("(Container Runtime Interface) are:", "description")],
					[ANSIThemeString("docker-shim", "argument"),
					 ANSIThemeString(" (", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" < ", "description"),
					 ANSIThemeString("1.24", "version"),
					 ANSIThemeString(")", "description"),
					 ANSIThemeString(", ", "separator")],
					[ANSIThemeString("containerd", "argument"),
					 ANSIThemeString(", ", "separator"),
					 ANSIThemeString("cri-o", "argument"),
					],
					[ANSIThemeString("Default CRI:", "description")],
					[ANSIThemeString("containerd", "argument"),
					 ANSIThemeString(" (", "description"),
					 ANSIThemeString("rke2", "argument"),
					 ANSIThemeString("), ", "description")],
					[ANSIThemeString("docker-shim", "argument"),
					 ANSIThemeString(" (", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" < ", "description"),
					 ANSIThemeString("1.24", "version"),
					 ANSIThemeString(")", "description"),
					 ANSIThemeString(", ", "separator")],
					[ANSIThemeString("containerd", "argument"),
					 ANSIThemeString(" (", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.24", "version"),
					 ANSIThemeString(")", "description"),
					 ANSIThemeString(", ", "separator")],
					[ANSIThemeString("cri-o", "argument"),
					 ANSIThemeString(" (", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.24", "version"),
					 ANSIThemeString(" with ", "description"),
					 ANSIThemeString("--enable-dra", "option"),
					 ANSIThemeString(")", "description")],
					[ANSIThemeString("Note", "note"),
					 ANSIThemeString(": ", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.26", "version"),
					 ANSIThemeString(" requires", "description")],
					[ANSIThemeString("containerd", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.6", "version"),
					 ANSIThemeString(" or ", "description"),
					 ANSIThemeString("cri-o", "programname")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": ["containerd", "cri-o", "docker-shim"],
				},
			},
			"--enable-dra": {
				"description": [ANSIThemeString("Enable DRA", "description")],
				"extended_description": [
					[ANSIThemeString("Enables the feature gates necessary to use", "description")],
					[ANSIThemeString("Dynamic Resource Allocation (DRA).", "description")],
					[ANSIThemeString("Currently only ", "description"),
					 ANSIThemeString("cri-o", "argument"),
					 ANSIThemeString(" supports DRA", "description")],
				],
			},
			"--override-cni": {
				"description": [ANSIThemeString("Override CNI", "description")],
				"extended_description": [
					[ANSIThemeString("Allow a change of CNI even if installation", "description")],
					[ANSIThemeString("started with a different CNI", "description")],
				],
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation", "description")],
			},
		},
		"optional_args": [
			{
				"name": "cni",
				"string": [ANSIThemeString("CNI", "argument")],
				"validation": {
					"validator": "allowlist",
					"allowlist": ["antrea", "calico", "canal", "cilium", "flannel", "kube-router", "weave", "none"],
				},
			},
			{
				"name": "pod_network_cidr",
				"string": [ANSIThemeString("POD_NETWORK_CIDR", "argument")],
				"validation": {
					"validator": "cidr",
				},
			},
		],
		"callback": setup_control_plane,
	},
	"Setup CNI": {
		"command": ["setup-cni"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("CNI", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Install and configure CNI", "description")],
		"extended_description": [
			[ANSIThemeString("Valid options for CNI", "description")],
			[ANSIThemeString("(Container Network Interface, aka Pod Network): ", "description")],
			[ANSIThemeString("antrea", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("calico", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("canal", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("cilium", "argument"),
			 ANSIThemeString(", ", "separator")],
			[ANSIThemeString("flannel", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("kube-router", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("weave", "argument"),
			],
			[ANSIThemeString("By default ", "description"),
			 ANSIThemeString("cilium", "argument"),
			 ANSIThemeString(" will be used as CNI", "description")],
		],
		"options": {
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation", "description")],
			},
		},
		"optional_args": [
			{
				"name": "cni",
				"string": [ANSIThemeString("CNI", "argument")],
				"validation": {
					"validator": "allowlist",
					"allowlist": ["antrea", "calico", "canal", "cilium", "flannel", "kube-router", "weave"],
				},
				"default": DEFAULT_CNI,
			},
		],
		"callback": setup_cni,
	},
	"Uninstall CNI": {
		"command": ["uninstall-cni"],
		"description": [ANSIThemeString("Uninstall the CNI", "description")],
		"extended_description": [
			[ANSIThemeString("This should be used in case", "description")],
			[ANSIThemeString("you want to switch to another CNI", "description")],
		],
		"options": {
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation", "description")],
			},
		},
		"callback": teardown_cni,
	},
	"Upgrade CNI": {
		"command": ["upgrade-cni"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("CNI", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Upgrade the CNI", "description")],
		"extended_description": [
			[ANSIThemeString("Currently only ", "description"),
			 ANSIThemeString("calico", "argument"),
			 ANSIThemeString(" and ", "description"),
			 ANSIThemeString("cilium", "argument"),
			 ANSIThemeString(" are supported", "description")],
		],
		"optional_args": [
			{
				"name": "cni",
				"string": [ANSIThemeString("CNI", "argument")],
				"validation": {
					"validator": "allowlist",
					"allowlist": ["calico", "cilium"],
				},
			},
		],
		"callback": upgrade_cni,
	},
	"Upgrade Control Plane": {
		"command": ["upgrade-control-plane"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("KUBERNETES_VERSION", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Upgrade the control plane", "description")],
		"extended_description": [
			[ANSIThemeString("If ", "description"),
			 ANSIThemeString("KUBERNETES_VERSION", "argument"),
			 ANSIThemeString(" is not specified", "description")],
			[ANSIThemeString("the newest available version will be used.", "description")],
			[ANSIThemeString("Upgrading requires all nodes to be drained first.", "description")],
			[ANSIThemeString("Once the control plane has been uppgraded you ", "description"),
			 ANSIThemeString("must", "emphasis")],
			[ANSIThemeString("upgrade all nodes to the same version.", "description")],
			[ANSIThemeString("Important", "emphasis"),
			 ANSIThemeString(": skipping PATCH REVISIONS is acceptable,", "description")],
			[ANSIThemeString("but when upgrading to a newer MINOR version", "description")],
			[ANSIThemeString("all intermediate MINOR versions must be", "description")],
			[ANSIThemeString("installed first; this applies to nodes too.", "description")],
		],
		"options": {
			"--no-cache-update": {
				"description": [ANSIThemeString("Do not update the APT cache", "description")],
			},
			"--resume": {
				"description": [ANSIThemeString("Resume upgrade", "description")],
				"extended_description": [
					[ANSIThemeString("This can be used to resume operations", "description")],
					[ANSIThemeString("if upgrade was aborted", "description")],
				],
			},
			"--start-at-task": {
				"values": [ANSIThemeString("TASK", "argument")],
				"description": [ANSIThemeString("Start at ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" instead of running all tasks", "description")],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (0, None),
				},
			},
			"--skip-tasks": {
				"values": [ANSIThemeString("TASK", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Skip ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(",", "separator"),
						ANSIThemeString("...", "argument")],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (0, None),
					"list_separator": ",",
				},
			},
			"--list-tasks": {
				"description": [ANSIThemeString("List valid values for ", "description"),
						ANSIThemeString("TASK", "argument")],
				"extended_description": [
					       [ANSIThemeString("List valid values to use with ", "description"),
						ANSIThemeString("--start-at-task", "option")],
					       [ANSIThemeString("and ", "description"),
						ANSIThemeString("--skip-tasks", "option")],
				],
			},
			"--reinstall": {
				"description": [ANSIThemeString("Allow installing the same version", "description")],
				"extended_description": [
					       [ANSIThemeString("This option allows you to install the same", "description")],
					       [ANSIThemeString("version that's already running in the cluster", "description")],
				],
			},
			"--override": {
				"description": [ANSIThemeString("Override/rebuild installation info", "description")],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs", "description")],
				"extended_description": [
					       [ANSIThemeString("The logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
				],
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation", "description")],
			},
		},
		"optional_args": [
			{
				"name": "version",
				"string": [ANSIThemeString("KUBERNETES_VERSION", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^\d+\.\d+(\.\d+-\d+|\.\d+|)$"
				},
			},
		],
		"callback": upgrade_control_plane,
	},
	"Teardown Control Plane": {
		"command": ["teardown-control-plane"],
		"description": [ANSIThemeString("Tear down the control plane", "description")],
		"extended_description": [
			[ANSIThemeString("Note", "emphasis"),
			 ANSIThemeString(": Before running this command all nodes", "description")],
			[ANSIThemeString("must have been removed first.", "description")],
			[ANSIThemeString("The configuration for the control plane", "description")],
			[ANSIThemeString("and any software installed during setup", "description")],
			[ANSIThemeString("will NOT be removed", "description")],

		],
		"options": {
			"--resume": {
				"description": [ANSIThemeString("Resume teardown", "description")],
				"extended_description": [
					[ANSIThemeString("This can be used to resume operations", "description")],
					[ANSIThemeString("if teardown was aborted", "description")],
				],
			},
			"--start-at-task": {
				"values": [ANSIThemeString("TASK", "argument")],
				"description": [ANSIThemeString("Start at ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" instead of running all tasks", "description")],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (0, None),
				},
			},
			"--skip-tasks": {
				"values": [ANSIThemeString("TASK", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Skip ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(",", "separator"),
						ANSIThemeString("...", "argument")],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (0, None),
					"list_separator": ",",
				},
			},
			"--list-tasks": {
				"description": [ANSIThemeString("List valid values for ", "description"),
						ANSIThemeString("TASK", "argument")],
				"extended_description": [
					       [ANSIThemeString("List valid values to use with ", "description"),
						ANSIThemeString("--start-at-task", "option")],
					       [ANSIThemeString("and ", "description"),
						ANSIThemeString("--skip-tasks", "option")],
				],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs", "description")],
				"extended_description": [
					       [ANSIThemeString("The logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
				],
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation", "description")],
			},
		},
		"callback": teardown_control_plane,
	},
	"Purge Control Plane": {
		"command": ["purge-control-plane"],
		"description": [ANSIThemeString("Purge configuration and packages", "description")],
		"extended_description": [
			[ANSIThemeString("Software and configuration needed", "description")],
			[ANSIThemeString("for ", "description"),
			 ANSIThemeString(f"{about.PROGRAM_SUITE_NAME}", "programname"),
			 ANSIThemeString(" itself will not be purged", "description")],
		],
		"options": {
			"--resume": {
				"description": [ANSIThemeString("Resume purge; can be used if purge was aborted", "description")],
			},
			"--start-at-task": {
				"values": [ANSIThemeString("TASK", "argument")],
				"description": [ANSIThemeString("Start at ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" instead of running all tasks", "description")],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (0, None),
				},
			},
			"--skip-tasks": {
				"values": [ANSIThemeString("TASK", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Skip ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(",", "separator"),
						ANSIThemeString("...", "argument")],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (0, None),
					"list_separator": ",",
				},
			},
			"--list-tasks": {
				"description": [ANSIThemeString("List valid values for ", "description"),
						ANSIThemeString("TASK", "argument")],
				"extended_description": [
					       [ANSIThemeString("List valid values to use with ", "description"),
						ANSIThemeString("--start-at-task", "option")],
					       [ANSIThemeString("and ", "description"),
						ANSIThemeString("--skip-tasks", "option")],
				],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs", "description")],
				"extended_description": [
					       [ANSIThemeString("The logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
				],
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation", "description")],
			},
		},
		"callback": purge_control_plane,
	},
	"Taint Control Plane": {
		"command": ["taint-control-plane"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("CONTROLPLANE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Mark control plane(s) as tainted", "description")],
		"extended_description": [
			[ANSIThemeString("If you have previously marked your control plane(s)", "description")],
			[ANSIThemeString("as untainted you can mark them as tainted", "description")],
			[ANSIThemeString("using this command.", "description")],
			[ANSIThemeString("If ", "description"),
			 ANSIThemeString("CONTROLPLANE", "argument"),
			 ANSIThemeString(",", "separator"),
			 ANSIThemeString("...", "argument"),
			 ANSIThemeString(" is not specified", "description")],
			[ANSIThemeString("all control planes will be tainted", "description")],
		],
		"optional_args": [
			{
				"name": "controlplane",
				"string": [ANSIThemeString("CONTROLPLANE", "argument")],
				"validation": {
					"validator": "hostname_or_ip",
					"list_separator": ",",
				},
			},
		],
		"callback": taint_control_plane,
	},
	"Untaint Control Plane": {
		"command": ["untaint-control-plane"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("CONTROLPLANE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Mark control plane(s) as untainted", "description")],
		"extended_description": [
			[ANSIThemeString("By default control planes are marked as tainted;", "description")],
			[ANSIThemeString("workloads that lack tolerations will not be", "description")],
			[ANSIThemeString("scheduled to control planes. If you are running", "description")],
			[ANSIThemeString("a single-node cluster, or if the control plane", "description")],
			[ANSIThemeString("is very powerful it might be useful to permit", "description")],
			[ANSIThemeString("workloads on control plane(s) too.", "description")],
			[ANSIThemeString("If ", "description"),
			 ANSIThemeString("CONTROLPLANE", "argument"),
			 ANSIThemeString(",", "separator"),
			 ANSIThemeString("...", "argument"),
			 ANSIThemeString(" is not specified", "description")],
			[ANSIThemeString("all control planes will be untainted", "description")],

		],
		"optional_args": [
			{
				"name": "controlplane",
				"string": [ANSIThemeString("CONTROLPLANE", "argument")],
				"validation": {
					"validator": "hostname_or_ip",
					"list_separator": ",",
				},
			},
		],
		"callback": untaint_control_plane,
	},
	"Audit": {
		"command": ["audit"],
		"description": [ANSIThemeString("Search for potential security issues in the cluster", "description")],
		"extended_description": [
			[ANSIThemeString("Note", "emphasis"),
			 ANSIThemeString(": If the system is configured", "description")],
			[ANSIThemeString("to use ", "description"),
			 ANSIThemeString("usergroups", "emphasis"),
			 ANSIThemeString(" (every user have their own group", "description")],
			[ANSIThemeString("that only they belong to), be sure to specify", "description")],
			[ANSIThemeString("that group using the ", "description"),
			 ANSIThemeString("--usergroup ", "option"),
			 ANSIThemeString("USERGROUP", "argument"),
			 ANSIThemeString(" option,", "description")],
			[ANSIThemeString("to prevent the permission checker", "description")],
			[ANSIThemeString("from complaining about insecure permissions", "description")],
		],
		"options": {
			"--usergroup": {
				"values": [ANSIThemeString("USERGROUP", "argument")],
				"description": [ANSIThemeString("The usergroup", "description")],
				"requires_arg": True,
				"validation": {
					"validator": "regex",
					# regex taken from debian; other distros might be stricter or possible more permissive
					"regex": r"^[a-z_][a-z0-9_-]*[$]?$",
				},
			},
		},
		"callback": audit,
	},
	"Preflight Check": {
		"command": ["preflight-check"],
		"values": [ANSIThemeString("CONTROLPLANE", "argument")],
		"description": [ANSIThemeString("Preflight check", "description")],
		"extended_description": [
			[ANSIThemeString("Check for potential pitfalls that may prevent", "description")],
			[ANSIThemeString("preparation or setup from succeeding", "description")],
		],
		"options": {
			"--no-password": {
				"description": [ANSIThemeString("Do not prompt for a password", "description")],
				"extended_description": [
					[ANSIThemeString("Use this if the hosts you are preparing", "description")],
					[ANSIThemeString("are already configured for login using an SSH key", "description")],
				],
			},
		},
		"required_args": [
			{
				"name": "controlplane",
				"string": [ANSIThemeString("CONTROLPLANE", "argument")],
				"validation": {
					"validator": "hostname_or_ip",
				},
			},
		],
		"callback": preflight_check,
	},
	"Troubleshoot": {
		"command": ["troubleshoot"],
		"description": [ANSIThemeString("Search for potential problems in the cluster", "description")],
		"callback": troubleshoot,
	},
	"spacer1": {
		"command": [""],
		"description": [ANSIThemeString("", "description")],
	},
}

def main() -> None:
	"""
	Main function for the program
	"""

	# Before doing anything else, make sure that the user is not running as root
	if os.geteuid() == 0:
		sys.exit("CRITICAL: This program should not be run as the root user; aborting.")

	# Then initialise the configuration file
	read_cmtconfig()

	command, options, args = parse_commandline(about.ADMIN_PROGRAM_NAME, about.ADMIN_PROGRAM_VERSION, PROGRAMDESCRIPTION, PROGRAMAUTHORS, sys.argv,
						   COMMANDLINE, theme = DEFAULT_THEME_FILE)

	# Used by the ansible module
	ansible_configuration["ansible_forks"] = deep_get(cmtlib.cmtconfig, DictPath("Ansible#forks"), 10)
	ansible_user = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_user"))
	if ansible_user is None or len(ansible_user) == 0:
		ansible_user = getuser()
	ansible_configuration["ansible_user"] = ansible_user
	ansible_password = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_password"))
	if ansible_password is not None and len(ansible_password) > 0:
		ansible_configuration["ansible_password"] = ansible_password
	ansible_configuration["disable_strict_host_key_checking"] = deep_get(cmtlib.cmtconfig, DictPath("Nodes#disablestricthostkeychecking"), False)
	ansible_configuration["save_logs"] = deep_get(cmtlib.cmtconfig, DictPath("Ansible#save_logs"), False)

	return command(options, args)

if __name__ == "__main__":
	main()
