#! /usr/bin/env python3
# Requires: python3 (>= 3.6)
# Requires: python3-natsort
# Requires: python3-openssl
# Requires: python3-paramiko

# pylint: disable=line-too-long

"""
This program is used to install, upgrade and uninstall control planes for Kubernetes clusters,
and to perform various other administrative tasks

For usage, see:
	iktadm help
"""

import errno
from getpass import getuser
from glob import glob
import os
from pathlib import Path, PurePath
import re
import shutil
import socket
import subprocess
import sys
import tempfile
from typing import Callable, cast, Dict, List, Optional, Set, Tuple, Union

try:
	from natsort import natsorted
except ModuleNotFoundError:
	sys.exit("ModuleNotFoundError: You probably need to install python3-natsort; did you forget to run ikt-install?")

from ikttypes import ANSIThemeString, deep_get, DictPath, FilePath, FilePathAuditError, SecurityChecks, SecurityPolicy, SecurityStatus
from iktpaths import BASH_COMPLETION_BASE_DIR, BASH_COMPLETION_DIR, BINDIR, HOMEDIR, SSH_DIR, SSH_KEYGEN_BIN_PATH, SSH_KEYGEN_ARGS
from iktpaths import DEPLOYMENT_DIR, IKT_HOOKS_DIR
from iktpaths import ANSIBLE_PLAYBOOK_DIR, ANSIBLE_INVENTORY
from iktpaths import DEFAULT_THEME_FILE, IKT_CONFIG_FILE, IKT_INSTALLATION_INFO_FILE, KUBE_CONFIG_DIR, KUBE_CONFIG_FILE

from commandparser import parse_commandline

from ansible_helper import ansible_configuration, ansible_get_inventory_dict, ansible_set_vars
from ansible_helper import ansible_run_playbook_on_selection, ansible_add_hosts, ansible_print_play_results, populate_playbooks_from_paths

import iktio
from iktio import check_path, execute_command, execute_command_with_response, secure_mkdir
from iktio import secure_read_string, secure_rm, secure_which, secure_write_string
from iktio_yaml import secure_read_yaml, secure_write_yaml
from networkio import download_files, scan_and_add_ssh_keys

import iktlib
from iktlib import check_deb_versions, read_iktconfig

import kubernetes_helper

from iktprint import iktinput, iktinput_password, iktprint

import checks

import about
PROGRAMDESCRIPTION = "Setup or teardown a Kubernetes cluster"
PROGRAMAUTHORS = "Written by David Weinehall."

DEFAULT_CNI = "cilium"
DEFAULT_POD_NETWORK_CIDR = "10.244.0.0/16"

no_password = False

prepare_targets: Dict = {
	"kubeadm": {
		"pretty_name": [("kubeadm", "programname"), (" (default)", "default")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_passwordless_ansible.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("install_packages.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_control_plane.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("add_kubernetes_repo.yaml"))),
		],
		"deb_packages": [
			"docker.io",
		],
	},
	"localhost": {
		"pretty_name": [("host system", "programname")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_passwordless_ansible.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("add_kubernetes_repo.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("install_packages.yaml"))),
		],
		"deb_packages": [
			"ansible",
			# If available
			# "ansible-mitogen",
		],
	},
}

setup_control_plane_targets: Dict = {
	"kubeadm": {
		"pretty_name": [("kubeadm", "programname"), (" (default)", "default")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("install_packages.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_setup_control_plane.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("fetch_kube_config.yaml"))),
		],
		"deb_packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
			"kubernetes-cni",
		],
		"deb_packages_held": [
			"kubeadm",
			"kubectl",
			"kubelet",
		],
	},
	"localhost": {
		"pretty_name": [("host system", "programname")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("install_packages.yaml"))),
		],
		"deb_packages": [
			"kubectl",
		],
		"deb_packages_held": [
			"kubectl",
		],
	},
}

upgrade_control_plane_targets: Dict = {
	"kubeadm": {
		"pretty_name": [("kubeadm", "programname"), (" (default)", "default")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_upgrade_control_plane.yaml"))),
		],
	},
	"localhost": {
		"pretty_name": [("host system", "programname")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("install_packages.yaml"))),
		],
		"deb_packages": [
			"kubectl",
		],
		"deb_packages_held": [
			"kubectl",
		],
	},
}

teardown_control_plane_targets: Dict = {
	"kubeadm": {
		"pretty_name": [("kubeadm", "programname"), (" (default)", "default")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("teardown_cni.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_teardown_control_plane.yaml"))),
		],
	},
}

purge_control_plane_targets: Dict = {
	"kubeadm": {
		"pretty_name": [("kubeadm", "programname"), (" (default)", "default")],
		"playbooks": [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_purge.yaml"))),
		],
		"deb_packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
			"kubernetes-cni",
		],
		"deb_packages_held": [
			"kubeadm",
			"kubectl",
			"kubelet",
		],
	},
}

def rebuild_installation_info(state: Optional[str] = None) -> None:
	"""
	If the installation info file does not exist, but a cluster already exists and is part of the inventory,
	this function will try to rebuild the installation info file

		Parameters:
			state (str): The installation state
	"""

	cluster_name = None
	distro = None
	version = None

	controlplanes = __selection_control_planes()
	if controlplanes is None or len(controlplanes) == 0:
		iktprint([ANSIThemeString("", "default")])
		iktprint([ANSIThemeString("Critical", "critical"),
			  ANSIThemeString(": No control plane defined in inventory; cannot rebuild installation info. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	deb_versions = check_deb_versions(["kubeadm"])
	if len(deb_versions) == 0 or deb_versions[0][1] == "<none>":
		iktprint([ANSIThemeString("", "default")])
		iktprint([ANSIThemeString("Critical", "critical"),
			  ANSIThemeString(": Failed to get kubeadm version; are you sure there's a kubeadm-based cluster installed? Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)
	else:
		version = deb_versions[0][1]
		distro = "kubeadm"

	cluster_name = get_cluster_name()
	update_installation_info(cluster_name = cluster_name, distro = distro, version = version, requested_version = "<none>",
				 state = state, phase = "<none>", phase_skiplist = [], cni = "<FIXME>", pod_network_cidr = "<FIXME>")

def get_installation_info(cluster_name: Optional[str] = None) -> Dict:
	"""
	Return installation info for a cluster, or prepares a new entry if no entry exists yet

		Parameters:
			cluster_name (str): The name of the cluster to get information for
		Returns:
			info (dict): A dictionary with information about a cluster
	"""

	info = None

	# We are OK with the file not existing
	checks = [
		SecurityChecks.PARENT_RESOLVES_TO_SELF,
		SecurityChecks.OWNER_IN_ALLOWLIST,
		SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
		SecurityChecks.PERMISSIONS,
		SecurityChecks.PARENT_PERMISSIONS,
		SecurityChecks.IS_FILE,
	]

	try:
		info = secure_read_yaml(IKT_INSTALLATION_INFO_FILE, checks = checks)
	except FileNotFoundError:
		pass

	if info is None or info.get("installation_target") is None or (info.get("installation_target") is not None and cluster_name is not None and cluster_name not in info):
		if info is None:
			info = {}
		info["installation_target"] = cluster_name
		info[cluster_name] = {
			"distro": "<none>",
			"version": "<none>",
			"requested_version": "<none>",
			"state": "<none>",
			"phase": "<none>",
			"phase_skiplist": [],
			"cni": "<none>",
			"pod_network_cidr": "<none>",
			"cri": "<none>",
		}
	elif info.get("installation_target") is None and cluster_name is not None:
		# Old format file; transition it
		tmpinfo = info.copy()
		tmpinfo.pop("cluster_name")
		info = {}
		info["installation_target"] = cluster_name
		info[cluster_name] = tmpinfo

	return info

# pylint: disable-next=too-many-arguments
def update_installation_info(cluster_name: Optional[str] = None, distro: Optional[str] = None, version: Optional[str] = None, requested_version: Optional[str] = None,
			     state: Optional[str] = None, phase: Optional[Union[int, str]] = None, phase_skiplist: Optional[List[str]] = None,
			     cni: Optional[str] = None, pod_network_cidr: Optional[str] = None, cri: Optional[str] = None) -> Dict:
	"""
	Update installation info for a cluster

		Parameters:
			cluster_name (str): The name of the cluster to update information for
			distro (str): The distribution used during installation (currently the only supported distro is kubeadm)
			version (str): The current version of Kubernetes
			requested_version (str): The requested version of Kubernetes
			state (str): The installation state
			phase (str): The installation phase
			phase_skiplist (list[str]): A list of phases to skip
			cni (str): The CNI to use
			pod_network_cidr (str): The CIDR to use for the pod network
			cri (str): The CRI to use
		Returns:
			info (dict): The updated installation info
	"""

	info = get_installation_info(cluster_name = cluster_name)

	if cluster_name is None:
		cluster_name = info.get("installation_target")

	if info.get("installation_target") is None:
		info["installation_target"] = cluster_name

	if distro is not None:
		info[cluster_name]["distro"] = distro
	if version is not None:
		info[cluster_name]["version"] = version
	if requested_version is not None:
		info[cluster_name]["requested_version"] = requested_version
	if state is not None:
		info[cluster_name]["state"] = state
	if phase is not None:
		info[cluster_name]["phase"] = phase
	if phase_skiplist is not None:
		info[cluster_name]["phase_skiplist"] = phase_skiplist
	if cni is not None:
		info[cluster_name]["cni"] = cni
	if pod_network_cidr is not None:
		info[cluster_name]["pod_network_cidr"] = pod_network_cidr
	if cri is not None:
		info[cluster_name]["cri"] = cri

	secure_write_yaml(IKT_INSTALLATION_INFO_FILE, info, sort_keys = False)

	return info

def check_and_print_status(retval: bool) -> None:
	"""
	A wrapper that prints OK if retval is True
	and NOT OK and aborts if retval is False
		Parameters:
			retval (bool): True on success, False on failure
	"""

	if retval == True:
		iktprint([ANSIThemeString("OK", "ok")])
	else:
		iktprint([ANSIThemeString("NOT OK", "notok"),
			  ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

def patch_cni_flannel(cni_path: FilePath, pod_network_cidr: str) -> None:
	"""
	Patch the configuration for Flannel

		Parameters:
			cni_path (FilePath): The path to the CNI configuration to patch
			pod_network_cidr (str): The CIDR for the pod network
	"""

	violations = check_path(cni_path)
	if violations != [SecurityStatus.OK]:
		violation_strings = []
		for violation in violations:
			violation_strings.append(str(violation))
		violations_joined = ",".join(violation_strings)
		raise FilePathAuditError(f"Violated rules: {violations_joined}", path = cni_path)

	# Ideally we should patch this using a round-trip capable YAML parser,
	# such as ruamel
	sedstr = fr's#^\(.*"\)Network": "10.244.0.0/16",$#\1Network:": "{pod_network_cidr}",#'
	args = ["/usr/bin/sed", "-i", "-e", sedstr, cni_path]
	check_and_print_status(execute_command(args))

def patch_cni_calico(cni_path: FilePath, pod_network_cidr: str) -> None:
	"""
	Patch the configuration for Calico

		Parameters:
			cni_path (FilePath): The path to the CNI configuration to patch
			pod_network_cidr (str): The CIDR for the pod network
	"""

	violations = check_path(cni_path)
	if violations != [SecurityStatus.OK]:
		violation_strings = []
		for violation in violations:
			violation_strings.append(str(violation))
		violations_joined = ",".join(violation_strings)
		raise FilePathAuditError(f"Violated rules: {violations_joined}", path = cni_path)

	# Ideally we should patch this using a round-trip capable YAML parser,
	# such as ruamel
	sedstr = fr's#cidr: 192.168.0.0/16$#cidr: {pod_network_cidr}#'
	args = ["/usr/bin/sed", "-i", "-e", sedstr, cni_path]
	check_and_print_status(execute_command(args))

# XXX: We should convert all of cni_data to use this format instead,
#      and move all of this code to a separate file to allow it to be used both from iku and iktadm
cni_upgrade_data = {
	"calico": {
		"executable": {
			"version_command": ["kubectl", "calico", "version"],
			# Safe
			"version_regex": r"^Client Version:\s+(v)(\d+)(\.)(\d+)(\.)(\d+)$",
			"urls": [
				{
					"url": "https://github.com/projectcalico/calico/releases/download/v3.24.4/calicoctl-linux-<<<arch>>>",
					"checksum_url": "https://github.com/projectcalico/calico/releases/download/v3.24.4/SHA256SUMS",
					"checksum_type": "sha256",
					"filename": "kubectl-calico",
				}
			]
		},
		"CNI": {
			"urls": [
				{
					# "url": "https://raw.githubusercontent.com/projectcalico/calico/<<<version>>>/manifests/tigera-operator.yaml",
					"url": "https://raw.githubusercontent.com/projectcalico/calico/v3.24.4/manifests/tigera-operator.yaml",
					# "filename": "tigera-operator-<<<version>>>.yaml",
					"filename": "tigera-operator-v3.24.4.yaml",
				}, {
					# "url": "https://raw.githubusercontent.com/projectcalico/calico/<<<version>>>/manifests/custom-resources.yaml",
					"url": "https://raw.githubusercontent.com/projectcalico/calico/v3.24.4/manifests/custom-resources.yaml",
					# "filename": "calico-custom-resources-<<<version>>>.yaml",
					"filename": "calico-custom-resources-v3.24.4.yaml",
					"patch": patch_cni_calico,
				}
			]
		}
	},
	"cilium": {
		"executable": {
			"version_command": ["cilium", "--context", "<<<context>>>", "version"],
			# Safe
			"version_regex": r"^cilium-cli: (v)(\d+)(\.)(\d+)(\.)(\d+) .*$",
			"candidate_version_url": "https://raw.githubusercontent.com/cilium/cilium-cli/master/stable.txt",
			# Safe
			"candidate_version_regex": r"(v)(\d+)(\.)(\d+)(\.)(\d+)$",
			"urls": [
				{
					"url": "https://github.com/cilium/cilium-cli/releases/download/<<<version>>>/cilium-linux-<<<arch>>>.tar.gz",
					"checksum_url": "https://github.com/cilium/cilium-cli/releases/download/<<<version>>>/cilium-linux-<<<arch>>>.tar.gz.sha256sum",
					"checksum_type": "sha256",
					"filename": "cilium",
				}
			],
		},
		"CNI": {
			"version_command": ["cilium", "--context", "<<<context>>>", "version"],
			# Safe
			"version_regex": r"^cilium image \(running\): (v)(\d+)(\.)(\d+)(\.)(\d+)$",
			"candidate_version_command": ["cilium", "--context", "<<<context>>>", "version"],
			# Safe
			"candidate_version_regex": r"^cilium image \(default\): (v)(\d+)(\.)(\d+)(\.)(\d+)$",
			"upgrade": ["cilium", "--context", "<<<context>>>", "upgrade"],
			"install": ["cilium", "--context", "<<<context>>>", "install"],
		}
	}
}

cni_data = {
	"antrea": {
		"url": "https://raw.githubusercontent.com/antrea-io/antrea/main/build/yamls/antrea.yml",
		"type": "yaml",
		"filename": "antrea.yaml",
	},
	"calico": {
		"url": "https://docs.projectcalico.org/manifests/calico.yaml",
		"type": "yaml",
		"filename": "calico.yaml",
	},
	"canal": {
		"url": "https://docs.projectcalico.org/manifests/canal.yaml",
		"type": "yaml",
		"filename": "canal.yaml",
	},
	"cilium": {
		"version_url": "https://raw.githubusercontent.com/cilium/cilium-cli/master/stable.txt",
		"url": "https://github.com/cilium/cilium-cli/releases/download/<<<version>>>/cilium-linux-<<<arch>>>.tar.gz",
		"checksum_url": "https://github.com/cilium/cilium-cli/releases/download/<<<version>>>/cilium-linux-<<<arch>>>.tar.gz.sha256sum",
		"checksum_type": "sha256",
		"type": "installer",
		"filename": "cilium",
		"command": ["cilium", "--context", "<<<context>>>", "install"]
	},
	"flannel": {
		"url": "https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml",
		"type": "yaml",
		"filename": "flannel.yaml",
		"patch_cni": patch_cni_flannel,
	},
	"kube-router": {
		"url": "https://raw.githubusercontent.com/cloudnativelabs/kube-router/master/daemonset/kubeadm-kuberouter.yaml",
		"type": "yaml",
		"filename": "kube-router.yaml",
	},
	"weave": {
		"url": "https://github.com/weaveworks/weave/releases/download/v2.8.1/weave-daemonset-k8s-1.11.yaml",
		"type": "yaml",
		"filename": "weave.yaml",
	},
}

def substitute_string(string: str, substitutions: Dict) -> str:
	"""
	Substitutes substrings in a string

		Parameters:
			string (str): The string to perform substitutions on
			substitutions (dict): A dict where key is the substring to match against, and value is the replacement for that substring
		Returns:
			string (str): The string with substitutions performed
	"""

	for key, value in substitutions.items():
		if string is None or value is None:
			continue
		string = string.replace(key, value)
	return string

def substitute_list(strlist: List[str], substitutions: Dict) -> List[str]:
	"""
	Substitutes substrings in all strings in a list

		Parameters:
			string (list[str]): A list with the strings to perform substitutions on
			substitutions (dict): A dict where key is the substring to match against, and value is the replacement for that substring
		Returns:
			list[str]: The list of strings with substitutions performed
	"""

	for key, value in substitutions.items():
		strlist = [s.replace(key, value) for s in strlist]
	return strlist

def check_version_from_url(url: str, version_regex: str) -> List[str]:
	"""
	Given a URL download a text file and treat the first line that matches version_regex as a version number

		Parameters:
			url (str): A URL
			version_regex (str): A regex
		Returns:
			version (str): The version number, or None in case of failure
	"""

	version: List[str] = []

	if url is not None:
		with tempfile.TemporaryDirectory() as td:
			check_and_print_status(download_files(td, [(url, "version.txt", None, None)], permissions = 0o600))
			tmp = secure_read_string(FilePath(f"{td}/version.txt"))
			versionoutput = tmp.splitlines()
			_version_regex = re.compile(version_regex)
			for line in versionoutput:
				tmp_match = _version_regex.match(cast(str, line))
				if tmp_match is not None:
					version = list(tmp_match.groups())
					break
	return version

def check_version_from_executable(command: FilePath, args: List[str], version_regex: str) -> List[str]:
	"""
	Given a path to an executable, the arguments needed to show version information,
	and a version_regex, return the executable version

		Parameters:
			command (str): A path to an executable
			args (list[str]): A list of arguments necessary to show version information
			version_regex (str): A regex
		Returns:
			version (str): The version number, or None in case of failure
	"""

	version: List[str] = []

	security_policy = SecurityPolicy.ALLOWLIST_RELAXED
	fallback_allowlist = ["/bin", "/sbin", "/usr/bin", "/usr/sbin", "/usr/local/bin", "/usr/local/sbin", f"{HOMEDIR}/bin"]

	try:
		cpath = iktio.secure_which(command, fallback_allowlist = fallback_allowlist, security_policy = security_policy)
	except FileNotFoundError:
		cpath = None

	if cpath is not None:
		result = execute_command_with_response([cpath] + args)

		if result is not None:
			versionoutput = result.splitlines()
			_version_regex = re.compile(version_regex)
			for line in versionoutput:
				tmp = _version_regex.match(line)
				if tmp is not None:
					version = list(tmp.groups())
					break
	return version

def __upgrade_cni(cni: str, upgradetype: str, context: str, pod_network_cidr: str) -> None:
	"""
	A helper that is used when upgrading a CNI; it can either upgrade the CNI itself or a helper executable

		Parameters:
			cni (str): The CNI to upgrade
			upgradetype (str): Valid options CNI, executable
			context (str): The cluster context
			pod_network_cidr (str): The CIDR of the pod network
	"""

	if upgradetype not in ("CNI", "executable"):
		raise Exception(f"Unknown upgradetype {upgradetype}; this is a programming error.")

	# FIXME: for now we hardcode this
	arch = "amd64"
	version_command = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#version_command"))
	version_command_regex = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#version_regex"))
	candidate_version_url = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#candidate_version_url"))
	candidate_version_command = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#candidate_version_command"))
	candidate_version_regex = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#candidate_version_regex"))
	install_command = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#install"))
	upgrade_command = deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#upgrade"))

	version_substitutions = {
		"<<<arch>>>": arch,
		"<<<context>>>": context,
	}

	version = []
	if version_command is not None:
		iktprint([ANSIThemeString("\n• ", "separator"),
			  ANSIThemeString(f"Checking {upgradetype} version", "action")])
		version = check_version_from_executable(version_command[0],
							substitute_list(version_command[1:], version_substitutions), version_command_regex)
	candidate_version = []
	if candidate_version_url is not None:
		iktprint([ANSIThemeString("\n• ", "separator"),
			  ANSIThemeString(f"Checking {upgradetype} candidate version", "action")])
		candidate_version = check_version_from_url(substitute_string(candidate_version_url, version_substitutions), candidate_version_regex)
	elif candidate_version_command is not None:
		iktprint([ANSIThemeString("\n• ", "separator"),
			  ANSIThemeString(f"Checking {upgradetype} candidate version", "action")])
		candidate_version = check_version_from_executable(candidate_version_command[0],
								  substitute_list(candidate_version_command[1:], version_substitutions),
								  candidate_version_regex)

	if "urls" in deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}")):
		if (version is None or len(version) == 0) or version is not None and (candidate_version is None or len(candidate_version) == 0) or version < candidate_version:
			new_version = "".join(candidate_version)

			iktprint([ANSIThemeString("\n• ", "separator"),
				  ANSIThemeString(f"Downloading {upgradetype} ", "action"),
				  ANSIThemeString(f"{new_version}", "version")])

			substitutions = {
				"<<<version>>>": new_version,
				"<<<arch>>>": arch,
				"<<<context>>>": context,
			}

			kubectl_path = secure_which(FilePath("/usr/bin/kubectl"), fallback_allowlist = [])
			if upgradetype == "CNI":
				secure_mkdir(DEPLOYMENT_DIR)
				directory = FilePath(str(PurePath(DEPLOYMENT_DIR).joinpath("cni")))
				permissions = 0o644
			elif upgradetype == "executable":
				directory = BINDIR
				permissions = 0o755
			secure_mkdir(directory)

			for url in deep_get(cni_upgrade_data, DictPath(f"{cni}#{upgradetype}#urls"), []):
				download_url = deep_get(url, DictPath("url"), "")
				checksum_url = deep_get(url, DictPath("checksum_url"), None)
				checksum_type = deep_get(url, DictPath("checksum_type"), None)
				filename = deep_get(url, DictPath("filename"), "")

				download_url = substitute_string(download_url, substitutions)
				checksum_url = substitute_string(checksum_url, substitutions)

				check_and_print_status(download_files(directory, [(download_url, filename, checksum_url, checksum_type)], permissions = permissions))

				if upgradetype == "CNI":
					new_path = FilePath(str(PurePath(directory).joinpath(filename)))
					patch_cni_call = deep_get(url, DictPath("patch"))
					if patch_cni_call is not None:
						patch_cni_call(new_path, pod_network_cidr)
					execute_command_with_response([kubectl_path, "apply", "-f", new_path])
		else:
			iktprint([ANSIThemeString("No newer version available.", "default")])
	elif install_command is not None and version is None or len(version) == 0:
		new_version = "".join(candidate_version)

		iktprint([ANSIThemeString("\n• ", "separator"),
			  ANSIThemeString(f"Installing {upgradetype} ", "action"),
			  ANSIThemeString(f"{new_version}", "version")])

		substitutions = {
			"<<<version>>>": new_version,
			"<<<arch>>>": arch,
			"<<<context>>>": context,
		}
		check_and_print_status(execute_command(substitute_list(install_command, substitutions)))
	elif upgrade_command is not None:
		if version is None or version < candidate_version:
			new_version = "".join(candidate_version)

			iktprint([ANSIThemeString("\n• ", "separator"),
				  ANSIThemeString(f"Upgrading {upgradetype} to ", "action"),
				  ANSIThemeString(f"{new_version}", "version")])

			substitutions = {
				"<<<version>>>": new_version,
				"<<<arch>>>": arch,
				"<<<context>>>": context,
			}
			check_and_print_status(execute_command(substitute_list(upgrade_command, substitutions)))
		else:
			iktprint([ANSIThemeString("No newer version available.", "default")])

# pylint: disable-next=unused-argument
def upgrade_cni(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Upgrade the specified CNI to the latest version

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): The CNI to upgrade (optional; if not specified the CNI will be taken from installation_info.yaml)
	"""

	kh = None

	if len(args) > 0:
		cni = args[0]
	else:
		installation_info = get_installation_info()
		cluster_name = installation_info["installation_target"]
		cni = installation_info[cluster_name]["cni"]
		pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]

	if pod_network_cidr is None:
		# If we have a running cluster and we are upgrading by CNI rather than through installation info we need to get the Pod CIDR
		# by some other means; try this. If this fails we give up.
		from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
		kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)
		pod_network_cidr = kh.get_pod_network_cidr()
		if pod_network_cidr is None:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": Could not identify Pod network CIDR; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOTSUP)

	if cni in ("", "<none>", "<unknown>"):
		if kh is None:
			from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
			kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)
		tmp_cni = kh.identify_cni()
		if len(tmp_cni) == 0:
			cni = "<unknown>"
		elif len(tmp_cni) > 1:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": Could not uniquely identify the CNI; multiple potential candidates identified; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		else:
			cni = tmp_cni[0][0]

	install_cni = False
	action_str = "Upgrading"
	for opt, _optarg in options:
		if opt == "install":
			install_cni = True
			action_str = "Installing"
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	if cni not in cni_upgrade_data:
		iktprint([ANSIThemeString(f"{action_str} ", "default"),
			  ANSIThemeString(f"{cni}", "command"),
			  ANSIThemeString(" is currently not supported; exiting.", "default")])
		sys.exit(errno.ENOTSUP)

	kubectl_path = secure_which(FilePath("/usr/bin/kubectl"), fallback_allowlist = [])
	context_name = execute_command_with_response([kubectl_path, "config", "current-context"]).splitlines()[0]

	if install_cni == True:
		iktprint([ANSIThemeString("\n[Installing CNI]", "phase")])
	else:
		iktprint([ANSIThemeString("\n[Upgrading CNI]", "phase")])

	__upgrade_cni(cni, "executable", context_name, pod_network_cidr)
	__upgrade_cni(cni, "CNI", context_name, pod_network_cidr)

	if install_cni == True:
		iktprint([ANSIThemeString("\nCNI installation successful", "success")])
	else:
		iktprint([ANSIThemeString("\nCNI upgrade successful", "success")])

def __setup_cni(cni: str, pod_network_cidr: str, context_name: str, cluster_name: str) -> None:
	"""
	Setup a CNI

		Parameters:
			cni (str): The CNI to configure and install
			pod_network_cidr (str): The CIDR of the pod network
			context_name (str): The name of the cluster context
			cluster_name (str): The name of the cluster
	"""

	if cni not in cni_data and cni not in cni_upgrade_data:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": ", "default"),
			  ANSIThemeString(f"{cni}", "argument"),
			  ANSIThemeString(" is not a valid/supported CNI; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if cni in cni_upgrade_data:
		upgrade_cni(options = [("install", "")], args = [])
		return

	version_url = deep_get(cni_data, DictPath(f"{cni}#version_url"))
	version_regex = deep_get(cni_data, DictPath(f"{cni}#version_regex"))

	version = check_version_from_url(version_url, version_regex)

	url = deep_get(cni_data, DictPath(f"{cni}#url"))
	if url is None:
		raise Exception(f"URL for {cni} is empty; this is a programming error.")

	checksum_url = deep_get(cni_data, DictPath(f"{cni}#checksum_url"))
	checksum_type = deep_get(cni_data, DictPath(f"{cni}#checksum_type"))

	# FIXME: for now we hardcode this
	arch = "amd64"
	substitutions = {
		"<<<version>>>": "".join(version),
		"<<<arch>>>": arch,
	}

	url = substitute_string(url, substitutions)
	checksum_url = substitute_string(checksum_url, substitutions)

	filename = deep_get(cni_data, DictPath(f"{cni}#filename"))
	patch_cni = deep_get(cni_data, DictPath(f"{cni}#patch_cni"), None)
	filetype = deep_get(cni_data, DictPath(f"{cni}#type"))
	if filetype is None:
		raise Exception(f"type for {cni} is missing; this is a programming error.")
	if filetype == "yaml":
		secure_mkdir(DEPLOYMENT_DIR)
		directory = FilePath(os.path.join(DEPLOYMENT_DIR, "cni"))
		permissions = 0o644
	elif filetype == "installer":
		directory = BINDIR
		permissions = 0o755
	secure_mkdir(directory)

	check_and_print_status(download_files(directory, [(url, filename, checksum_url, checksum_type)], permissions = permissions))

	cni_path = f"{directory}/{filename}"

	if patch_cni is not None:
		iktprint([ANSIThemeString("\n• ", "separator"),
			  ANSIThemeString("Patching “", "action"),
			  ANSIThemeString(f"{cni}", "argument"),
			  ANSIThemeString("“ configuration", "action")])
		patch_cni(cni_path, pod_network_cidr)

	if filetype == "yaml":
		args = ["/usr/bin/kubectl", "apply", "--context=<<<context>>>", "-f", cni_path]
	elif filetype == "installer":
		args = deep_get(cni_data, DictPath(f"{cni}#command"))

	substitutions = {
		"<<<cluster>>>": cluster_name,
		"<<<context>>>": context_name,
	}

	check_and_print_status(execute_command(substitute_list(args, substitutions)))

def check_for_ssh_key() -> bool:
	"""
	Check whether there's an existing public ssh key on the system already

		Returns:
			retval (bool): True if a key exists, False if no key exists
	"""

	retval = False
	files = [file for file in glob(os.path.join(HOMEDIR, ".ssh", "*.pub")) if os.path.isfile(file)]
	for file in files:
		if os.path.isfile(file) and os.path.isfile(file[:-len(".pub")]):
			retval = True
			break
	return retval

def create_ssh_key() -> bool:
	"""
	Create a new ssh key (ECDSA-P521 format)

		Returns:
			retval (bool): True on success, False on failure
	"""

	if not os.path.exists(f"{HOMEDIR}/.ssh/id_ecdsa"):
		args = [SSH_KEYGEN_BIN_PATH] + SSH_KEYGEN_ARGS + ["-f", f"{SSH_DIR}/id_ecdsa"]
		retval = execute_command(args)
	else:
		retval = True
	return retval

def add_ssh_keys_to_authorized_keys() -> bool:
	"""
	Add all public keys for this host to authorized keys on this host;
	in other words, make the host able to SSH to itself

		Returns:
			retval (bool): True on success, False on failure
	"""

	retval = False

	# Since we run create_ssh_key() before this task we can safely assume that .ssh/ exists
	for path in Path(SSH_DIR).iterdir():
		if not path.name.endswith(".pub"):
			continue

		tmp = secure_read_string(FilePath(str(path)))
		if tmp is not None:
			tmplines = tmp.splitlines()
			pubkey = cast(str, tmplines[0])
			if len(pubkey) == 0:
				continue

		exists = False

		authorized_keys_path = FilePath(str(PurePath(SSH_DIR).joinpath("authorized_keys")))

		try:
			tmp = secure_read_string(authorized_keys_path)
			if tmp is not None and len(tmp) > 0:
				for line in tmp:
					if line == pubkey[0]:
						exists = True
						break
		except FileNotFoundError:
			pass

		if exists == False:
			secure_write_string(authorized_keys_path, f"{pubkey}\n", write_mode = "a")

		# We've added at least one public key
		retval = True

	return retval

# pylint: disable-next=unused-argument
def __task_check_and_create_ssh_key(installation_info: Dict) -> None:
	"""
	An installer task that checks whether the system has an ssh-key,
	and creates one if not

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	if check_for_ssh_key() == False:
		retval = iktinput([ANSIThemeString("Warning", "warning"),
				   ANSIThemeString(": No ssh key found in ", "default"),
				   ANSIThemeString(f"{HOMEDIR}/.ssh", "path"),
				   ANSIThemeString("; create one now? (No will abort the installation) [y/", "default"),
				   ANSIThemeString("N", "emphasis"),
				   ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([ANSIThemeString("\nAborting:", "error"),
				  ANSIThemeString(" No ssh key available.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			check_and_print_status(create_ssh_key())

# pylint: disable-next=unused-argument
def __task_scan_and_add_ssh_keys(installation_info: Dict) -> None:
	"""
	An installer task that scans all specified control planes for public ssh keys
	and adds them to known hosts

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	controlplanes = get_control_planes()
	hosts = [controlplane[0] for controlplane in controlplanes]
	hosts += [f"{controlplane[0]}.local" for controlplane in controlplanes]
	hosts += [
		"localhost",
	]

	scan_and_add_ssh_keys(hosts)

# pylint: disable-next=unused-argument
def __task_add_ssh_keys_to_inventory(installation_info: Dict) -> None:
	"""
	An installer task that adds SSH keys to the iKT inventory

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	pubkey = None
	d = ansible_get_inventory_dict()
	__vars = deep_get(d, DictPath("all#vars"), {})
	__authorized_keys = __vars.get("authorized_keys", [])
	found_key = False

	for path in Path(SSH_DIR).iterdir():
		if not str(path).endswith(".pub"):
			continue

		tmp = secure_read_string(FilePath(str(path)))
		if tmp is not None:
			tmplines = tmp.splitlines()
			pubkey = tmplines[0]

		if tmp is None or len(pubkey) == 0:
			iktprint([ANSIThemeString("Warning", "warning"),
				  ANSIThemeString(": Failed to read a key from ", "default"),
				  ANSIThemeString(str(path), "path"),
				  ANSIThemeString("; skipping.", "default")], stderr = True)
			continue

		if pubkey not in __authorized_keys:
			__authorized_keys.append(pubkey)

		found_key = True

	if found_key == False:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Could not find a valid public key in ", "default"),
			  ANSIThemeString(SSH_DIR, "path"),
			  ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	__vars["authorized_keys"] = __authorized_keys
	ansible_set_vars(ANSIBLE_INVENTORY, "all", __vars)

# pylint: disable-next=unused-argument
def __task_check_and_add_ssh_keys_to_authorized_keys(installation_info: Dict) -> None:
	"""
	An installer task that adds SSH keys to authorized keys

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	add_ssh_keys_to_authorized_keys()

def install_ansible_posix() -> bool:
	"""
	Install ansible-posix using ansible-galaxy; this is necessary on systems
	where the version of Ansible is too old to support certain actions.

		Returns:
			(bool): True on success, False on failure
	"""

	# Old versions of ansible-galaxy does not have the list command;
	# if it does not work we just assume that ansible.posix is missing
	args = ["/usr/bin/ansible-galaxy", "collection", "list"]
	result = execute_command_with_response(args)

	if "COLLECTION_ACTION: invalid choice" in result or "ansible.posix" not in result:
		http_proxy = deep_get(iktlib.iktconfig, DictPath("Network#http_proxy"), "")
		https_proxy = deep_get(iktlib.iktconfig, DictPath("Network#https_proxy"), "")
		no_proxy = deep_get(iktlib.iktconfig, DictPath("Network#no_proxy"), "")
		env = {
			"http_proxy": http_proxy,
			"https_proxy": https_proxy,
			"no_proxy": no_proxy,
		}
		args = ["/usr/bin/ansible-galaxy", "collection", "install", "ansible.posix"]
		return execute_command(args, env = env)

	return True

# pylint: disable-next=unused-argument
def __task_check_and_install_ansible_posix(installation_info: Dict) -> None:
	"""
	An installer task that installs ansible-posix

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	check_and_print_status(install_ansible_posix())

def update_apt_cache() -> bool:
	"""
	Update the APT cache

		Returns:
			True on success, False on failure
	"""

	sudo_path = iktio.secure_which(FilePath("sudo"), fallback_allowlist = ["/bin", "/usr/bin"], security_policy = SecurityPolicy.ALLOWLIST_STRICT)
	apt_get_path = iktio.secure_which(FilePath("apt-get"), fallback_allowlist = ["/bin", "/usr/bin"], security_policy = SecurityPolicy.ALLOWLIST_STRICT)
	args = [sudo_path, apt_get_path, "update"]
	return execute_command(args)

def deb_compare_versions(current_version: str, candidate_version: str) -> bool:
	"""
	Compare two package versions

		Returns:
			True if current version < candidate version, else False
	"""

	args = ["/usr/bin/dpkg", "--compare-versions", current_version, "lt", candidate_version]
	return execute_command(args, comparison = 1)

def __get_theme(string: str, default: str) -> str:
	"""
	Return the suitable format reference for a particular string

		Parameters:
			string (str): A string to return the format reference for
			default (str): The default format reference to use if there's no matching translation
		Returns:
			theme (str): A format reference
	"""

	translation = {
		"<none>": "none",
		"<unknown>": "unknown",
	}
	return translation.get(string, default)

def check_versions(deb_packages: List[str], version_checks: List[Tuple[str, List[str], str]]) -> Tuple[List[Tuple[str, str, str, List[str]]], List[Tuple[str, str, str, List[str]]]]:
	"""
	Check versions for all relevant software

		Parameters:
			deb_packages (list[str]): A list of debian packages
			version_checks (list[(software, args, regex)]): A list of component, the command needed to check its version, and a regex to extract the version number
		Returns:
			(deb_versions, other_versions): A tuple of utput from check_deb_versions(), (software, installed_version, "")
	"""

	other_versions: List[Tuple[str, str, str, List[str]]] = []

	# First check all Debian versions
	deb_versions = check_deb_versions(deb_packages)

	# Now check versions that need special checks
	for version_check in version_checks:
		tmp_software: str = version_check[0]
		args = version_check[1]
		regex = version_check[2]

		try:
			response = execute_command_with_response(args)
		except FileNotFoundError:
			other_versions.append((tmp_software, "<none>", "", []))
			continue
		except subprocess.CalledProcessError:
			other_versions.append((tmp_software, "<unknown>", "", []))
			continue

		if regex is None:
			tmp_installed_version = response
		else:
			tmp_match = re.match(regex, response)
			if tmp_match is not None:
				tmp_installed_version = tmp_match[1]
			else:
				tmp_installed_version = "<none>"
		other_versions.append((tmp_software, tmp_installed_version, "", []))

	# Finally, display the gathered version information; find the longest string of each type
	# Create lists of header + all values belonging to that header, and get the length of the longest element
	slen = len(max(["Software:"] + [tmp[0] for tmp in deb_versions + other_versions], key = len))
	ilen = len(max(["Installed Version:"] + [tmp[1] for tmp in deb_versions + other_versions], key = len))

	# Print a header
	iktprint([ANSIThemeString("Software:", "header"),
		  ANSIThemeString(f"{''.ljust(slen - len('Software:') + 2)}", "default"),
		  ANSIThemeString("Installed Version:", "header"),
		  ANSIThemeString(f"{''.ljust(ilen - len('Installed Version:') + 2)}", "default"),
		  ANSIThemeString("Candidate Version:", "header")])
	for software, installed_version, candidate_version, _ in cast(Tuple[str, str, str, List[str]], natsorted(deb_versions)):
		iformat = __get_theme(installed_version, "version")
		cformat = __get_theme(candidate_version, "version")
		iktprint([ANSIThemeString(f"{software.ljust(slen + 2)}", "default"),
			  ANSIThemeString(f"{installed_version.ljust(ilen + 2)}", iformat),
			  ANSIThemeString(f"{candidate_version}", cformat)])
	print()
	for software, installed_version, candidate_version, _ in cast(Tuple[str, str, str, List[str]], natsorted(other_versions)):
		iformat = __get_theme(installed_version, "version")
		cformat = __get_theme(candidate_version, "version")
		iktprint([ANSIThemeString(f"{software.ljust(slen + 2)}", "default"),
			  ANSIThemeString(f"{installed_version.ljust(ilen + 2)}", iformat),
			  ANSIThemeString(f"{candidate_version}", cformat)])

	return deb_versions, other_versions

# pylint: disable-next=unused-argument
def run_playbook(playbookpath: FilePath, hosts: List[str], extra_values: Optional[Dict] = None, quiet: bool = False) -> Tuple[int, Dict]:
	"""
	Run a playbook

		Parameters:
			playbookpath (FilePath): A path to the playbook to run
			hosts (list[str]): A list of hosts to run the playbook on
			extra_values (dict): A dict of values to set before running the playbook
			quiet (bool): Should the results of the run be printed?
		Returns:
			retval (int): The return value from ansible_run_playbook_on_selection()
			ansible_results (dict): A dict with the results from the run
	"""

	# Set necessary Ansible keys before running playbooks
	http_proxy = deep_get(iktlib.iktconfig, DictPath("Network#http_proxy"), "")
	if http_proxy is None:
		http_proxy = ""
	https_proxy = deep_get(iktlib.iktconfig, DictPath("Network#https_proxy"), "")
	if https_proxy is None:
		https_proxy = ""
	no_proxy = deep_get(iktlib.iktconfig, DictPath("Network#no_proxy"), "")
	if no_proxy is None:
		no_proxy = ""
	insecure_registries = deep_get(iktlib.iktconfig, DictPath("Docker#insecure_registries"), [])
	registry_mirrors = deep_get(iktlib.iktconfig, DictPath("Containerd#registry_mirrors"), [])
	retval = 0

	use_proxy = "no"
	if len(http_proxy) > 0 or len(https_proxy) > 0:
		use_proxy = "yes"

	if extra_values is None:
		extra_values = {}

	values = {
		"http_proxy": http_proxy,
		"https_proxy": https_proxy,
		"no_proxy": no_proxy,
		"insecure_registries": insecure_registries,
		"registry_mirrors": registry_mirrors,
		"use_proxy": use_proxy,
	}
	merged_values = { **values, **extra_values }

	retval, ansible_results = ansible_run_playbook_on_selection(playbookpath, selection = hosts, values = merged_values)

	if quiet == False:
		ansible_print_play_results(retval, ansible_results)

	return retval, ansible_results

def run_playbooks(playbooks: List[Tuple[List[ANSIThemeString], FilePath]], hosts: Optional[List[str]] = None, extra_values: Optional[Dict] = None) -> bool:
	"""
	Run a set of playbooks

		Parameters:
			playbooks (list[(description (list[ANSIThemeString]), playbookpath (FilePath))]): A list of playbooks
			hosts (list[str]): The hosts to run the playbooks on
			extra_values (dict): Variables to set before running the playbooks
		Returns:
			True on success, False on failure
	"""

	if len(playbooks) == 0 or hosts is None:
		return True

	for string, playbookpath in playbooks:
		iktprint(string)
		retval, _ansible_results = run_playbook(playbookpath, hosts = hosts, extra_values = extra_values)

		# We do not want to continue executing playbooks if the first one failed
		if retval != 0:
			break

	return retval == 0

def __playbook_paths_from_path(playbook_path: FilePath) -> List[FilePath]:
	"""
	Scan a directory and return a list of playbook paths

		Parameters:
			playbook_path (str): A path to a directory
		Returns:
			list[FilePath]: A list of paths
	"""

	if playbook_path is None:
		raise Exception("No path passed to __playbook_paths_from_path; this is a programming error.")

	playbook_paths = []

	# Populate list of playbooks
	for path in Path(playbook_path).iterdir():
		# Do not process backups, etc.
		if path.name.startswith(("~", ".")):
			continue
		if not path.name.endswith((".yml", ".yaml")):
			continue
		playbook_paths.append(FilePath(str(path)))

	return playbook_paths

# Add all playbooks in the directory
def populate_playbooks_from_dir(path: FilePath) -> List[Tuple[List[ANSIThemeString], FilePath]]:
	"""
	Populate a playbook list from path

		Parameters:
			paths (FilePath): A directory to populate playbooks from
		Returns:
			list[(description, playbookpath)]: A playbook list for use with run_playbooks()
	"""

	playbook_paths = __playbook_paths_from_path(path)

	return populate_playbooks_from_paths(playbook_paths)

# pylint: disable-next=unused-argument
def __task_request_ansible_password(installation_info: Optional[Dict]) -> None:
	"""
	An installer task that requests the ansible password

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	# Check whether ansible_password is defined or not
	if deep_get(ansible_configuration, DictPath("ansible_password")) is None and no_password == False:
		iktprint([ANSIThemeString("Attention", "warning"),
			  ANSIThemeString(": To be able to run playbooks you need to provide the ansible/ssh password.", "default")])
		iktprint([ANSIThemeString("Since the systems will be reconfigured to use passwordless sudo and ssh keys this is a one-time thing.\n", "default")])
		iktprint([ANSIThemeString("Note", "note"),
			  ANSIThemeString(": If the remote host is already configured for passwordless sudo and allows for login using a pre-generated SSH-key you can use “", "default"),
			  ANSIThemeString("--no-password", "option"),
			  ANSIThemeString("“ to bypass this check.", "default")])
		ansible_password = iktinput_password([ANSIThemeString("\nPassword: ", "default")])
		if len(ansible_password) == 0:
			iktprint([ANSIThemeString("\nError", "error"),
				  ANSIThemeString(": Empty password; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		else:
			ansible_configuration["ansible_password"] = ansible_password

def __run_playbooks_on_selection(playbooks: List[Tuple[List[ANSIThemeString], FilePath]], selection: List[str], extra_values: Optional[Dict] = None) -> None:
	"""
	A helper that runs a playbook list on a selection

		Parameters:
			playbooks (list[(description, playbookpath)]): A playbook list
			selection (list[str]): A list of hosts
			extra_values (dict): A dict of values to set before running the playbook
	"""

	check_and_print_status(run_playbooks(playbooks, hosts = selection, extra_values = extra_values))

def __selection_control_planes() -> List[str]:
	"""
	Return a selection with all control planes

		Returns:
			(list[str]): A list of control planes
	"""

	__controlplanes = get_control_planes(fail_on_empty = False)
	return [controlplane[0] for controlplane in __controlplanes]

def __selection_localhost() -> List[str]:
	"""
	Returns a list with the hostname of localhost

		Returns:
			(list[str]): A list with the hostname of localhost
	"""

	return [socket.gethostname()]

# pylint: disable-next=unused-argument
def __task_run_preparation_playbooks_on_localhost(installation_info: Dict) -> None:
	"""
	An installer task that runs preparation playbooks on localhost

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	selection = __selection_localhost()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], prepare_targets["localhost"]["playbooks"]))
	extra_values = {
		"packages": prepare_targets["localhost"].get("deb_packages", []),
		"held_packages": prepare_targets["localhost"].get("deb_packages_held", []),
		"ansible_become_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
		"ansible_ssh_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

def __task_run_preparation_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs preparation playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	distro = installation_info[cluster_name]["distro"]
	selection = __selection_control_planes()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], prepare_targets[distro]["playbooks"]))
	cri = installation_info[cluster_name]["cri"]
	extra_values = {
		"packages": prepare_targets[distro].get("deb_packages", []),
		"held_packages": prepare_targets[distro].get("deb_packages_held", []),
		"ansible_become_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
		"ansible_ssh_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
		"cri": cri,
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

# pylint: disable-next=unused-argument
def __task_setup_bash_completion(installation_info: Dict) -> None:
	"""
	An installer task that sets up bash completion

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	secure_mkdir(FilePath(str(PurePath(HOMEDIR).joinpath(".local"))), verbose = True)
	secure_mkdir(FilePath(str(PurePath(HOMEDIR).joinpath(".local", "share"))), verbose = True)
	secure_mkdir(BASH_COMPLETION_BASE_DIR, verbose = True)
	secure_mkdir(BASH_COMPLETION_DIR, verbose = True)

	args = ["/usr/bin/kubectl", "completion", "bash"]
	result = execute_command_with_response(args)
	secure_write_string(FilePath(str(PurePath(BASH_COMPLETION_DIR).joinpath("kubectl"))), result)

def get_cluster_name() -> Optional[str]:
	"""
	Return the name of the cluster

		Returns:
			cluster_name (str): The name of the cluster
	"""
	try:
		d1 = secure_read_yaml(KUBE_CONFIG_FILE)
	except FileNotFoundError:
		return None

	current_context = d1.get("current-context", None)
	if current_context is None:
		return None

	cluster_name = None

	for context in d1.get("contexts", []):
		if context.get("name", "") == current_context:
			cluster_name = context["context"].get("cluster", None)
			break

	return cluster_name

def __task_run_setup_playbooks_on_localhost(installation_info: Dict) -> None:
	"""
	An installer task that runs playbooks on localhost

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]
	selection = __selection_localhost()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], setup_control_plane_targets["localhost"]["playbooks"]))
	extra_values = {
		"cluster_name": cluster_name,
		"pod_network_cidr": pod_network_cidr,
		"packages": setup_control_plane_targets["localhost"].get("deb_packages", []),
		"held_packages": setup_control_plane_targets["localhost"].get("deb_packages_held", []),
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

def __task_run_setup_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	distro = installation_info[cluster_name]["distro"]
	pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]
	selection = __selection_control_planes()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], setup_control_plane_targets[distro]["playbooks"]))
	extra_values = {
		"cluster_name": cluster_name,
		"pod_network_cidr": pod_network_cidr,
		"packages": setup_control_plane_targets[distro].get("deb_packages", []),
		"held_packages": setup_control_plane_targets[distro].get("deb_packages_held", []),
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

def __task_import_kube_config(installation_info: Dict) -> None:
	"""
	An installer task that merges a Kube config into ~/.kube/config

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	config_file_name = FilePath(f"{HOMEDIR}/.kube/config.{cluster_name}")
	admin_name = f"kubernetes-admin+{cluster_name}"
	context_name = f"{admin_name}@{cluster_name}"

	# This read must not fail, so no exceptions
	d2 = secure_read_yaml(config_file_name)

	# This file will not exist if this is the first cluster
	checks = [
		SecurityChecks.PARENT_RESOLVES_TO_SELF,
		SecurityChecks.OWNER_IN_ALLOWLIST,
		SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
		SecurityChecks.PERMISSIONS,
		SecurityChecks.PARENT_PERMISSIONS,
		SecurityChecks.IS_FILE,
	]

	try:
		d1 = secure_read_yaml(KUBE_CONFIG_FILE, checks = checks)
	except FileNotFoundError:
		d1 = dict(d2)
		# We will be renaming things anyway, so instead of using a lot of special casing below we just empty
		# these fields
		d1["clusters"] = []
		d1["contexts"] = []
		d1["current-context"] = context_name
		d1["users"] = []

	for cluster in d1["clusters"]:
		if cluster_name == cluster["name"]:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": A cluster named ", "default"),
				  ANSIThemeString(cluster_name, "hostname"),
				  ANSIThemeString(" already exists in ", "default"),
				  ANSIThemeString(f"{HOMEDIR}/.kube/config", "path"),
				  ANSIThemeString("; manual merge is necessary.", "default")], stderr = True)
			return

	for user in d1["users"]:
		if admin_name == user["name"]:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": A user named ", "default"),
				  ANSIThemeString(admin_name, "hostname"),
				  ANSIThemeString(" already exists in ", "default"),
				  ANSIThemeString(f"{HOMEDIR}/.kube/config", "path"),
				  ANSIThemeString("; manual merge is necessary.", "default")], stderr = True)
			return

	for context in d1["contexts"]:
		if context_name == context["name"]:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": A context named ", "default"),
				  ANSIThemeString(context_name, "hostname"),
				  ANSIThemeString(" already exists in ", "default"),
				  ANSIThemeString(f"{HOMEDIR}/.kube/config", "path"),
				  ANSIThemeString("; manual merge is necessary.", "default")], stderr = True)
			return

	cad = d2["clusters"][0]["cluster"].get("certificate-authority-data")
	server = d2["clusters"][0]["cluster"]["server"]
	insecure_skip_tls_verify = d2["clusters"][0]["cluster"].get("insecure-skip-tls-verify")
	cluster = {
		"cluster": {
			"server": server,
		},
		"name": cluster_name,
	}
	if cad is not None:
		cluster["cluster"]["certificate-authority-data"] = cad
	if insecure_skip_tls_verify is not None:
		cluster["cluster"]["insecure-skip-tls-verify"] = insecure_skip_tls_verify

	d1["clusters"].append(cluster)

	context = {
		"context": {
			"cluster": cluster_name,
			"user": admin_name,
		},
		"name": context_name,
	}
	d1["contexts"].append(context)

	ccd = d2["users"][0]["user"].get("client-certificate-data")
	ckd = d2["users"][0]["user"].get("client-key-data")
	token = d2["users"][0]["user"].get("token")
	user = {
		"user": {
		},
		"name": admin_name,
	}
	if ccd is not None:
		user["user"]["client-certificate-data"] = ccd
	if ckd is not None:
		user["user"]["client-key-data"] = ckd
	if token is not None:
		user["user"]["token"] = token

	d1["users"].append(user)

	secure_write_yaml(KUBE_CONFIG_FILE, d1, permissions = 0o600, sort_keys = False)

	check_and_print_status(True)

def __task_setup_kubeadm_cni(installation_info: Dict) -> None:
	"""
	An installer task that sets up a CNI

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	cni = installation_info[cluster_name]["cni"]
	pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]
	admin_name = f"kubernetes-admin+{cluster_name}"
	context_name = f"{admin_name}@{cluster_name}"

	# If everything is successful so far we deploy the pod network
	__setup_cni(cni, pod_network_cidr, context_name, cluster_name)

# pylint: disable-next=unused-argument
def __task_drain_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that drains control plains

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	controlplanes = __selection_control_planes()

	# Check if there is an API-server running that will listen to our request;
	# drain is issued during teardown--so if we are resuming a teardown the cluster
	# might already be partially deconfigured
	# XXX: This should be done on the control plane(s), not on localhost
	args = ["/usr/bin/sudo", "/usr/bin/lsof", "-i", "-P", "-n"]
	response = execute_command_with_response(args)
	running = False
	for line in response.splitlines():
		if "6443 (LISTEN)" in line:
			running = True
			break
	if running == False:
		check_and_print_status(True)
		return

	kubectl_major_version, kubectl_minor_version, _kubectl_git_version, _server_major_version, _server_minor_version, _server_git_version = kubernetes_helper.kubectl_get_version()

	# Build the drain command line based on what version of kubectl is installed
	args = ["/usr/bin/kubectl", "drain", "--ignore-daemonsets"]
	if kubectl_major_version >= 1 and kubectl_minor_version >= 20:
		args.append("--delete-emptydir-data")
	else:
		args.append("--delete-local-data")
	if kubectl_major_version >= 1 and kubectl_minor_version >= 18:
		args.append("--disable-eviction")

	for controlplane in controlplanes:
		check_and_print_status(execute_command(args + [controlplane]))

# pylint: disable-next=unused-argument
def __task_uncordon_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that uncordons control planes

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	controlplanes = __selection_control_planes()

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for controlplane in controlplanes:
		iktprint([ANSIThemeString(f"  {controlplane}:", "hostname")])
		message, status = kh.uncordon_node(controlplane)
		if status in (200, 204):
			iktprint([ANSIThemeString("    Uncordoned", "success")])
			print(message)
		elif status == 42503:
			iktprint([ANSIThemeString("\n  ", "default"),
				  ANSIThemeString("Critical", "critical"),
				  ANSIThemeString(": Cluster not available; aborting", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			iktprint([ANSIThemeString("\n  API call returned error:", "error")], stderr = True)
			iktprint([ANSIThemeString(f"    {message}", "error")], stderr = True)
			sys.exit(errno.EINVAL)

# pylint: disable-next=unused-argument
def __task_run_preupgrade_playbooks_on_localhost(installation_info: Dict) -> None:
	"""
	An installer task that runs pre-upgrade playbooks on localhost

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	selection = __selection_localhost()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], upgrade_control_plane_targets["localhost"]["playbooks"]))
	extra_values = {
		"packages": upgrade_control_plane_targets["localhost"].get("deb_packages", []),
		"held_packages": upgrade_control_plane_targets["localhost"].get("deb_packages_held", []),
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

# pylint: disable-next=unused-argument
def __task_run_preupgrade_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs pre-upgrade playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	selection = __selection_control_planes()
	paths = __playbook_paths_from_path(FilePath(str(PurePath(IKT_HOOKS_DIR).joinpath("pre-upgrade.d"))))
	playbooks = populate_playbooks_from_paths(paths)
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = {})

# Run upgrade playbooks on control planes
def __task_run_upgrade_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs upgrade playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	distro = installation_info[cluster_name]["distro"]
	requested_version = installation_info[cluster_name]["requested_version"]
	selection = __selection_control_planes()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], upgrade_control_plane_targets[distro]["playbooks"]))
	extra_values = {
		"packages": upgrade_control_plane_targets[distro].get("deb_packages", []),
		"held_packages": upgrade_control_plane_targets[distro].get("deb_packages_held", []),
		"requested_control_plane_k8s_version": requested_version,
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

# pylint: disable-next=unused-argument
def __task_run_postupgrade_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs post-upgrade playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	selection = __selection_control_planes()
	paths = __playbook_paths_from_path(FilePath(str(PurePath(IKT_HOOKS_DIR).joinpath("post-upgrade.d"))))
	playbooks = populate_playbooks_from_paths(paths)
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = {})

# pylint: disable-next=unused-argument
def __task_verify_that_cluster_has_no_nodes(installation_info: Dict) -> None:
	"""
	An installer task that verifies that no non-control plane nodes remain in the cluster

		Parameters:
			installation_info (dict): A dict with installation information (Unused)
	"""

	node_statuses, _kh = __get_node_info()

	if node_statuses is not None:
		for node in node_statuses:
			if "control-plane" not in node["roles"]:
				iktprint([ANSIThemeString("\nPlease delete all nodes (except the ", "warning"),
					  ANSIThemeString("control plane", "emphasis"),
					  ANSIThemeString(") from the cluster before attempting a teardown.", "warning")])
				sys.exit(errno.EAGAIN)

	iktprint([ANSIThemeString("OK", "ok")])

# Run teardown playbooks on control planes
def __task_run_teardown_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs teardown playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	distro = installation_info[cluster_name]["distro"]
	selection = __selection_control_planes()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], teardown_control_plane_targets[distro]["playbooks"]))
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = {})

def __task_remove_kube_config(installation_info: Dict) -> None:
	"""
	An installer task that removes a cluster configuration from ~/.kube/config

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	if not Path(KUBE_CONFIG_DIR).is_dir():
		check_and_print_status(True)
		return

	cluster_name = installation_info["installation_target"]
	admin_name = f"kubernetes-admin+{cluster_name}"
	context_name = f"{admin_name}@{cluster_name}"
	d1 = None

	if os.path.exists(f"{HOMEDIR}/.kube/config.{cluster_name}"):
		os.remove(f"{HOMEDIR}/.kube/config.{cluster_name}")

	try:
		d1 = secure_read_yaml(KUBE_CONFIG_FILE)

		# This is not perfect--there might be leftover users and contexts belonging to this cluster;
		# but we better not go on a killing spree--better leave cruft behind than remove everything.
		for i in range(0, len(d1["clusters"])):
			if d1["clusters"][i].get("name") == cluster_name:
				d1["clusters"].pop(i)
				break
		for i in range(0, len(d1["users"])):
			if d1["users"][i].get("name") == admin_name:
				d1["users"].pop(i)
				break
		for i in range(0, len(d1["contexts"])):
			if d1["contexts"][i].get("name") == context_name:
				d1["contexts"].pop(i)
				break
	except FileNotFoundError:
		pass

	# If there's no cluster left, remove the config completely
	if d1 is None or len(d1["clusters"]) == 0:
		secure_rm(KUBE_CONFIG_FILE, ignore_non_existing = True)

		_dir = os.listdir(f"{HOMEDIR}/.kube")
		try:
			_dir.remove("cache")
		except ValueError:
			pass
		try:
			_dir.remove("http-cache")
		except ValueError:
			pass

		# If there's nothing else than the cache subdirectories in .kube, remove .kube too
		if len(_dir) == 0:
			shutil.rmtree(f"{HOMEDIR}/.kube")
	else:
		# Set the context to the first remaining context, if any
		if len(d1["contexts"]) > 0:
			d1["current-context"] = d1["contexts"][0]["name"]

		secure_write_yaml(KUBE_CONFIG_FILE, d1, permissions = 0o600, sort_keys = False)

	check_and_print_status(True)

# Run purge playbooks on control planes
def __task_run_purge_playbooks_on_control_planes(installation_info: Dict) -> None:
	"""
	An installer task that runs purge playbooks on control planes

		Parameters:
			installation_info (dict): A dict with installation information
	"""

	cluster_name = installation_info["installation_target"]
	distro = installation_info[cluster_name]["distro"]
	selection = __selection_control_planes()
	playbooks = populate_playbooks_from_paths(cast(List[FilePath], purge_control_plane_targets[distro]["playbooks"]))
	extra_values = {
		"packages": purge_control_plane_targets[distro].get("deb_packages", []),
		"held_packages": purge_control_plane_targets[distro].get("deb_packages_held", []),
	}
	__run_playbooks_on_selection(playbooks = playbooks, selection = selection, extra_values = extra_values)

def __validate_task_index(tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]], phase: Union[str, int]) -> int:
	"""
	Helper that validates the installer task index
		Parameters:
			tasks (list[tasks]): A list of tasks
			phase (int): An integer index
		Returns:
			phase (int): The integer index on success; exits if the task is out of range
	"""

	try:
		phase = int(phase)
	except ValueError as e:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": ", "default"),
			  ANSIThemeString("TASK", "argument"),
			  ANSIThemeString(f" needs to be an integer index in the range [0, {len(tasks) - 1}]. Aborting.", "default")], stderr = True)
		sys.exit(f"Exception: {e}")

	if phase < 0 or phase >= len(tasks):
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": ", "default"),
			  ANSIThemeString("TASK", "argument"),
			  ANSIThemeString(f" needs to be in the range [0, {len(tasks) - 1}]. Aborting.", "default")], stderr = True)
		sys.exit(errno.ERANGE)
	return phase

def __list_phases(phases: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]]) -> None:
	"""
	Helper that lists installation phases
	"""

	for i, phase in enumerate(phases):
		tmp = [ANSIThemeString(f"{str(i).rjust(2)}: ", "emphasis")]
		tmp += phase[0]
		iktprint(tmp)

def __expand_index_list(index_list: str) -> Set[int]:
	indexes = set()

	for index in index_list.split(","):
		try:
			if "-" in index:
				tmp_first, tmp_last = index.split("-")
				first = int(tmp_first)
				last = int(tmp_last)
			else:
				first = int(index)
				last = first
		except ValueError as e:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": ", "default"),
				  ANSIThemeString(f"{index}", "argument"),
				  ANSIThemeString(" is not an integer or range of integers. Aborting.", "default")], stderr = True)
			sys.exit(f"Exception: {e}")
		for i in range(first, last + 1):
			indexes.add(i)
	return indexes

def __format_none(string: Optional[str], fmt: str) -> ANSIThemeString:
	if string is None or string == "<none>":
		__string = ANSIThemeString("<none>", "none")
	else:
		__string = ANSIThemeString(string, fmt)
	return __string

prepare_tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]] = [
	([ANSIThemeString("Check for ssh host key and create if needed", "action")], __task_check_and_create_ssh_key),
	([ANSIThemeString("Add ssh keys for localhost and the control plane(s) to ", "action"),
	  ANSIThemeString(f"{HOMEDIR}/.ssh/known_hosts", "path")], __task_scan_and_add_ssh_keys),
	([ANSIThemeString("Add public ssh keys to ", "action"),
	  ANSIThemeString(f"{HOMEDIR}/.ssh/authorized_keys", "path")], __task_check_and_add_ssh_keys_to_authorized_keys),
	([ANSIThemeString("Add public ssh keys to inventory", "action")], __task_add_ssh_keys_to_inventory),
	([ANSIThemeString("Request the ansible password if necessary", "action")], __task_request_ansible_password),
	([ANSIThemeString("Install ", "action"),
	  ANSIThemeString("ansible.posix", "programname"),
	  ANSIThemeString(" if necessary", "action")], __task_check_and_install_ansible_posix),
	([ANSIThemeString("Run playbooks on ", "action"),
	  ANSIThemeString("localhost", "hostname")], __task_run_preparation_playbooks_on_localhost),
	([ANSIThemeString("Run playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_preparation_playbooks_on_control_planes),
]

__setup_kubeadm_control_plane_tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]] = [
	([ANSIThemeString("Run playbooks on ", "action"),
	  ANSIThemeString("localhost", "hostname")], __task_run_setup_playbooks_on_localhost),
	([ANSIThemeString("Setup ", "action"),
	  ANSIThemeString("bash completion", "emphasis"),
	  ANSIThemeString(" for ", "action"),
	  ANSIThemeString("kubectl", "programname")], __task_setup_bash_completion),
	([ANSIThemeString("Run playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_setup_playbooks_on_control_planes),
	([ANSIThemeString("Import kube config", "action")], __task_import_kube_config),
	([ANSIThemeString("Setup ", "action"),
	  ANSIThemeString("Container Network Interface (CNI)", "action")], __task_setup_kubeadm_cni),
]

setup_control_plane_tasks = __setup_kubeadm_control_plane_tasks

upgrade_control_plane_tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]] = [
	([ANSIThemeString("Drain the ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_drain_control_planes),
	([ANSIThemeString("Run pre-upgrade playbooks on ", "action"),
	  ANSIThemeString("localhost", "hostname")], __task_run_preupgrade_playbooks_on_localhost),
	([ANSIThemeString("Run pre-upgrade playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_preupgrade_playbooks_on_control_planes),
	([ANSIThemeString("Run upgrade playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_upgrade_playbooks_on_control_planes),
	([ANSIThemeString("Run post-upgrade playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_postupgrade_playbooks_on_control_planes),
	([ANSIThemeString("Uncordon the ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_uncordon_control_planes),
]

teardown_control_plane_tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]] = [
	([ANSIThemeString("Verify that only ", "action"),
	  ANSIThemeString("control planes", "hostname"),
	  ANSIThemeString(" remain in the cluster", "action")], __task_verify_that_cluster_has_no_nodes),
	([ANSIThemeString("Drain the ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_drain_control_planes),
	([ANSIThemeString("Run teardown playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_teardown_playbooks_on_control_planes),
	([ANSIThemeString("Remove kube config", "action")], __task_remove_kube_config),
]

purge_control_plane_tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]] = [
	([ANSIThemeString("Run purge playbooks on ", "action"),
	  ANSIThemeString("control planes", "hostname")], __task_run_purge_playbooks_on_control_planes),
]

def run_tasks(tasks: List[Tuple[List[ANSIThemeString], Callable[[Dict], None]]], phase: int, phase_skiplist: Set[int], final_state: str) -> None:
	"""
	Run tasks

		Parameters:
			tasks list[(themestring, task)]: A list of tasks containing tuples of describing the task (in form of a themestr) and a function reference
			phase (int): The installation phase
			phase_skiplist (set(phase)): A set of phases to skip
			final_state (str): The state to set if the task completes successfully
	"""

	installation_info = get_installation_info()

	if not isinstance(phase, int):
		phase = 0

	for i in range(phase, len(tasks)):
		iktprint([ANSIThemeString("\n• ", "separator")] + tasks[i][0])
		if i not in set(phase_skiplist):
			tasks[i][1](installation_info)
		if i < len(tasks) - 1:
			installation_info = update_installation_info(phase = i)
		else:
			update_installation_info(state = final_state, phase = "<done>")

def __find_requested_version(distro: str, version: Optional[str] = None) -> str:
	"""
	Based on a provided version, try to find a matching package;
	Passing None will give the latest version, passing major, minor will give the latest patch revision of that version.
	Passing an exact version will give that version.

		Parameters:
			distro (str): Currently only kubeadm is supported
			version (str): The requested version string or version substring
		Returns:
			requested_version (str): The best matching package version
	"""

	requested_version = None

	if distro == "kubeadm":
		# If version is an exact match for a package version, use it.
		# If version is a match for a package version with the package revision ("-nn") removed, use the latest matching package revision.
		# If no version is specified, use the latest package revision.
		versions = check_deb_versions(["kubeadm"])

		if len(versions) == 0:
			iktprint([ANSIThemeString("Critical", "critical"),
				  ANSIThemeString(": No candidate version for ", "default"),
				  ANSIThemeString("kubeadm", "programname"),
				  ANSIThemeString(" available; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		elif version is not None:
			# The list is sorted in falling order, so the first match is the one we want, since that's the newest package revision.
			for package_version in versions[0][3]:
				if package_version.split("-")[0] == version:
					requested_version = package_version
					break
				if package_version.split(".")[0] + "." + package_version.split(".")[1] == version:
					requested_version = package_version
					break
				if version.split(".")[0] == version and package_version.split(".")[0] == version:
					requested_version = package_version
					break
		else:
			requested_version = versions[0][2]
			if len(requested_version) == 0:
				requested_version = versions[0][1]

		if requested_version is None:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": Could not find a matching kubeadm package for version ", "default"),
				  ANSIThemeString(f"{version}", "version"),
				  ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
	else:
		raise Exception("No support for other distros implemented")

	_major, minor, _patchrev = requested_version.split(".")
	if int(minor) < 11:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Kubernetes versions older than ", "default"),
			  ANSIThemeString("1.11", "version"),
			  ANSIThemeString(" are not supported by ", "default"),
			  ANSIThemeString(f"{about.PROGRAM_SUITE_NAME}", "programname"),
			  ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)
	elif int(minor) < 18:
		iktprint([ANSIThemeString("Warning", "warning"),
			  ANSIThemeString(": Kubernetes versions older than ", "default"),
			  ANSIThemeString("1.18", "version"),
			  ANSIThemeString(" are not fully supported by ", "default"),
			  ANSIThemeString(f"{about.PROGRAM_SUITE_NAME}", "programname"),
			  ANSIThemeString(". Some features may be missing or completely broken.", "default")], stderr = True)

	return requested_version

def prepare_installation(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Install and configure pre-requisites for a control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	global no_password # pylint: disable=global-statement
	confirm = True

	# We do not need a cluster name for --list-tasks, so check this first of all
	if "--list-tasks" in (tmp[0] for tmp in options):
		__list_phases(prepare_tasks)
		sys.exit(0)
	elif len(args) == 0:
		iktprint([ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
			  ANSIThemeString(": “", "default"),
			  ANSIThemeString("prepare", "command"),
			  ANSIThemeString("“ requires at least 1 arguments.", "default")], stderr = True)
		iktprint([ANSIThemeString("Try “", "default"),
			  ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME} ", "programname"),
			  ANSIThemeString("help", "command"),
			  ANSIThemeString("“ for more information.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# Always require the user to specify the name of the cluster to operate against, even when resuming prepare;
	# this avoids a lot of hairy corner-cases and attempts to figure out what cluster the user intended to operate against
	cluster_name = args[0]

	installation_info = get_installation_info(cluster_name = cluster_name)
	distro = "kubeadm"
	requested_version = installation_info[cluster_name]["requested_version"]
	state = installation_info[cluster_name]["state"]
	phase: Union[str, int] = installation_info[cluster_name]["phase"]
	phase_skiplist = set(installation_info[cluster_name]["phase_skiplist"])

	if state is not None and state not in ("<none>", "preparing", "prepared"):
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Invalid installation state; the system cannot be in a configured or semi-configured state when running prepare; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if phase == "<none>":
		phase = 0

	hostname = socket.gethostname()

	# default options
	installation_info = update_installation_info(cluster_name = cluster_name, distro = distro, requested_version = requested_version, state = "preparing", phase = phase)

	__controlplanes = get_control_planes(fail_on_empty = False)
	controlplanes = [controlplane[0] for controlplane in __controlplanes]
	if len(controlplanes) == 0 and "--control-plane" not in (tmp[0] for tmp in options):
		retval = iktinput([ANSIThemeString("\nWarning", "warning"),
				   ANSIThemeString(": No control plane defined in the inventory; do you want to add ", "default"),
				   ANSIThemeString(f"{hostname}", "hostname"),
				   ANSIThemeString(" as control plane? (No will abort the installation) [y/", "default"),
				   ANSIThemeString("N", "emphasis"),
				   ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([ANSIThemeString("\nAborting:", "error"),
				  ANSIThemeString(" No available control plane in inventory.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = [hostname], group = "controlplane", skip_all = False)
			ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = [hostname], group = cluster_name, skip_all = True)

	cri = None

	for opt, optarg in options:
		if opt == "--control-plane":
			ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = [optarg], group = "controlplane", skip_all = False)
			ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = [optarg], group = cluster_name, skip_all = True)
		elif opt == "--no-password":
			no_password = True
		elif opt == "--start-at-task":
			phase = __validate_task_index(prepare_tasks, optarg)
		elif opt == "--skip-tasks":
			skip_phases = __expand_index_list(optarg)
			for __phase in skip_phases:
				__validate_task_index(prepare_tasks, __phase)
			phase_skiplist = set(skip_phases)
		elif opt == "--resume":
			if phase is None or phase == "<none>":
				phase = 0
			elif phase == "<done>":
				iktprint([ANSIThemeString("Warning", "warning"),
					  ANSIThemeString(": Ignoring request to resume a completed preparation. Exiting.", "default")], stderr = True)
				sys.exit(0)

			else:
				phase = __validate_task_index(prepare_tasks, phase)
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--cri":
			if optarg in ("dockershim", "containerd", "manual"):
				cri = optarg
			else:
				iktprint([ANSIThemeString("Error", "error"),
					  ANSIThemeString(": Unknown CRI “", "default"),
					  ANSIThemeString(optarg, "argument"),
					  ANSIThemeString("“ specified; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
		elif opt == "-Y":
			confirm = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	if len(args) > 1:
		_version = args[1].split(".")
		if len(_version) == 1 or len(_version) >= 2 and int(_version[1]) >= 24:
			if cri == "dockershim":
				iktprint([ANSIThemeString("Error", "error"),
					  ANSIThemeString(": CRI cannot be “", "default"),
					  ANSIThemeString("dockershim", "argument"),
					  ANSIThemeString("“ for ", "default"),
					  ANSIThemeString("Kubernetes ", "programname"),
					  ANSIThemeString(">= ", "default"),
					  ANSIThemeString("1.24", "version"),
					  ANSIThemeString("; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
			elif cri is None:
				cri = "containerd"
		else:
			if cri is None:
				cri = "dockershim"
	else:
		if cri is None:
			cri = "containerd"
		elif cri == "dockershim":
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": CRI cannot be “", "default"),
				  ANSIThemeString("dockershim", "argument"),
				  ANSIThemeString("“ for ", "default"),
				  ANSIThemeString("Kubernetes ", "programname"),
				  ANSIThemeString(">= ", "default"),
				  ANSIThemeString("1.24", "version"),
				  ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)

	installation_info = update_installation_info(cri = cri)
	show_configuration()

	if confirm == True:
		retval = iktinput([ANSIThemeString("\nStart control plane preparation? [y/", "default"),
				   ANSIThemeString("N", "emphasis"),
				   ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([ANSIThemeString("\nAborting:", "error"),
				  ANSIThemeString(" User stopped control plane preparation.", "default")], stderr = True)
			os.remove(IKT_INSTALLATION_INFO_FILE)
			sys.exit(errno.EINTR)

	iktprint([ANSIThemeString("\n[Preparing localhost and control plane(s)]", "phase")])

	run_tasks(tasks = prepare_tasks, phase = cast(int, phase), phase_skiplist = phase_skiplist, final_state = "prepared")

	# Adjust the kube* packages for the control plane(s) and localhost to match the requested cluster version if necessary;
	# we could not do this before since the apt repository was not available then
	if len(args) > 1:
		requested_version = __find_requested_version(distro, args[1])
	else:
		requested_version = __find_requested_version(distro)

	# We need one final sanity check; we cannot install Kubernetes >= 1.26 if containerd < 1.6
	if cri == "containerd":
		ansible_retval, ansible_results = run_playbook(FilePath(f"{ANSIBLE_PLAYBOOK_DIR}/get_versions.yaml"), hosts = controlplanes, quiet = True)
		if ansible_retval != 0:
			print()
			iktprint([ANSIThemeString("Critical", "critical"),
                                  ANSIThemeString(": failed to get package versions; aborting.", "default")], stderr = True)
			update_installation_info(phase = "preparing")
			sys.exit(errno.ENOENT)

		for host, results in ansible_results.items():
			for result in results:
				if deep_get(result, DictPath("task"), "") != "package versions":
					continue
				data = deep_get(result, DictPath("msg_lines"), [])
				containerd_version = ""
				for package in data:
					if package.startswith(("containerd:", "containerd.io:")):
						containerd_version = package.split(" ")[1]
						break
				containerd_version_split = containerd_version.split(".")
				requested_version_split = requested_version.split(".")

				if int(containerd_version_split[0]) < 2 and int(containerd_version_split[1]) < 6 and int(requested_version_split[0]) >= 1 and int(requested_version_split[1]) >= 26:
					print()
					iktprint([ANSIThemeString("Critical", "critical"),
						  ANSIThemeString(": containerd ", "programname"),
						  ANSIThemeString("versions < ", "default"),
						  ANSIThemeString("1.6", "version"),
						  ANSIThemeString(" do not work with ", "default"),
						  ANSIThemeString("Kubernetes", "programname"),
						  ANSIThemeString(" >= ", "default"),
						  ANSIThemeString("1.26", "version"),
						  ANSIThemeString("; either use an older version of ", "default"),
						  ANSIThemeString("Kubernetes", "programname"),
						  ANSIThemeString(" or a newer version of ", "default"),
						  ANSIThemeString("containerd", "programname"),
						  ANSIThemeString("; aborting.", "default")], stderr = True)
					update_installation_info(phase = "preparing")
					sys.exit(errno.ENOTSUP)

	iktprint([ANSIThemeString("\n• ", "separator"),
		  ANSIThemeString("Updating installation information", "action")])

	iktprint([ANSIThemeString("   Requested version: ", "action"),
		  ANSIThemeString(requested_version, "version")])
	update_installation_info(requested_version = requested_version)

	iktprint([ANSIThemeString("\nControl plane preparation successful", "success")])
	print("\nNext step:")
	iktprint([ANSIThemeString("• ", "separator"),
		  ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
		  ANSIThemeString(" setup-control-plane ", "command"),
		  ANSIThemeString("[", "separator"),
		  ANSIThemeString("CNI", "argument"),
		  ANSIThemeString("]", "separator"),
		  ANSIThemeString(" [", "separator"),
		  ANSIThemeString("POD_NETWORK_CIDR", "argument"),
		  ANSIThemeString("]", "separator")])
	iktprint([ANSIThemeString("\nSee “", "separator"),
		  ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
		  ANSIThemeString(" help", "command"),
		  ANSIThemeString("“ for more information about valid ", "default"),
		  ANSIThemeString("CNI", "argument"),
		  ANSIThemeString(" options.\n", "default")])

def import_cluster(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Import an existing cluster to iKT

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	global no_password # pylint: disable=global-statement

	# default options
	confirm = True

	for opt, _optarg in options:
		if opt == "-Y":
			confirm = False
		elif opt == "--no-password":
			no_password = True

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)
	clusters = kh.list_clusters()
	available_clusters = [tmp[0] for tmp in clusters]

	pad = len("Cluster:")
	match = False
	for cluster_name, context in clusters:
		if len(args) > 0 and cluster_name not in args[0].split(","):
			continue
		pad = max(len(cluster_name), pad)
		match = True

	if len(args) > 0:
		for cluster in args[0].split(","):
			if cluster not in available_clusters and match == True:
				iktprint([ANSIThemeString("Warning", "warning"),
					  ANSIThemeString(": Ignoring non-existing cluster ", "default"),
					  ANSIThemeString(cluster, "hostname"),
					  ANSIThemeString("\n", "default")], stderr = True)

	if match == False:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": No matching clusters found; available clusters are:", "default")], stderr = True)
		for cluster in available_clusters:
			iktprint([ANSIThemeString("• ", "separator"),
				  ANSIThemeString(cluster, "hostname")])
		iktprint([ANSIThemeString("\nAborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	iktprint([ANSIThemeString("Cluster:", "header"),
		  ANSIThemeString("".ljust(pad + 2 - len("Cluster:")), "default"),
		  ANSIThemeString("Context:", "header")])
	for cluster_name, context in clusters:
		if len(args) > 0 and cluster_name not in args[0]:
			continue
		iktprint([ANSIThemeString(cluster_name, "hostname"),
			  ANSIThemeString("".ljust(pad + 2 - len(cluster_name)), "default"),
			  ANSIThemeString(context, "default")])

	if confirm == True:
		input_retval = iktinput([ANSIThemeString("\nImport the following clusters? [y/", "default"),
					 ANSIThemeString("N", "emphasis"),
					 ANSIThemeString("]: ", "default")])

		if input_retval.lower() not in ("y", "yes"):
			iktprint([ANSIThemeString("\nAborting:", "error"),
				  ANSIThemeString(" User stopped cluster import.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	iktprint([ANSIThemeString("\n[Importing cluster(s)]", "phase")])

	# Since the clusters might use different versions of Kubernetes
	# we always install the latest kubectl on localhost, so no need to adjust version

	contexts = kh.list_contexts()
	current_context = None
	for ctx in contexts:
		if ctx[0] == True:
			current_context = ctx[1]

	for cluster_name, context in clusters:
		if len(args) > 0 and cluster_name not in args[0]:
			continue

		kh.set_context(name = context)

		vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
		if status != 200:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": API-server returned ", "default"),
				  ANSIThemeString(f"{status}", "errorvalue"),
				  ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		if vlist is None:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": API-server did not return any data", "default")], stderr = True)
			sys.exit(errno.EINVAL)

		controlplane = None

		for node in vlist:
			node_name = deep_get(node, DictPath("metadata#name"))
			node_roles = kh.get_node_roles(cast(Dict, node))
			if "control-plane" in node_roles:
				controlplane = node_name
				break

		if controlplane is None:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": Could not find a control plane for the cluster ", "default"),
				  ANSIThemeString(cluster_name, "hostname"),
				  ANSIThemeString("; aborting.", "default")], stderr = True)
			# Remember to restore current-context
			kh.set_context(name = current_context)
			sys.exit(errno.ENOENT)

		__task_request_ansible_password(None)

		extra_values = {
			"ansible_become_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
			"ansible_ssh_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
		}

		install_ansible_posix()

		retval, ansible_results = run_playbook(FilePath(f"{ANSIBLE_PLAYBOOK_DIR}/prepare_passwordless_ansible.yaml"), hosts = [controlplane], extra_values = extra_values, quiet = True)
		if retval != 0:
			break

		tmp_cni = kh.identify_cni()
		if len(tmp_cni) != 1:
			cni = "<unknown>"
		else:
			cni = tmp_cni[0][0]

		retval, ansible_results = run_playbook(FilePath(f"{ANSIBLE_PLAYBOOK_DIR}/get_versions.yaml"), hosts = [controlplane], extra_values = extra_values, quiet = True)
		distro = "<unknown>"
		version = "<unknown>"
		if retval == 0:
			for host in ansible_results: # pylint: disable=consider-using-dict-items
				if str(host) != controlplane:
					continue

				data = ansible_results[host]["TASK: package versions"]["msg"].splitlines()
				for package in data:
					if package.startswith("kubeadm:"):
						distro = "kubeadm"
						version = package.split(" ")[1]
						break
				break

		update_installation_info(cluster_name = cluster_name, distro = distro, version = version, requested_version = "<none>", cni = cni, state = "installed", phase = "<none>", pod_network_cidr = "<FIXME>")

	kh.set_context(name = current_context)

	iktprint([ANSIThemeString("\nCluster import successful", "success")])

# pylint: disable-next=unused-argument
def check_for_updates(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Check whether there are newer versions of packages that are related to the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	# default options
	update_cache = True

	for opt, _optarg in options:
		if opt == "--no-cache-update":
			update_cache = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	iktprint([ANSIThemeString("\n[Checking for software updates]", "phase")])

	if update_cache == True:
		iktprint([ANSIThemeString("\n• ", "separator"),
			  ANSIThemeString("Updating APT cache", "action")])
		check_and_print_status(update_apt_cache())

	deb_packages = [
		"ansible",
		"ansible-mitogen",
		"containerd",
		"containerd.io",
		"cri-tools",
		"kubeadm",
		"kubectl",
		"kubelet",
		"kubernetes-cni",
		"kubernetes-client",
		"kubernetes-master",
		"kubernetes-node",
		"docker.io",
		"docker-ce",
		"python3-ansible-runner",
		"python3-natsort",
		"python3-openssl",
		"python3-paramiko",
		"python3-pip",
		"python3-ujson",
		"python3-urllib3",
		"runc",
	]

	version_checks: List = []

	print()
	check_versions(deb_packages, version_checks)
	print()

def show_configuration() -> None:
	"""
	Show cluster configuration
	"""

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	distro = installation_info[cluster_name]["distro"]
	version = installation_info[cluster_name]["version"]
	requested_version = installation_info[cluster_name]["requested_version"]
	cni = installation_info[cluster_name]["cni"]
	pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]
	cri = installation_info[cluster_name]["cri"]

	controlplanes = get_control_planes()

	http_proxy = deep_get(iktlib.iktconfig, DictPath("Network#http_proxy"), "")
	if http_proxy is not None and http_proxy == "":
		http_proxy = None
	http_proxy_env = os.getenv("http_proxy")
	if http_proxy_env is not None and http_proxy_env == "":
		http_proxy_env = None
	https_proxy = deep_get(iktlib.iktconfig, DictPath("Network#https_proxy"), "")
	if https_proxy is not None and https_proxy == "":
		https_proxy = None
	https_proxy_env = os.getenv("https_proxy")
	if https_proxy_env is not None and https_proxy_env == "":
		https_proxy_env = None
	no_proxy = deep_get(iktlib.iktconfig, DictPath("Network#no_proxy"), "")
	if no_proxy is not None and no_proxy == "":
		no_proxy = None
	no_proxy_env = os.getenv("no_proxy")
	if no_proxy_env is not None and no_proxy_env == "":
		no_proxy_env = None

	iktprint([ANSIThemeString("\n[Summary]", "phase")])
	iktprint([ANSIThemeString("\n• ", "separator"),
		  ANSIThemeString("Configuration:", "action")])
	iktprint([ANSIThemeString("        Cluster Name: ", "action"),
		  ANSIThemeString(f"{cluster_name}", "hostname")])
	iktprint([ANSIThemeString("        Distribution: ", "action"),
		  ANSIThemeString(f"{distro}", "programname")])
	iktprint([ANSIThemeString("   Installed Version: ", "action"),
		  __format_none(version, "version")])
	if requested_version is not None and requested_version != "<none>":
		iktprint([ANSIThemeString("   Requested Version: ", "action"),
			  __format_none(requested_version, "version")])
	if cni is not None and cni != "<none>":
		iktprint([ANSIThemeString("                 CNI: ", "action"),
			  ANSIThemeString(f"{cni}", "programname")])
	if pod_network_cidr is not None and pod_network_cidr != "<none>":
		iktprint([ANSIThemeString("    Pod Network CIDR: ", "action"),
			  ANSIThemeString(f"{pod_network_cidr}", "emphasis")])
	if cri is not None and cri != "<none>":
		iktprint([ANSIThemeString("                 CRI: ", "action"),
			  ANSIThemeString(f"{cri}", "programname")])
	iktprint([ANSIThemeString("          HTTP Proxy: ", "action"),
		  __format_none(http_proxy, "url"),
		  ANSIThemeString(" (", "default"),
		  ANSIThemeString(f"{IKT_CONFIG_FILE}", "path"),
		  ANSIThemeString(")", "default")])
	iktprint([ANSIThemeString("          HTTP Proxy: ", "action"),
		  __format_none(http_proxy_env, "url"),
		  ANSIThemeString(" (Environment)", "default")])
	iktprint([ANSIThemeString("         HTTPS Proxy: ", "action"),
		  __format_none(https_proxy, "url"),
		  ANSIThemeString(" (", "default"),
		  ANSIThemeString(f"{IKT_CONFIG_FILE}", "path"),
		  ANSIThemeString(")", "default")])
	iktprint([ANSIThemeString("         HTTPS Proxy: ", "action"),
		  __format_none(https_proxy_env, "url"),
		  ANSIThemeString(" (Environment)", "default")])
	iktprint([ANSIThemeString("            No Proxy: ", "action"),
		  __format_none(no_proxy, "url"),
		  ANSIThemeString(" (", "default"),
		  ANSIThemeString(f"{IKT_CONFIG_FILE}", "path"),
		  ANSIThemeString(")", "default")])
	iktprint([ANSIThemeString("            No Proxy: ", "action"),
		  __format_none(no_proxy_env, "url"),
		  ANSIThemeString(" (Environment)", "default")])
	if len(controlplanes) > 0:
		iktprint([ANSIThemeString("\n• ", "separator"),
			  ANSIThemeString("Control Plane(s):", "action")])
		for controlplane in controlplanes:
			iktprint([ANSIThemeString("            Hostname: ", "action"),
				  ANSIThemeString(f"{controlplane[0]} ", "emphasis"),
				  ANSIThemeString("(", "default"),
				  ANSIThemeString(f"{controlplane[1]}", "emphasis"),
				  ANSIThemeString(")", "default")])

def setup_control_plane(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Setup a control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	confirm = True
	override_cni = False

	# We do not need a cluster name for --list-tasks, so check this first of all
	if "--list-tasks" in (tmp[0] for tmp in options):
		__list_phases(setup_control_plane_tasks)
		sys.exit(0)

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	distro = installation_info[cluster_name]["distro"]
	requested_version = installation_info[cluster_name]["requested_version"]
	state = installation_info[cluster_name]["state"]
	phase: Union[str, int] = installation_info[cluster_name]["phase"]
	phase_skiplist = set(installation_info[cluster_name]["phase_skiplist"])
	cni = installation_info[cluster_name]["cni"]
	pod_network_cidr = installation_info[cluster_name]["pod_network_cidr"]

	if state is not None and state in ("installed", "upgrading", "tearing_down", "torn_down", "purging"):
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Invalid installation state; there is a partial or full installation already; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)
	elif state is None or state in ("<none>", "preparing"):
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": The system is not prepared for installation yet; run ", "default"),
			  ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
			  ANSIThemeString(" prepare", "command"),
			  ANSIThemeString(" before continuing. Aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if state == "prepared":
		phase = 0

	for opt, optarg in options:
		if opt == "--start-at-task":
			phase = __validate_task_index(setup_control_plane_tasks, optarg)
		elif opt == "--skip-tasks":
			skip_phases = __expand_index_list(optarg)
			for __phase in skip_phases:
				__validate_task_index(setup_control_plane_tasks, __phase)
			phase_skiplist = set(skip_phases)
		elif opt == "--resume":
			if phase is None or phase == "<none>":
				phase = 0
			elif phase == "<done>":
				iktprint([ANSIThemeString("Warning", "warning"),
					  ANSIThemeString(": Ignoring request to resume a completed installation. Exiting.", "default")], stderr = True)
				sys.exit(0)

			phase = __validate_task_index(setup_control_plane_tasks, phase)
		elif opt == "--override-cni":
			override_cni = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "-Y":
			confirm = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	if cni is None or cni == "<none>":
		if len(args) == 0:
			iktprint([ANSIThemeString("Warning", "warning"),
				  ANSIThemeString(": No CNI specified; defaulting to ", "default"),
				  ANSIThemeString(f"{DEFAULT_CNI}", "programname"),
				  ANSIThemeString(".", "default")], stderr = True)
			cni = DEFAULT_CNI
		elif cni != args[0]:
			cni = args[0]
	else:
		new_cni = cni
		if len(args) > 0:
			new_cni = args[0]

		if new_cni != cni:
			if override_cni == False:
				iktprint([ANSIThemeString("Error", "error"),
					  ANSIThemeString(": Installation was previous initiated with ", "default"),
					  ANSIThemeString(f"{cni}", "programname"),
					  ANSIThemeString(" as CNI; ", "default"),
					  ANSIThemeString("you can attempt to override this by using ", "default"),
					  ANSIThemeString("--override-cni", "option"),
					  ANSIThemeString(", but success is not guaranteed. Aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
			else:
				iktprint([ANSIThemeString("Warning", "warning"),
					  ANSIThemeString(": Installation was previous initiated with ", "default"),
					  ANSIThemeString(f"{cni}", "programname"),
					  ANSIThemeString(" as CNI, ", "default"),
					  ANSIThemeString("but ", "default"),
					  ANSIThemeString("--override-cni", "option"),
					  ANSIThemeString(" was specified; continuing installation.", "default")], stderr = True)
		cni = new_cni

	if len(args) > 1:
		new_pod_network_cidr = args[1]
	else:
		new_pod_network_cidr = DEFAULT_POD_NETWORK_CIDR
	if pod_network_cidr == "<none>" or pod_network_cidr == new_pod_network_cidr or phase == 0:
		pod_network_cidr = new_pod_network_cidr
	else:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Installation was previously initiated with ", "default"),
			  ANSIThemeString(f"{pod_network_cidr}", "emphasis"),
			  ANSIThemeString(" as Pod Network CIDR;\n", "default"),
			  ANSIThemeString("changing this value in the middle of installation is not supported. Aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	update_installation_info(cni = cni, pod_network_cidr = pod_network_cidr, state = "installing", phase = phase, phase_skiplist = list(phase_skiplist))

	show_configuration()

	if confirm == True:
		retval = iktinput([ANSIThemeString("\nStart installation? [y/", "default"),
				   ANSIThemeString("N", "emphasis"),
				   ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([ANSIThemeString("\nAborting:", "error"),
				  ANSIThemeString(" User stopped installation.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	iktprint([ANSIThemeString("\n[Setting up control plane]", "phase")])

	if distro == "kubeadm":
		setup_control_plane_targets["localhost"]["deb_packages"].remove("kubectl")
		setup_control_plane_targets["localhost"]["deb_packages"].append(f"kubectl={requested_version}")
		setup_control_plane_targets["kubeadm"]["deb_packages"].remove("kubectl")
		setup_control_plane_targets["kubeadm"]["deb_packages"].append(f"kubectl={requested_version}")
		setup_control_plane_targets["kubeadm"]["deb_packages"].remove("kubeadm")
		setup_control_plane_targets["kubeadm"]["deb_packages"].append(f"kubeadm={requested_version}")
		setup_control_plane_targets["kubeadm"]["deb_packages"].remove("kubelet")
		setup_control_plane_targets["kubeadm"]["deb_packages"].append(f"kubelet={requested_version}")

	run_tasks(tasks = setup_control_plane_tasks, phase = cast(int, phase), phase_skiplist = phase_skiplist, final_state = "installed")
	update_installation_info(version = requested_version)

	iktprint([ANSIThemeString("\nControl plane setup successful", "success")])

def __get_node_info(kh: Optional[kubernetes_helper.KubernetesHelper] = None) -> Tuple[List[Dict], kubernetes_helper.KubernetesHelper]:
	if not Path(KUBE_CONFIG_FILE).is_file():
		iktprint([ANSIThemeString("Critical", "critical"),
			  ANSIThemeString(": Could not find ", "default"),
			  ANSIThemeString(f"{KUBE_CONFIG_FILE}", "path"),
			  ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# The reason for importing inside the function is to avoid slow startup
	# when we do not use the Kubernetes helper
	if kh is None:
		from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
		kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	# If kh is *still* None here something has gone wrong. It is time to exit.
	if kh is None:
		iktprint([ANSIThemeString("Critical", "critical"),
			  ANSIThemeString(": Failed to initialise connection to API-server; do you have a running cluster? Aborting.", "default")], stderr = True)
		sys.exit(errno.ENXIO)

	node_statuses = []

	vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
	if status != 200:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": API-server returned ", "default"),
			  ANSIThemeString(f"{status}", "errorvalue"),
			  ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)
	if vlist is None:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": API-server did not return any data", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for node in vlist:
		node_name = deep_get(node, DictPath("metadata#name"))
		node_schedulable = not deep_get(node, DictPath("spec#unschedulable"), False)
		node_roles = kh.get_node_roles(cast(Dict, node))
		node_taints = deep_get(node, DictPath("spec#taints"), [])
		node_statuses.append({
			"name": node_name,
			"schedulable": node_schedulable,
			"roles": node_roles,
			"taints": node_taints,
		})

	return node_statuses, kh

def get_control_planes(fail_on_empty: bool = True) -> List[Tuple[str, str]]:
	"""
	Get a list of control planes defined in the inventory

		Parameters:
			fail_on_empty (bool): If True the action will fail if no control planes are defined in the inventory
		Returns:
			control_planes (list[hostname, ip]): A list of control planes
				hostname (str): The hostname
				ip (str): The IP-address
	"""

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	inventory = ansible_get_inventory_dict()
	__controlplanes = deep_get(inventory, DictPath("controlplane#hosts"), {})
	__clusterhosts = deep_get(inventory, DictPath(f"{cluster_name}#hosts"), {})
	controlplanes = []
	if len(__controlplanes) == 0 and fail_on_empty == True:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": No control plane(s) defined in the inventory; rebuilding the inventory using “", "default"),
			  ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME} ", "programname"),
			  ANSIThemeString("rebuild-inventory", "command"),
			  ANSIThemeString("“ might help. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)
	if len(__clusterhosts) == 0 and fail_on_empty == True:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": The cluster ", "default"),
			  ANSIThemeString(f"{cluster_name}", "hostname"),
			  ANSIThemeString(" has no hosts in the inventory; rebuilding the inventory using “", "default"),
			  ANSIThemeString(f"{about.INVENTORY_PROGRAM_NAME} ", "programname"),
			  ANSIThemeString("rebuild-inventory", "command"),
			  ANSIThemeString("“ might help. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	for controlplane in __controlplanes:
		# Only include control planes belonging to this cluster
		if controlplane not in __clusterhosts:
			continue
		ip = socket.gethostbyname(controlplane)
		controlplanes.append((controlplane, ip))
	return controlplanes

# pylint: disable-next=unused-argument
def teardown_control_plane(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Teardown an existing control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	confirm = True

	# We do not need a cluster name for --list-tasks, so check this first of all
	if "--list-tasks" in (tmp[0] for tmp in options):
		__list_phases(teardown_control_plane_tasks)
		sys.exit(0)

	if not Path(IKT_INSTALLATION_INFO_FILE).is_file():
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Could not find reliable installation information. Aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	distro = installation_info[cluster_name]["distro"]
	state = installation_info[cluster_name]["state"]
	phase: Union[str, int] = installation_info[cluster_name]["phase"]
	phase_skiplist = set(installation_info[cluster_name]["phase_skiplist"])

	if distro is None or distro == "<none>":
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Could not find reliable installation information. Aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if state is None:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Cannot determine installation state; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)
	elif state in ("preparing", "prepared", "torn_down"):
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": The system has no installed cluster; try ", "default"),
			  ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
			  ANSIThemeString(" purge-control-plane", "command"),
			  ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	for opt, optarg in options:
		if opt == "--start-at-task":
			phase = __validate_task_index(teardown_control_plane_tasks, optarg)
		elif opt == "--skip-tasks":
			skip_phases = __expand_index_list(optarg)
			for __phase in skip_phases:
				__validate_task_index(teardown_control_plane_tasks, __phase)
			phase_skiplist = set(skip_phases)
		elif opt == "--resume":
			if phase is None or phase == "<none>":
				phase = 0
			elif phase == "<done>":
				iktprint([ANSIThemeString("Warning", "warning"),
					  ANSIThemeString(": Ignoring request to resume a completed teardown. Exiting.", "default")], stderr = True)
				sys.exit(0)

			phase = __validate_task_index(setup_control_plane_tasks, phase)
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "-Y":
			confirm = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	show_configuration()

	if confirm == True:
		retval = iktinput([ANSIThemeString("\nStart teardown? [y/", "default"),
				   ANSIThemeString("N", "emphasis"),
				   ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([ANSIThemeString("\nAborting:", "error"),
				  ANSIThemeString(" User stopped teardown.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	iktprint([ANSIThemeString("\n[Tearing down cluster]", "phase")])

	installation_info = update_installation_info(state = "tearing_down", phase = 0)

	run_tasks(tasks = teardown_control_plane_tasks, phase = cast(int, phase), phase_skiplist = phase_skiplist, final_state = "torn_down")
	iktprint([ANSIThemeString("\nCluster teardown successful", "success")])

def purge_control_plane(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Purge an existing control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	confirm = True

	# We do not need a cluster name for --list-tasks, so check this first of all
	if "--list-tasks" in (tmp[0] for tmp in options):
		__list_phases(purge_control_plane_tasks)
		sys.exit(0)

	if not Path(IKT_INSTALLATION_INFO_FILE).is_file():
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Could not find reliable installation information. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	state = installation_info[cluster_name]["state"]
	phase: Union[str, int] = installation_info[cluster_name]["phase"]
	phase_skiplist = set(installation_info[cluster_name]["phase_skiplist"])

	if state is None or state in ("preparing", "installing", "upgrading"):
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Invalid installation state; there's no fully installed cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(options) == 0:
		phase = 0

	for opt, optarg in options:
		if opt == "--start-at-task":
			phase = __validate_task_index(teardown_control_plane_tasks, optarg)
		elif opt == "--skip-tasks":
			skip_phases = __expand_index_list(optarg)
			for __phase in skip_phases:
				__validate_task_index(teardown_control_plane_tasks, __phase)
			phase_skiplist = set(skip_phases)
		elif opt == "--resume":
			if phase is None or phase == "<none>":
				phase = 0
			elif phase == "<done>":
				iktprint([ANSIThemeString("Warning", "warning"),
					  ANSIThemeString(": Ignoring request to resume a completed teardown. Exiting.", "default")], stderr = True)
				sys.exit(0)

			phase = __validate_task_index(setup_control_plane_tasks, phase)
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "-Y":
			confirm = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	# If there is still an installed cluster or if the teardown has not finished, teardown the cluster before purging
	if state in ("installed", "upgraded", "tearing_down"):
		teardown_control_plane(options, args)
		state = "torn_down"
	else:
		show_configuration()

		if confirm == True:
			retval = iktinput([ANSIThemeString("\nStart purge? [y/", "default"),
					   ANSIThemeString("N", "emphasis"),
					   ANSIThemeString("]: ", "default")])
			if retval.lower() not in ("y", "yes"):
				iktprint([ANSIThemeString("\nAborting:", "error"),
					  ANSIThemeString(" User stopped purge.", "default")], stderr = True)
				sys.exit(errno.EINTR)

	iktprint([ANSIThemeString("\n\n[Purging cluster configuration and software]", "phase")])

	# If we are purging the control plane we want to leave kubectl behind; if we have a setup with multiple
	# control planes and we run this from one of them, then kubectl will remain on the other two.
	if __selection_localhost() == __selection_control_planes():
		purge_control_plane_targets["kubeadm"]["deb_packages"].remove("kubectl")
		purge_control_plane_targets["kubeadm"]["deb_packages_held"].remove("kubectl")

	installation_info = update_installation_info(state = "purging", phase = 0)

	run_tasks(tasks = purge_control_plane_tasks, phase = cast(int, phase), phase_skiplist = phase_skiplist, final_state = "purged")
	secure_rm(IKT_INSTALLATION_INFO_FILE, ignore_non_existing = True)

	iktprint([ANSIThemeString("\nCluster purge successful", "success")])

	iktprint([ANSIThemeString("\nNote", "note"),
		  ANSIThemeString(": It is recommended to reboot the control plane(s) after purging the cluster\n", "default")])

def upgrade_control_plane(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Upgrade a control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	confirm = True

	# default options
	update_cache = True
	allow_reinstall = False
	requested_version = None

	# We do not need a cluster name for --list-tasks or --override, so check this first of all
	if "--list-tasks" in (tmp[0] for tmp in options):
		__list_phases(upgrade_control_plane_tasks)
		sys.exit(0)
	elif "--override" in (tmp[0] for tmp in options):
		if Path(IKT_INSTALLATION_INFO_FILE).is_file():
			iktprint([ANSIThemeString("Warning", "warning"),
				  ANSIThemeString(": Overriding ", "default"),
				  ANSIThemeString(f"{IKT_INSTALLATION_INFO_FILE}", "path"),
				  ANSIThemeString("; this may cause issues.", "default")], stderr = True)
		else:
			iktprint([ANSIThemeString("Note", "note"),
				  ANSIThemeString(": ", "default"),
				  ANSIThemeString(f"{IKT_INSTALLATION_INFO_FILE}", "path"),
				  ANSIThemeString(" does not exist; rebuilding.", "default")])
		rebuild_installation_info(state = "upgrading")

	installation_info = get_installation_info()
	cluster_name = installation_info["installation_target"]
	distro = installation_info[cluster_name]["distro"]
	version = installation_info[cluster_name]["version"]
	requested_version = installation_info[cluster_name]["requested_version"]
	state = installation_info[cluster_name]["state"]
	phase: Union[str, int] = installation_info[cluster_name]["phase"]
	phase_skiplist = set(installation_info[cluster_name]["phase_skiplist"])

	if state is None or state == "<none>":
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Unknown installation state; if you believe this is OK (such as when upgrading a cluster not installed using ", "default"),
			  ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
			  ANSIThemeString(" you can try using the “", "default"),
			  ANSIThemeString("--override", "option"),
			  ANSIThemeString("“ option; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if state in ("preparing", "prepared", "installing", "tearing_down", "torn_down", "purging"):
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Invalid installation state; Kubernetes does not seems to be fully installed; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if state in ("installed", "upgraded"):
		phase = 0

	if len(args) > 0:
		requested_version = __find_requested_version(distro, args[0])
	else:
		requested_version = __find_requested_version(distro)

	for opt, optarg in options:
		if opt == "--start-at-task":
			phase = __validate_task_index(upgrade_control_plane_tasks, optarg)
		elif opt == "--skip-tasks":
			skip_phases = __expand_index_list(optarg)
			for __phase in skip_phases:
				__validate_task_index(upgrade_control_plane_tasks, __phase)
			phase_skiplist = set(skip_phases)
		elif opt == "--resume":
			if phase is None or phase == "<none>":
				phase = 0
			elif phase == "<done>":
				iktprint([ANSIThemeString("Warning", "warning"),
					  ANSIThemeString(": Ignoring request to resume a completed upgrade. Exiting.", "default")], stderr = True)
				sys.exit(0)

			phase = __validate_task_index(upgrade_control_plane_tasks, phase)
		elif opt == "--no-cache-update":
			update_cache = False
		elif opt == "--reinstall":
			allow_reinstall = True
		elif opt in ("--override", "--list-tasks"):
			continue
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "-Y":
			confirm = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	# XXX: How do we check that nodes are drained? We can check whether they are cordoned
	node_status, _kh = __get_node_info()

	if node_status is None:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": No ", "default"),
			  ANSIThemeString(f"{HOMEDIR}/.kube/config", "path"),
			  ANSIThemeString(" available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if update_cache == True:
		iktprint([ANSIThemeString("\n• ", "separator"),
			  ANSIThemeString("Updating APT cache", "action")])
		check_and_print_status(update_apt_cache())

	iktprint([ANSIThemeString("\n• ", "separator"),
		  ANSIThemeString("Running sanity checks", "action")])

	deb_versions = check_deb_versions(["kubeadm"])

	if len(deb_versions) == 0:
		iktprint([ANSIThemeString("Critical", "critical"),
			  ANSIThemeString(": No candidate version for ", "default"),
			  ANSIThemeString("kubeadm", "programname"),
			  ANSIThemeString(" available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if requested_version is not None:
		if requested_version not in deb_versions[0][3]:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": The requested version ", "default"),
				  ANSIThemeString(f"{requested_version}", "version"),
				  ANSIThemeString(" is not available; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		elif requested_version == version:
			if allow_reinstall == False:
				iktprint([ANSIThemeString("Warning", "warning"),
					  ANSIThemeString(": The requested version ", "default"),
					  ANSIThemeString(f"{requested_version}", "version"),
					  ANSIThemeString(" is already installed; to reinstall use the option “", "default"),
					  ANSIThemeString("--reinstall", "option"),
					  ANSIThemeString("“.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
		elif deb_compare_versions(version, requested_version) == True:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": The requested version ", "default"),
				  ANSIThemeString(f"{requested_version}", "version"),
				  ANSIThemeString(" is older than than the installed version ", "default"),
				  ANSIThemeString(f"{deb_versions[0][1]}", "version"),
				  ANSIThemeString(". Downgrades are not supported; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
	else:
		requested_version = deb_versions[0][2]
		if len(requested_version) == 0 or requested_version == "<none>":
			iktprint([ANSIThemeString("Note", "note"),
				  ANSIThemeString(": The latest version ", "default"),
				  ANSIThemeString(f"{deb_versions[0][1]}", "version"),
				  ANSIThemeString(" is already installed.", "default")])
			sys.exit(0)

	# Is this an major, minor, or patchrev upgrade?
	installed_version_tuple = version.split(".")
	requested_version_tuple = requested_version.split(".")

	upgrade_type = None

	if installed_version_tuple[0] != requested_version_tuple[0]:
		iktprint([ANSIThemeString("Error", "error"),
			  ANSIThemeString(": Upgrades between ", "default"),
			  ANSIThemeString("MAJOR", "emphasis"),
			  ANSIThemeString(" versions is currently not supported (installed version: ", "default"),
			  ANSIThemeString(f"{deb_versions[0][1]}", "version"),
			  ANSIThemeString(", requested version: ", "default"),
			  ANSIThemeString(f"{requested_version}", "version"),
			  ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOTSUP)
	elif installed_version_tuple[1] != requested_version_tuple[1]:
		if int(requested_version_tuple[1]) - int(installed_version_tuple[1]) > 1:
			iktprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": Skipping ", "default"),
				  ANSIThemeString("MINOR", "emphasis"),
				  ANSIThemeString(" versions is not supported, please perform the following upgrades sequentially:", "default")], stderr = True)
			minor_versions: Dict = {}
			for version in reversed(deb_versions[0][3]):
				version_tuple = version.split(".")
				major_minor = f"{version_tuple[0]}.{version_tuple[1]}"
				if int(version_tuple[1]) > int(installed_version_tuple[1]) and int(version_tuple[1]) <= int(requested_version_tuple[1]) and (major_minor not in minor_versions or minor_versions[major_minor] < version_tuple[2]):
					minor_versions[major_minor] = version_tuple[2]
			for version, minor_version in minor_versions.items():
				iktprint([ANSIThemeString("• ", "separator"),
					  ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
					  ANSIThemeString(" upgrade-control-plane", "command"),
					  ANSIThemeString(f" {version}.{minor_version}", "version")])
			sys.exit(errno.EINVAL)
		else:
			upgrade_type = "minor"
	else:
		upgrade_type = "patchrev"

	# If this is an upgrade to a new patchrev the cluster does not have to be drained
	if upgrade_type == "minor":
		schedulable_count = 0
		nodes_to_drain = ""
		for node in node_status:
			if node["schedulable"] == False:
				continue

			if "control-plane" in node["roles"]:
				continue

			if schedulable_count == 0:
				iktprint([ANSIThemeString("\nError", "error"),
					  ANSIThemeString(": The following nodes need to be drained; aborting.", "default")])
			schedulable_count += 1
			iktprint([ANSIThemeString("• ", "separator"),
				  ANSIThemeString(f"{node['name']}", "emphasis")])
			nodes_to_drain += node['name']

		if schedulable_count > 0:
			iktprint([ANSIThemeString("\nThis can be achieved with: “", "default"),
				  ANSIThemeString("kubectl ", "programname"),
				  ANSIThemeString("drain ", "command"),
				  ANSIThemeString("--ignore-daemonsets --delete-emptydir-data ", "option"),
				  ANSIThemeString(f"{nodes_to_drain}", "url"),
				  ANSIThemeString("“", "default")])
			sys.exit(errno.EBUSY)

	installation_info = update_installation_info(state = "upgrading", requested_version = requested_version, phase = 0)

	# If we got here all the sanity checks were successful
	iktprint([ANSIThemeString("OK", "ok")])

	# Adjust package version for localhost
	upgrade_control_plane_targets["localhost"]["deb_packages"].remove("kubectl")
	upgrade_control_plane_targets["localhost"]["deb_packages"].append(f"kubectl={requested_version}")

	show_configuration()

	if confirm == True:
		retval = iktinput([ANSIThemeString("\nStart upgrade? [y/", "default"),
				   ANSIThemeString("N", "emphasis"),
				   ANSIThemeString("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([ANSIThemeString("\nAborting:", "error"),
				  ANSIThemeString(" User stopped upgrade.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	iktprint([ANSIThemeString("\n[Upgrading control plane]", "phase")])

	run_tasks(tasks = upgrade_control_plane_tasks, phase = cast(int, phase), phase_skiplist = phase_skiplist, final_state = "upgraded")
	values = {
		"control_plane_k8s_version": requested_version,
	}
	ansible_set_vars(ANSIBLE_INVENTORY, "all", values)
	update_installation_info(version = requested_version)

	iktprint([ANSIThemeString("\nControl plane upgrade successful", "success")])

# pylint: disable-next=unused-argument
def taint_control_plane(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Taint a control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	node_statuses, kh = __get_node_info()

	if node_statuses is None:
		iktprint([ANSIThemeString("Critical", "critical"),
			  ANSIThemeString(": Failed to get node information; do you have a running cluster? Aborting.", "default")], stderr = True)
		sys.exit(errno.ENXIO)

	first = True

	for node in node_statuses:
		if "control-plane" in node["roles"] and (len(args) == 0 or node["name"] in args):
			if first == True:
				iktprint([ANSIThemeString("Tainting control plane(s):", "header")])
				first = False
			iktprint([ANSIThemeString(node["name"], "hostname")])
			_message, status = kh.taint_node(node["name"], node["taints"], ("node-role.kubernetes.io/control-plane", None, None, "NoSchedule"))
			if status == 304:
				iktprint([ANSIThemeString("  Not modified", "none")])
			elif status == 200:
				iktprint([ANSIThemeString("  Tainted", "success")])
			else:
				iktprint([ANSIThemeString("  Failed to modify taint", "error"),
					  ANSIThemeString(f"; HTTP error {status}; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

		if "master" in node["roles"] and (len(args) == 0 or node["name"] in args):
			if first == True:
				iktprint([ANSIThemeString("Tainting control plane(s):", "header")])
				first = False
			iktprint([ANSIThemeString(node["name"], "hostname")])
			_message, status = kh.taint_node(node["name"], node["taints"], ("node-role.kubernetes.io/master", None,  None, "NoSchedule"))
			if status == 304:
				iktprint([ANSIThemeString("  Not modified", "none")])
			elif status == 200:
				iktprint([ANSIThemeString("  Tainted", "success")])
			else:
				iktprint([ANSIThemeString("  Failed to modify taint", "error"),
					  ANSIThemeString(f"; HTTP error {status}; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

	if first == True:
		iktprint([ANSIThemeString("Warning", "warning"),
			  ANSIThemeString(": No matching control planes found. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

# pylint: disable-next=unused-argument
def untaint_control_plane(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Untaint a control plane

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	node_statuses, kh = __get_node_info()

	if node_statuses is None:
		iktprint([ANSIThemeString("Critical", "critical"),
			  ANSIThemeString(": Failed to get node information; do you have a running cluster? Aborting.", "default")], stderr = True)
		sys.exit(errno.ENXIO)

	first = True

	for node in node_statuses:
		if "control-plane" in node["roles"] and (len(args) == 0 or node["name"] in args):
			if first == True:
				iktprint([ANSIThemeString("Untainting control plane(s):", "header")])
				first = False
			iktprint([ANSIThemeString(node["name"], "hostname")])
			_message, status = kh.taint_node(node["name"], node["taints"], ("node-role.kubernetes.io/control-plane", None, None, None))
			if status == 304:
				iktprint([ANSIThemeString("  Not modified", "none")])
			elif status == 200:
				iktprint([ANSIThemeString("  Untainted", "success")])
			else:
				iktprint([ANSIThemeString("  Failed to modify taint", "error"),
					  ANSIThemeString(f"; HTTP error {status}; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

		if "master" in node["roles"] and (len(args) == 0 or node["name"] in args):
			if first == True:
				iktprint([ANSIThemeString("Untainting control plane(s):", "header")])
				first = False
			iktprint([ANSIThemeString(node["name"], "hostname")])
			_message, status = kh.taint_node(node["name"], node["taints"], ("node-role.kubernetes.io/master", None, None, None))
			if status == 304:
				iktprint([ANSIThemeString("  Not modified", "none")])
			elif status == 200:
				iktprint([ANSIThemeString("  Untainted", "success")])
			else:
				iktprint([ANSIThemeString("  Failed to modify taint", "error"),
					  ANSIThemeString(f"; HTTP error {status}; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

	if first == True:
		iktprint([ANSIThemeString("Warning", "warning"),
			  ANSIThemeString(": No matching control planes found. Aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

# pylint: disable=unused-argument,redefined-outer-name
def run_checks(checks: List[Dict], **kwargs) -> bool:
	"""
	Run a batch of checks, and output the result.
	The checks can return 4 different severities; critical, error, warning, and note.

		Parameters:
			checks (list[dict]): A list with all checks to run
		Return:
			clean_run (bool): True if nothing higher than "note" was returned, False otherwise
	"""

	critical: int = 0
	error: int = 0
	warning: int = 0
	note: int = 0
	skip: int = 0

	user = ""
	cluster_name = ""
	kubeconfig: Dict = {}

	for check in checks:
		preconditions = deep_get(check, DictPath("preconditions"), [])
		if "user" in preconditions and len(user) == 0:
			user = getuser()
		if "clusterinfo" in preconditions and len(kubeconfig) == 0:
			if not Path(KUBE_CONFIG_DIR).is_dir():
				iktprint([ANSIThemeString(deep_get(check, DictPath("description"), ""), "phase")])
				iktprint([ANSIThemeString("  Warning:", "warning"),
					  ANSIThemeString(f" {KUBE_CONFIG_DIR} ", "path"),
					  ANSIThemeString("does not exist; most likely there's no cluster; skipping.\n", "default")], stderr = True)
				skip += 1
				continue
			if not Path(KUBE_CONFIG_FILE).is_file():
				iktprint([ANSIThemeString(deep_get(check, DictPath("description"), ""), "phase")])
				iktprint([ANSIThemeString("  Warning:", "warning"),
					  ANSIThemeString(f" {KUBE_CONFIG_FILE} ", "path"),
					  ANSIThemeString("does not exist; most likely there's no cluster; skipping.\n", "default")], stderr = True)
				skip += 1
				continue
			kubeconfig = secure_read_yaml(KUBE_CONFIG_FILE)
			cluster_name = cast(str, get_cluster_name())

		call = deep_get(check, DictPath("call"))
		if call is not None:
			critical, error, warning, note = call(cluster_name, kubeconfig, iktlib.iktconfig, user, critical, error, warning, note, **kwargs)

	iktprint([ANSIThemeString("Summary:", "header")])
	iktprint([ANSIThemeString("Critical", "critical"), ANSIThemeString(f": {critical}", "error")])
	iktprint([ANSIThemeString(f"  Errors: {error}", "error")])
	iktprint([ANSIThemeString(f"Warnings: {warning}", "warning")])
	iktprint([ANSIThemeString(f" Skipped: {skip}", "emphasis")])
	iktprint([ANSIThemeString(f"   Notes: {note}", "note")])

	return critical + error + warning == 0

security_audit_checks = [
	{
		"description": "Check whether strict host key checking has been disabled",
		"call": checks.check_security_disable_strict_host_key_checking,
	},
	{
		"description": "Check for insecure kube config options",
		"call": checks.check_insecure_kube_config_options,
		"preconditions": [
			"clusterinfo",
		],
	}, {
		"description": "Check for insecure file permissions",
		"call": checks.check_file_permissions,
		"preconditions": [
			"user",
		],
	},
]

# pylint: disable-next=unused-argument
def audit(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Run security audit checks

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	usergroup = ""

	for opt, optarg in options:
		if opt == "--usergroup":
			usergroup = optarg
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	kwargs = {
		"usergroup": usergroup
	}

	clean_run = run_checks(security_audit_checks, **kwargs)

	if clean_run == True:
		iktprint([ANSIThemeString("\nImportant:", "emphasis"),
			  ANSIThemeString(" iktadm", "programname"),
			  ANSIThemeString(" audit", "command"),
			  ANSIThemeString(" currently only checks for a very limited set of issues;", "default")])
		iktprint([ANSIThemeString("a perfect score is not a guarantee that your installation is secure.", "default")])

preflight_checks = [
	{
		"description": "Check whether the user can sudo without a password on localhost",
		"call": checks.check_sudo_configuration,
		"preconditions": [
			"user",
		],
	}, {
		"description": "Check whether SSH known_hosts hashing is enabled on localhost",
		"call": checks.check_known_hosts_hashing,
	}, {
		"description": "Check control plane for suitability",
		"call": checks.check_control_plane,
	}
]

def preflight_check(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Run preflight checks before creating a new cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	global no_password # pylint: disable=global-statement

	for opt, _optarg in options:
		if opt == "-Y":
			confirm = False
		elif opt == "--no-password":
			no_password = True

	control_planes = [args[0]]

	__task_request_ansible_password(None)

	clean_run = run_checks(preflight_checks, hosts = control_planes)

	if clean_run == True:
		iktprint([ANSIThemeString("\nImportant:", "emphasis"),
			  ANSIThemeString(" iktadm", "programname"),
			  ANSIThemeString(" preflight-check", "command"),
			  ANSIThemeString(" currently only checks for a very limited set of issues;", "default")])
		iktprint([ANSIThemeString("a perfect score is not a guarantee that installation will succeed.", "default")])

troubleshoot_checks = [
	# First start with the really basic: does the cluster respond?
	# Check no_proxy, perhaps?
	{
		"description": "Check whether client / server versions match",
		"call": checks.check_client_server_version_match,
		"preconditions": [
			"clusterinfo",
		],
	}, {
		"description": "Check kubelet and kube-proxy versions",
		"call": checks.check_kubelet_and_kube_proxy_versions,
		"preconditions": [
			"clusterinfo",
		],
	},
	# Check kube-controller-manager, kube-scheduler, and cloud-controller-manager;
	# they should match, but can be up to one version older,
	# but must not be newer

	# check whether role bindings and cluster role bindings refer to non-existing roles/cluster roles
]

# pylint: disable-next=unused-argument
def troubleshoot(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	Troubleshoot issues in the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	clean_run = run_checks(troubleshoot_checks)

	if clean_run == True:
		iktprint([ANSIThemeString("\nImportant:", "emphasis"),
			  ANSIThemeString(" iktadm", "programname"),
			  ANSIThemeString(" troubleshoot", "command"),
			  ANSIThemeString(" currently only checks for a very limited set of issues;", "default")])
		iktprint([ANSIThemeString("a perfect score is not a guarantee that your cluster is problem free.", "default")])

COMMANDLINE = {
	"Check Versions": {
		"command": ["check-versions", "cv"],
		"description": [ANSIThemeString("Update the package cache and show software versions", "description")],
		"extended_description": [
			[ANSIThemeString("Note", "note"),
			 ANSIThemeString(": some of the listed software may not be relevant", "description")],
			[ANSIThemeString("to the configuration in use.", "description")],
		],
		"options": {
			"--no-cache-update": {
				"description": [ANSIThemeString("Do not update the APT cache", "description")],
			},
		},
		"min_args": 0,
		"max_args": 0,
		"callback": check_for_updates,
	},
	"Import Cluster": {
		"command": ["import-cluster"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("CLUSTER_NAME", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString(f"Import existing cluster(s) and prepare them for use with {about.PROGRAM_SUITE_NAME}", "description")],
		"extended_description": [
			[ANSIThemeString("If ", "description"),
			 ANSIThemeString("CLUSTER_NAME", "argument"),
			 ANSIThemeString(",", "separator"),
			 ANSIThemeString("...", "argument"),
			 ANSIThemeString(" is not specified all clusters in ", "description"),
			 ANSIThemeString(f"{HOMEDIR}/.kube/config", "path")],
			[ANSIThemeString("will be imported.", "description")],
		],
		"options": {
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation before performing actions", "description")],
			},
			"--no-password": {
				"description": [ANSIThemeString("Do not prompt for a password; use this if the hosts you are preparing are already configured for login using an SSH key", "description")],
			},
		},
		"min_args": 0,
		"max_args": 1,
		"callback": import_cluster,
	},
	"Prepare Installation": {
		"command": ["prepare"],
		"values": [ANSIThemeString("CLUSTER_NAME", "argument"),
			   ANSIThemeString(" [", "separator"),
			   ANSIThemeString("KUBERNETES_VERSION", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Install and configure pre-requisites; run this before ", "description"),
				ANSIThemeString("setup-control-plane", "command")],
		"extended_description": [
			[ANSIThemeString("If no version is specified the newest available version will be used.", "description")],
		],
		"options": {
			"--control-plane": {
				"values": [ANSIThemeString("HOST", "argument")],
				"extended_description": [
					[ANSIThemeString("Note", "note"),
					 ANSIThemeString(": ", "description"),
					 ANSIThemeString("HOST", "argument"),
					 ANSIThemeString(" should be a resolvable hostname; using IP-addresses may cause issues.", "description")],
					[ANSIThemeString("If the host intended for use as control plane in the cluster does not have a resolvable", "description")],
					[ANSIThemeString("hostname it is recommended to use ", "description"),
					 ANSIThemeString("/etc/hosts", "path"),
					 ANSIThemeString(" for this purpose.", "description")],
				],
				"description": [ANSIThemeString("Use ", "description"),
						ANSIThemeString("HOST", "argument"),
						ANSIThemeString(" as control plane ", "description")],
				"requires_arg": True,
			},
			"--resume": {
				"description": [ANSIThemeString("Resume preparation; can be used if preparation was aborted", "description")],
			},
			"--start-at-task": {
				"values": [ANSIThemeString("TASK", "argument")],
				"description": [ANSIThemeString("Start at ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" instead of running all tasks", "description")],
				"requires_arg": True,
				"validator": "int",
				"valid_range": (0, None),
			},
			"--skip-tasks": {
				"values": [ANSIThemeString("TASK", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Skip ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(",", "separator"),
						ANSIThemeString("...", "argument")],
				"requires_arg": True,
				"validator": "int",
				"valid_range": (0, None),
				"list_separator": ",",
			},
			"--list-tasks": {
				"description": [ANSIThemeString("List valid values for ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" to use with ", "description"),
						ANSIThemeString("--start-at-task", "option"),
						ANSIThemeString(" and ", "description"),
						ANSIThemeString("--skip-tasks", "option")],
			},
			"--no-password": {
				"description": [ANSIThemeString("Do not prompt for a password; use this if the hosts you are preparing are already configured for login using an SSH key", "description")],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs; the logs can be viewed using “", "description"),
						ANSIThemeString("iku", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
			},
			"--cri": {
				"values": [ANSIThemeString("CRI", "argument")],
				"description": [ANSIThemeString("Use ", "description"),
						ANSIThemeString("CRI", "argument"),
						ANSIThemeString(" instead of the default CRI", "description")],
				"extended_description": [
					[ANSIThemeString("Valid options for CRI (Container Runtime Interface) are:", "description")],
					[ANSIThemeString("dockershim", "argument"),
					 ANSIThemeString(" (", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" < ", "description"),
					 ANSIThemeString("1.24", "version"),
					 ANSIThemeString(")", "description"),
					 ANSIThemeString(", ", "separator"),
					 ANSIThemeString("containerd", "argument"),
					 ANSIThemeString(", ", "separator"),
					],
					[ANSIThemeString("manual", "argument"),
					 ANSIThemeString(" (do not install a CRI; this requires you to manually install and configure the CRI).", "description"),
					],
					[ANSIThemeString("The default CRI is ", "description"),
					 ANSIThemeString("dockershim", "argument"),
					 ANSIThemeString(" for ", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" < ", "description"),
					 ANSIThemeString("1.24", "version")],
					[ANSIThemeString("and ", "description"),
					 ANSIThemeString("containerd", "argument"),
					 ANSIThemeString(" for ", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.24", "version"),
					 ANSIThemeString(".", "description")],
					[ANSIThemeString("Note", "note"),
					 ANSIThemeString(": ", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.26", "version"),
					 ANSIThemeString(" requires ", "description"),
					 ANSIThemeString("containerd", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.6", "version"),
					 ANSIThemeString(".", "description")],
				],
				"requires_arg": True,
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation before performing actions", "description")],
			},
		},
		"min_args": 0,
		"max_args": 2,
		"callback": prepare_installation,
	},
	"Setup Control Plane": {
		"command": ["setup-control-plane"],
		"values": [
			ANSIThemeString("[", "separator"),
			ANSIThemeString("CNI", "argument"),
			ANSIThemeString("]", "separator"),
			ANSIThemeString(" [", "separator"),
			ANSIThemeString("POD_NETWORK_CIDR", "argument"),
			ANSIThemeString("]", "separator"),
		],
		"description": [ANSIThemeString("Setup and launch the control plane", "description")],
		"extended_description": [
			[ANSIThemeString("Valid options for CNI (Container Network Interface, aka Pod Network): ", "description")],
			[ANSIThemeString("antrea", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("calico", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("canal", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("cilium", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("flannel", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("kube-router", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("weave", "argument"),
			],
			[ANSIThemeString("By default ", "description"),
			 ANSIThemeString("cilium", "argument"),
			 ANSIThemeString(" will be used as CNI", "description")],
			[ANSIThemeString("and ", "description"),
			 ANSIThemeString("10.244.0.0/16", "argument"),
			 ANSIThemeString(" will be used as pod network CIDR.", "description")],
		],
		"options": {
			"--resume": {
				"description": [ANSIThemeString("Resume installation; can be used if installation was aborted", "description")],
			},
			"--start-at-task": {
				"values": [ANSIThemeString("TASK", "argument")],
				"description": [ANSIThemeString("Start at ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" instead of running all tasks", "description")],
				"requires_arg": True,
			},
			"--skip-tasks": {
				"values": [ANSIThemeString("TASK", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Skip ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(",", "separator"),
						ANSIThemeString("...", "argument")],
				"requires_arg": True,
				"validator": "int",
				"valid_range": (0, None),
				"list_separator": ",",
			},
			"--list-tasks": {
				"description": [ANSIThemeString("List valid values for ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" to use with ", "description"),
						ANSIThemeString("--start-at-task", "option"),
						ANSIThemeString(" and ", "description"),
						ANSIThemeString("--skip-tasks", "option")],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs; the logs can be viewed using “", "description"),
						ANSIThemeString("iku", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
			},
			"--override-cni": {
				"description": [ANSIThemeString("Allow a change of CNI even if installation started with a different CNI", "description")],
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation before performing actions", "description")],
			},
		},
		"min_args": 0,
		"max_args": 2,
		"callback": setup_control_plane,
	},
	"Upgrade CNI": {
		"command": ["upgrade-cni"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("CNI", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Upgrade the CNI", "description")],
		"extended_description": [
			[ANSIThemeString("Upgrades the CNI (currently only ", "description"),
			 ANSIThemeString("calico", "argument"),
			 ANSIThemeString(" and ", "description"),
			 ANSIThemeString("cilium", "argument"),
			 ANSIThemeString(" are supported).", "description")],
		],
		"min_args": 0,
		"max_args": 1,
		"callback": upgrade_cni,
	},
	"Upgrade Control Plane": {
		"command": ["upgrade-control-plane"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("KUBERNETES_VERSION", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Upgrade the control plane", "description")],
		"extended_description": [
			[ANSIThemeString("Upgrades the control plane to ", "description"),
			 ANSIThemeString("KUBERNETES_VERSION", "argument"),
			 ANSIThemeString(" if specified;", "description")],
			[ANSIThemeString("if no version is specified the newest available version will be used.", "description")],
			[ANSIThemeString("Upgrading requires all nodes to be drained first.  Once the control plane", "description")],
			[ANSIThemeString("has been upgraded you ", "description"),
			 ANSIThemeString("must", "emphasis"),
			 ANSIThemeString(" upgrade all nodes to the same version.", "description")],
			[ANSIThemeString("Important", "emphasis"),
			 ANSIThemeString(": skipping PATCH REVISIONS is acceptable,", "description")],
			[ANSIThemeString("but when upgrading to a newer MINOR version all intermediate MINOR versions", "description")],
			[ANSIThemeString("must be installed first; this applies to nodes too.", "description")],
		],
		"options": {
			"--no-cache-update": {
				"description": [ANSIThemeString("Do not update the APT cache", "description")],
			},
			"--resume": {
				"description": [ANSIThemeString("Resume upgrade; can be used if upgrade was aborted", "description")],
			},
			"--start-at-task": {
				"values": [ANSIThemeString("TASK", "argument")],
				"description": [ANSIThemeString("Start at ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" instead of running all tasks", "description")],
				"requires_arg": True,
				"validator": "int",
				"valid_range": (0, None),
			},
			"--skip-tasks": {
				"values": [ANSIThemeString("TASK", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Skip ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(",", "separator"),
						ANSIThemeString("...", "argument")],
				"requires_arg": True,
				"validator": "int",
				"valid_range": (0, None),
				"list_separator": ",",
			},
			"--list-tasks": {
				"description": [ANSIThemeString("List valid values for ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" to use with ", "description"),
						ANSIThemeString("--start-at-task", "option"),
						ANSIThemeString(" and ", "description"),
						ANSIThemeString("--skip-tasks", "option")],
			},
			"--reinstall": {
				"description": [ANSIThemeString("Allow installing an already installed Kubernetes version", "description")],
			},
			"--override": {
				"description": [ANSIThemeString("Override/rebuild installation info", "description")],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs; the logs can be viewed using “", "description"),
						ANSIThemeString("iku", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation before performing actions", "description")],
			},
		},
		"min_args": 0,
		"max_args": 1,
		"callback": upgrade_control_plane,
	},
	"Teardown Control Plane": {
		"command": ["teardown-control-plane"],
		"description": [ANSIThemeString("Tear down the control plane", "description")],
		"extended_description": [
			[ANSIThemeString("Note", "emphasis"),
			 ANSIThemeString(": Before running this command all nodes must have been removed first", "description")],
			[ANSIThemeString("The configuration for the control plane and any software installed", "description")],
			[ANSIThemeString("during installation will NOT be removed.", "description")],

		],
		"options": {
			"--resume": {
				"description": [ANSIThemeString("Resume teardown; can be used if teardown was aborted", "description")],
			},
			"--start-at-task": {
				"values": [ANSIThemeString("TASK", "argument")],
				"description": [ANSIThemeString("Start at ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" instead of running all tasks", "description")],
				"requires_arg": True,
				"validator": "int",
				"valid_range": (0, None),
			},
			"--skip-tasks": {
				"values": [ANSIThemeString("TASK", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Skip ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(",", "separator"),
						ANSIThemeString("...", "argument")],
				"requires_arg": True,
				"validator": "int",
				"valid_range": (0, None),
				"list_separator": ",",
			},
			"--list-tasks": {
				"description": [ANSIThemeString("List valid values for ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" to use with ", "description"),
						ANSIThemeString("--start-at-task", "option"),
						ANSIThemeString(" and ", "description"),
						ANSIThemeString("--skip-tasks", "option")],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs; the logs can be viewed using “", "description"),
						ANSIThemeString("iku", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation before performing actions", "description")],
			},
		},
		"min_args": 0,
		"max_args": 0,
		"callback": teardown_control_plane,
	},
	"Purge Control Plane": {
		"command": ["purge-control-plane"],
		"description": [ANSIThemeString("Purge configuration and installed software", "description")],
		"extended_description": [
			[ANSIThemeString("purge-control-plane", "command"),
			 ANSIThemeString(" will run ", "description"),
			 ANSIThemeString("teardown-control-plane", "command"),
			 ANSIThemeString(" first if necessary.", "description")],
			[ANSIThemeString("Software and configuration needed for ", "description"),
			 ANSIThemeString(f"{about.PROGRAM_SUITE_NAME}", "programname"),
			 ANSIThemeString(" will not be purged.", "description")],
		],
		"options": {
			"--resume": {
				"description": [ANSIThemeString("Resume purge; can be used if purge was aborted", "description")],
			},
			"--start-at-task": {
				"values": [ANSIThemeString("TASK", "argument")],
				"description": [ANSIThemeString("Start at ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" instead of running all tasks", "description")],
				"requires_arg": True,
				"validator": "int",
				"valid_range": (0, None),
			},
			"--skip-tasks": {
				"values": [ANSIThemeString("TASK", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Skip ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(",", "separator"),
						ANSIThemeString("...", "argument")],
				"requires_arg": True,
				"validator": "int",
				"valid_range": (0, None),
			},
			"--list-tasks": {
				"description": [ANSIThemeString("List valid values for ", "description"),
						ANSIThemeString("TASK", "argument"),
						ANSIThemeString(" to use with ", "description"),
						ANSIThemeString("--start-at-task", "option"),
						ANSIThemeString(" and ", "description"),
						ANSIThemeString("--skip-tasks", "option")],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs; the logs can be viewed using “", "description"),
						ANSIThemeString("iku", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation before performing actions", "description")],
			},
		},
		"min_args": 0,
		"max_args": 0,
		"callback": purge_control_plane,
	},
	"Taint Control Plane": {
		"command": ["taint-control-plane"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("CONTROLPLANE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Mark control plane(s) as tainted", "description")],
		"extended_description": [
			[ANSIThemeString("If you have previously marked your control plane(s) as untainted", "description")],
			[ANSIThemeString("you can mark them as tainted again using this command.", "description")],
			[ANSIThemeString("If ", "description"),
			 ANSIThemeString("CONTROLPLANE", "argument"),
			 ANSIThemeString(",", "separator"),
			 ANSIThemeString("...", "argument"),
			 ANSIThemeString(" is not specified all control planes will be tainted.", "description")],
		],
		"optional_args": [
			{
				"name": "controlplane",
				"string": [ANSIThemeString("CONTROLPLANE", "argument")],
				"validator": "hostname_or_ip",
				"list_separator": ",",
			}
		],
		"callback": taint_control_plane,
	},
	"Untaint Control Plane": {
		"command": ["untaint-control-plane"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("CONTROLPLANE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Mark control plane(s) as untainted", "description")],
		"extended_description": [
			[ANSIThemeString("Per default control planes are marked as tainted; workloads that lack ", "description")],
			[ANSIThemeString("tolerations will not be scheduled to them", "description")],
			[ANSIThemeString("If you are running a single-node cluster, or if the control plane is very", "description")],
			[ANSIThemeString("powerful it might be useful to permit workloads on control plane(s) too", "description")],
			[ANSIThemeString("If ", "description"),
			 ANSIThemeString("CONTROLPLANE", "argument"),
			 ANSIThemeString(",", "separator"),
			 ANSIThemeString("...", "argument"),
			 ANSIThemeString(" is not specified all control planes will be untainted", "description")],

		],
		"optional_args": [
			{
				"name": "controlplane",
				"string": [ANSIThemeString("CONTROLPLANE", "argument")],
				"validator": "hostname_or_ip",
				"list_separator": ",",
			}
		],
		"callback": untaint_control_plane,
	},
	"Audit": {
		"command": ["audit"],
		"description": [ANSIThemeString("Search for potential security issues in the cluster", "description")],
		"extended_description": [
			[ANSIThemeString("Note", "emphasis"),
			 ANSIThemeString(": If the system is configured to use ", "description"),
			 ANSIThemeString("usergroups", "emphasis")],
			[ANSIThemeString("(every user have their own group that only they belong to) ", "description")],
			[ANSIThemeString("be sure to specify that group using the ", "description"),
			 ANSIThemeString("--usergroup ", "option"),
			 ANSIThemeString("USERGROUP", "argument"),
			 ANSIThemeString(" option,", "description")],
			[ANSIThemeString("to prevent the permission checker from complain about insecure permissions",  "description")],
		],
		"options": {
			"--usergroup": {
				"values": [ANSIThemeString("USERGROUP", "argument")],
				"description": [ANSIThemeString("If your system uses usergroups, specify your usergroup here", "description")],
				"requires_arg": True,
			},
		},
		"min_args": 0,
		"max_args": 0,
		"callback": audit,
	},
	"Preflight Check": {
		"command": ["preflight-check"],
		"values": [ANSIThemeString("CONTROLPLANE", "argument")],
		"description": [ANSIThemeString("Check for potential pitfalls that may prevent installation from succeeding", "description")],
		"options": {
			"--no-password": {
				"description": [ANSIThemeString("Do not prompt for a password; use this if the hosts you are checking are already configured for login using an SSH key", "description")],
			},
		},
		"required_args": [
			{
				"name": "controlplane",
				"string": [ANSIThemeString("CONTROLPLANE", "argument")],
				"validator": "hostname_or_ip",
			}
		],
		"callback": preflight_check,
	},
	"Troubleshoot": {
		"command": ["troubleshoot"],
		"description": [ANSIThemeString("Search for potential problems in the cluster", "description")],
		"min_args": 0,
		"max_args": 0,
		"callback": troubleshoot,
	},
	"spacer1": {
		"command": [""],
		"description": [ANSIThemeString("", "description")],
	},
}

def main() -> None:
	"""
	Main function for the program
	"""

	# Before doing anything else, make sure that the user is not running as root
	if os.geteuid() == 0:
		sys.exit("CRITICAL: This program should not be run as the root user; aborting.")

	# Then initialise the configuration file
	read_iktconfig()

	command, options, args = parse_commandline(about.ADMIN_PROGRAM_NAME, about.ADMIN_PROGRAM_VERSION, PROGRAMDESCRIPTION, PROGRAMAUTHORS, sys.argv,
						   COMMANDLINE, theme = DEFAULT_THEME_FILE)

	# Used by the ansible module
	ansible_configuration["ansible_forks"] = deep_get(iktlib.iktconfig, DictPath("Ansible#forks"), 5)
	ansible_user = deep_get(iktlib.iktconfig, DictPath("Ansible#ansible_user"))
	if ansible_user is None or len(ansible_user) == 0:
		ansible_user = getuser()
	ansible_configuration["ansible_user"] = ansible_user
	ansible_password = deep_get(iktlib.iktconfig, DictPath("Ansible#ansible_password"))
	if ansible_password is not None and len(ansible_password) > 0:
		ansible_configuration["ansible_password"] = ansible_password
	ansible_configuration["disable_strict_host_key_checking"] = deep_get(iktlib.iktconfig, DictPath("Nodes#disablestricthostkeychecking"), False)
	ansible_configuration["save_logs"] = deep_get(iktlib.iktconfig, DictPath("Ansible#save_logs"), False)

	return command(options, args)

if __name__ == "__main__":
	main()
