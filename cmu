#! /bin/sh
# vim: filetype=python
# pylint: disable-next=anomalous-backslash-in-string,line-too-long
''''eval version=$( ls /usr/bin/python3.* | grep '.*[0-9]$' | sort -nr -k2 -t. | head -n1 ) && version=${version##/usr/bin/python3.} && [ ${version} ] && [ ${version} -ge 8 ] && exec /usr/bin/python3.${version} "$0" "$@" || exec /usr/bin/env python3 "$0" "$@"' #'''
__doc__ = "The above hack is to handle distros that don't have /usr/bin/python3 point to the latest version of python3 they provide"
# Requires: ansible
# Requires: python3 (>= 3.8)
# Requires: python3-natsort
# Requires: python3-openssl
# Recommends: python3-ujson
#
# Copyright the Cluster Management Toolkit for Kubernetes contributors.
# SPDX-License-Identifier: MIT

# pylint: disable=line-too-long

"""
A curses-based UI for Cluster Management
"""

import ast
import base64
import binascii
import concurrent.futures
import copy
import csv
import curses
from curses import wrapper
from datetime import datetime, timedelta, timezone
import errno
from getpass import getuser
import http.client
from itertools import zip_longest
# ujson is much faster than json,
# but it might not be available
try:  # pragma: no cover
	import ujson as json
	# The exception raised by ujson when parsing fails is different
	# from what json raises
	DecodeException = ValueError
except ModuleNotFoundError:  # pragma: no cover
	import json  # type: ignore
	DecodeException = json.decoder.JSONDecodeError  # type: ignore
from operator import itemgetter
import os
from pathlib import Path, PurePath
import re
import socket
import subprocess  # nosec
from subprocess import PIPE, STDOUT # nosec
import sys
import threading
from typing import Any, cast, Dict, List, Optional, Sequence, Tuple, Type, Union
try:
	import yaml
except ModuleNotFoundError:  # pragma: no cover
	sys.exit("ModuleNotFoundError: Could not import yaml; you may need to (re-)run `cmt-install` or `pip3 install PyYAML`; aborting.")

try:
	from natsort import natsorted
except ModuleNotFoundError:  # pragma: no cover
	sys.exit("ModuleNotFoundError: Could not import natsort; you may need to (re-)run `cmt-install` or `pip3 install natsort`; aborting.")

from cmttypes import deep_get, deep_get_list, deep_get_with_fallback, deep_set, DictPath, FilePath, Retval, SecurityPolicy, StatusGroup
from cmttypes import ProgrammingError
from cmtpaths import BINDIR, KUBE_CONFIG_FILE, HOMEDIR, DEPLOYMENT_DIR, CMT_CONFIG_FILE_DIR, THEME_DIR, VIEW_DIR
from cmtpaths import DEFAULT_THEME_FILE, CMT_CONFIG_FILE_DIRNAME, CMT_CONFIG_FILE, CMT_CONFIG_FILENAME, SSH_ARGS_RELAXED, SSH_ARGS_STRICT, SSH_BIN_PATH

from cmtio import execute_command, execute_command_with_response, expand_path, secure_read_string, secure_which, secure_write_string
from cmtio_yaml import secure_read_yaml, secure_read_yaml_all
# from cmtlog import auditlog, debuglog, CMTLogType, CMTLog
from cmtlog import debuglog, CMTLogType, CMTLog

from cmtvalidators import validate_name

from commandparser import parse_commandline

import logparser as logparsers
from logparser import logparser, logparser_initialised, LogLevel, logparser_configuration
from logparser import lvl_to_letter_severity, lvl_to_4letter_severity, lvl_to_word_severity, loglevel_to_name, get_loglevel_names, name_to_loglevel, get_parser_list
import curses_helper
import cmtlib
from cmtlib import clamp, disksize_to_human, get_package_versions, identify_k8s_distro, make_set_expression_list
from cmtlib import none_timestamp, timestamp_to_datetime, datetime_to_timestamp, get_since
from cmtlib import split_msg, versiontuple, read_cmtconfig, substitute_list
from cmtlib import normalise_cpu_usage_to_millicores, normalise_mem_to_bytes, normalise_mem_bytes_to_str
from curses_helper import curses_configuration, color_log_severity, format_helptext, get_mousemask, color_status_group
from curses_helper import UIProps, WidgetLineAttrs, get_theme_ref, read_theme
from curses_helper import themearray_wrap_line, themearray_to_string, themearray_len, themearray_truncate, ThemeAttr, ThemeRef, ThemeString

import datagetter as datagetters
from datagetter import datagetter_allowlist
import generator as generators
from generator import generator_allowlist, default_processor
import itemgetter as itemgetters
from itemgetter import itemgetter_allowlist
from objgetter import objgetter_allowlist
# pylint: disable=deprecated-module
import formatter as formatters  # pylint: disable=wrong-import-order
# pylint: disable=deprecated-module
from formatter import formatter_allowlist  # pylint: disable=wrong-import-order

from ansible_helper import ansible_configuration
from ansible_helper import ansible_get_inventory_dict, ansible_get_groups, ansible_get_groups_by_host, ansible_add_hosts, ansible_remove_hosts, ansible_set_vars
from ansible_helper import ansible_run_playbook_on_selection, ansible_get_logs, ansible_delete_log, ansible_print_play_results, get_playbook_path
from ansible_helper import ANSIBLE_PLAYBOOK_DIR, ANSIBLE_INVENTORY
import helptexts

from kubernetes_helper import KubernetesHelper, get_image_version, get_node_status, kubectl_get_version, make_selector, update_api_status as kh_update_api_status, guess_kind

from ansithemeprint import ANSIThemeString, ansithemestring_join_tuple_list, clear_screen, ansithemeinput, ansithemeprint

import reexecutor

import about

PROGRAMDESCRIPTION = "UI for managing Kubernetes clusters"
PROGRAMAUTHORS = "Written by David Weinehall."

# If the user passes an object (and optionally namespace for that object)
# on the command line, they are stored here
# For pods a container can be appended too
initial_name = None
initial_namespace = None
initial_container = None

# Is cmu running in read only-mode?
read_only_mode = False

# Is Kubernetes support enabled
kubernetes_support = True
kube_config_file = None

# Namespace
selected_namespace = ""

# defaults
defaultview = ""

kh: KubernetesHelper = None  # type: ignore

executor = reexecutor.ReExecutor()
async_data: Dict = {}

def init_kubernetes_client() -> None:
	"""
	Initialise the Kubernetes client
	"""

	global kh  # pylint: disable=global-statement

	if kubernetes_support:
		kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, config_path = kube_config_file)

override_tail_lines = None
default_tail_lines = 4000

def gather_cluster_info() -> None:
	"""
	Gather information about the cluster necessary for running playbooks
	"""

	if not kubernetes_support:
		return

	ansithemeprint([ANSIThemeString("[Gathering cluster information]\n", "phase")])

	# Set global variables that need to be available when executing playbooks
	join_token = kh.get_join_token()
	ca_cert_hash = kh.get_ca_cert_hash()
	control_plane_ip, control_plane_port, control_plane_path = kh.get_control_plane_address()
	_control_plane_node, control_plane_name = get_control_plane()

	# This is tricky: we get this from the Debian package;
	# since we cannot assume that we are running cmu on the [main] control plane
	# we have to ask the [main] control plane, via ansible, what version of kubeadm it is running
	package_versions = get_package_versions(control_plane_name)
	control_plane_k8s_version = ""
	for package, version in package_versions:
		if package == "kubeadm":
			control_plane_k8s_version = version
	if len(control_plane_k8s_version) == 0:
		sys.exit(f"Failed to get kubeadm version from control plane “{control_plane_name}“; aborting.")

	http_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), None)
	https_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), None)
	no_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), None)
	insecure_registries = deep_get(cmtlib.cmtconfig, DictPath("Docker#insecure_registries"), [])
	registry_mirrors = deep_get(cmtlib.cmtconfig, DictPath("Containerd#registry_mirrors"), [])
	packages = deep_get(cmtlib.cmtconfig, DictPath("Packages"), {})

	values = {
		"control_plane_ip": control_plane_ip,
		"control_plane_port": control_plane_port,
		"control_plane_path": control_plane_path,
		"join_token": join_token,
		"ca_cert_hash": ca_cert_hash,
		"control_plane_k8s_version": control_plane_k8s_version,
		"ntp_server": control_plane_ip,
		"http_proxy": http_proxy,
		"https_proxy": https_proxy,
		"no_proxy": no_proxy,
		"insecure_registries": insecure_registries,
		"registry_mirrors": registry_mirrors,
		"packages": packages,
	}

	ansible_set_vars(ANSIBLE_INVENTORY, "all", values)

	print("\n\n")

def format_timestamp(timestamp: datetime, localtimezone: bool = False) -> List[Union[ThemeRef, ThemeString]]:
	"""
	Takes datetime and formats it as a YYYY-MM-DD HH:MM:SS themearray

		Parameters:
			timestamp (datetime): The timestamp
			localtimezone (bool): IS the timestamp in local time
		Returns:
			array (list[Union[ThemeRef, ThemeString]]): A formatted timestamp
	"""

	array = []

	if timestamp is None:
		array = [ThemeRef("strings", "none")]
	else:
		if localtimezone:
			ftimestamp = timestamp.astimezone().strftime("%Y-%m-%d %H:%M:%S")
		else:
			ftimestamp = timestamp.strftime("%Y-%m-%d %H:%M:%S")
		array = generators.format_numerical_with_units(ftimestamp, "timestamp", False)

	return array

def update_field_widths(field_dict: Dict, field_names: List[str], objects: List[Type]) -> int:
	linelen = 0
	pos = 0

	for field_name in field_names:
		field_dict[field_name]["pos"] = pos
		field_dict[field_name]["fieldlen"] = 0

		# These are necessary to calculate width of list items
		item_separator = field_dict[field_name].get("item_separator", ThemeRef("separators", "list"))
		field_separators = field_dict[field_name].get("field_separators", [ThemeRef("separators", "field")])
		ellipsise = field_dict[field_name].get("ellipsise", -1)
		ellipsis = field_dict[field_name].get("ellipsis", ThemeRef("separators", "ellipsis"))
		field_prefixes = field_dict[field_name].get("field_prefixes", None)
		field_suffixes = field_dict[field_name].get("field_suffixes", None)
		formatting = deep_get(field_dict, DictPath(f"{field_name}#formatting"), {})

		tmplen = 0

		for obj in objects:
			generator = field_dict[field_name].get("generator")
			processor = field_dict[field_name].get("processor")

			if processor is None:
				processor = default_processor.get(generator)

			if processor is not None:
				if processor in (generators.processor_list, generators.processor_list_with_status):
					tmp = processor(obj, field_name, item_separator = item_separator, field_separators = field_separators, ellipsise = ellipsise, ellipsis = ellipsis, field_prefixes = field_prefixes, field_suffixes = field_suffixes)
				# pylint: disable-next=comparison-with-callable
				elif processor == generators.processor_timestamp_with_age:
					tmp = processor(obj, field_name, formatting)
				else:
					tmp = processor(obj, field_name)
			else:
				tmp = getattr(obj, field_name)

			tmplen = max(len(str(tmp)), field_dict[field_name].get("fieldlen", 0))

			field_dict[field_name]["fieldlen"] = tmplen

		field_dict[field_name]["fieldlen"] = max(tmplen, len(field_dict[field_name]["header"]))

		linelen += field_dict[field_name].get("fieldlen") + len(ThemeRef("separators", "pad"))
		pos = linelen

	# The last element should not be padded
	if linelen > 0:
		linelen -= len(ThemeRef("separators", "pad"))

	return linelen

# pylint: disable-next=unused-argument
def get_hpa_metrics(obj: Dict, **kwargs: Dict) -> Tuple[List[Dict], int]:
	vlist = []
	status = 200

	for metric in deep_get(obj, DictPath("spec#metrics"), []):
		if "type" not in metric:
			continue
		metric_type = deep_get(metric, DictPath("type"))
		metric_name = metric_type[0].lower() + metric_type[1:]
		target_type = deep_get(metric, DictPath(f"{metric_name}#target#type"), "")
		if target_type == "Utilization":
			target_type = "AverageUtilization"
		target_type_name = target_type[0].lower() + target_type[1:]

		kind = ""
		api_group = ""
		object_name = ""

		if metric_name in ("resource", "containerResource"):
			name = deep_get(metric, DictPath(f"{metric_name}#name"))
		elif metric_name in ("pods", "object", "external"):
			name = deep_get(metric, DictPath(f"{metric_name}#metric#name"))
			api_version = ""
			if metric_type == "Object":
				kind = deep_get(metric, DictPath(f"{metric_name}#describedObject#kind"))
				api_version = deep_get(metric, DictPath(f"{metric_name}#describedObject#apiVersion"))
				object_name = deep_get(metric, DictPath(f"{metric_name}#describedObject#name"))
			api_group = api_version.split("/")[0]
		else:
			metric_type += " (Unsupported)"

		target_value = deep_get(metric, DictPath(f"{metric_name}#target#{target_type_name}"), "")
		selector = deep_get(metric, DictPath(f"{metric_name}#metric#selector#matchLabels"), {})

		d = {
			"metric_type": metric_type,
			"name": name,
			"target_type": target_type,
			"described_object_kind": kind,
			"described_object_api_group": api_group,
			# The autoscaler shares namespace with the described object
			"described_object_namespace": deep_get(obj, DictPath("metadata#namespace"), ""),
			"described_object_name": object_name,
			"selector": selector,
			"target_value": target_value,
		}
		vlist.append(d)
	return vlist, status

def get_metrics_list(**kwargs: Dict) -> Tuple[List[Dict], int]:
	vlist = []

	metrics, status = kh.get_metrics()

	# metrics are on the form:
	# apiserver_audit_event_total 0
	# aggregator_openapi_v2_regeneration_count{apiservice="*",reason="startup"} 0
	# apiserver_requested_deprecated_apis{group="autoscaling",removed_release="1.25",resource="horizontalpodautoscalers",subresource="",version="v2beta1"} 1

	metrics_regex = re.compile(r"^([^{]*){([^}]*)}\s\d+$")

	for line in metrics:
		tmp = metrics_regex.match(line)
		if tmp is None:
			continue
		metric = tmp[1]
		if deep_get(kwargs, DictPath("filter")) is not None:
			if metric not in deep_get(kwargs, DictPath("filter")):
				continue

		fields = [f"{x}" for x in next(csv.reader([tmp[2]], delimiter = ",", quotechar = "\""))]
		if len(fields) == 0:
			continue
		d: Dict = {
			"name": metric,
			"fields": {},
		}
		for field in fields:
			key_value = [f"{x}" for x in next(csv.reader([field], delimiter = "=", quotechar = "\""))]
			key, value = key_value
			d["fields"][key] = value.strip("\"")

		vlist.append(d)

	return vlist, status

def __recurse_data(path: Dict, obj: Any):
	datapath = deep_get(path, DictPath("path"), "")
	pathtype = deep_get(path, DictPath("pathtype"), "raw")
	nextpath = deep_get(path, DictPath("data"), {})

	if pathtype == "raw":
		return obj
	if pathtype == "list":
		if obj is None or len(obj) < datapath:
			return obj
		data = obj[datapath]
	else:
		data = deep_get(obj, datapath)

	if len(nextpath) == 0:
		return data

	return __recurse_data(nextpath, data)

def listgetter_dir(**kwargs):
	dirpath = deep_get(kwargs, DictPath("dirpath"), "")
	# Substitute {HOME} for {HOMEDIR}
	if dirpath.startswith("{HOME}"):
		dirpath = dirpath.replace("{HOME}", HOMEDIR, 1)
	prefixes = deep_get(kwargs, DictPath("prefixes"), [])
	suffixes = deep_get(kwargs, DictPath("suffixes"), [])
	kind = deep_get(kwargs, DictPath("kind"))

	vlist = []

	if os.path.isdir(dirpath):
		for filename in os.listdir(dirpath):
			if len(prefixes) > 0 and not filename.startswith(tuple(prefixes)):
				continue
			if len(suffixes) > 0 and not filename.endswith(tuple(suffixes)):
				continue
			filepath = FilePath(PurePath(dirpath).joinpath(filename))
			filepath_entry = Path(filepath)
			fstat = filepath_entry.stat()
			mtime = datetime.fromtimestamp(fstat.st_mtime)
			ctime = datetime.fromtimestamp(fstat.st_ctime)
			filesize = disksize_to_human(fstat.st_size)

			vlist.append({
					"filename": filename,
					"mtime": mtime,
					"ctime": ctime,
					"filesize": filesize,
					"ref": {
						"filename": filename,
						"filepath": FilePath(str(filepath)),
						"filesize": filesize,
						"mtime": mtime,
						"ctime": ctime,
					},
					"kind": kind,
				})

	return vlist, 200

def listgetter_files(**kwargs):
	paths = deep_get(kwargs, DictPath("paths"), [])
	vlist = []

	for path in paths:
		filepath = deep_get(path, DictPath("filepath"), "")
		filetype = deep_get(path, DictPath("filetype"), "yaml")

		# Substitute {HOME}/ for {HOMEDIR}
		if filepath.startswith(("{HOME}/", "{HOME}\\")):
			filepath = FilePath(str(PurePath(HOMEDIR).joinpath(filepath[len('{HOME}/'):])))

		if filetype == "yaml":
			d = secure_read_yaml(filepath)
		else:
			d = secure_read_string(filepath)

		if len(d) == 0:
			continue

		# Get the mtime of the file
		p = Path(FilePath(filepath))
		mtime = p.stat().st_mtime

		if filetype == "text":
			item = d
		else:
			item = __recurse_data(path, d)
		extra_data = deep_get(path, DictPath("_extra_data"), {})
		extra_data["mtime"] = mtime

		if len(extra_data) > 0 and isinstance(item, dict):
			item = { **item, "_extra_data": extra_data }

		vlist.append(item)

	return vlist, 200

# pylint: disable-next=unused-argument
def get_context_list(**kwargs: Dict) -> Tuple[List[Dict], List[str]]:
	vlist = []
	hosts = []

	# Do we want to ping the hosts?
	ping_hosts = deep_get(cmtlib.cmtconfig, DictPath("__Context#ping_hosts"), "Lazy")

	context_list = kh.list_contexts()

	tag_prefix = str(ThemeRef("separators", "tag"))

	inventory_dict: Dict = {
		"all": {
			"hosts": {},
		}
	}

	server_address_regex = re.compile(r"^(https?://)(.+)(:\d+)$")

	for is_current_context, name, cluster, authinfo, namespace, server in context_list:
		if is_current_context:
			current = tag_prefix
		else:
			current = "".ljust(len(tag_prefix))

		server_address = ""
		tmp = server_address_regex.match(server)
		if tmp is not None:
			server_address = tmp[2]
			hosts.append(server_address)


		vlist.append({
			"current": current,
			"name": name,
			"cluster": cluster,
			"authinfo": authinfo,
			"namespace": namespace,
			"server": server,
			"server_address": server_address,
			# Before we ping the hosts their status is unknown
			"status": "UNKNOWN",
		})

		if len(server_address) > 0:
			inventory_dict["all"]["hosts"][server_address] = {}
			inventory_dict["all"]["hosts"][server_address]["status"] = "UNKNOWN"
			inventory_dict["all"]["vars"] = {}

	key = deep_get(kwargs, DictPath("key"), "name")

	return vlist, hosts

def get_image_tuple(image: str) -> Tuple[str, str]:
	"""
	Given the name of a container, return the name and the version field

		Paramters:
			image (str): The full container name
		Returns:
			(name, version):
				name (str): The container name
				version (str): The container version
	"""

	tmp = re.match(r"^(.*):(.*)", image)
	if tmp is not None:
		image_name = f"{tmp[1]}"
		image_version = f"{tmp[2]}"
	else:
		image_name = f"{image}"
		image_version = "<undefined>"
	return image_name, image_version

# We should probably have a real type for container_type here
def __get_container_info(obj: Dict, container_type: str, spec_path: DictPath, status_path: DictPath) -> Dict:

	containers: Dict = {}

	for container in deep_get(obj, spec_path, []):
		container_name = deep_get(container, DictPath("name"))
		container_image = deep_get(container, DictPath("image"))
		image_version = get_image_version(container_image)

		# To get the image ID we need to cross-reference container_image against status#{status_path}->image"
		image_id = None
		for item in deep_get(obj, status_path, []):
			if deep_get(item, DictPath("name"), "") == container_name:
				image_id = deep_get(item, DictPath("imageID"))
		# This (most likely) means that the pod has not managed to instantiate a container
		if image_id is None:
			image_id = "<unknown>"
		key = (container_name, container_type, image_version, image_id)

		# If this container is in the dict already, just add a pod reference
		# This is unlikely to ever happen (this would mean that the same pod uses the same image multiple times,
		# which seems unlikely), but better safe than sorry
		if key not in containers:
			containers[key] = {}
			containers[key]["pod_references"] = []
			containers[key]["instances"] = 0

		containers[key]["pod_references"].append(obj)
		containers[key]["instances"] += 1

	return containers

# pylint: disable-next=unused-argument
def get_container_info(**kwargs: Dict) -> List[Type]:
	"""
	Infogetter for Containers

		Parameters:
			kwargs (dict): Additional parameters
		Returns:
			info (list[InfoClass]): A list with info
	"""

	info: List[Type] = []
	containers: Dict = {}

	# There's no direct way to get a list of unique containers
	# as defined by the tuple (name, type, version, image_id),
	# so we need to iterate the list of all pods and extract this
	# information.
	vlist, status = kh.get_list_by_kind_namespace(("Pod", ""), "")
	if status != 200:
		return info

	for obj in vlist:
		tmp = __get_container_info(obj, "InitContainer", DictPath("spec#initContainers"), DictPath("status#initContainerStatuses"))
		for key, value in tmp.items():
			instances = value["instances"]
			pod_references = value["pod_references"]
			if key not in containers:
				containers[key] = {}
				containers[key]["instances"] = 0
				containers[key]["pod_references"] = []

			containers[key]["instances"] += instances
			containers[key]["pod_references"] += pod_references
		tmp = __get_container_info(obj, "Container", DictPath("spec#containers"), DictPath("status#containerStatuses"))
		for key, value in tmp.items():
			instances = value["instances"]
			pod_references = value["pod_references"]
			if key not in containers:
				containers[key] = {}
				containers[key]["instances"] = 0
				containers[key]["pod_references"] = []

			containers[key]["instances"] += instances
			containers[key]["pod_references"] += pod_references

	for name, container_type, image_version, image_id in containers:
		pod_references = containers[(name, container_type, image_version, image_id)]["pod_references"]
		pods = []
		for pod in pod_references:
			pods.append((deep_get(pod, DictPath("metadata#namespace")), deep_get(pod, DictPath("metadata#name"))))
		instances = containers[(name, container_type, image_version, image_id)]["instances"]
		info.append(type("InfoClass", (), {
			"name": name,
			# This replaces ref
			"ref": {
				"name": name,
				"container_type": container_type,
				"image_version": image_version,
				"image_id": image_id,
				"pod_references": pod_references,
			},
			"container_type": container_type,
			"image_version": image_version,
			"instances": instances,
			"image_id": image_id,
			"pods": pods,
			"pod_references": pod_references,
		}))
	return info

# pylint: disable-next=unused-argument
def get_log_info(**kwargs: Dict) -> List[Type]:
	"""
	Infogetter for logs

		Parameters:
			kwargs (dict): Additional parameters
		Returns:
			info (list[InfoClass]): A list with info
	"""

	info: List[Type] = []

	# Fetch kubelet log, if available (for now only useful if run on the control plane)
	sudo_path = secure_which(FilePath("sudo"), fallback_allowlist = ["/bin", "/usr/bin"],
				 security_policy = SecurityPolicy.ALLOWLIST_STRICT)
	journalctl_path = secure_which(FilePath(os.path.join(BINDIR, "journalctl")), fallback_allowlist = ["/bin", "/usr/bin"],
				       security_policy = SecurityPolicy.ALLOWLIST_STRICT)
	args = [sudo_path, journalctl_path, "--no-pager", "-o", "json"]

	logs = [
		("Latest boot, last 1h", "[dmesg]", ["-k", "-b", "--since", "1 hour ago", "--lines", "10000"], "glog"),
		("Latest 1000 lines", "[kubelet]", ["--lines", "1000", "-u", "kubelet"], "glog"),
		("Latest 1000 lines", "[containerd]", ["--lines", "1000", "-u", "containerd"], "key_value"),
		("Latest 1000 lines", "[cri-o]", ["--lines", "1000", "-u", "crio"], "key_value"),
	]

	try:
		for name, action, log, parser in logs:
			response = execute_command_with_response(args + log)
			if len(response) == 0:
				continue

			# The first entry in the obj list holds metadata
			split_response = [{
				"parser": parser,
			}]
			split_response += response.splitlines()
			latestentry = split_response[1]

			d = json.loads(latestentry)

			split_response[0]["name"] = deep_get(d, DictPath("SYSLOG_IDENTIFIER"), "<unknown>")
			hostname = deep_get(d, DictPath("_HOSTNAME"), "<unknown>")
			split_response[0]["host"] = hostname
			created_at = datetime.fromtimestamp(int(deep_get(d, DictPath("__REALTIME_TIMESTAMP"))) / 1000000)
			split_response[0]["created_at"] = created_at

			info.append(type("InfoClass", (), {
				"name": f"<dynamic> {hostname}: {name}",
				"ref": {
					"ref": split_response,
					"kind": "__JournalctlLogView",
				},
				"action": action,
				"message": deep_get(d, DictPath("MESSAGE"), ""),
				"created_at": created_at,
				"log_type": "journalctl",
			}))
	except FileNotFoundError:
		pass

	# Get the list of available Ansible logs
	ansible_logs = ansible_get_logs()

	# TODO: Here we might possibly want to insert other logs?

	for name, action, ref, created_at in ansible_logs:
		log_type = "Ansible Play"
		info.append(type("InfoClass", (), {
			"name": name,
			"ref": {
				"ref": ref,
				"kind": "__AnsibleLog",
			},
			"action": action,
			"created_at": created_at,
			"log_type": log_type,
		}))
	return info

# pylint: disable-next=unused-argument
def get_pod_containers_list(**kwargs: Dict) -> Tuple[List[Dict], int]:
	vlist = []
	_vlist, status = kh.get_list_by_kind_namespace(("Pod", ""), "")

	if status == 200:
		for obj in _vlist:
			namespace = deep_get(obj, DictPath("metadata#namespace"))
			name = deep_get(obj, DictPath("metadata#name"))
			node_name = deep_get(obj, DictPath("spec#nodeName"))
			for container in deep_get(obj, DictPath("spec#containers")):
				container_name = deep_get(container, DictPath("name"))
				reason, status_group, _restarts, _message, _age = datagetters.get_container_status(deep_get(obj, DictPath("status#containerStatuses")), container_name)
				container_status = None
				for container_status in deep_get(obj, DictPath("status#containerStatuses"), []):
					if deep_get(container_status, DictPath("name")) == container_name:
						break
				if container_status is not None:
					image_id = deep_get(container_status, DictPath("imageID"), "")
				else:
					image_id = "<unavailable>"
				vlist.append({
					"namespace": namespace,
					"name": name,
					"container": container_name,
					"status": reason,
					"status_group": status_group,
					"node_name": node_name,
					"image_id": image_id,
				})

	return vlist, status

# pylint: disable-next=unused-argument
def get_sidecar_rule_list(obj: Dict, **kwargs: Dict) -> Tuple[List[Dict], int]:
	vlist = []

	for traffic_type, items in (("Ingress", deep_get(obj, DictPath("spec#ingress"), [])), ("Egress", deep_get(obj, DictPath("spec#egress"), []))):
		for item in items:
			pport = deep_get(item, DictPath("port#number"), "")
			name = deep_get(item, DictPath("port#name"), "")
			protocol = deep_get(item, DictPath("port#protocol"), "")
			port = (name, pport, protocol)
			ref = item
			bind = deep_get(item, DictPath("bind"), "")
			capture_mode = deep_get(item, DictPath("captureMode"), "NONE")
			# Required
			default_endpoint = deep_get(item, DictPath("defaultEndpoint"), "")
			# N/A
			hosts = deep_get(item, DictPath("hosts"), [])
			vlist.append({
				"traffic_type": traffic_type,
				"port": port,
				"ref": ref,
				"bind": bind,
				"capture_mode": capture_mode,
				"default_endpoint": default_endpoint,
				"hosts": hosts,
			})

	return vlist, 200

def __get_timestamp_with_fallback(obj: Dict, paths: List[DictPath]) -> datetime:
	return timestamp_to_datetime(deep_get_with_fallback(obj, paths))

def __process_string(value: str, replace_quotes: str) -> str:
	# We do not want any newlines, and extra trailing whitespace
	if value is None:
		value = ""
	if isinstance(value, str):
		value = value.replace("\n", "\\n").rstrip()
		if replace_quotes == "pretty":
			value = value.replace("\\\"", "“")
		elif replace_quotes == "same":
			value = value.replace("\\\"", "\"")
	return value

def __process_sum_numerical(value: Sequence[Union[int, float]]) -> Union[float, int]:
	return sum(value)

def __process_stringify_list(values: Sequence[Any]) -> List[str]:
	tmp: List[str] = []
	for value in values:
		tmp.append(str(value))
	return tmp

def __process_sum_cpu_usage(values: List[str]) -> str:
	cpu_usage_sum = 0.0
	for value in values:
		cpu_usage_sum += normalise_cpu_usage_to_millicores(value)
	return f"{cpu_usage_sum:0.1f}"

def __process_sum_mem_usage(values: List[str]) -> str:
	mem_usage_sum = 0
	for value in values:
		mem_usage_sum += normalise_mem_to_bytes(value)
	return normalise_mem_bytes_to_str(mem_usage_sum)

def __process_regex_to_sequence(values: Union[str, List[str]], match_regex: str, target_type: str) -> Union[Sequence[Union[str, Tuple]], str]:
	new_values: List[Union[str, Tuple]] = []

	compiled_regex = re.compile(match_regex)

	if len(values) > 0:
		if isinstance(values, str):
			values = [values]
		compiled_regex = re.compile(match_regex)
		for item in values:
			tmp_match = compiled_regex.match(item)
			groups = []
			if tmp_match is not None:
				for group in tmp_match.groups():
					if group is not None:
						groups.append(group)
				if target_type == "tuples":
					new_values.append(tuple(groups))
				else:
					new_values += groups

	if len(new_values) == 1:
		return new_values[0]

	return new_values

def __process_timestamp(value: Union[Sequence[Union[int, str]], str], action: str, formatter: str) -> Union[datetime, int]:
	if action in ("earliest", "latest") and isinstance(value, (list, tuple)):
		tmp_timestamp: datetime = none_timestamp()
		for tmp1 in value:
			if tmp1 is None or tmp1 == -1:
				continue
			# The only valid integer value is -1
			timestamp = timestamp_to_datetime(cast(str, tmp1))
			if tmp_timestamp == none_timestamp():
				tmp_timestamp = timestamp
			else:
				if timestamp < tmp_timestamp and action == "earliest":
					tmp_timestamp = timestamp
				elif timestamp > tmp_timestamp and action == "latest":
					tmp_timestamp = timestamp
		new_value = tmp_timestamp
	else:
		if value == -1:
			new_value = none_timestamp()
		elif isinstance(value, str) and value.startswith("<") and value.endswith(">"):
			new_value = value
		else:
			new_value = timestamp_to_datetime(cast(str, value))

	if formatter == "age":
		# If we are gonna format this as age we want this passed through get_since()
		return get_since(new_value)

	return new_value

# pylint: disable-next=too-many-arguments
def process_value(field_name: str, value: Any, vtype: str, view: str, field_index: str, action: str,
		  formatter: str, replace_quotes: str, _regex: str) -> Union[int, float, str, List[str], datetime, None]:
	override_kind = deep_get_with_fallback(cmtlib.cmtconfig, [
				DictPath(f"Views#{view}#kind_format_{field_index}"),
				DictPath(f"Views#{view}#kind_format"),
				DictPath(f"Global#kind_format_{field_index}"),
				DictPath("Global#kind_format")], "mixed")

	new_value: Union[int, float, str, List[str], datetime, None] = None

	if vtype == "str":
		new_value = __process_string(value, replace_quotes)
	elif vtype in ("float", "int", "bool"):
		if isinstance(value, (list, tuple)) and action == "sum":
			new_value = __process_sum_numerical(value)
		elif isinstance(value, tuple):
			new_value = __process_stringify_list(value)
		else:
			new_value = str(value)
	elif vtype in ("cpu_usage", "cpu_usage_round"):
		if isinstance(value, list) and action == "sum":
			new_value = __process_sum_cpu_usage(value)
		elif vtype == "cpu_usage_round":
			tmp_float = normalise_cpu_usage_to_millicores(value)
			new_value = f"{int(tmp_float / 1000)}"
		else:
			tmp_float = normalise_cpu_usage_to_millicores(value)
			new_value = f"{tmp_float:0.1f}"
	elif vtype == "mem_usage":
		if isinstance(value, list) and action == "sum":
			new_value = __process_sum_mem_usage(value)
		else:
			tmp_int = normalise_mem_to_bytes(value)
			new_value = normalise_mem_bytes_to_str(tmp_int)
	elif vtype in ("regex_to_tuples", "regex_to_list"):
		target_type = vtype[len("regex_to_"):]
		new_value = __process_regex_to_sequence(cast(Union[List[str], str], value), _regex, target_type)
	elif vtype == "len":
		if value is None:
			new_value = "0"
		else:
			new_value = str(len(cast(Union[str, Sequence], value)))
	elif vtype == "unix_timestamp":
		new_value = datetime.fromtimestamp(value)
	elif vtype == "timestamp":
		new_value = __process_timestamp(value, action, formatter)
	elif isinstance(vtype, list):
		if not isinstance(value, (list, tuple)):
			raise ValueError(f"Field {field_name}: type({value}) is {vtype}; for type {vtype} pathtype must be a multi-element type")
		_values = []
		override_kind = deep_get_with_fallback(cmtlib.cmtconfig,
						       [DictPath(f"Views#{view}#kind_format_{field_index}"),
						        DictPath(f"Views#{view}#kind_format"),
							DictPath(f"Global#kind_format_{field_index}"),
							DictPath("Global#kind_format")], "mixed")
		for i in range(0, len(value)):
			if i < len(vtype):
				_vtype = vtype[i]
			else:
				_vtype = "raw"
			if _vtype in ("raw", "name"):
				_values.append(value[i])
			elif _vtype == "kind":
				if override_kind == "skip":
					_values.append("")
				else:
					_values.append(value[i])
			elif _vtype == "api_group":
				if override_kind == "skip":
					_values.append("")
					continue

				if value[i] is not None and "/" in value[i]:
					if override_kind == "full" or override_kind == "mixed" and "." in value[i]:
						_values.append(value[i].split("/")[0])
					else:
						_values.append("")
				else:
					_values.append("")
			elif _vtype == "skip":
				_values.append("")
			else:
				raise ValueError(f"Field {field_name}: type[{i}] ({vtype}) is unknown")
		if isinstance(value, list):
			new_value = _values
		elif isinstance(value, tuple):
			new_value = tuple(cast(List, _values))
	elif vtype == "raw":
		# Do not convert this type
		new_value = value
	else:
		theme = get_theme_ref()

		# Is a custom type used for theming?
		if vtype not in theme["types"]:
			raise ValueError(f"Unknown value type {vtype}; the view file is probably invalid")
		new_value = value
	return new_value

def transform_filter(transformations: Dict, value: DictPath) -> Any:
	if len(transformations) > 0 and value in transformations:
		value = deep_get(transformations, value)
	return value

def when_filter(when_path: Dict, item: Dict, key: Optional[str] = None, value: Any = None) -> bool:
	# When is a list of when-conditions,
	# all of which have to evaluate to true
	when_conditions = deep_get(when_path, DictPath("when"), [])

	_key = key
	_value = value

	for when_condition in when_conditions:
		# These apply to the key
		if _key is None:
			key = deep_get(when_condition, DictPath("key"))

		# These do not make sense when using when#key, since we already know the key
		when_key_eq = deep_get(when_condition, DictPath("key_eq"))
		when_key_ne = deep_get(when_condition, DictPath("key_ne"))
		when_key_in = deep_get(when_condition, DictPath("key_in"))
		when_key_notin = deep_get(when_condition, DictPath("key_notin"))
		when_key_startswith = deep_get(when_condition, DictPath("key_startswith"))
		when_key_notstartswith = deep_get(when_condition, DictPath("key_notstartswith"))
		when_key_endswith = deep_get(when_condition, DictPath("key_endswith"))
		when_key_notendswith = deep_get(when_condition, DictPath("key_notendswith"))
		if when_key_eq is not None and when_key_eq != key:
			return False
		if when_key_ne is not None and when_key_eq == key:
			return False
		if when_key_in is not None and key not in when_key_in:
			return False
		if when_key_notin is not None and key in when_key_in:
			return False
		if when_key_startswith is not None and not key.startswith(when_key_startswith):
			return False
		if when_key_notstartswith is not None and key.startswith(when_key_notstartswith):
			return False
		if when_key_endswith is not None and not key.endswith(when_key_endswith):
			return False
		if when_key_notendswith is not None and key.endswith(when_key_notendswith):
			return False

		# Check for none
		if _value is None:
			if key is None:
				raise ValueError("key is None")
			value = deep_get(item, DictPath(key))

		# These check whether the key has a value
		when_none = deep_get(when_condition, DictPath("none"))
		when_notnone = deep_get(when_condition, DictPath("notnone"))

		# All these check the value
		when_eq = deep_get(when_condition, DictPath("eq"))
		when_ne = deep_get(when_condition, DictPath("ne"))
		when_lt = deep_get(when_condition, DictPath("lt"))
		when_lte = deep_get(when_condition, DictPath("lte"))
		when_gt = deep_get(when_condition, DictPath("gt"))
		when_gte = deep_get(when_condition, DictPath("gte"))
		when_in = deep_get(when_condition, DictPath("in"))
		when_notin = deep_get(when_condition, DictPath("notin"))
		when_missing = deep_get(when_condition, DictPath("missing"))
		when_notmissing = deep_get(when_condition, DictPath("notmissing"))

		# These check dict values
		when_isdict = deep_get(when_condition, DictPath("isdict"))
		when_notisdict = deep_get(when_condition, DictPath("notisdict"))
		when_dicthaskey = deep_get(when_condition, DictPath("dicthaskey"))
		when_notdicthaskey = deep_get(when_condition, DictPath("notdicthaskey"))

		# Check for existance
		if when_missing is not None and when_missing in item:
			return False
		if when_notmissing is not None and when_notmissing not in item:
			return False

		if when_notnone is not None and value is None:
			return False
		if when_none is not None and value is not None:
			return False

		# dict-based checks
		if when_isdict is not None and not isinstance(value, dict):
			return False
		if when_notisdict is not None and isinstance(value, dict):
			return False
		if when_dicthaskey is not None and (not isinstance(value, dict) or when_dicthaskey not in value):
			return False
		if when_notdicthaskey is not None and (not isinstance(value, dict) or when_notdicthaskey in value):
			return False

		# Set-based checks
		if when_in is not None and value not in when_in:
			return False
		if when_notin is not None and value in when_notin:
			return False

		# Check for equality
		if when_eq is not None and (value is None or value != type(value)(when_eq)):
			return False
		if when_ne is not None and (value is None or value == type(value)(when_ne)):
			return False

		if when_lt is not None and not value < type(value)(when_lt):
			return False
		if when_lte is not None and not value <= type(value)(when_lte):
			return False
		if when_gt is not None and not value > type(value)(when_gt):
			return False
		if when_gte is not None and value >= type(value)(when_gte):
			return False

	return True

def transform_list(vlist, transform):
	sort = deep_get(transform, DictPath("sorted"), False)
	key_regexes = deep_get(transform, DictPath("key#regex"), [])
	key_groups = deep_get(transform, DictPath("key#groups"), [])
	key_join = deep_get(transform, DictPath("key#join"))
	key_defaults = deep_get(transform, DictPath("key#default"), [])
	value_regexes = deep_get(transform, DictPath("value#regex"), [])
	value_groups = deep_get(transform, DictPath("value#groups"), [])
	value_join = deep_get(transform, DictPath("value#join"))
	value_defaults = deep_get(transform, DictPath("value#default"), [])
	output = deep_get(transform, DictPath("output"), ["key", "value"])

	result = []

	# This handles both lists and dicts
	for key in vlist:
		if not isinstance(vlist, dict):
			value = None
		else:
			value = vlist[key]

		key_data = []

		if key is None:
			continue

		key = str(key)

		if len(key_regexes) == 0:
			key_data.append(key)
		else:
			for _regex in key_regexes:
				_tmp = re.match(_regex, key)
				if _tmp is not None:
					for group in key_groups:
						if group < len(_tmp.groups()):
							_tmp2 = _tmp.groups()[group]
							if _tmp2 is None and group < len(key_defaults):
								key_data.append(key_defaults[group])
							else:
								key_data.append(_tmp2)
				if key_join is not None and len(key_data) > 1:
					tmp = ""
					for i in range(0, len(key_data)):
						tmp += key_data[i]
						if i < len(key_data) - 1:
							tmp += key_join[min(i, len(key_join) - 1)]
					key_data = [tmp]

		value_data = []
		for _regex in value_regexes:
			if value is None:
				continue

			value = str(value)

			_tmp = re.match(_regex, value)
			if _tmp is not None:
				for group in value_groups:
					if group < len(_tmp.groups()):
						_tmp2 = _tmp.groups()[group]
						if _tmp2 is None and group < len(value_defaults):
							value_data.append(value_defaults[group])
						else:
							value_data.append(_tmp2)
			if value_join is not None and len(value_data) > 1:
				tmp = ""
				for i in range(0, len(value_data)):
					tmp += value_data[i]
					if i < len(value_data) - 1:
						tmp += value_join[min(i, len(value_join) - 1)]
				value_data = [tmp]

		tmp = []
		for _output in output:
			if _output == "key":
				if len(key_data) == 1:
					tmp.append(key_data[0])
				else:
					tmp.append(tuple(key_data))
			elif _output == "value":
				if len(value_data) == 1:
					tmp.append(value_data[0])
				else:
					tmp.append(tuple(value_data))
		if len(tmp) == 1:
			tmp = tmp[0]
		else:
			tmp = tuple(tmp)
		result.append(tmp)

	if sort:
		return natsorted(result)

	return result

# pylint: disable-next=too-many-arguments
def get_obj(obj: Dict, field_dict: Dict, field_names: List[str], field_index: str, view: str, filters: Dict, deleted: bool = False):
	d = {}

	# fields both specify formatting and where to get the data from; here we are only concerned with the data
	for field_name in field_names:
		name = field_name
		field = field_dict[name]
		path = deep_get(field, DictPath("path"))
		paths = deep_get(field, DictPath("paths"), [])
		datagetter = deep_get(field, DictPath("datagetter"))
		if datagetter is not None:
			if isinstance(datagetter, str):
				datagetter = deep_get(datagetter_allowlist, DictPath(datagetter))
		if "default" not in field:
			default = ""
		else:
			default = deep_get(field, DictPath("default"))
		global_default = default
		fallback_on_empty = deep_get(field, DictPath("fallback_on_empty"), False)
		formatter = deep_get(field, DictPath("formatter"))
		action = None
		replace_quotes = None

		if (path is None and len(paths) == 0 or path is not None and len(paths) > 0) and datagetter is None:
			raise ValueError(f"Field {name}: exactly one of path and paths must be non-empty unless a datagetter is specified\npath={path}\npaths={paths}\ndatagetter={datagetter}")

		if datagetter is not None:
			d[name], extradata = datagetter(kh, obj, path, default)
			for key, value in extradata.items():
				d[key] = value
		else:
			_values = []

			if path is not None:
				if deep_get(field, DictPath("type")) is None:
					raise ValueError(f"Field {name}: the path field has no default type; type must always be specified")
				tmp_value = deep_get(obj, DictPath(path), global_default)
				if tmp_value is not None and isinstance(tmp_value, (str, list)) and len(tmp_value) == 0 and fallback_on_empty:
					tmp_value = global_default
				_values.append((tmp_value, deep_get(field, DictPath("type"))))

			_path = None
			for _path in paths:
				default = deep_get(_path, DictPath("default"))
				vtype = deep_get(_path, DictPath("type"), "raw")
				path = deep_get(_path, DictPath("path"))
				mpaths = deep_get(_path, DictPath("paths"))
				if path is not None and mpaths is not None or path is None and mpaths is None:
					raise ValueError(f"Field {name}: exactly one of path & paths must be used in a 'paths:' block\npath={path}\npaths={paths}")

				if mpaths is None:
					if isinstance(path, str):
						path = [path]
					mpaths = [path]

				ptype = deep_get(_path, DictPath("pathtype"), "list")
				limit = deep_get(_path, DictPath("limit"))
				action = deep_get(_path, DictPath("action"), "")
				subpath = deep_get(_path, DictPath("subpath"), "")
				subpaths = deep_get(_path, DictPath("subpaths"), [])
				fallback_on_empty = deep_get(_path, DictPath("fallback_on_empty"), False)
				replace_quotes = deep_get(_path, DictPath("replace_quotes"), "no")
				if ptype == "list":
					tmp = deep_get_with_fallback(obj, path, default = default, fallback_on_empty = fallback_on_empty)
					if deep_get(_path, DictPath("sorted"), False) and tmp is not None:
						tmp = natsorted(tmp)

					if tmp is not None and tmp in ("None", ["None"]) and deep_get(_path, DictPath("none_str_as_none"), False):
						tmp = default

					# Just return the list, unless a subset has been requested
					if limit is not None and tmp is not None:
						value = tmp[0:limit]
					else:
						value = tmp

					_values.append((value, vtype))
				elif ptype == "dictlist":
					_raw = deep_get_with_fallback(obj, path, default = default, fallback_on_empty = fallback_on_empty)
					transform = deep_get(_path, DictPath("transform"), {})
					if _raw is not None:
						for tmp in transform_list(_raw, transform = transform):
							_values.append((tmp, vtype))
				# This takes a list of paths as indata, and--for all numerical entries in the list,
				# builds ranges; all non-numerical entries are included as is
				elif ptype == "ranges":
					rawvals = []
					for p in path:
						tmp = deep_get(obj, DictPath(p))
						if tmp is not None:
							rawvals += tmp
					rangevals = []
					if tmp is not None:
						firstnum = None
						lastnum = None
						sortedvals = natsorted(tmp)
						for i in range(0, len(sortedvals)):
							# The range is sorted; this means that we add everything as is except None
							# until we reach the first numerical, create ranges for the numericals,
							# then add everything as is except None until the end
							if sortedvals[i] is None:
								continue
							# pylint: disable-next=unidiomatic-typecheck
							if type(sortedvals[i]) == int:  # noqa: E721
								if firstnum is None:
									firstnum = sortedvals[i]
								else:
									if lastnum is None or sortedvals[i] == lastnum + 1:
										lastnum = sortedvals[i]
									else:
										# Flush and start a new range
										rangevals.append((f"{firstnum}", f"{lastnum}", ""))
										firstnum = sortedvals[i]
										lastnum = None
							else:
								if firstnum is not None:
									if lastnum is None:
										rangevals.append((f"{firstnum}", "", ""))
									else:
										rangevals.append((f"{firstnum}", f"{lastnum}", ""))
										lastnum = None
									firstnum = None
								rangevals.append(("", "", sortedvals[i]))
						if firstnum is not None:
							if lastnum is None:
								rangevals.append((f"{firstnum}", "", ""))
							else:
								rangevals.append((f"{firstnum}", f"{lastnum}", ""))
					_values.append((rangevals, "raw"))
				elif ptype == "key_value":
					value = []
					for _key, _value in deep_get_with_fallback(obj, path, {}).items():
						subpaths = deep_get(_path, DictPath("subpaths"), [])
						if len(subpaths) > 0:
							_value = deep_get_with_fallback(_value, subpaths)
						if not when_filter(_path, item = None, key = _key, value = _value):
							continue
						_regexes_key = deep_get(_path, DictPath("key#regex"), [])
						_regexes_value = deep_get(_path, DictPath("value#regex"), [])
						if isinstance(_regexes_key, str):
							_regexes_key = [_regexes_key]
						if isinstance(_regexes_value, str):
							_regexes_value = [_regexes_value]
						_key = transform_filter(deep_get(_path, DictPath("key#transform"), {}), _key)
						_value = transform_filter(deep_get(_path, DictPath("value#transform"), {}), _value)
						# A regex for key/value is required to capture only one group;
						# (though conceivably there might be scenario for joining),
						# thus the first non-None capture group will exit the match;
						# when using multiple regexes the first matching regex exits
						match = False
						for _regex in _regexes_key:
							_tmp = re.match(_regex, _key)
							if _tmp is None:
								continue

							for group in _tmp.groups():
								if group is not None:
									_key = group
									match = True
							if match:
								break
						match = False
						for _regex in _regexes_value:
							_tmp = re.match(_regex, _value)
							if _tmp is None:
								continue

							for group in _tmp.groups():
								if group is not None:
									_value = group
									match = True
							if match:
								break
						# A transform might yield multiple identical key/value pairs;
						# ignore all except the first one
						if (_key, _value) in value:
							continue
						value.append((_key, _value))
					if len(value) == 0:
						if default is None:
							value = []
						else:
							value = default
					for tmp in value:
						_values.append((tmp, vtype))
				elif ptype == "match_expression":
					tmp = deep_get_with_fallback(obj, path)
					if isinstance(tmp, list):
						value = []
						subpath = deep_get(_path, DictPath("subpath"))
						if subpath is None:
							value = make_set_expression_list(tmp)
						else:
							value = make_set_expression_list(tmp)
							for _tmp in tmp:
								__tmp = deep_get(_tmp, DictPath(subpath), _tmp)
								value.append(make_set_expression_list(__tmp))
						if len(value) == 1:
							_values.append((value[0], "raw"))
						else:
							for tmp in value:
								_values.append((tmp, "raw"))
					elif isinstance(tmp, dict):
						value = make_set_expression_list(tmp)
						_values.append((value, "raw"))
					else:
						_values.append((default, "raw"))
				elif ptype == "lookup":
					lookup_kind, lookup_api_group, lookup_namespace, lookup_name, tmp_lookup_selector = path
					if isinstance(lookup_kind, list):
						lookup_kind = deep_get_with_fallback(obj, lookup_kind, "")
					if isinstance(lookup_api_group, list):
						lookup_api_group = deep_get_with_fallback(obj, lookup_api_group, "")
					if isinstance(lookup_namespace, list):
						lookup_namespace = deep_get_with_fallback(obj, lookup_namespace, "")
					if isinstance(lookup_name, list):
						lookup_name = deep_get_with_fallback(obj, lookup_name, "")
					if len(tmp_lookup_selector) == 0:
						lookup_selector = ""
					else:
						_lookup_selector = {}
						for ls in tmp_lookup_selector:
							ls_key = ls[0]
							ls_value = ls[1]
							if isinstance(ls_value, list):
								ls_value = deep_get_with_fallback(obj, ls_value)
							_lookup_selector[ls_key] = ls_value
						lookup_selector = make_selector(_lookup_selector)

					try:
						if len(lookup_name) == 0:
							lookup_obj, _status = kh.get_list_by_kind_namespace((lookup_kind, lookup_api_group), lookup_namespace, label_selector = lookup_selector)
						else:
							lookup_obj = kh.get_ref_by_kind_name_namespace((lookup_kind, lookup_api_group), lookup_name, lookup_namespace)
					except NameError:
						unknown = deep_get(_path, DictPath("unknown"), "Unknown Kind")
						_values.append((unknown, "raw"))
						continue
					if lookup_obj is None or isinstance(lookup_obj, dict) and not when_filter(_path, item = lookup_obj):
						_values.append((default, "raw"))
						continue
					subpaths = deep_get(_path, DictPath("subpaths"), [])
					value = []
					if len(subpaths) > 0:
						tmp = []
						if isinstance(lookup_obj, dict):
							lookup_obj = [lookup_obj]

						for _lookup_obj in lookup_obj:
							for i in range(0, len(subpaths)):
								tmp.append(deep_get(_lookup_obj, DictPath(subpaths[i])))
						if len(tmp) == 1:
							value.append(tmp[0])
						else:
							value.append(tuple(tmp))

					if len(value) == 0:
						value = default

					substitute = deep_get(_path, DictPath("substitute"))
					if substitute is not None:
						value = substitute
					_values.append((value, "raw"))
				elif ptype == "remap":
					value = []
					substitutions = deep_get(_path, DictPath("substitutions"), "")
					tmp = deep_get_with_fallback(obj, path)
					if tmp is None:
						tmp = []

					if type(tmp) in (bool, int, str):
						tmp = [tmp]

					if isinstance(tmp, list):
						for _tmp in tmp:
							if isinstance(_tmp, bool):
								_tmp = f"__{str(_tmp)}"

							if _tmp in substitutions:
								value.append(substitutions.get(_tmp))
							elif "__default" in substitutions:
								value.append(substitutions.get("__default"))
							else:
								value.append(_tmp)
					else:
						raise ValueError(f"remap is not supported yet for type {type(tmp)}")
					if len(value) == 0:
						if default is None:
							continue
						value.append(default)
					for tmp in value:
						_values.append((tmp, vtype))
				elif ptype == "substitution":
					value = []
					substitute = deep_get(_path, DictPath("substitute"), "")
					tmp = deep_get_with_fallback(obj, path)
					if tmp is None:
						tmp = []
					if isinstance(tmp, dict):
						tmp = [tmp]
					for _tmp in tmp:
						if not when_filter(_path, item = _tmp):
							continue
						value.append(substitute)
						break
					else:
						if "else" in _path:
							tmp = deep_get(_path, DictPath("else"))
							if isinstance(tmp, list):
								tmp = deep_get_with_fallback(obj, tmp)
							if len(tmp) > 0:
								value.append(tmp)
					if len(value) == 0:
						if default is None:
							continue
						value.append(default)
					for tmp in value:
						_values.append((tmp, vtype))
				elif ptype == "transform":
					transform = deep_get(_path, DictPath("transform"), {})
					tmp = deep_get_with_fallback(obj, path)
					tmp_type = type(tmp)
					if not isinstance(tmp, (dict, list)):
						tmp = [tmp]
					tmp = transform_list(tmp, transform)
					if tmp_type not in (dict, list) and len(tmp) == 1:
						tmp = tmp[0]
					_values.append((tmp, vtype))
				elif ptype == "timediff":
					if len(mpaths) != 2:
						raise ValueError(f"Field {name}: when using pathtype: 'timediff' path must be [start_time_path(s), end_time_path(s)]")
					start_time = deep_get_with_fallback(obj, mpaths[0], default = None)
					end_time = deep_get_with_fallback(obj, mpaths[1], default = None)
					if end_time is None or start_time is None:
						duration = -1
					else:
						datetime_start = timestamp_to_datetime(start_time)
						if isinstance(end_time, int):
							datetime_end = timedelta(seconds = end_time)
							timediff = datetime_start + datetime_end
							duration = timediff
						else:
							datetime_end = timestamp_to_datetime(end_time)
							timediff = datetime_end - datetime_start
							duration = timediff.days * 24 * 60 * 60 + timediff.seconds
						_values.append((duration, "raw"))
				elif ptype == "comparison":
					# Input is two paths; output is the value of the first path and -2/-1/0/1 (for type mismatch, lt, eq, gt)
					if isinstance(default, list) and len(default) == 2:
						_default1 = default[0]
						_default2 = default[1]
					else:
						_default1 = default
						_default2 = default
					val1 = deep_get(obj, DictPath(path[0]), _default1)
					val2 = deep_get(obj, DictPath(path[1]), _default2)
					# pylint: disable-next=unidiomatic-typecheck
					if type(val1) != type(val2):  # noqa: E721
						res = -2
					elif val1 == val2:
						res = 0
					elif val1 < val2:
						res = -1
					else:
						res = 1
					_values.append(((val1, res), "raw"))
				elif ptype == "timestamp_with_age":
					# The first array is assumed to be the start time, the second array the end time
					start_time = None
					end_time = None
					start_time_index = -1
					end_time_index = -1
					for i in range(0, len(mpaths)):
						if isinstance(mpaths[i], list):
							if start_time_index == -1:
								start_time_index = i
								start_time = deep_get_with_fallback(obj, mpaths[i], default = None)
							elif end_time_index == -1:
								end_time_index = i
								end_time = deep_get_with_fallback(obj, mpaths[i], default = None)
							else:
								raise ValueError(f"{field_name} received too many timestamp paths; the view file is most likely malformed")
					if end_time is None or start_time is None:
						end_time = None
						duration = -1
					else:
						timediff = timestamp_to_datetime(end_time) - timestamp_to_datetime(start_time)
						duration = timediff.days * 24 * 60 * 60 + timediff.seconds
					__values = []
					for i in range(0, len(mpaths)):
						if i == start_time_index:
							__values.append(end_time)
						elif i == end_time_index:
							__values.append(duration)
						else:
							__values.append(mpaths[i])
					_values.append((tuple(__values), "raw"))
				elif ptype in ("items", "appenditems"):
					if len(subpath) > 0:
						if len(subpaths) > 0:
							raise ValueError(f"Field {name}: when using action: 'items' exactly one of subpath and subpaths must be specified")
						subpaths = [subpath]
					value = []
					items = []
					index = deep_get(_path, DictPath("index"))
					for mpath in mpaths:
						if isinstance(mpath, str):
							mpath = [mpath]
						tmp = deep_get_list(obj, mpath, default = [], fallback_on_empty = fallback_on_empty)
						if index is not None:
							try:
								tmp = [tmp[index]]
							except IndexError:
								pass
						# XXX: This is to avoid breaking anything
						# Ideally the "appenditems" behaviour should be the only one,
						# but requires rewriting a lot of files
						if ptype == "items":
							items += tmp
						else:
							items.append(tmp)

					for item in items:
						if not when_filter(_path, item):
							continue

						tmp = []
						for i in range(0, len(subpaths)):
							if isinstance(default, list):
								if i < len(default):
									_default = default[i]
								else:
									_default = None
							else:
								_default = default

							if (vtype in ("int", "float") or action in ["sum"]) and type(default) not in (int, float):
								_default = 0

							if isinstance(subpaths[i], dict):
								_subpath = deep_get(subpaths[i], DictPath("str"))
								if _subpath is not None:
									tmp.append(_subpath)
								else:
									_subpath = deep_get(subpaths[i], DictPath("subpath"))
									if isinstance(_subpath, str):
										_subpath = [_subpath]
									_regexes = deep_get(subpaths[i], DictPath("regex"), [])
									if isinstance(_regexes, str):
										_regexes = [_regexes]
									_raw = deep_get_with_fallback(item, _subpath, _default)
									_raw = transform_filter(deep_get(subpaths[i], DictPath("transform"), {}), _raw)
									for _regex in _regexes:
										_tmp = re.match(_regex, _raw)
										if _tmp is not None:
											for group in _tmp.groups():
												if group is not None:
													tmp.append(group)
											break
										tmp.append("")
							else:
								prefix = deep_get(_path, DictPath("prefix"), [])
								suffix = deep_get(_path, DictPath("suffix"), [])
								_subpath = subpaths[i]
								if isinstance(_subpath, str):
									_subpath = [_subpath]
								_tmp = deep_get_with_fallback(item, _subpath, _default)
								if isinstance(prefix, str):
									if isinstance(_tmp, str):
										_tmp = prefix + _tmp
									else:
										_tmp = [prefix] + _tmp
								else:
									tmp += prefix

								if isinstance(suffix, str):
									if isinstance(_tmp, str):
										_tmp += suffix
									else:
										_tmp += [suffix]

								tmp.append(_tmp)

								if isinstance(suffix, list):
									tmp += suffix
						if len(tmp) == 1:
							value.append(tmp[0])
						else:
							value.append(tuple(tmp))
					if len(value) == 0:
						value = default
					if value is not None:
						if action in ("sum", "latest", "earliest"):
							_values.append((value, vtype))
						else:
							for tmp in value:
								_values.append((tmp, vtype))
				elif ptype == "count":
					count = 0
					for p in path:
						count += len(deep_get(obj, DictPath(p), {}))
					_values.append((count, vtype))
				elif ptype == "split":
					value = []
					separator = deep_get(_path, DictPath("separator"), ",")
					_raw = deep_get_with_fallback(obj, path, "")
					if _raw is not None:
						for tmp in _raw.split(separator):
							_values.append((tmp, vtype))
				elif ptype == "regex":
					value = []
					_raw = deep_get_with_fallback(obj, path, "")
					_regexes = deep_get(_path, DictPath("regex"), [])
					if isinstance(_regexes, str):
						_regexes = [_regexes]
					for _regex in _regexes:
						_tmp = re.match(_regex, _raw)
						if _tmp is not None:
							for group in _tmp.groups():
								if group is not None:
									value.append(group)
							break
					value = tuple(value)
					_values.append((value, "raw"))
				elif ptype == "tuple":
					value = []
					if not when_filter(_path, item = obj):
						continue
					for i in range(0, len(path)):
						if isinstance(default, list):
							if i < len(default):
								_default = default[i]
							else:
								_default = None
						else:
							_default = default

						if vtype in ("int", "float") and type(default) not in (int, float):
							_default = 0

						# This is a literal string, not a path
						if isinstance(path[i], str):
							tmp = path[i]
						else:
							tmp = deep_get_with_fallback(obj, path[i], default = _default, fallback_on_empty = fallback_on_empty)

						if vtype == "api_group":
							override_kind = deep_get_with_fallback(cmtlib.cmtconfig, [DictPath(f"Views#{view}#kind_format_{field_index}"),
														  DictPath(f"Views#{view}#kind_format"),
														  DictPath(f"Global#kind_format_{field_index}"),
														  DictPath("Global#kind_format")], "mixed")
							if override_kind == "skip" or override_kind == "mixed" and "." not in tmp:
								tmp = ""
							vtype = "kind"
						value.append(tmp)
					if isinstance(deep_get(_path, DictPath("substitute")), list):
						value = deep_get(_path, DictPath("substitute"))
					value = tuple(value)
					_values.append((value, vtype))
				elif ptype == "status_tuple":
					if "lookup" in _path:
						lookup_kind = deep_get(_path, DictPath("lookup#kind"))
						lookup_api_family = deep_get(_path, DictPath("lookup#api_family"))
						lookup_status = deep_get(_path, DictPath("lookup#status"))
					else:
						raise ValueError(f"Field {name}: currently status_tuple only supports 'lookup'")
					path = deep_get(_path, DictPath("path"))
					value = deep_get(obj, DictPath(path))
					tmp = kh.get_ref_by_kind_name_namespace((lookup_kind, lookup_api_family), value, "")
					if lookup_status == "highlight":
						if tmp is None:
							status_group = StatusGroup.NOT_OK
						else:
							status_group = StatusGroup.OK
						value = (value, status_group)
					elif lookup_status == "message":
						if tmp is None:
							value = (deep_get(_path, DictPath("lookup#messages#not_ok")), StatusGroup.NEUTRAL)
						else:
							value = (deep_get(_path, DictPath("lookup#messages#ok")), StatusGroup.NEUTRAL)
					_values.append((value, "raw"))
				elif ptype == "dictfields":
					subpaths = deep_get_with_fallback(_path, [DictPath("subpaths"), DictPath("subpath")], [])
					if isinstance(subpaths, str):
						subpaths = [[subpaths]]
					for mpath in mpaths:
						tmp = deep_get_with_fallback(obj, mpath)
						if not when_filter(_path, item = tmp):
							continue
						value = []
						for key in subpaths:
							if isinstance(key, str):
								value.append(key)
							else:
								value.append(deep_get_with_fallback(tmp, key, default))
						if len(value) == 1:
							_values.append((value[0], "raw"))
						else:
							_values.append((tuple(value), "raw"))
				else:
					value = deep_get_with_fallback(obj, path, default, fallback_on_empty = fallback_on_empty)
					_values.append((value, vtype))

			values = []

			for value, _vtype in _values:
				_regex = deep_get(_path, DictPath("regex"))
				if isinstance(_vtype, list):
					if value is None or len(value) == 0:
						value = []
				if isinstance(value, list) and _vtype == "raw":
					values += value
					continue
				if isinstance(value, list) and isinstance(_vtype, list):
					tmp = []
					for _value in value:
						tmp.append(process_value(name, _value, _vtype, view, field_index, action, formatter, replace_quotes, _regex))
				else:
					tmp = process_value(name, value, _vtype, view, field_index, action, formatter, replace_quotes, _regex)
				values.append(tmp)

			if len(values) == 0:
				values = global_default

			if isinstance(values, list) and len(values) == 1 and formatter != "list":
				d[name] = values[0]
			else:
				d[name] = values


	# We've got all the information we can get now; time to apply filters
	skip = False
	for f in filters:
		if not deep_get(filters[f], DictPath("enabled"), True):
			continue

		# If len(allow) > 0, we only allow fields that match
		allow = deep_get(filters[f], DictPath("allow"), [])
		# If len(block) > 0, we skip fields that match
		block = deep_get(filters[f], DictPath("block"), [])
		source = deep_get(filters[f], DictPath("source"), "")
		if source == "object":
			src = obj
		else:
			src = d
		if len(allow) > 0:
			# If all field + value pairs match we allow
			for rule in allow:
				key = deep_get(rule, DictPath("key"), "")
				values = deep_get(rule, DictPath("values"), "")

				if deep_get(src, DictPath(key), "").rstrip() not in values:
					skip = True
					break
		if len(block) > 0:
			# If all field + value pairs match we block
			for rule in block:
				key = deep_get(rule, DictPath("key"), "")
				values = deep_get(rule, DictPath("values"), "")
				if deep_get(src, DictPath(key), "").rstrip() in values:
					skip = True
					break
		if skip:
			break
	if skip:
		entry = None
	else:
		d["ref"] = obj
		d["__deleted"] = deleted
		d["__uid"] = deep_get(obj, DictPath("metadata#uid"))
		entry = type("InfoClass", (), d)

	return entry

def generic_infogetter(**kwargs: Dict) -> List[Dict]:
	info = []

	vlist = deep_get(kwargs, DictPath("_vlist"), [])

	# Generate an empty entry
	if vlist == []:
		return []

	field_dict = deep_get(kwargs, DictPath("_field_dict"), {})
	field_names = deep_get(kwargs, DictPath("_field_names"), [])
	field_index = deep_get(kwargs, DictPath("_field_index"), "Normal")
	filters = deep_get(kwargs, DictPath("_filters"), {})
	extra_data = deep_get(kwargs, DictPath("extra_data"), {})

	if len(field_dict) == 0 or len(field_names) == 0:
		sys.exit(f"generic_infogetter() received empty field_dict {field_dict} or field_names {field_names}; this is a programming error")

	# If we know the view we can use it to get overrides from cmt.yaml
	view = deep_get(kwargs, DictPath("_view"), "")
	for obj in vlist:
		if len(extra_data) > 0:
			obj["_extra_data"] = extra_data
		deleted = False
		if deep_get(obj, DictPath("metadata#deletionTimestamp")) is not None:
			deleted = True
		tmp = get_obj(obj, field_dict = field_dict, field_names = field_names, field_index = field_index, view = view, filters = filters, deleted = deleted)
		if tmp is None:
			continue

		info.append(tmp)

	return info

def get_device_model(obj: Dict, device: DictPath) -> str:
	for dev in deep_get(obj, DictPath("ansible_devices"), {}):
		partitions = deep_get(obj, DictPath(f"ansible_devices#{dev}#partitions"), {})
		model = deep_get(obj, DictPath(f"ansible_devices#{dev}#model"), "")
		for partition in partitions:
			if device in partition:
				return model
	return ""

# Takes a list and splits it into four lists;
# exacts, strings starting _and_ ending with "*", strings starting with "*",
# and strings ending with "*"
def split_matchlist(matchlist, exacts: List[str], prefixes: List[str], suffixes: List[str], ins: List[str]):
	tmp_exacts = []
	tmp_prefixes = []
	tmp_suffixes = []
	tmp_ins = []
	for item in matchlist:
		if item.startswith("*") and item.endswith("*"):
			tmp_ins.append(item[1:-1])
		elif item.endswith("*"):
			tmp_prefixes.append(item[:-1])
		elif item.startswith("*"):
			tmp_suffixes.append(item[1:])
		else:
			tmp_exacts.append(item)
	if len(tmp_exacts) == 0:
		tmp_exacts = exacts
	if len(tmp_prefixes) == 0:
		tmp_prefixes = prefixes
	if len(tmp_suffixes) == 0:
		tmp_suffixes = suffixes
	if len(tmp_ins) == 0:
		tmp_ins = ins
	return tmp_exacts, tuple(tmp_prefixes), tuple(tmp_suffixes), tmp_ins

def check_matchlists(item, exacts: List[str], prefixes: List[str], suffixes: List[str], ins: List[str]) -> bool:
	if item in exacts:
		return True
	for _in in ins:
		if _in in item:
			return True
	if len(prefixes) > 0 and item.startswith(prefixes) or len(suffixes) > 0 and item.endswith(suffixes):
		return True
	return False

# Takes an unprocessed matchlist, splits it into individual matchlists, and checks for matches
def check_matchlist(item, matchlist):
	exacts, prefixes, suffixes, ins = split_matchlist(matchlist, exacts = [], prefixes = [], suffixes = [], ins = [])
	return check_matchlists(item, exacts = exacts, prefixes = prefixes, suffixes = suffixes, ins = ins)

# pylint: disable-next=unused-argument
def listgetter_noop(obj: Dict, **kwargs: Dict) -> Tuple[Dict, str]:
	"""
	A noop listgetter that returns an empty list
		Parameters:
			obj (Dict): Unused
			kwargs (Dict): Unused
		Returns:
			(match_list, retval):
				match_list (list[dict]): An empty list
				retval (str): Always "OK"
	"""

	return [], "OK"

# pylint: disable-next=unused-argument
def listgetter_matchrules(obj: Dict, **kwargs: Dict) -> Tuple[Dict, str]:
	"""
	Extract match rules from an object

		Parameters:
			obj (Dict): The object to extract a list of matchrules from
			kwargs (Dict): Additional parameters
		Returns:
			(match_list, retval):
				match_list (list[dict]): The list of data
				retval (str): Always "OK"
	"""

	match_list = []

	for match_any in deep_get(obj, DictPath("matchAny"), []):
		for match_feature in deep_get(match_any, DictPath("matchFeatures"), []):
			feature = deep_get(match_feature, DictPath("feature"), "")
			match_expressions_dict = deep_get(match_feature, DictPath("matchExpressions"), {})
			match_expressions = []
			for match_expression_name, match_expression in match_expressions_dict.items():
				tmp = make_set_expression_list([match_expression], match_expression_name)[0]
				match_expressions.append(tmp)
			match_list.append({
				"feature": f"Any:{feature}",
				"match_expressions": match_expressions,
			})

	for match_feature in deep_get(obj, DictPath("matchFeatures"), []):
		feature = deep_get(match_feature, DictPath("feature"), "")
		match_expressions_dict = deep_get(match_feature, DictPath("matchExpressions"), {})
		match_expressions = []
		for match_expression_name, match_expression in match_expressions_dict.items():
			tmp = make_set_expression_list([match_expression], match_expression_name)[0]
			match_expressions.append(tmp)
		match_list.append({
			"feature": f"{feature}",
			"match_expressions": match_expressions,
		})

	return match_list, "OK"

# pylint: disable-next=unused-argument
def listgetter_ansible_volumes(obj: Dict, **kwargs: Dict) -> Tuple[List[Dict], str]:
	info = []

	# Find all mounts
	for item in deep_get(obj, DictPath("ansible_mounts"), []):
		d = {}
		device = deep_get(item, DictPath("device"), "")
		if len(device) == 0:
			continue
		fstype = deep_get(item, DictPath("fstype"), "")
		size_total = deep_get(item, DictPath("size_total"), 0)
		if size_total == 0:
			continue
		size_available = deep_get(item, DictPath("size_available"), 0)
		partition_size_total = disksize_to_human(size_total)
		partition_size_used = disksize_to_human(size_total - size_available)
		mountpoint = deep_get(item, DictPath("mount"), "")
		options = deep_get(item, DictPath("options"), "").split(",")
		# NFS mounts can be added directly; no need to do lookups
		if fstype == "nfs":
			d = {
				"mountpoint": mountpoint,
				"fstype": fstype,
				"options": options,
				"device": device,
				"model": "",
				"partition_size_used": partition_size_used,
				"partition_size_total": partition_size_total,
			}
			info.append(d)
			continue
		device = os.path.basename(device)

		if check_matchlist(mountpoint, deep_get(cmtlib.cmtconfig, DictPath("__Inventory#mountpoint_skiplist"), ["/boot/efi", "/var/lib/origin/*", "/run/*", "*@docker*"])):
			continue
		if check_matchlist(device, deep_get(cmtlib.cmtconfig, DictPath("__Inventory#device_skiplist"), ["loop*"])):
			continue

		model = get_device_model(obj, device)
		d = {
			"mountpoint": mountpoint,
			"fstype": fstype,
			"options": options,
			"device": device,
			"partition_size_used": partition_size_used,
			"partition_size_total": partition_size_total,
			"model": model,
		}
		info.append(d)

	return info, "OK"

def get_journalctl_log(obj: Dict, **kwargs: Dict):
	timestamps = []
	facilities = []
	severities = []
	messages = []

	show_raw = deep_get(kwargs, DictPath("_show_raw"), False)
	objlist = deep_get(obj, DictPath("obj"))
	parser = deep_get(objlist[0], DictPath("parser"))

	for line in objlist[1:]:
		try:
			d = json.loads(line)
		except DecodeException:
			d = {}

		timestamp = datetime.fromtimestamp(int(deep_get(d, DictPath("__REALTIME_TIMESTAMP")), 0) / 1000000)
		severity = None
		facility = ""
		remnants = None
		msg = ""

		raw_severity = int(deep_get(d, DictPath("PRIORITY"), "6"))
		raw_msg = deep_get(d, DictPath("MESSAGE"), "")

		if show_raw:
			msg = raw_msg
		elif parser == "glog":
			msg, severity, facility, remnants, matched = logparsers.split_glog(raw_msg, raw_severity)

			if not matched:
				severity = raw_severity
				remnants = None
				msg = raw_msg
		elif "=" in raw_msg and parser == "key_value":
			facility, severity, msg, remnants = logparsers.key_value(raw_msg, raw_severity, fold_msg = False)
		else:
			severity = raw_severity
			msg = raw_msg

		timestamps.append(timestamp)
		facilities.append(facility)
		if severity is None:
			severity = raw_severity
		severities.append(severity)
		messages.append(msg)

		if remnants is not None:
			if isinstance(remnants, tuple):
				fmt_remnants, remnant_severity = remnants

				for remnant in fmt_remnants:
					timestamps.append("")
					facilities.append("")
					severities.append(remnant_severity)
					messages.append(remnant)
			else:
				for remnant, remnant_severity in remnants:
					timestamps.append("")
					facilities.append("")
					severities.append(remnant_severity)
					messages.append(remnant)

	return (timestamps, facilities, severities, messages)

# pylint: disable-next=unused-argument
def get_traceflow(obj: Dict, **kwargs: Dict):
	timestamps = []
	facilities = []
	severities = []
	messages = []

	for result in deep_get(obj, DictPath("status#results"), []):
		node = deep_get(result, DictPath("node"), "<unset>")
		nodestr_len = len(node) + themearray_len([ThemeRef("separators", "facility_prefix"), ThemeRef("separators", "facility_suffix"), ThemeRef("separators", "facility_padding")])
		tmp_timestamp = deep_get(result, DictPath("timestamp"), -1)
		if tmp_timestamp >= 0:
			saved_timestamp = str(datetime.fromtimestamp(tmp_timestamp))
		else:
			saved_timestamp = ""
		message = []
		for observation in deep_get(result, DictPath("observations"), []):
			facility = node
			timestamp = saved_timestamp
			for key, value in sorted(observation.items()):
				facilities.append(facility)
				timestamps.append(timestamp)
				message = []
				if len(facility) == 0 and len(node) > 0:
					message.append(ThemeString("".ljust(nodestr_len), ThemeAttr("main", "default")))
				message += [
					ThemeString(key, ThemeAttr("types", "yaml_key")),
					ThemeRef("separators", "yaml_key_separator"),
					ThemeRef("separators", "space"),
					ThemeString(value, ThemeAttr("types", "yaml_value")),
				]
				messages.append(message)
				facility = ""
				timestamp = ""

	return (timestamps, facilities, severities, messages)

# pylint: disable-next=unused-argument
def get_task_log(obj: Dict, **kwargs: Dict):
	field = []

	skipped = deep_get(obj, DictPath("log#skipped"), False)
	stdout_lines = deep_get(obj, DictPath("log#stdout_lines"), [])
	stderr_lines = deep_get(obj, DictPath("log#stderr_lines"), [])
	msg_lines = deep_get(obj, DictPath("log#msg_lines"), [])

	if skipped:
		field.append([ThemeString("[skipped]", ThemeAttr("types", "unset"))])
		return field

	if len(stderr_lines) > 0:
		field.append([ThemeString("stderr:", ThemeAttr("main", "paragraphheader"))])
		for line in stderr_lines:
			field.append([ThemeString(f"{line}", color_status_group(StatusGroup.NOT_OK))])

	if len(stdout_lines) > 0:
		if len(field) > 0:
			field.append([ThemeString("", ThemeAttr("main", "default"))])
		field.append([ThemeString("stdout:", ThemeAttr("main", "paragraphheader"))])
		for line in stdout_lines:
			field.append([ThemeString(f"{line}", ThemeAttr("main", "default"))])

	if len(msg_lines) > 0:
		if len(field) > 0:
			field.append([ThemeString("", ThemeAttr("main", "default"))])
			field.append([ThemeString("", ThemeAttr("main", "default"))])
		field.append([ThemeString("msg:", ThemeAttr("main", "paragraphheader"))])
		for line in msg_lines:
			field.append([ThemeString(f"{line}", color_status_group(StatusGroup.OK))])

	return field

# pylint: disable-next=unused-argument
def get_themearrays(obj: Dict, **kwargs: Dict) -> Dict:
	return obj

def logpad_files(obj: Dict, **kwargs: Dict) -> List[List[Union[ThemeRef, ThemeString]]]:
	# This is essentially just a wrapper around listgetter_files
	show_raw = deep_get(kwargs, DictPath("_show_raw"), False)
	extra_values = deep_get(kwargs, DictPath("extra_values"), {})
	extra_values_lookup = deep_get(kwargs, DictPath("extra_values_lookup"), {})
	formatter = deep_get(kwargs, DictPath("formatter"), "none")

	for key, path in extra_values_lookup.items():
		if "extra_values" not in kwargs:
			kwargs["extra_values"] = {}
		kwargs["extra_values"][key] = deep_get_with_fallback(obj, path, "")

	kwargs.pop("extra_values_lookup", "")

	vlist, _status = listgetter_files(**kwargs)

	formatter_args = deep_get(kwargs, DictPath("formatter_args"), {})

	if not show_raw and formatter == "markdown":
		return formatters.format_markdown(vlist[0], **formatter_args)
	return formatters.format_none(vlist[0], **formatter_args)

def logpad_formatted(obj: Dict, **kwargs: Dict) -> List[List[Union[ThemeRef, ThemeString]]]:
	"""
	Takes an object and dumps it using the specified format (if possible)

		Parameters:
			obj (dict): The dict to dump
			kwargs (Dict): Additional parameters
		Returns:
			list[themearray]: A list of themearrays
	"""

	path = deep_get(kwargs, DictPath("path"), "")
	dump_formatter_tmp = deep_get(kwargs, DictPath("formatter"), "format_none")
	dump_formatter = deep_get(formatter_allowlist, DictPath(dump_formatter_tmp))
	if dump_formatter is None:
		raise ValueError(f"{dump_formatter_tmp} is not a valid formatter; the view-file is probably incorrect.")

	messages = dump_formatter(deep_get(obj, path))

	return messages

# pylint: disable-next=unused-argument
def get_cmt_log(obj: Dict, **kwargs: Dict):
	filepath = deep_get(obj, DictPath("filepath"), "")
	timestamps = []
	messages = []
	facilities = []
	severities = []
	messages = []

	d = secure_read_yaml(filepath)

	if len(d) == 0 or not isinstance(d, list):
		return messages

	for message in d:
		timestamp = deep_get(message, DictPath("timestamp"), "")
		severity = deep_get(message, DictPath("severity"), "")
		facility = deep_get(message, DictPath("facility"), "")
		file = deep_get(message, DictPath("file"), "")
		function = deep_get(message, DictPath("function"), "")
		lineno = deep_get(message, DictPath("lineno"), "")

		facilitystr = f"{file}:{lineno} [{function}()]"

		themestrings = True
		msgs = deep_get(message, DictPath("themearray"), [])
		if len(msgs) == 0:
			themestrings = False
			msgs = deep_get(message, DictPath("strarray"), [])

		first = True

		for msg in msgs:
			if first:
				timestamps.append(timestamp)
				if len(facility) > 0:
					facilities.append((facilitystr, facility))
				else:
					facilities.append(facilitystr)
				first = False
			else:
				timestamps.append("")
				if len(facility) > 0:
					facilities.append(("".ljust(len(facilitystr)), "".ljust(len(facility))))
				else:
					facilities.append("".ljust(len(facilitystr)))
			severities.append(severity)

			reformatted_msg = []
			for substring in msg:
				if themestrings:
					# These log messages are in ANSIThemeString format;
					# hence we need to convert them to ThemeStrings.
					# Luckily ANSIThemeString has fewer formats
					# than ThemeString. We should probably have
					# a cross-reference table in themes though.
					string = deep_get(substring, DictPath("string"))
					themeref = deep_get(substring, DictPath("themeref"))
				else:
					string = substring
					themeref = "default"
				if themeref == "default":
					fmt = ThemeAttr("main", "default")
				elif themeref == "emphasis":
					fmt = ThemeAttr("main", "highlight")
				elif themeref == "argument":
					fmt = ThemeAttr("main", "infoheader")
				elif themeref == "error":
					fmt = ThemeAttr("logview", "severity_error")
				# Insert more here when necessary
				else:
					fmt = ThemeAttr("main", "default")
				reformatted_msg.append(ThemeString(string, fmt))
			messages.append(reformatted_msg)

	return (timestamps, facilities, severities, messages)

def logpad_yaml(obj: Dict, **kwargs: Dict) -> List[List[Union[ThemeRef, ThemeString]]]:
	"""
	Takes an object and dumps it as formatted YAML

		Parameters:
			obj (dict): The dict to dump formatted as YAML
			kwargs (Dict): Additional parameters
		Returns:
			list[themearray]: A list of themearrays
	"""

	try:
		tmp = yaml.dump(obj)
		messages = formatters.format_yaml(tmp)
	except yaml.YAMLError:
		messages = []

	return messages

def logpad_msg_getter(obj: Dict, **kwargs: Dict) -> List[List[Union[ThemeRef, ThemeString]]]:
	messages: List[List[Union[ThemeRef, ThemeString]]] = []

	path = deep_get(kwargs, DictPath("path"))
	tmp = deep_get(obj, DictPath(path), "")

	for line in split_msg(tmp):
		messages.append([ThemeString(f"{line}", ThemeAttr("main", "default"))])

	return messages

# pylint: disable-next=unused-argument
def get_netpol_rule_list(obj: Dict, **kwargs: Dict) -> Tuple[List[Dict], int]:
	vlist = []
	for item in deep_get(obj, DictPath("spec#ingress"), []):
		policy_type = "ingress"
		ports = []
		for port in deep_get(item, DictPath("ports"), []):
			ports.append((deep_get(port, DictPath("port"), ""), deep_get(port, DictPath("protocol"), "")))
		pod_label_selector = deep_get(item, DictPath("podSelector#matchLabels"), {})
		namespace_label_selector = deep_get(item, DictPath("namespaceSelector#matchLabels"), {})

		from_rules = deep_get(item, DictPath("from"), [])

		for source in from_rules:
			ipblock = deep_get(source, DictPath("cidr"))
			ipblock_exceptions = deep_get(source, DictPath("except"))
			vlist.append({
				"policy_type": policy_type,
				"ipblock": ipblock,
				"ipblock_exceptions": ipblock_exceptions,
				"ports": ports,
				"pod_label_selector": pod_label_selector,
				"namespace_label_selector": namespace_label_selector,
			})

		if len(from_rules) == 0:
			vlist.append({
				"policy_type": policy_type,
				"ipblock": "",
				"ipblock_exceptions": [],
				"ports": ports,
				"pod_label_selector": pod_label_selector,
				"namespace_label_selector": namespace_label_selector,
			})

	for item in deep_get(obj, DictPath("spec#egress"), []):
		policy_type = "egress"
		ports = []
		for port in deep_get(item, DictPath("ports"), []):
			ports.append((deep_get(port, DictPath("port"), ""), deep_get(port, DictPath("protocol"), "")))
		pod_label_selector = deep_get(item, DictPath("podSelector#matchLabels"), {})
		namespace_label_selector = deep_get(item, DictPath("namespaceSelector#matchLabels"), {})

		to_rules = deep_get(item, DictPath("to"), [])

		for source in to_rules:
			ipblock = deep_get(source, DictPath("cidr"))
			ipblock_exceptions = deep_get(source, DictPath("except"))
			vlist.append({
				"policy_type": policy_type,
				"ipblock": ipblock,
				"ipblock_exceptions": ipblock_exceptions,
				"ports": ports,
				"pod_label_selector": pod_label_selector,
				"namespace_label_selector": namespace_label_selector,
			})

		if len(to_rules) == 0:
			vlist.append({
				"policy_type": policy_type,
				"ipblock": "",
				"ipblock_exceptions": [],
				"ports": ports,
				"pod_label_selector": pod_label_selector,
				"namespace_label_selector": namespace_label_selector,
			})

	return vlist, 200

# pylint: disable-next=unused-argument
def get_virtsvc_rule_list(obj: Dict, **kwargs: Dict) -> Tuple[List[Dict], int]:
	vlist = []

	for rule_path, rule_type in [("spec#http", "HTTP"), ("spec#tls", "TLS"), ("spec#tcp", "TCP")]:
		destinations = []

		for rule in deep_get(obj, DictPath(rule_path), []):
			for item in deep_get(rule, DictPath("route"), []):
				host = deep_get(item, DictPath("destination#host"), "")
				subset = deep_get(item, DictPath("destination#subset"))
				if subset is None:
					subset = "*"
				port = deep_get(item, DictPath("destination#port#number"), "")
				destinations.append((host, subset, port))

		if len(destinations) > 0:
			vlist.append({
				"rule_type": rule_type,
				"destinations": destinations,
			})

	return vlist, 200

def get_promrules_info(**kwargs: Dict) -> List[Type]:
	"""
	Infogetter for Prometheus Rules

		Parameters:
			kwargs (dict): Additional parameters
		Returns:
			info (list[InfoClass]): A list with info
	"""

	obj = deep_get(kwargs, DictPath("_obj"))
	info: List[Type] = []

	if obj is None:
		return []

	for group in deep_get(obj, DictPath("spec#groups"), []):
		for rule in deep_get(group, DictPath("rules")):
			name = deep_get(group, DictPath("name"))
			alert = deep_get(rule, DictPath("alert"), "")
			record = deep_get(rule, DictPath("record"), "")
			if len(alert) > 0 and len(record) > 0:
				sys.exit("We need a better way to handle PrometheusRule; this one has both an alert and a record")
			elif len(alert) > 0:
				rtype = "Alert"
				alertrecord = alert
			elif len(record) > 0:
				rtype = "Record"
				alertrecord = record
			else:
				sys.exit("We need a better way to handle PrometheusRule; this one has neither alert nor record")
			_extra_data = {
				"name": alertrecord,
				"group": name,
				"rtype": rtype,
			}
			if "_extra_data" not in rule:
				rule["_extra_data"] = _extra_data
			ref = rule
			age = deep_get(rule, DictPath("for"), "")
			duration = cmtlib.age_to_seconds(age)
			info.append(type("InfoClass", (), {
				"group": name,
				"ref": ref,
				"rtype": rtype,
				"alertrecord": alertrecord,
				"duration": duration,
			}))
	return info

def get_svcmon_endpoints_info(**kwargs: Dict) -> List[Type]:
	"""
	Infogetter for Service Monitor Endpoints

		Parameters:
			kwargs (dict): Additional parameters
		Returns:
			info (list[InfoClass]): A list with info
	"""

	obj = deep_get(kwargs, DictPath("_obj"))
	info: List[Type] = []

	if obj is None:
		return []

	for item in deep_get(obj, DictPath("spec#endpoints")):
		bearer_token_file = deep_get(item, DictPath("bearerTokenFile"), "")
		ref = item
		port = deep_get(item, DictPath("port"), "")
		target_port = deep_get(item, DictPath("targetPort"), "")
		interval = deep_get(item, DictPath("interval"), "")
		scheme = deep_get(item, DictPath("scheme"), "")
		path = deep_get(item, DictPath("path"), "")
		honor_labels = deep_get(item, DictPath("honorLabels"), "")
		proxy_url = deep_get(item, DictPath("proxyUrl"), "")
		info.append(type("InfoClass", (), {
			"bearer_token_file": bearer_token_file,
			"ref": ref,
			"port": port,
			"target_port": target_port,
			"interval": interval,
			"scheme": scheme,
			"path": path,
			"honor_labels": honor_labels,
			"proxy_url": proxy_url
		}))

	return info

def get_limit_info(**kwargs: Dict) -> List[Type]:
	"""
	Infogetter for Limits

		Parameters:
			kwargs (dict): Additional parameters
		Returns:
			info (list[InfoClass]): A list with info
	"""

	obj = deep_get(kwargs, DictPath("_obj"))
	info: List[Type] = []

	if obj is None:
		return []

	for limit in deep_get(obj, DictPath("spec#limits"), []):
		resources = set()

		for item in deep_get(limit, DictPath("default"), []):
			resources.add(item)
		for item in deep_get(limit, DictPath("defaultRequest"), []):
			resources.add(item)
		for item in deep_get(limit, DictPath("min"), []):
			resources.add(item)
		for item in deep_get(limit, DictPath("max"), []):
			resources.add(item)
		for item in deep_get(limit, DictPath("max"), []):
			resources.add(item)
		for item in deep_get(limit, DictPath("maxLimitRequestRatio"), []):
			resources.add(item)
		ltype = deep_get(limit, DictPath("type"))

		for item in resources:
			lmin = deep_get(limit, DictPath(f"min#{item}"), "-")
			lmax = deep_get(limit, DictPath(f"max#{item}"), "-")
			default_request = deep_get(limit, DictPath(f"defaultRequest#{item}"), "-")
			default_limit = deep_get(limit, DictPath(f"default#{item}"), "-")
			max_lr_ratio = deep_get(limit, DictPath(f"maxLimitRequestRatio#{item}"), "-")
			info.append(type("InfoClass", (), {
				"name": item,
				"ref": limit,
				"ltype": ltype,
				"lmin": lmin,
				"lmax": lmax,
				"default_request": default_request,
				"default_limit": default_limit,
				"max_lr_ratio": max_lr_ratio,
			}))
	return info

def get_auth_rule_info(**kwargs: Dict) -> List[Type]:
	"""
	Infogetter for Istio Authorization Policy Rules

		Parameters:
			kwargs (dict): Additional parameters
		Returns:
			info (list[InfoClass]): A list with info
	"""

	obj = deep_get(kwargs, DictPath("_obj"))
	info: List[Type] = []

	if obj is None:
		return []

	for item in deep_get(obj, DictPath("spec#rules"), []):
		sources = []
		operations = []
		conditions = []

		for source in deep_get(item, DictPath("from"), []):
			principals = ",".join(deep_get(source, DictPath("source#principals"), []))
			not_principals = ",".join(deep_get(source, DictPath("source#notPrincipals"), []))
			request_principals = ",".join(deep_get(source, DictPath("source#requestPrincipals"), []))
			not_request_principals = ",".join(deep_get(source, DictPath("source#notRequestPrincipals"), []))
			namespaces = ",".join(deep_get(source, DictPath("source#namespaces"), []))
			not_namespaces = ",".join(deep_get(source, DictPath("source#notNamespaces"), []))
			ip_blocks = ",".join(deep_get(source, DictPath("source#ipBlocks"), []))
			not_ip_blocks = ",".join(deep_get(source, DictPath("source#notIpBlocks"), []))
			sources.append((principals, not_principals, request_principals, not_request_principals, namespaces, not_namespaces, ip_blocks, not_ip_blocks))

		for operation in deep_get(item, DictPath("to"), []):
			hosts = ",".join(deep_get(operation, DictPath("operation#hosts"), []))
			not_hosts = ",".join(deep_get(operation, DictPath("operation#notHosts"), []))
			ports = ",".join(deep_get(operation, DictPath("operation#ports"), []))
			not_ports = ",".join(deep_get(operation, DictPath("operation#notPorts"), []))
			methods = ",".join(deep_get(operation, DictPath("operation#methods"), []))
			not_methods = ",".join(deep_get(operation, DictPath("operation#notMethods"), []))
			paths = ",".join(deep_get(operation, DictPath("operation#paths"), []))
			not_paths = ",".join(deep_get(operation, DictPath("operation#notPaths"), []))
			operations.append((hosts, not_hosts, ports, not_ports, methods, not_methods, paths, not_paths))

		for condition in deep_get(item, DictPath("when"), []):
			key = deep_get(condition, DictPath("key"))
			values = ",".join(deep_get(condition, DictPath("values"), []))
			not_values = ",".join(deep_get(condition, DictPath("notValues"), []))
			conditions.append((key, values, key, not_values))

		if len(sources) > 0 or len(operations) > 0 or len(conditions) > 0:
			info.append(type("InfoClass", (), {
				"sources": sources,
				"operations": operations,
				"conditions": conditions,
			}))
	return info

def listgetter_feature_gates(obj: Dict, **kwargs: Dict) -> Tuple[Union[Dict, List[Dict]], int]:
	"""
	Listgetter for FeatureGate.config.openshift.io

		Parameters:
			obj (Dict): The object to extract a list of data from
			kwargs (Dict): Additional parameters
		Returns:
			(vlist, retval):
				vlist (list[dict]): The list of data
				retval (int): The return value
	"""

	vlist = []
	path = deep_get(kwargs, DictPath("path"))

	for payload_version_data in deep_get(obj, DictPath(path), []):
		version = deep_get(payload_version_data, DictPath("version"), "<unknown>")
		for enabled_feature_gate in deep_get(payload_version_data, DictPath("enabled"), []):
			name = deep_get(enabled_feature_gate, DictPath("name"), "<unknown>")
			item = {
				"enabled": True,
				"version": version,
				"name": name,
			}
			vlist.append(item)
		for disabled_feature_gate in deep_get(payload_version_data, DictPath("disabled"), []):
			name = deep_get(disabled_feature_gate, DictPath("name"), "<unknown>")
			item = {
				"enabled": False,
				"version": version,
				"name": name,
			}
			vlist.append(item)
	return vlist, 200

def listgetter_path(obj: Dict, **kwargs: Dict) -> Tuple[Union[Dict, List[Dict]], int]:
	"""
	Listgetter for paths

		Parameters:
			obj (Dict): The object to extract a list of data from
			kwargs (Dict): Additional parameters
		Returns:
			(vlist, retval):
				vlist (list[dict]): The list of data
				retval (int): The return value
	"""

	vlists = []
	vlist = []

	rename_bare = deep_get(kwargs, DictPath("rename_bare"), None)
	flatten_dicts = deep_get(kwargs, DictPath("flatten_dicts"), False)
	paths = deep_get(kwargs, DictPath("paths"))
	join_key = deep_get(kwargs, DictPath("join_key"))

	if paths is not None:
		ppaths = []

		for path in paths:
			ppath = deep_get(path, DictPath("path"))
			ptype = deep_get(path, DictPath("type"))
			key_name = deep_get(path, DictPath("key_name"))
			key_value = deep_get(path, DictPath("key_value"))

			if ptype == "list":
				tmp = []
				for item in deep_get(obj, DictPath(ppath), []):
					tmpitem = copy.deepcopy(item)
					if key_name is not None and key_value is not None:
						tmpitem[key_name] = key_value
					tmp.append(tmpitem)
				vlists.append(tmp)
			else:
				for key in deep_get(obj, DictPath(ppath), []):
					for item in deep_get(obj, DictPath(f"{ppath}#{key}"), []):
						tmpitem = copy.deepcopy(item)
						if key_name is not None and key_value is not None:
							tmpitem[key_name] = key_value
						vlist.append(tmpitem)
		if join_key is None:
			for tmp in vlists:
				vlist += tmp
		else:
			for tmp in vlists:
				vlist = [{**u, **v} for u, v in zip_longest(vlist, tmp, fillvalue = {})]
		return vlist, 200

	path = deep_get(kwargs, DictPath("path"))
	subpath = deep_get(kwargs, DictPath("subpath"))
	path_fields = deep_get(kwargs, DictPath("path_fields"))

	# As a special case passing the empty string as path will return the object instead of a list
	if path == "":
		return obj, 200

	# If a subpath and path_fields are set path_fields from path will be merged into subpath
	# and the subpath lists are flattened into the path list.
	if subpath is not None and path_fields is not None:
		for item in deep_get(obj, DictPath(path), []):
			for subobj in deep_get(item, DictPath(subpath), []):
				for path_field in path_fields:
					subobj[path_field] = deep_get(item, DictPath(path_field))
				vlist.append(subobj)
	else:
		tmp = deep_get(obj, DictPath(path))
		vlist = []
		if rename_bare is not None and tmp is not None:
			for item in tmp:
				if not isinstance(item, dict):
					d = { rename_bare: item }
					if flatten_dicts and isinstance(deep_get(tmp, DictPath(item)), dict):
						for key, value in deep_get(tmp, DictPath(item), {}).items():
							d[key] = value
					vlist.append(d)
				else:
					vlist.append(item)
		else:
			vlist = tmp

	return vlist, 200

# pylint: disable-next=unused-argument
def listgetter_policy_rules(obj: Dict, **kwargs: Dict) -> Tuple[List[Dict], int]:
	"""
	Listgetter for Role & ClusterRole policy rules

		Parameters:
			obj (Dict): The object to extract ingress policy rule information from
			kwargs (Dict): Additional parameters
		Returns:
			((vlist, retval)):
				vlist (list[dict]): The ingress rules
				retval (int): The return value
	"""

	vlist: List[Dict] = []

	if obj is None:
		return [], 200

	# We want one entry per resource, hence a dict
	# Structure:
	# {
	# (api_group, resource): {
	#	"non_resource_urls": [],
	#	"resource_names": [],
	#	"verbs": [],
	# }
	resources: Dict = {}

	for rule in deep_get(obj, DictPath("rules"), []):
		non_resource_urls = deep_get(rule, DictPath("nonResourceURLs"), [])
		resource_names = deep_get(rule, DictPath("resourceNames"), [])
		verbs = deep_get(rule, DictPath("verbs"), [])
		api_groups = deep_get(rule, DictPath("apiGroups"), [""])
		resourcelist = deep_get(rule, DictPath("resources"), [""])

		for api_group in api_groups:
			for resource in resourcelist:
				tmp = (resource, api_group)
				if tmp not in resources:
					resources[tmp] = {
						"non_resource_urls": {},
						"resource_names": {},
						"verbs": {},
					}
				for non_resource_url in non_resource_urls:
					resources[tmp]["non_resource_urls"][non_resource_url] = {}
				for resource_name in resource_names:
					resources[tmp]["resource_names"][resource_name] = {}
				for verb in verbs:
					resources[tmp]["verbs"][verb] = {}

	for item in resources.items():
		resource, data = item
		resource, api_group = resource
		non_resource_urls = list(deep_get(data, DictPath("non_resource_urls"), {}))
		resource_names = list(deep_get(data, DictPath("resource_names"), {}))
		verbs = list(deep_get(data, DictPath("verbs"), {}))
		verbs_all = "*" in verbs
		# "*" includes all other verbs
		if verbs_all:
			verbs_get = True
			verbs_list = True
			verbs_watch = True
			verbs_create = True
			verbs_update = True
			verbs_patch = True
			verbs_delete = True
			verbs_misc = ["*"]
		else:
			verbs_get = "get" in verbs
			verbs_list = "list" in verbs
			verbs_watch = "watch" in verbs
			verbs_create = "create" in verbs
			verbs_update = "update" in verbs
			verbs_patch = "patch" in verbs
			verbs_delete = "delete" in verbs
			verbs_misc = []
			for verb in verbs:
				if verb not in ("*", "get", "list", "watch", "create", "update", "patch", "delete"):
					verbs_misc.append(verb)

		vlist.append({
			"resource": resource,
			"api_group": api_group,
			"non_resource_urls": non_resource_urls,
			"resource_names": resource_names,
			"verbs": verbs,
			"verbs_all": verbs_all,
			"verbs_get": verbs_get,
			"verbs_list": verbs_list,
			"verbs_watch": verbs_watch,
			"verbs_create": verbs_create,
			"verbs_update": verbs_update,
			"verbs_patch": verbs_patch,
			"verbs_delete": verbs_delete,
			"verbs_misc": natsorted(verbs_misc)
		})

	return vlist, 200

# pylint: disable-next=unused-argument
def get_ingress_rule_list(obj: Dict, **kwargs: Dict) -> Tuple[List[Dict], int]:
	"""
	Listgetter for Ingress rules

		Parameters:
			obj (Dict): The object to extract ingress rule information from
			kwargs (Dict): Additional parameters
		Returns:
			((vlist, retval)):
				vlist (list[dict]): The ingress rules
				retval (int): The return value
	"""

	vlist = []

	for item in deep_get(obj, DictPath("spec#rules"), []):
		host = deep_get(item, DictPath("host"), "*")

		if deep_get(item, DictPath("http")) is not None:
			for path in deep_get(item, DictPath("http#paths")):
				rpath = deep_get(path, DictPath("path"), "")
				path_type = deep_get(path, DictPath("pathType"), "")
				if "service" in deep_get(path, DictPath("backend"), {}):
					backend_kind = ("Service", "")
					name = deep_get(path, DictPath("backend#service#name"))
					port = (deep_get(path, DictPath("backend#service#port#number"), ""), deep_get(path, DictPath("backend#service#port#name"), ""))
				elif "resource" in deep_get(path, DictPath("backend"), {}):
					backend_kind = (deep_get(path, DictPath("backend#resource#kind"), ""), deep_get(path, DictPath("backend#resource#apiGroup"), ""))
					name = deep_get(path, DictPath("backend#resource#name"), "")
					port = ("", "")
				# Old-style ingress rule
				else:
					backend_kind = ("Service", "")
					name = deep_get(path, DictPath("backend#serviceName"))
					port = (deep_get(path, DictPath("backend#servicePort"), ""), "")

				vlist.append({
					"host": host,
					"path": rpath,
					"path_type": path_type,
					"backend_kind": backend_kind,
					"name": name,
					"port": port,
				})

	return vlist, 200

def get_sas_info(**kwargs: Dict) -> List[Type]:
	"""
	Infogetter for Service Account secrets

		Parameters:
			kwargs (dict): Additional parameters
		Returns:
			info (list[InfoClass]): A list with info
	"""

	obj = deep_get(kwargs, DictPath("_obj"))
	info: List[Type] = []

	if obj is None:
		return []

	saname = deep_get(obj, DictPath("metadata#name"))
	sanamespace = deep_get(obj, DictPath("metadata#namespace"))

	for secret in deep_get(obj, DictPath("secrets"), []):
		snamespace = deep_get(secret, DictPath("namespace"), deep_get(obj, DictPath("metadata#namespace")))
		secret_name = deep_get(secret, DictPath("name"))

		# Get a reference to the secret
		ref = kh.get_ref_by_kind_name_namespace(("Secret", ""), secret_name, snamespace)

		info.append(type("InfoClass", (), {
			"name": secret_name,
			"ref": ref,
			"namespace": snamespace,
			"kind": ("Secret", ""),
			"type": "Mountable",
		}))

	for secret in deep_get(obj, DictPath("imagePullSecrets"), []):
		deep_set(ref, DictPath("kind"), "Secret", create_path = True)
		deep_set(ref, DictPath("apiVersion"), "", create_path = True)
		snamespace = deep_get(secret, DictPath("namespace"), deep_get(obj, DictPath("metadata#namespace")))
		secret_name = deep_get(secret, DictPath("name"))

		# Get a reference to the secret
		ref = kh.get_ref_by_kind_name_namespace(("Secret", ""), secret_name, snamespace)

		info.append(type("InfoClass", (), {
			"name": secret_name,
			"ref": ref,
			"namespace": snamespace,
			"kind": ("Secret", ""),
			"type": "Image Pull",
		}))

	vlist, status = kh.get_list_by_kind_namespace(("RoleBinding", "rbac.authorization.k8s.io"), "")

	# Get all Role Bindings that bind to this ServiceAccount
	for ref in vlist:
		deep_set(ref, DictPath("kind"), "RoleBinding", create_path = True)
		deep_set(ref, DictPath("apiVersion"), "rbac.authorization.k8s.io/", create_path = True)
		for subject in deep_get(ref, DictPath("subjects"), []):
			subjectkind = deep_get(subject, DictPath("kind"), "")
			subjectname = deep_get(subject, DictPath("name"), "")
			subjectnamespace = deep_get(subject, DictPath("namespace"), "")
			if subjectkind == "ServiceAccount" and subjectname == saname and subjectnamespace == sanamespace:
				info.append(type("InfoClass", (), {
					"name": deep_get(ref, DictPath("metadata#name")),
					"ref": ref,
					"namespace": deep_get(ref, DictPath("metadata#namespace")),
					"kind": ("RoleBinding", "rbac.authorization.k8s.io"),
					"type": "",
				}))

				# Excellent, we have a Role Binding, now add the role it binds to
				rolerefkind = (deep_get(ref, DictPath("roleRef#kind"), ""), deep_get(ref, DictPath("roleRef#apiGroup")))
				rolerefname = deep_get(ref, DictPath("roleRef#name"), "")
				rolerefnamespace = deep_get(ref, DictPath("metadata#namespace"), "")
				roleref = kh.get_ref_by_kind_name_namespace(rolerefkind, rolerefname, rolerefnamespace)
				if roleref is not None:
					deep_set(roleref, DictPath("kind"), rolerefkind[0], create_path = True)
					deep_set(roleref, DictPath("apiVersion"), f"{rolerefkind[1]}/", create_path = True)
				info.append(type("InfoClass", (), {
					"name": rolerefname,
					"ref": roleref,
					"namespace": subjectnamespace,
					"kind": rolerefkind,
					"type": "",
				}))
				break

	vlist, status = kh.get_list_by_kind_namespace(("ClusterRoleBinding", "rbac.authorization.k8s.io"), "")

	# Get all Cluster Role Bindings that bind to this ServiceAccount
	for ref in vlist:
		deep_set(ref, DictPath("kind"), "ClusterRoleBinding", create_path = True)
		deep_set(ref, DictPath("apiVersion"), "rbac.authorization.k8s.io/", create_path = True)
		for subject in deep_get(ref, DictPath("subjects"), []):
			subjectkind = deep_get(subject, DictPath("kind"), "")
			subjectname = deep_get(subject, DictPath("name"), "")
			subjectnamespace = deep_get(subject, DictPath("namespace"), "")
			if subjectkind == "ServiceAccount" and subjectname == saname and subjectnamespace == sanamespace:
				info.append(type("InfoClass", (), {
					"name": deep_get(ref, DictPath("metadata#name")),
					"ref": ref,
					"namespace": deep_get(ref, DictPath("metadata#namespace")),
					"kind": ("ClusterRoleBinding", "rbac.authorization.k8s.io"),
					"type": "",
				}))

				# Excellent, we have a Cluster Role Binding, now add the role it binds to
				rolerefkind = (deep_get(ref, DictPath("roleRef#kind"), ""), deep_get(ref, DictPath("roleRef#apiGroup")))
				rolerefname = deep_get(ref, DictPath("roleRef#name"), "")
				roleref = kh.get_ref_by_kind_name_namespace(rolerefkind, rolerefname, subjectnamespace)
				if roleref is not None:
					deep_set(roleref, DictPath("kind"), rolerefkind[0], create_path = True)
					deep_set(roleref, DictPath("apiVersion"), f"{rolerefkind[1]}/", create_path = True)
				info.append(type("InfoClass", (), {
					"name": rolerefname,
					"ref": roleref,
					"namespace": subjectnamespace,
					"kind": rolerefkind,
					"type": "",
				}))
				break

	return info

def get_name_by_kind_from_owner_references(owner_references: List[Dict], kind: str) -> str:
	for owr in owner_references:
		if deep_get(owr, DictPath("kind"), "") == kind:
			name = deep_get(owr, DictPath("name"))
			break

	return name

def get_holder_kind_from_owner_references(owner_references: List[Dict], holder_name: str):
	holder_kind = ""

	for owr in owner_references:
		if deep_get(owr, DictPath("name")) == holder_name:
			holder_kind = deep_get(owr, DictPath("kind"), "")
			break

	return holder_kind

def format_controller(controller, show_kind: str):
	if len(show_kind) > 0:
		if show_kind == "short" or len(controller[0][1]) == 0:
			controller = (f"{controller[0][0]}", f"{controller[1]}")
		elif show_kind == "full":
			controller = (f"{controller[0][0]}.{controller[0][1]}", f"{controller[1]}")
		elif show_kind == "mixed":
			# Strip the API group for standard controllers, but show for custom controllers
			if controller[0] in (("StatefulSet", "apps"), ("ReplicaSet", "apps"), ("DaemonSet", "apps"), ("Job", "batch"), ("CronJob", "batch"), ("Node", "")):
				controller = (f"{controller[0][0]}", f"{controller[1]}")
			else:
				controller = (f"{controller[0][0]}.{controller[0][1]}", f"{controller[1]}")
		else:
			raise ValueError(f"unknown value passed to show_kind: {show_kind}")
	else:
		controller = ("", f"{controller[1]}")

	return controller

def get_controller_from_owner_references(owner_references: List[Dict]) -> Tuple[Tuple[str, str], str]:
	controller = (("", ""), "")
	if owner_references is not None:
		api_group_regex = re.compile(r"^(.*)/.*")

		for owr in owner_references:
			if deep_get(owr, DictPath("controller"), False):
				api_version = deep_get(owr, DictPath("apiVersion"), "")
				tmp = api_group_regex.match(api_version)
				if tmp is not None:
					api_group = tmp[1]
				else:
					api_group = ""
				kind = (deep_get(owr, DictPath("kind")), api_group)
				controller = (kind, deep_get(owr, DictPath("name"), ""))

	return controller

class SubsetsInfo:
	def __init__(self, addresses, ports, status, status_group):
		self.addresses = addresses
		self.ports = ports
		self.status = status
		self.status_group = status_group

	def __repr__(self):
		return repr((self.addresses, self.ports, self.status, self.status_group))

def get_subsets_info(**kwargs):
	obj = deep_get(kwargs, DictPath("_obj"))
	subsets = []

	if obj is None:
		return []

	# Policy for subsets expansion
	expand_subsets = deep_get(cmtlib.cmtconfig, DictPath("Endpoints#expand_subsets"), "None")

	for subset in deep_get(obj, DictPath("subsets"), []):
		ready_addresses = []
		not_ready_addresses = []
		ports = []

		if deep_get(subset, DictPath("ports")) is None:
			continue

		if len(deep_get(subset, DictPath("addresses"), [])) == 0 and len(deep_get(subset, DictPath("notReadyAddresses"), [])) == 0:
			continue

		for port in deep_get(subset, DictPath("ports"), []):
			name = deep_get(port, DictPath("name"), "")
			ports.append((name, deep_get(port, DictPath("port")), deep_get(port, DictPath("protocol"))))

		for address in deep_get(subset, DictPath("addresses"), []):
			ready_addresses.append(deep_get(address, DictPath("ip")))

		for not_ready_address in deep_get(subset, DictPath("notReadyAddresses"), []):
			not_ready_addresses.append(deep_get(not_ready_address, DictPath("ip")))

		if expand_subsets == "None":
			if len(ready_addresses) > 0:
				subsets.append(SubsetsInfo(ready_addresses, ports, "Ready", StatusGroup.OK))
			if len(not_ready_addresses) > 0:
				subsets.append(SubsetsInfo(not_ready_addresses, ports, "Not Ready", StatusGroup.NOT_OK))
		elif expand_subsets == "Port":
			for port in ports:
				if len(ready_addresses) > 0:
					subsets.append(SubsetsInfo(ready_addresses, [port], "Ready", StatusGroup.OK))
				if len(not_ready_addresses) > 0:
					subsets.append(SubsetsInfo(not_ready_addresses, [port], "Not Ready", StatusGroup.NOT_OK))
		elif expand_subsets == "Address":
			for address in ready_addresses:
				subsets.append(SubsetsInfo([address], ports, "Ready", StatusGroup.OK))
			for address in not_ready_addresses:
				subsets.append(SubsetsInfo([address], ports, "Not Ready", StatusGroup.NOT_OK))
		elif expand_subsets == "Both":
			for port in ports:
				for address in ready_addresses:
					subsets.append(SubsetsInfo([address], [port], "Ready", StatusGroup.OK))
				for address in not_ready_addresses:
					subsets.append(SubsetsInfo([address], [port], "Not Ready", StatusGroup.NOT_OK))

	return subsets

class EPSSubsetsInfo:
	# pylint: disable-next=too-many-arguments
	def __init__(self, addresstype, addresses, ports_eps, status, status_group, target_ref, topology):
		self.addresstype = addresstype
		self.addresses = addresses
		self.ports_eps = ports_eps
		self.status = status
		self.status_group = status_group
		self.target_ref = target_ref
		self.topology = topology

	def __repr__(self):
		return repr((self.addresstype, self.addresses, self.ports_eps, self.status, self.status_group, self.target_ref, self.topology))

def get_eps_subsets_info(**kwargs):
	obj = deep_get(kwargs, DictPath("_obj"))
	subsets = []

	if obj is None:
		return []

	addresstype = deep_get(obj, DictPath("addressType"))
	ports = []

	for port in deep_get(obj, DictPath("ports"), []):
		port_name = deep_get(port, DictPath("name"), "")
		ports.append((port_name, deep_get(port, DictPath("port")), deep_get(port, DictPath("protocol"))))

	for endpoint in deep_get(obj, DictPath("endpoints"), []):
		ready_addresses = []
		not_ready_addresses = []

		for address in deep_get(endpoint, DictPath("addresses"), []):
			if deep_get(endpoint, DictPath("conditions#ready")):
				ready_addresses.append(address)
			else:
				not_ready_addresses.append(address)
		target_ref = (deep_get(endpoint, DictPath("targetRef#kind"), ""), deep_get(endpoint, DictPath("targetRef#apiVersion"), ""), deep_get(endpoint, DictPath("targetRef#namespace"), ""), deep_get(endpoint, DictPath("targetRef#name"), ""))
		topology = []
		# If nodeName is available this is the new API where topology is replaced by nodeName and zone
		if "nodeName" in endpoint:
			topology.append(("nodeName", deep_get(endpoint, DictPath("nodeName"), "<unset>")))
			if "zone" in endpoint:
				topology.append(("zone", deep_get(endpoint, DictPath("zone"), "<unset>")))
		else:
			for key, value in deep_get(endpoint, DictPath("topology"), {}).items():
				topology.append((key, value))

		if len(ready_addresses) > 0:
			subsets.append(EPSSubsetsInfo(addresstype, ready_addresses, ports, "Ready", StatusGroup.OK, target_ref, topology))
		if len(not_ready_addresses) > 0:
			subsets.append(EPSSubsetsInfo(addresstype, not_ready_addresses, ports, "Not Ready", StatusGroup.NOT_OK, target_ref, topology))

	return subsets

def cpu_usage_to_millicores(cpu_usage: str) -> str:
	if cpu_usage == "0":
		return cpu_usage
	if cpu_usage.endswith("n"):
		cpu_usage = f"{float(cpu_usage[:-1]) / 1000000:0.1f}"
		return cpu_usage
	if cpu_usage.endswith("m"):
		cpu_usage = f"{float(cpu_usage[:-1]) / 1000:0.1f}"
		return cpu_usage
	if cpu_usage.endswith("u"):
		cpu_usage = f"{float(cpu_usage[:-1]):0.1f}"
		return cpu_usage
	raise ValueError(f"Unknown cpu usage metrics: {cpu_usage}")

# pylint: disable-next=unused-argument
def listgetter_configmap_data(obj: Dict, **kwargs: Dict) -> Tuple[List[Dict], int]:
	vlist = []

	cm_name = deep_get(obj, DictPath("metadata#name"))
	cm_namespace = deep_get(obj, DictPath("metadata#namespace"), "")

	for key, value in deep_get(obj, DictPath("binary_data"), {}).items():
		vlist.append({
			"cm_name": cm_name,
			"cm_namespace": cm_namespace,
			"configmap": key,
			"type": "Binary",
			"formatter": None,
			"data": value,
		})

	for key, value in deep_get(obj, DictPath("data"), {}).items():
		data_type, formatter = identify_cmdata(key, cm_name, cm_namespace, value)
		vlist.append({
			"cm_name": cm_name,
			"cm_namespace": cm_namespace,
			"configmap": key,
			"type": data_type,
			"formatter": formatter,
			"data": value,
		})

	return vlist, 200

class StrategyInfo:
	def __init__(self, strategy, name, operator, target):
		self.strategy = strategy
		self.name = name
		self.operator = operator
		self.target = target

	def __repr__(self):
		return repr((self.strategy, self.name, self.operator, self.target))

def get_strategy_info(**kwargs):
	obj = deep_get(kwargs, DictPath("_obj"))
	info = []

	if obj is None:
		return []

	deschedule_rules = deep_get(obj, DictPath("spec#strategies#deschedule#rules"), [])
	dontschedule_rules = deep_get(obj, DictPath("spec#strategies#dontschedule#rules"), [])
	scheduleonmetric_rules = deep_get(obj, DictPath("spec#strategies#scheduleonmetric#rules"), [])

	if len(deschedule_rules) > 0:
		strategy = "deschedule"
		rule = deschedule_rules[0]

		# Even though this is an array there's only one rule
		name = deep_get(rule, DictPath("metricname"), "")
		operator = deep_get(rule, DictPath("operator"), "")
		target = deep_get(rule, DictPath("target"), -1)
		info.append(StrategyInfo(strategy, name, operator, target))

	if len(dontschedule_rules) > 0:
		strategy = "dontschedule"
		# dontschedule can have multiple rules; if it does we build a hackish tree
		if len(dontschedule_rules) > 1:
			info.append(StrategyInfo(strategy, "", "", -1))
			for rule in dontschedule_rules:
				name = rule.get("metricname", "")
				operator = rule.get("operator", "")
				target = rule.get("target", -1)
				info.append(StrategyInfo("", name, operator, target))
		else:
			rule = dontschedule_rules[0]
			name = rule.get("metricname", "")
			operator = rule.get("operator", "")
			target = rule.get("target", -1)
			info.append(StrategyInfo(strategy, name, operator, target))

	if len(scheduleonmetric_rules) > 0:
		strategy = "scheduleonmetric"
		rule = deschedule_rules[0]

		# Even though this is an array there's only one rule
		name = rule.get("metricname", "")
		operator = rule.get("operator", "")
		target = rule.get("target", -1)
		info.append(StrategyInfo(strategy, name, operator, target))

	return info

class RQItemInfo:
	def __init__(self, resource, used, hard):
		self.resource = resource
		self.used = used
		self.hard = hard

	def __repr__(self):
		return repr((self.resource, self.used, self.hard))

def get_rq_item_info(**kwargs):
	obj = deep_get(kwargs, DictPath("_obj"))
	hard_path = deep_get(kwargs, DictPath("hard_path"), DictPath("spec#hard"))
	used_path = deep_get(kwargs, DictPath("used_path"), DictPath("status#used#hard"))
	info = []

	if obj is None:
		return []

	for resource in deep_get(obj, hard_path, []):
		used = deep_get(obj, DictPath(f"{used_path}#{resource}"), [])
		hard = deep_get(obj, DictPath(f"{hard_path}#{resource}"), [])

		info.append(RQItemInfo(resource, used, hard))

	return info

class KeyValueInfo:
	# pylint: disable-next=too-many-arguments
	def __init__(self, key, ref, decoded_value, value, vtype, vlen):
		self.key = key
		self.ref = ref
		self.decoded_value = decoded_value
		self.value = value
		self.vtype = vtype
		self.vlen = vlen

	def __repr__(self):
		return repr((self.key, self.decoded_value, self.ref, self.value, self.vtype, self.vlen))

def decode_value(value):
	# Is this base64?
	try:
		decoded = base64.b64decode(value)
		vtype = "base64"
	except binascii.Error:
		vtype = "string"

	if vtype == "base64":
		try:
			tmp = decoded.decode("utf-8")
			if "\n" in tmp:
				vtype = "base64-utf-8"
			else:
				vtype = "string"
				value = tmp
		except UnicodeDecodeError:
			vtype = "base64-binary"

			try:
				if len(decoded) >= 2 and decoded[0:2] == [0x1f, 0x8b]:
					vtype = "gzip"
					value = decoded
				elif len(decoded) >= 6 and decoded[0:6] == [0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x0]:
					vtype = "xz"
					value = decoded
				elif len(decoded) >= 3 and decoded[0:3] == [0x42, 0x5a, 0x68]:
					vtype = "bz2"
					value = decoded
				elif len(decoded) >= 3 and decoded[0:3] == [0x51, 0x46, 0x49]:
					vtype = "qcow"
					value = decoded
			except binascii.Error:
				pass

	return vtype, value

def get_key_value_info(**kwargs: Dict):
	info = []

	vlist = deep_get(kwargs, DictPath("_vlist"))
	if vlist is None:
		return info

	for key, value in vlist.items():
		decoded_value = ""

		vtype, value = decode_value(value)
		vlen = len(value)
		decoded_value = value

		if vlen == 0:
			value = ""
			vtype = "empty"

		if vtype.startswith("base64-utf-8"):
			fully_decoded_value = base64.b64decode(decoded_value).decode("utf-8")
		else:
			fully_decoded_value = decoded_value

		if len(decoded_value) > 8192 and len(value) > 0:
			vtype = f"{vtype} [truncated]"
			decoded_value = value[0:8192 - 1]

		ref = {
			"key": key,
			"value": value,
			"decoded_value": decoded_value,
			"fully_decoded_value": fully_decoded_value,
			"vtype": vtype,
			"vlen": vlen,
		}
		info.append(KeyValueInfo(key, ref, decoded_value, value, vtype, vlen))

	return info

class ResourceInfo:
	# pylint: disable-next=too-many-arguments
	def __init__(self, resource_tuple, ref, rtype, kind, status, status_group, restarts, message, age = -1):
		self.resource_tuple = resource_tuple
		# The reference to the "true" resource object
		self.ref = ref
		self.rtype = rtype
		self.kind = kind
		self.status = status
		self.status_group = status_group
		self.restarts = restarts
		self.message = message
		self.age = age

	def __repr__(self):
		return repr((self.resource_tuple, self.ref, self.rtype, self.kind, self.status, self.status_group, self.restarts, self.message, self.age))

def get_pv_from_pvc_name(pvc_name: str):
	pv = None
	pv_name = None
	field_selector = f"metadata.name={pvc_name}"

	vlist, status = kh.get_list_by_kind_namespace(("PersistentVolumeClaim", ""), "", field_selector = field_selector)
	if status == 200:
		for pvc in vlist:
			if deep_get(pvc, DictPath("metadata#name")) == pvc_name:
				volume_name = deep_get(pvc, DictPath("spec#volumeName"))
				if volume_name is not None:
					pv_name = volume_name
					pv = kh.get_ref_by_kind_name_namespace(("PersistentVolume", ""), pv_name, None)
					break

	return pv, pv_name

def get_pv_status(pv) -> Tuple[str, StatusGroup]:
	phase = deep_get(pv, DictPath("status#phase"))

	if phase in ("Bound", "Available"):
		reason = phase
		status_group = StatusGroup.OK
	elif phase in ("Released", "Pending"):
		reason = phase
		status_group = StatusGroup.PENDING
	else:
		reason = deep_get(pv, DictPath("status#reason"), "").strip()
		status_group = StatusGroup.NOT_OK
	return reason, status_group

def get_pod_log_by_name_namespace_container(name: str, namespace: str, container: str, tail_lines: int = default_tail_lines) -> Tuple[str, bool]:
	internal_error = False

	rawmsg, status = kh.read_namespaced_pod_log(name, namespace, container = container, tail_lines = tail_lines)
	if status == 200:
		# Everything is successful
		internal_error = False
	elif status == 400:
		# Not successful; error in rawmsg
		rawmsg = f"{datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} CRITICAL: {rawmsg}"
		internal_error = True
	elif status == 500:
		# Not successful; error in rawmsg
		internal_error = True
	else:
		rawmsg = f"{datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} CRITICAL: Failed to fetch log for pod (name: {name}, namespace: {namespace}, container: {container}); Request Status: {status}"
		internal_error = True

	if rawmsg.startswith("unable to retrieve container logs for"):
		rawmsg = f"{datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} CRITICAL: {rawmsg}"
		internal_error = True

	return rawmsg, internal_error

def resource_kind_to_rtype(resource):
	rtypes = {
		("AntreaAgentInfo", "crd.antrea.io"): "[antrea_agent_info]",
		("AntreaControllerInfo", "crd.antrea.io"): "[antrea_controller_info]",
		("CiliumEndpoint", "cilium.io"): "[cilium_endpoint]",
		("ConfigAuditReport", "aquasecurity.github.io"): "[report]",
		("ConfigMap", ""): "[configmap]",
		("Container", ""): "[container]",
		("Controller", ""): "[controller]",
		("ControllerRevision", "apps"): "[controller_revision]",
		("CronJob", "batch"): "[job_controller]",
		("DaemonSet", "apps"): "[controller]",
		("Deployment", "apps"): "[controller]",
		("Endpoints", ""): "[endpoints]",
		("EndpointSlice", "discovery.k8s.io"): "[endpoint_slice]",
		("EphemeralContainer", ""): "[ephemeral_container]",
		("ExposedSecretReport", "aquasecurity.github.io"): "[report]",
		("Event", ""): "[event]",
		("Event", "events.k8s.io"): "[event]",
		("HorizontalPodAutoscaler", "autoscaling"): "[pod_autoscaler]",
		("InfraAssessmentReport", "aquasecurity.github.io"): "[report]",
		("Ingress", "networking.k8s.io"): "[ingress]",
		("InitContainer", ""): "[init_container]",
		("Job", "batch"): "[controller]",
		("Lease", "coordination.k8s.io"): "[lease]",
		("LimitRange", ""): "[limit]",
		("MutatingWebhookConfiguration", "admissionregistration.k8s.io"): "[webhook_configuration]",
		("Node", ""): "[node]",
		("PersistentVolume", ""): "[volume]",
		("PersistentVolumeClaim", ""): "[volume_claim]",
		("Pod", ""): "[pod]",
		("PodDisruptionBudget", "policy"): "[pod_disruption_budget]",
		("PodMetrics", "metrics.k8s.io"): "[pod_metrics]",
		("PriorityClass", "scheduling.k8s.io"): "[priority_class]",
		("ReplicaSet", "apps"): "[controller]",
		("ReplicationController", ""): "[controller]",
		("ResourceClaim", "resource.k8s.io"): "[resource_claim]",
		("Role", "rbac.authorization.k8s.io"): "[role]",
		("RoleBinding", "rbac.authorization.k8s.io"): "[role_binding]",
		("RuntimeClass", "node.k8s.io"): "[runtime_class]",
		("SbomReport", "aquasecurity.github.io"): "[report]",
		("Scheduler", ""): "[scheduler]",
		("Secret", ""): "[secret]",
		("Service", ""): "[service]",
		("ServiceAccount", ""): "[service_account]",
		("ServiceEntry", ""): "[service_entry]",
		("StatefulSet", "apps"): "[controller]",
		("TASPolicy", "telemetry.intel.com"): "[scheduling_policy]",
		("TFJob", "kubeflow.org"): "[controller]",
		("ValidatingWebhookConfiguration", "admissionregistration.k8s.io"): "[webhook_configuration]",
		("VulnerabilityReport", "aquasecurity.github.io"): "[report]",
		("Workflow", "argoproj.io"): "[controller]",
	}

	return rtypes.get(resource, "[unknown]")

def get_resource_info_by_last_applied_configuration(obj, **kwargs):
	kind = deep_get(kwargs, DictPath("kind"))
	if kind is None:
		return [], 404

	configuration = {
		"kind": kind[0]
	}

	if deep_get(kwargs, DictPath("match_api_version"), False):
		version_path = deep_get(kwargs, DictPath("version_path"))
		group_path = deep_get(kwargs, DictPath("group_path"))
		api_version = f"{deep_get(obj, DictPath(group_path))}/{deep_get(obj, DictPath(version_path))}"
		configuration["apiVersion"] = api_version

	resource_info = []
	status = None

	items, _status = kh.get_list_by_kind_namespace(kind, "")
	if _status != 200:
		return resource_info, _status

	for item in items:
		last_applied_configuration = deep_get(item, DictPath("metadata#annotations#kubectl.kubernetes.io/last-applied-configuration"), {})
		if last_applied_configuration is None or len(last_applied_configuration) == 0:
			continue
		try:
			data = json.loads(last_applied_configuration)
		except DecodeException:
			# The data is malformed; skip the entry
			continue

		match = True
		for key, conf in configuration.items():
			if key not in data or conf != data[key]:
				match = False
				break
		if match:
			name = deep_get(item, DictPath("metadata#name"))
			namespace = deep_get(item, DictPath("metadata#namespace"), "")
			d = {
				"kind": kind,
				"metadata": {
					"namespace": namespace,
					"name": name,
				}
			}
			resource_info.append(d)

	return resource_info, status

# pylint: disable-next=unused-argument
def get_pod_resource_list(obj, **kwargs):
	vlist = []

	init_containers = True
	containers = True
	ephemeral_containers = True

	pod_name = deep_get(obj, DictPath("metadata#name"))
	pod_namespace = deep_get(obj, DictPath("metadata#namespace"))

	container_resources = []
	if init_containers:
		kind = ("InitContainer", "")
		for container in deep_get(obj, DictPath("spec#initContainers"), []):
			# We need these when iterating containers
			container_resources.append((kind, container, deep_get(obj, DictPath("status#initContainerStatuses"))))
	if containers:
		kind = ("Container", "")
		for container in deep_get(obj, DictPath("spec#containers"), []):
			# We need these when iterating containers
			container_resources.append((kind, container, deep_get(obj, DictPath("status#containerStatuses"))))
	if ephemeral_containers:
		kind = ("EphemeralContainer", "")
		for container in deep_get(obj, DictPath("spec#ephemeralContainers"), []):
			# We need these when iterating containers
			container_resources.append((kind, container, deep_get(obj, DictPath("status#ephemeralContainerStatuses"))))

	for kind, container, container_status in container_resources:
		rtype = resource_kind_to_rtype(kind)
		ref = container
		name = deep_get(container, DictPath("name"))
		resource_tuple = ("", "", name)
		status, status_group, restarts, message, age = datagetters.get_container_status(container_status, name)
		vlist.append({
			"ref": ref,
			"namespace": pod_namespace,
			"name": name,
			"kind": kind[0],
			"api_group": kind[1],
			"type": rtype,
			"resource_tuple": resource_tuple,
			"status": status,
			"restarts": restarts,
			"message": message,
			"age": age,
		})

	if "node" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		kind = ("Node", "")
		rtype = resource_kind_to_rtype(kind)
		name = deep_get(obj, DictPath("spec#nodeName"))
		ref = None
		if name is not None:
			ref = kh.get_ref_by_kind_name_namespace(("Node", ""), name, None)
		if name is None:
			name = "<unset>"
		resource_tuple = ("", "", name)

		if ref is not None:
			status, status_group, _taints, _full_taints = get_node_status(ref)
		else:
			status = "<unset>"

		vlist.append({
			"ref": ref,
			"namespace": pod_namespace,
			"name": name,
			"kind": kind[0],
			"api_group": kind[1],
			"type": rtype,
			"resource_tuple": resource_tuple,
			"status": status,
			"restarts": "",
			"message": "",
			"age": -1,
		})

	controller_name = ""
	controller_kind = ""

	for owr in deep_get(obj, DictPath("metadata#ownerReferences"), []):
		owr_kind = deep_get(owr, DictPath("kind"), "")
		owr_api_version = deep_get(owr, DictPath("apiVersion"), "")
		if "/" in owr_api_version:
			owr_api_version = owr_api_version.split("/")[0]
		else:
			owr_api_version = ""
		owr_kind = (owr_kind, owr_api_version)
		owr_name = deep_get(owr, DictPath("name"), "")
		is_controller = deep_get(owr, DictPath("controller"), False)
		if is_controller:
			controller_name = owr_name
			controller_kind = owr_kind[0]
			if "controller" in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
				continue
			rtype = "[controller]"
		elif owr_kind == ("CronJob", "batch"):
			if "cronjob" in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
				continue
			rtype = "[cronjob]"
		else:
			if "owner_reference" in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
				continue
			rtype = "[owner_reference]"

		status = ""

		ref = kh.get_ref_by_kind_name_namespace(owr_kind, owr_name, pod_namespace)
		# XXX: Maybe we should get the ref status here?
		if ref is None:
			status = "<missing>"
		else:
			conditions = deep_get(ref, DictPath("status#conditions"), [])
			for condition in conditions:
				if deep_get(condition, DictPath("type"), "") == "Ready":
					_status = deep_get(condition, DictPath("status"), "")
					reason = deep_get(condition, DictPath("reason"), "")
					if len(reason) > 0:
						status = reason
					else:
						if _status == "True":
							status = "Ready"
						elif _status == "False":
							status = "NotReady"
						elif _status == "Unknown":
							status = "Unknown"

		resource_tuple = (owr_kind[0], owr_kind[1], owr_name)
		vlist.append({
			"ref": ref,
			"namespace": pod_namespace,
			"name": owr_name,
			"kind": owr_kind[0],
			"api_group": owr_kind[1],
			"type": rtype,
			"resource_tuple": resource_tuple,
			"status": status,
			"restarts": "",
			"message": "",
			"age": -1,
		})

	if "persistent_volume_claim" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		for volume in deep_get(obj, DictPath("spec#volumes"), []):
			if deep_get(volume, DictPath("persistentVolumeClaim")) is None:
				continue

			kind = ("PersistentVolume", "")
			rtype = resource_kind_to_rtype(kind)

			claim_name = deep_get(volume, DictPath("persistentVolumeClaim#claimName"))
			pv, pv_name = get_pv_from_pvc_name(claim_name)

			if pv is not None:
				status, status_group = get_pv_status(pv)
			else:
				pv_name = "<INVALID PV>"
				status = "Error"
			ref = pv
			resource_tuple = ("", "", pv_name)
			vlist.append({
				"ref": ref,
				"namespace": pod_namespace,
				"name": name,
				"kind": kind[0],
				"api_group": kind[1],
				"type": rtype,
				"resource_tuple": resource_tuple,
				"status": status,
				"restarts": "",
				"message": "",
				"age": -1,
			})

	if "service_account" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []) and deep_get(obj, DictPath("spec#serviceAccountName")) is not None:
		kind = ("ServiceAccount", "")
		rtype = resource_kind_to_rtype(kind)

		name = deep_get(obj, DictPath("spec#serviceAccountName"))
		ref = kh.get_ref_by_kind_name_namespace(kind, name, pod_namespace)
		resource_tuple = ("", "", name)
		vlist.append({
			"ref": ref,
			"namespace": pod_namespace,
			"name": name,
			"kind": kind[0],
			"api_group": kind[1],
			"type": rtype,
			"resource_tuple": resource_tuple,
			"status": "",
			"restarts": "",
			"message": "",
			"age": -1,
		})

	for vol in deep_get(obj, DictPath("spec#volumes"), []):
		status = ""

		if deep_get(vol, DictPath("secret")) is not None and "secret" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
			kind = ("Secret", "")
			rtype = resource_kind_to_rtype(kind)
			secret_name = deep_get(vol, DictPath("secret#secretName"))
			optional = deep_get(vol, DictPath("secret#optional"), False)
			resource_tuple = ("", "", secret_name)
			ref = kh.get_ref_by_kind_name_namespace(kind, secret_name, pod_namespace)
			if ref is None:
				if not optional:
					status = "<missing>"
				else:
					status = "<optional>"
			vlist.append({
				"ref": ref,
				"namespace": pod_namespace,
				"name": secret_name,
				"kind": kind[0],
				"api_group": kind[1],
				"type": rtype,
				"resource_tuple": resource_tuple,
				"status": status,
				"restarts": "",
				"message": "",
				"age": -1,
			})

		if deep_get(vol, DictPath("configMap")) is not None and "config_map" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
			kind = ("ConfigMap", "")
			rtype = resource_kind_to_rtype(kind)
			cm_name = deep_get(vol, DictPath("configMap#name"))
			optional = deep_get(vol, DictPath("configMap#optional"), False)
			resource_tuple = ("", "", cm_name)
			ref = kh.get_ref_by_kind_name_namespace(kind, cm_name, pod_namespace)
			if ref is None:
				if not optional:
					status = "<missing>"
				else:
					status = "<optional>"
			else:
				if len(deep_get(ref, DictPath("data"), [])) == 0:
					status = "<empty>"
			vlist.append({
				"ref": ref,
				"namespace": pod_namespace,
				"name": cm_name,
				"kind": kind[0],
				"api_group": kind[1],
				"type": rtype,
				"resource_tuple": resource_tuple,
				"status": status,
				"restarts": "",
				"message": "",
				"age": -1,
			})

	for vol in deep_get(obj, DictPath("spec#imagePullSecrets"), []):
		if "secret" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
			kind = ("Secret", "")
			rtype = "[image_pull_secret]"
			secret_name = deep_get(vol, DictPath("name"))
			resource_tuple = ("", "", secret_name)
			ref = kh.get_ref_by_kind_name_namespace(kind, secret_name, pod_namespace)
			vlist.append({
				"ref": ref,
				"namespace": pod_namespace,
				"name": secret_name,
				"kind": kind[0],
				"api_group": kind[1],
				"type": rtype,
				"resource_tuple": resource_tuple,
				"status": "",
				"restarts": "",
				"message": "",
				"age": -1,
			})

	if "event" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		#kind = ("Event", "events.k8s.io")
		kind = ("Event", "")
		rtype = resource_kind_to_rtype(kind)

		_vlist, status = kh.get_list_by_kind_namespace(kind, "")
		tmp_vlist = []
		for event in _vlist:
			event_involved_object_name = deep_get_with_fallback(event, [DictPath("regarding#name"), DictPath("involvedObject#name")])
			event_involved_object_namespace = deep_get_with_fallback(event, [DictPath("regarding#namespace"), DictPath("involvedObject#namespace")])
			if event_involved_object_name == pod_name and event_involved_object_namespace == pod_namespace:
				ref = event
				# For kind we do not want the api_family
				event_name = deep_get(event, DictPath("metadata#name"))
				resource_tuple = (kind[0], "", event_name)
				status = deep_get(event, DictPath("type"))
				tmp = __get_timestamp_with_fallback(event, [DictPath("series#lastObservedTime"),
									    DictPath("deprecatedLastTimestamp"),
									    DictPath("lastTimestamp"),
									    DictPath("eventTime"),
									    DictPath("deprecatedFirstTimestamp"),
									    DictPath("firstTimestamp")])
				seen = get_since(tmp)
				message = deep_get(event, DictPath("message"), "")
				message = message.replace("\n", "\\n").rstrip()

				tmp_vlist.append({
					"ref": ref,
					"namespace": pod_namespace,
					"name": event_name,
					"kind": kind[0],
					"api_group": kind[1],
					"type": rtype,
					"resource_tuple": resource_tuple,
					"status": status,
					"restarts": "",
					"message": message,
					"age": seen,
				})
		for event in natsorted(tmp_vlist, key = itemgetter("age")):
			vlist.append(event)

	if "pod_disruption_budget" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		# XXX: Are there are other means of specifying what pod to apply the PDB to than this?
		if "app" in deep_get(obj, DictPath("metadata#labels"), {}):
			kind = ("PodDisruptionBudget", "policy")
			_vlist, status = kh.get_list_by_kind_namespace(kind, "", label_selector = f"app={deep_get(obj, DictPath('metadata#labels'))['app']}")
			for pdb in _vlist:
				rtype = resource_kind_to_rtype(kind)
				pdb_name = deep_get(pdb, DictPath("metadata#name"))
				pdb_namespace = deep_get(pdb, DictPath("metadata#namespace"))
				resource_tuple = ("", "", pdb_name)
				ref = kh.get_ref_by_kind_name_namespace(kind, pdb_name, pdb_namespace)
				vlist.append({
					"ref": ref,
					"namespace": pdb_namespace,
					"name": pdb_name,
					"kind": kind[0],
					"api_group": kind[1],
					"type": rtype,
					"resource_tuple": resource_tuple,
					"status": "",
					"restarts": "",
					"message": "",
					"age": -1,
				})

	if "pod_metrics" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		kind = ("PodMetrics", "metrics.k8s.io")
		podmetrics = kh.get_ref_by_kind_name_namespace(kind, pod_name, pod_namespace)
		if podmetrics is not None:
			ref = podmetrics
			rtype = resource_kind_to_rtype(kind)
			resource_tuple = ("", "", pod_name)
			vlist.append({
				"ref": ref,
				"namespace": pod_namespace,
				"name": pod_name,
				"kind": kind[0],
				"api_group": kind[1],
				"type": rtype,
				"resource_tuple": resource_tuple,
				"status": "",
				"restarts": "",
				"message": "",
				"age": -1,
			})

	if "config_audit_report" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		kind = ("ConfigAuditReport", "aquasecurity.github.io")
		if controller_kind == "Node":
			trivy_kind = "Pod"
			trivy_name = pod_name
		else:
			trivy_kind = controller_kind
			trivy_name = controller_name
		selector = {
			"trivy-operator.resource.kind": trivy_kind,
			"trivy-operator.resource.name": trivy_name,
		}
		lref, status = kh.get_list_by_kind_namespace(kind, pod_namespace, label_selector = make_selector(selector))

		if len(lref) == 0 or status != 200:
			ref = None
		else:
			ref = lref[0]

		if ref is not None:
			report_name = deep_get(ref, DictPath("metadata#name"))

			rtype = resource_kind_to_rtype(kind)
			resource_tuple = (kind[0], "", report_name)

			critical = deep_get(ref, DictPath("report#summary#criticalCount"), 0)
			high = deep_get(ref, DictPath("report#summary#highCount"), 0)
			medium = deep_get(ref, DictPath("report#summary#mediumCount"), 0)
			low = deep_get(ref, DictPath("report#summary#lowCount"), 0)

			message = ""
			message_array = []

			status = "OK"

			if low > 0:
				status = "Warning"
				message_array.append(f"{low} Low")
			if medium > 0:
				status = "Warning"
				message_array.insert(0, f"{medium} Medium")
			if high > 0:
				status = "Warning"
				message_array.insert(0, f"{high} High")
			if critical > 0:
				status = "Warning"
				message_array.insert(0, f"{critical} Critical")

			if len(message_array) > 0:
				message = "Reported issues: "
				message += " / ".join(message_array)

			vlist.append({
				"ref": ref,
				"namespace": pod_namespace,
				"name": pod_name,
				"kind": kind[0],
				"api_group": kind[1],
				"type": rtype,
				"resource_tuple": resource_tuple,
				"status": status,
				"restarts": "",
				"message": message,
				"age": -1,
			})

	if "infra_assessment_report" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		kind = ("InfraAssessmentReport", "aquasecurity.github.io")
		if controller_kind == "Node":
			trivy_kind = "Pod"
			trivy_name = pod_name
		else:
			trivy_kind = controller_kind
			trivy_name = controller_name
		selector = {
			"trivy-operator.resource.kind": trivy_kind,
			"trivy-operator.resource.name": trivy_name,
		}
		lref, status = kh.get_list_by_kind_namespace(kind, pod_namespace, label_selector = make_selector(selector))

		if len(lref) == 0 or status != 200:
			ref = None
		else:
			ref = lref[0]

		if ref is not None:
			report_name = deep_get(ref, DictPath("metadata#name"))

			rtype = resource_kind_to_rtype(kind)
			resource_tuple = (kind[0], "", report_name)

			critical = deep_get(ref, DictPath("report#summary#criticalCount"), 0)
			high = deep_get(ref, DictPath("report#summary#highCount"), 0)
			medium = deep_get(ref, DictPath("report#summary#mediumCount"), 0)
			low = deep_get(ref, DictPath("report#summary#lowCount"), 0)

			message = ""
			message_array = []

			status = "OK"

			if low > 0:
				status = "Warning"
				message_array.append(f"{low} Low")
			if medium > 0:
				status = "Warning"
				message_array.insert(0, f"{medium} Medium")
			if high > 0:
				status = "Warning"
				message_array.insert(0, f"{high} High")
			if critical > 0:
				status = "Warning"
				message_array.insert(0, f"{critical} Critical")

			if len(message_array) > 0:
				message = "Reported issues: "
				message += " / ".join(message_array)

			vlist.append({
				"ref": ref,
				"namespace": pod_namespace,
				"name": pod_name,
				"kind": kind[0],
				"api_group": kind[1],
				"type": rtype,
				"resource_tuple": resource_tuple,
				"status": status,
				"restarts": "",
				"message": message,
				"age": -1,
			})

	if "vulnerability_report" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		kind = ("VulnerabilityReport", "aquasecurity.github.io")
		if controller_kind == "Node":
			trivy_kind = "Pod"
			trivy_name = pod_name
		else:
			trivy_kind = controller_kind
			trivy_name = controller_name
		selector = {
			"trivy-operator.resource.kind": trivy_kind,
			"trivy-operator.resource.name": trivy_name,
		}
		lref, status = kh.get_list_by_kind_namespace(kind, pod_namespace, label_selector = make_selector(selector))

		if len(lref) == 0 or status != 200:
			ref = None
		else:
			ref = lref[0]

		if ref is not None:
			report_name = deep_get(ref, DictPath("metadata#name"))

			rtype = resource_kind_to_rtype(kind)
			resource_tuple = (kind[0], "", report_name)

			critical = deep_get(ref, DictPath("report#summary#criticalCount"), 0)
			high = deep_get(ref, DictPath("report#summary#highCount"), 0)
			medium = deep_get(ref, DictPath("report#summary#mediumCount"), 0)
			unknown = deep_get(ref, DictPath("report#summary#unknownCount"), 0)
			low = deep_get(ref, DictPath("report#summary#lowCount"), 0)

			message = ""
			message_array = []

			status = "OK"

			if low > 0:
				status = "Warning"
				message_array.append(f"{low} Low")
			if unknown > 0:
				status = "Warning"
				message_array.insert(0, f"{unknown} Unknown")
			if medium > 0:
				status = "Warning"
				message_array.insert(0, f"{medium} Medium")
			if high > 0:
				status = "Warning"
				message_array.insert(0, f"{high} High")
			if critical > 0:
				status = "Warning"
				message_array.insert(0, f"{critical} Critical")

			if len(message_array) > 0:
				message = "Reported issues: "
				message += " / ".join(message_array)

			vlist.append({
				"ref": ref,
				"namespace": pod_namespace,
				"name": pod_name,
				"kind": kind[0],
				"api_group": kind[1],
				"type": rtype,
				"resource_tuple": resource_tuple,
				"status": status,
				"restarts": "",
				"message": message,
				"age": -1,
			})

	if "exposed_secret_report" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		kind = ("ExposedSecretReport", "aquasecurity.github.io")
		if controller_kind == "Node":
			trivy_kind = "Pod"
			trivy_name = pod_name
		else:
			trivy_kind = controller_kind
			trivy_name = controller_name
		selector = {
			"trivy-operator.resource.kind": trivy_kind,
			"trivy-operator.resource.name": trivy_name,
		}
		lref, status = kh.get_list_by_kind_namespace(kind, pod_namespace, label_selector = make_selector(selector))

		if len(lref) == 0 or status != 200:
			ref = None
		else:
			ref = lref[0]

		if ref is not None:
			report_name = deep_get(ref, DictPath("metadata#name"))

			rtype = resource_kind_to_rtype(kind)
			resource_tuple = (kind[0], "", report_name)

			critical = deep_get(ref, DictPath("report#summary#criticalCount"), 0)
			high = deep_get(ref, DictPath("report#summary#highCount"), 0)
			medium = deep_get(ref, DictPath("report#summary#mediumCount"), 0)
			low = deep_get(ref, DictPath("report#summary#lowCount"), 0)

			message = ""
			message_array = []

			status = "OK"

			if low > 0:
				status = "Warning"
				message_array.append(f"{low} Low")
			if medium > 0:
				status = "Warning"
				message_array.insert(0, f"{medium} Medium")
			if high > 0:
				status = "Warning"
				message_array.insert(0, f"{high} High")
			if critical > 0:
				status = "Warning"
				message_array.insert(0, f"{critical} Critical")

			if len(message_array) > 0:
				message = "Reported issues: "
				message += " / ".join(message_array)

			vlist.append({
				"ref": ref,
				"namespace": pod_namespace,
				"name": pod_name,
				"kind": kind[0],
				"api_group": kind[1],
				"type": rtype,
				"resource_tuple": resource_tuple,
				"status": status,
				"restarts": "",
				"message": message,
				"age": -1,
			})

	if "sbom_report" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		kind = ("SbomReport", "aquasecurity.github.io")
		if controller_kind == "Node":
			trivy_kind = "Pod"
			trivy_name = pod_name
		else:
			trivy_kind = controller_kind
			trivy_name = controller_name
		selector = {
			"trivy-operator.resource.kind": trivy_kind,
			"trivy-operator.resource.name": trivy_name,
		}
		lref, status = kh.get_list_by_kind_namespace(kind, pod_namespace, label_selector = make_selector(selector))

		if len(lref) == 0 or status != 200:
			ref = None
		else:
			ref = lref[0]

		if ref is not None:
			report_name = deep_get(ref, DictPath("metadata#name"))

			rtype = resource_kind_to_rtype(kind)
			resource_tuple = (kind[0], "", report_name)

			message = ""
			status = ""

			if len(message_array) > 0:
				message = "Reported issues: "
				message += " / ".join(message_array)

			vlist.append({
				"ref": ref,
				"namespace": pod_namespace,
				"name": pod_name,
				"kind": kind[0],
				"api_group": kind[1],
				"type": rtype,
				"resource_tuple": resource_tuple,
				"status": status,
				"restarts": "",
				"message": message,
				"age": -1,
			})

	if "antrea_agent" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []) and deep_get(obj, DictPath("metadata#labels#component"), "") == "antrea-agent":
		# OK, this pod is an antrea-agent, so we should look for one that matches it
		kind = ("AntreaAgentInfo", "crd.antrea.io")
		_vlist, status = kh.get_list_by_kind_namespace(kind, "")
		for item in _vlist:
			if deep_get(item, DictPath("podRef#namespace"), "") == pod_namespace and deep_get(item, DictPath("podRef#name"), "") == pod_name:
				ref = item
				name = deep_get(item, DictPath("metadata#name"))
				status = "Unknown"
				for condition in deep_get(item, DictPath("agentConditions"), {}):
					if deep_get(condition, DictPath("type")) == "AgentHealthy":
						healthy = deep_get(condition, DictPath("status"), "Unknown")
						if healthy == "True":
							status = "Healthy"
						elif healthy == "False":
							status = "Unhealthy"
				rtype = resource_kind_to_rtype(kind)
				resource_tuple = ("", "", name)

				vlist.append({
					"ref": ref,
					"namespace": pod_namespace,
					"name": name,
					"kind": kind[0],
					"api_group": kind[1],
					"type": rtype,
					"resource_tuple": resource_tuple,
					"status": status,
					"restarts": "",
					"message": "",
					"age": -1,
				})
				break

	if "antrea_controller" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []) and deep_get(obj, DictPath("metadata#labels#component"), "") == "antrea-controller":
		# OK, this pod is an antrea-agent, so we should look for one that matches it
		kind = ("AntreaControllerInfo", "crd.antrea.io")
		_vlist, status = kh.get_list_by_kind_namespace(kind, "")
		for item in _vlist:
			if deep_get(item, DictPath("podRef#namespace"), "") == pod_namespace and deep_get(item, DictPath("podRef#name"), "") == pod_name:
				ref = item
				name = deep_get(item, DictPath("metadata#name"))
				status = "Unknown"
				for condition in deep_get(item, DictPath("controllerConditions"), {}):
					if deep_get(condition, DictPath("type")) == "ControllerHealthy":
						healthy = deep_get(condition, DictPath("status"), "Unknown")
						if healthy == "True":
							status = "Healthy"
						elif healthy == "False":
							status = "Unhealthy"
				rtype = resource_kind_to_rtype(kind)
				resource_tuple = ("", "", name)
				vlist.append({
					"ref": ref,
					"namespace": pod_namespace,
					"name": name,
					"kind": kind[0],
					"api_group": kind[1],
					"type": rtype,
					"resource_tuple": resource_tuple,
					"status": status,
					"restarts": "",
					"message": "",
					"age": -1,
				})
				break

	if "cilium_endpoint" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		# Check if there's a matching cilium endpoint
		kind = ("CiliumEndpoint", "cilium.io")
		ref = kh.get_ref_by_kind_name_namespace(kind, pod_name, pod_namespace)
		if ref is not None:
			rtype = resource_kind_to_rtype(kind)
			resource_tuple = ("", "", pod_name)
			status = deep_get(ref, DictPath("status#state"), "Unknown")
			vlist.append({
				"ref": ref,
				"namespace": pod_namespace,
				"name": pod_name,
				"kind": kind[0],
				"api_group": kind[1],
				"type": rtype,
				"resource_tuple": resource_tuple,
				"status": status.capitalize(),
				"restarts": "",
				"message": "",
				"age": -1,
			})

	if "service" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		# Find service(s) that has a selector that points to this pod
		kind = ("Service", "")
		rtype = resource_kind_to_rtype(kind)
		_vlist, status = kh.get_list_by_kind_namespace(kind, pod_namespace)
		for item in _vlist:
			selector = deep_get(item, DictPath("spec#selector"), {})
			if len(selector) == 0:
				continue
			_vlist2, status = kh.get_list_by_kind_namespace(("Pod", ""), pod_namespace, label_selector = make_selector(selector), field_selector = f"metadata.name={pod_name},metadata.namespace={pod_namespace}")
			if len(_vlist2) > 0:
				ref = item
				name = deep_get(item, DictPath("metadata#name"))
				namespace = deep_get(item, DictPath("metadata#namespace"))
				resource_tuple = ("", "", name)
				vlist.append({
					"ref": ref,
					"namespace": namespace,
					"name": name,
					"kind": kind[0],
					"api_group": kind[1],
					"type": rtype,
					"resource_tuple": resource_tuple,
					"status": "",
					"restarts": "",
					"message": "",
					"age": -1,
				})

	if "runtimeclass" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		kind = ("RuntimeClass", "node.k8s.io")
		name = deep_get(obj, DictPath("spec#runtimeClassName"))
		ref = kh.get_ref_by_kind_name_namespace(kind, name, "")
		if ref is not None:
			rtype = resource_kind_to_rtype(kind)
			resource_tuple = ("", "", name)
			vlist.append({
				"ref": ref,
				"namespace": pod_namespace,
				"name": name,
				"kind": kind[0],
				"api_group": kind[1],
				"type": rtype,
				"resource_tuple": resource_tuple,
				"status": "",
				"restarts": "",
				"message": "",
				"age": -1,
			})

	if "resourceclaim" not in deep_get(cmtlib.cmtconfig, DictPath("Pod#filter_resources"), []):
		kind = ("ResourceClaim", "resource.k8s.io")
		rtype = resource_kind_to_rtype(kind)

		_vlist, status = kh.get_list_by_kind_namespace(kind, pod_namespace)
		for item in _vlist:
			owr = deep_get(item, DictPath("metadata#ownerReferences"), [])
			for owner_reference in owr:
				if deep_get(owner_reference, DictPath("controller"), False) and \
				   deep_get(owner_reference, DictPath("kind"), "") == "Pod" and \
				   deep_get(owner_reference, DictPath("name"), "") == pod_name:
					name = deep_get(item, DictPath("metadata#name"))
					resource_tuple = ("", "", name)
					vlist.append({
						"ref": item,
						"namespace": pod_namespace,
						"name": name,
						"kind": kind[0],
						"api_group": kind[1],
						"type": rtype,
						"resource_tuple": resource_tuple,
						"status": "",
						"restarts": "",
						"message": "",
						"age": -1,
					})

	return vlist, 200

# This function is really just used as a cookie at the moment
def get_inventory_list() -> None:
	return

def get_node_addresses(name, addresses):
	iips = []
	eips = []

	new_name = None

	for address in addresses:
		address_type = deep_get(address, DictPath("type"))
		address_address = deep_get(address, DictPath("address"))
		if address_type == "InternalIP":
			iips.append(address_address)
		elif address_type == "ExternalIP":
			eips.append(address_address)
		# handle external IPs too
		elif address_type == "Hostname":
			if new_name is None:
				new_name = address_address
			else:
				debuglog.add([
						[ANSIThemeString("We need to handle multiple hostnames in a better way", "default")],
				       ], severity = LogLevel.ERR)
		else:
			continue

	if iips == []:
		iips = ["<unset>"]
		eips = ["<unset>"]
	if eips == []:
		eips = ["<none>"]
	if new_name is None:
		new_name = "<unset>"

	return new_name, iips, eips

# pylint: disable-next=unused-argument
def get_node_info(vlist, extra_vars) -> List[Type]:
	"""
	Infogetter for Nodes

		Parameters:
			kwargs (dict): Additional parameters
		Returns:
			info (list[InfoClass]): A list with info
	"""
	info: List[Type] = []

	if vlist == []:
		return []

	for obj in vlist:
		# For now we do not do anything with external IPs; we should
		name, internal_ips, external_ips = get_node_addresses(deep_get(obj, DictPath("metadata#name")), deep_get(obj, DictPath("status#addresses")))
		ref = obj
		kubernetes_roles = kh.get_node_roles(obj)
		timestamp = timestamp_to_datetime(deep_get(obj, DictPath("metadata#creationTimestamp")))
		age = get_since(timestamp)
		cpu = (deep_get(obj, DictPath("status#allocatable"))["cpu"], deep_get(obj, DictPath("status#capacity"))["cpu"])
		# Strip Ki suffix
		mem = (deep_get(obj, DictPath("status#allocatable"))["memory"][:-2], deep_get(obj, DictPath("status#capacity"))["memory"][:-2])
		status, status_group, taints, _full_taints = get_node_status(obj)
		kubelet_version = deep_get(obj, DictPath("status#nodeInfo#kubeletVersion"))
		container_runtime = deep_get(obj, DictPath("status#nodeInfo#containerRuntimeVersion"))
		operating_system = deep_get(obj, DictPath("status#nodeInfo#osImage"))
		kernel = deep_get(obj, DictPath("status#nodeInfo#kernelVersion"))

		info.append(type("InfoClass", (), {
			"name": name,
			"ref": ref,
			"status": status,
			"status_group": status_group,
			"kubernetes_roles": kubernetes_roles,
			"age": age,
			"kubelet_version": kubelet_version,
			"internal_ips": internal_ips,
			"os": operating_system,
			"kernel": kernel,
			"container_runtime": container_runtime,
			"cpu": cpu,
			"mem": mem,
			"taints": taints,
		}))

	return info

# To make the failure case easier, return both the ref and the name of the control plane
def get_control_plane() -> Tuple[Dict, str]:
	if not kubernetes_support:
		return None, ""

	vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
	control_planes = []

	if vlist is None or len(vlist) == 0 or status != 200:
		return None, ""

	# Find control planes; but for now only return the first match
	for obj in vlist:
		labels = deep_get(obj, DictPath("metadata#labels"), {})
		if "node-role.kubernetes.io/control-plane" in labels or "node-role.kubernetes.io/master" in labels:
			control_planes.append((obj, deep_get(obj, DictPath("metadata#name"))))

	# If we have exactly one node, assume that it is the control plane even if it lacks that label
	if len(control_planes) == 0 and len(vlist) == 1:
		control_planes.append((vlist[0], deep_get(vlist[0], DictPath("metadata#name"))))

	if len(control_planes) == 0:
		ansithemeprint([ANSIThemeString("Error", "warning"),
				ANSIThemeString(": None of the nodes in the cluster are labelled as control planes. The cluster is most likely misconfigured.", "default")], stderr = True)
		return {}, ""
	if len(control_planes) > 1:
		ansithemeprint([ANSIThemeString("Warning", "warning"),
				ANSIThemeString(": Multiple control planes not supported yet, found multiple; returning first entry:", "default")], stderr = True)
		for control_plane in control_planes:
			ansithemeprint([ANSIThemeString(f"  {control_plane[1]}", "default")], stderr = True)

	return control_planes[0][0], control_planes[0][1]

def get_pod_restarts_total(pod):
	restarts = 0
	restarted_at = None

	#for status in deep_get(pod, DictPath("status#initContainerStatuses"), []) + deep_get(pod, DictPath("status#containerStatuses"), []):
	for status in deep_get(pod, DictPath("status#containerStatuses"), []):
		restart_count = deep_get(status, DictPath("restartCount"), 0)
		restarts += restart_count
		if restart_count > 0:
			started_at = timestamp_to_datetime(deep_get_with_fallback(status, [DictPath("state#running#startedAt"), DictPath("lastState#terminated#finishedAt")], None))
			if started_at is not None and (restarted_at is None or restarted_at < started_at):
				restarted_at = started_at

	if restarts == 0:
		restarted_at = -1
	return restarts, restarted_at

# pylint: disable-next=unused-argument
def set_cluster_context(stdscr: curses.window, **kwargs) -> None:
	global force_refresh_apis  # pylint: disable=global-statement

	selected = deep_get(kwargs, DictPath("selected"))
	name = getattr(selected, "name")

	retval = kh.set_context(name = name)
	# If we actually changed context we need to force an API reload,
	# since we might have changed between different clusters (or switched
	# to a role that does not have access to a particular API)
	if retval:
		force_refresh_apis = True

def get_containers(containers, container_statuses):
	container_dict = {}

	container_list = []

	for container in containers:
		container_name = deep_get(container, DictPath("name"))
		container_image = deep_get(container, DictPath("image"))
		image_version = get_image_version(container_image)
		container_dict[container_name] = image_version

	for container in container_statuses:
		container_name = deep_get(container, DictPath("name"))
		container_image = deep_get(container, DictPath("image"))
		if container_dict[container_name] == "<undefined>":
			image_version = get_image_version(container_image, "<undefined>")
			container_list.append([container_name, image_version])
		else:
			container_list.append([container_name, container_dict[container_name]])

	return container_list

# Returns True if the item should be skipped
def filter_list_entry(obj, caller_obj, filters):
	skip = False
	for f in filters:
		if not deep_get(filters[f], DictPath("enabled"), True):
			continue

		# If len(allow) > 0, we only allow fields that match
		allow = deep_get(filters[f], DictPath("allow"), [])
		# If len(block) > 0, we skip fields that match
		block = deep_get(filters[f], DictPath("block"), [])
		if len(allow) > 0:
			# If all field + value pairs match we allow
			for rule in allow:
				rtype = deep_get(rule, DictPath("type"), "")
				if rtype == "":
					key = deep_get(rule, DictPath("key"), "")
					values = deep_get(rule, DictPath("values"), [])
					if isinstance(values, dict):
						if deep_get(rule, DictPath("values#source"), "object") == "caller":
							src = caller_obj
						else:
							src = obj
						values_path = deep_get(rule, DictPath("values#path"), "")
						values = deep_get(src, DictPath(values_path), [])
						if isinstance(values, str):
							values = [values]

					_listref = deep_get(rule, DictPath("list"))
					if _listref is not None:
						_list = deep_get(obj, DictPath(_listref), [])
						for _item in _list:
							if deep_get(_item, DictPath(key), "").rstrip() in values:
								break
						else:
							skip = True
							break
					elif deep_get(obj, DictPath(key), "").rstrip() not in values:
						skip = True
						break
				elif rtype == "dictlist":
					path = deep_get(rule, DictPath("path"), "")
					target_dict = deep_get(obj, DictPath(path), {})
					key_value_matches = []
					matched = False
					for _dict in target_dict:
						for key, value in deep_get(rule, DictPath("fields"), {}).items():
							if isinstance(value, dict):
								if deep_get(value, DictPath("source"), "object") == "caller":
									src = caller_obj
								else:
									src = target_dict
								value_path = deep_get(value, DictPath("path"), "")
								if len(value_path) > 0:
									value = deep_get(src, DictPath(value_path))
							if key == "api_family":
								target_value = deep_get(_dict, DictPath("apiVersion"))
								if "/" in target_value:
									target_value = target_value.split("/", 1)[0]
								else:
									target_value = ""
							else:
								target_value = deep_get(_dict, DictPath(key))
							# pylint: disable-next=unidiomatic-typecheck
							if type(value) == type(target_value) and value == target_value:  # noqa: E721
								matched = True
							else:
								# This particular dict did not fully match
								matched = False
								break
						if matched:
							break
					if not matched:
						skip = True
						break
				else:
					sys.exit(f"filter: unknown rule-type: {rtype}")

		if len(block) > 0:
			# If all field + value pairs match we block
			for rule in block:
				key = deep_get(rule, DictPath("key"), "")
				values = deep_get(rule, DictPath("values"), [])
				if isinstance(values, dict):
					if deep_get(rule, DictPath("values#source"), "object") == "caller":
						src = caller_obj
					else:
						src = obj
					values_path = deep_get(rule, DictPath("values#path"), "")
					values = deep_get(src, DictPath(values_path), [])
					if isinstance(values, str):
						values = [values]
				if deep_get(obj, DictPath(key), "").rstrip() in values:
					skip = True
					break
		if skip:
			break
	return skip

def generic_listgetter(kind: Tuple[str, str], namespace: str, **kwargs: Dict) -> List[Dict]:
	label_selector = deep_get(kwargs, DictPath("label_selector"), "")
	field_selector = deep_get(kwargs, DictPath("field_selector"), "")
	filters = deep_get(kwargs, DictPath("filters"), [])
	vlist, status = kh.get_list_by_kind_namespace(kind, namespace, label_selector = label_selector, field_selector = field_selector)
	if len(vlist) == 0 or status != 200 or len(filters) == 0:
		return vlist, status

	vlist2 = []

	for item in vlist:
		if filter_list_entry(item, deep_get(kwargs, DictPath("_obj"), {}), filters):
			continue
		vlist2.append(item)

	return vlist2, status

def listgetter_field(obj, **kwargs):
	path = deep_get(kwargs, DictPath("path"))
	vlist = deep_get(obj, DictPath(path))
	return vlist, 200

# Return all items of a dict as a list of dicts
# with the key and the value in the fields
# "key" and "value", respectively
def listgetter_dict_list(obj, **kwargs):
	path = deep_get(kwargs, DictPath("path"))
	vlist = []
	for key, value in deep_get(obj, DictPath(path), {}).items():
		vlist.append({"key": key, "value": value})
	return vlist, 200

def listgetter_join_lists(obj, **kwargs):
	paths = deep_get(kwargs, DictPath("paths"))
	vlist = []

	for path in paths:
		name_key = deep_get(path, DictPath("name_key"), "")
		name_value = deep_get(path, DictPath("name_value"), "")
		list_path = deep_get(path, DictPath("path"), [])
		d = {}
		if len(name_key) > 0:
			d[name_key] = name_value
		for key, value in deep_get_with_fallback(obj, list_path, []).items():
			d[key] = value
		vlist.append(d)
	return vlist, 200

# key_paths: the dict keys that should be turned into values
# key_name: name for the key that holds these values
# fields: paths the fields in the dict that should be added to the list
#
# Thus:
# "a": {
#     "b": {
#        "d": 1,
#        "e": 2
#     },
#     "c": {
#        "d": 2,
#        "e": 3,
#     },
# }
# key_paths = ["a#b", "a#c"]
# key_name = "foo"
# fields = [{"path": "a#b", "name": "bar"}, {"path": "a#c", "name": "baz"}]
# would generate the list
# [{"foo": "d", "bar": 1, "baz": 2}, {"foo": "e", "bar": 2, "baz": 3}]
def listgetter_join_dicts_to_list(obj, **kwargs):
	vlist = []
	key_paths = deep_get(kwargs, DictPath("key_paths"), "")
	key_name = deep_get(kwargs, DictPath("key_name"), "")
	fields = deep_get(kwargs, DictPath("fields"), [])

	keys = set()

	for key_path in key_paths:
		for key in deep_get(obj, DictPath(key_path), {}):
			keys.add(key)

	for key in keys:
		d = {
			key_name: key
		}
		for field in fields:
			path = deep_get(field, DictPath("path"), "")
			name = deep_get(field, DictPath("name"))
			default = deep_get(field, DictPath("default"))
			if name is None:
				continue
			value = deep_get(obj, DictPath(f"{path}#{key}"))
			d[name] = value
		if len(d) <= 1:
			continue
		vlist.append(d)

	return vlist, 200

def get_pod_info(**kwargs) -> List[Type]:
	"""
	Infogetter for Pods

		Parameters:
			kwargs (dict): Additional parameters
		Returns:
			info (list[InfoClass]): A list with info
	"""
	vlist = deep_get(kwargs, DictPath("_vlist"))
	in_depth_node_status = deep_get(kwargs, DictPath("in_depth_node_status"), True)
	extra_vars = deep_get(kwargs, DictPath("extra_vars"), {"show_kind": "", "show_evicted": True})
	filters = deep_get(kwargs, DictPath("filters"), [])
	info: List[Type] = []

	if vlist == []:
		return []

	for obj in vlist:
		skip = False

		# Sadly field_labels do not support all fields we might want to filter on,
		# so we have to complicate things a bit
		if len(filters) > 0:
			for key, value in filters:
				ovalue = deep_get(obj, DictPath(key), None)
				if ovalue is None or ovalue != value:
					skip = True
					break

		if skip:
			continue

		phase = deep_get(obj, DictPath("status#phase"))
		reason = deep_get(obj, DictPath("status#reason"), "").rstrip()

		if not deep_get(extra_vars, DictPath("show_evicted"), False) and phase == "Failed" and reason == "Evicted":
			continue

		namespace = deep_get(obj, DictPath("metadata#namespace"))
		name = deep_get(obj, DictPath("metadata#name"))
		ref = obj
		nodename = deep_get(obj, DictPath("spec#nodeName"), "<none>")
		status, status_group = datagetters.get_pod_status(kh, obj, in_depth_node_status = in_depth_node_status)

		if in_depth_node_status:
			timestamp = timestamp_to_datetime(deep_get(obj, DictPath("metadata#creationTimestamp")))
			age = get_since(timestamp)

			owr = deep_get(obj, DictPath("metadata#ownerReferences"), [])
			controller = get_controller_from_owner_references(owr)
			show_kind = deep_get(extra_vars, DictPath("show_kind"), "").lower()
			controller = format_controller(controller, show_kind)

			pod_ip = deep_get(obj, DictPath("status#podIP"), "<unset>")
			pod_restarts, restarted_at = get_pod_restarts_total(obj)
			if restarted_at == -1:
				last_restart = -1
			else:
				last_restart = get_since(restarted_at)
			tolerations = itemgetters.get_pod_tolerations(kh, obj)
			containers = get_containers(containers = deep_get(obj, DictPath("spec#initContainers"), []), container_statuses = deep_get(obj, DictPath("status#initContainerStatuses"), []))
			containers += get_containers(containers = deep_get(obj, DictPath("spec#containers"), []), container_statuses = deep_get(obj, DictPath("status#containerStatuses"), []))

			info.append(type("InfoClass", (), {
				"namespace": namespace,
				"name": name,
				# The reference to the "true" resource object
				"ref": ref,
				"status": status,
				"status_group": status_group,
				"node": nodename,
				"pod_ip": pod_ip,
				"age": age,
				"restarts": pod_restarts,
				"last_restart": last_restart,
				"controller": controller,
				"tolerations": tolerations,
				"containers": containers,
			}))

		else:
			# This is to speed up the cluster overview, which doesn't use most of this information anyway;
			# for clusters with a huge amount of pods this can make a quite significant difference
			info.append(type("InfoClass", (), {
				"namespace": namespace,
				"name": name,
				# The reference to the "true" resource object
				"ref": ref,
				"status": status,
				"status_group": status_group,
				"node": nodename,
			}))

	return info

def generate_list_header(uip: UIProps, headerpad: curses.window, field_dict: Dict, is_taggable: bool = False) -> None:
	headerarray: List[Union[ThemeRef, ThemeString]] = []
	first = True

	tabstops = []

	tabstop = 0

	# Is the list taggable?
	if is_taggable:
		tabstops.append(tabstop)
		headerarray.append(ThemeRef("separators", "tag"))
		tabstop = themearray_len(headerarray)

	for field in field_dict:
		generator = field_dict[field].get("generator")
		if generator is None:
			continue

		tabstops.append(tabstop)

		theme = get_theme_ref()
		if uip.get_sortcolumn() == field:
			if not uip.reversible:
				sort_direction_char = theme["boxdrawing"]["arrownone"]
			elif uip.sortorder_reverse:
				sort_direction_char = theme["boxdrawing"]["arrowup"]
			else:
				sort_direction_char = theme["boxdrawing"]["arrowdown"]
		else:
			sort_direction_char = theme["boxdrawing"]["arrownone"]

		# We always want this much padding between the headers,
		# except if this is the first header
		#
		# Note that we need to subtract the width of sort direction char
		# from the width of pad; this only works if len(pad) > 0
		if not first:
			headerarray.append(ThemeString("".ljust(len(ThemeRef("separators", "pad")) - len(sort_direction_char)), ThemeAttr("types", "generic")))

		tabstop = themearray_len(headerarray)

		# This tells the length of the alignment of the header
		fieldlen = deep_get(field_dict, DictPath(f"{field}#fieldlen"))
		header = deep_get(field_dict, DictPath(f"{field}#header"))
		ralign = deep_get(field_dict, DictPath(f"{field}#ralign"), False)

		# We cannot use ljust/rjust on the string,
		# because we want the string and arrow in different colours,
		# so just prepend/append whitespace instead
		if ralign:
			headerarray.append(ThemeString("".ljust(fieldlen - len(header)), ThemeAttr("types", "generic")))
		headerarray.append(ThemeString(header, ThemeAttr("main", "listheader"), selected = uip.get_sortcolumn() == field))
		headerarray.append(ThemeString(sort_direction_char, ThemeAttr("main", "listheader_arrows")))
		if not ralign:
			headerarray.append(ThemeString("".ljust(fieldlen - len(header)), ThemeAttr("types", "generic")))
		first = False

	# We've got to account for the last entry
	if len(field_dict) > 0:
		tabstops.append(tabstop)

	# We've processed all fields, time to output the header
	uip.addthemearray(headerpad, headerarray, y = 0, x = 0)
	uip.tabstops = tabstops

# pylint: disable-next=too-many-arguments
def generate_list_row(uip: UIProps, listpad: curses.window, data, field_list, ypos: int, is_selected: bool, is_taggable: bool = False, is_tagged: bool = False, is_deleted: bool = False) -> None:
	first = True

	i = 0

	for field in field_list:
		i += 1

		attribute = curses.A_NORMAL

		if is_taggable:
			tagprefixlen = len(ThemeRef("separators", "tag"))

			if is_tagged:
				tagprefix: List[Union[ThemeRef, ThemeString]] = [ThemeRef("separators", "tag")]
			else:
				tagprefix = [ThemeString("".ljust(tagprefixlen), ThemeAttr("types", "generic"))]
		else:
			tagprefix = ""
			tagprefixlen = 0

		generator = field_list[field].get("generator")
		if generator is None:
			continue
		if isinstance(generator, str):
			generator = deep_get(generator_allowlist, DictPath(generator), generators.generator_basic)

		fieldlen = field_list[field]["fieldlen"]
		if i < len(field_list):
			fpad = len(ThemeRef("separators", "pad"))
		else:
			fpad = 0

		ralign = field_list[field].get("ralign", False)

		formatting = {
			"item_separator": field_list[field].get("item_separator", ThemeRef("separators", "list")),
			"field_separators": field_list[field].get("field_separators", [ThemeRef("separators", "field")]),
			"field_colors": field_list[field].get("field_colors", [ThemeAttr("types", "field")]),
			"ellipsise": field_list[field].get("ellipsise", -1),
			"ellipsis": field_list[field].get("ellipsis", ThemeRef("separators", "ellipsis")),
			"field_prefixes": field_list[field].get("field_prefixes", None),
			"field_suffixes": field_list[field].get("field_suffixes", None),
			"mapping": field_list[field].get("mapping", {}),
		}

		tmp = generator(data, field, fieldlen, fpad, ralign, is_selected, **formatting)

		pos = field_list[field]["pos"]

		if first and is_taggable:
			uip.addthemearray(listpad, tagprefix, y = ypos, x = pos, deleted = is_deleted)
			first = False

		uip.addthemearray(listpad, tmp, y = ypos, x = pos + tagprefixlen, selected = is_selected, deleted = is_deleted)

def genericlistloop(stdscr: curses.window, view: str) -> Retval:
	"""
	Generic main loop for listviews

		Parameters:
			stdscr (curses.window): The curses window to operate on
			view (str): The view to show
		Returns:
			Retval
		Raises:
			ProgrammingError (view is invalid)
	"""
	global async_data  # pylint: disable=global-statement
	global executor  # pylint: disable=global-statement

	global selected_namespace  # pylint: disable=global-statement
	global initial_name  # pylint: disable=global-statement
	global initial_namespace  # pylint: disable=global-statement

	if not (isinstance(stdscr, curses.window) and isinstance(view, str)):
		msg = [
			[("genericlistloop()", "emphasis"),
			 (" called with invalid argument(s):", "error")],
			[("stdscr = ", "default"),
			 (f"{stdscr}", "argument"),
			 (" (type: ", "default"),
			 (f"{type(stdscr)}", "argument"),
			 (", expected: ", "default"),
			 ("{curses.window}", "argument"),
			 (")", "default")],
			[("view = ", "default"),
			 (f"{yaml.dump(view)}", "argument"),
			 (" (type: ", "default"),
			 (f"{type(view)}", "argument"),
			 (", expected: ", "default"),
			 ("str", "argument"),
			 (")", "default")],
		]

		unformatted_msg, formatted_msg = ANSIThemeString.format_error_msg(msg)

		raise ProgrammingError(unformatted_msg,
				       severity = LogLevel.ERR,
				       formatted_msg = formatted_msg)

	denylist = deep_get(views, DictPath(f"{view}#field_denylist"), [])
	field_indexes = deep_get(views, DictPath(f"{view}#field_indexes"), {})

	if not (isinstance(field_indexes, dict) and field_indexes):
		msg = [
			[("genericlistloop()", "emphasis"),
			 (" called with invalid argument(s):", "error")],
			[("field_indexes = ", "default")],
			[(f"{yaml.dump(field_indexes)}", "argument"),
			 (" (type: ", "default"),
			 (f"{type(field_indexes)}", "argument"),
			 (", expected: ", "default"),
			 (f"{dict}", "argument"),
			 (") with at least one element", "default")],
		]

		unformatted_msg, formatted_msg = ANSIThemeString.format_error_msg(msg)

		raise ProgrammingError(unformatted_msg,
				       severity = LogLevel.ERR,
				       formatted_msg = formatted_msg)

	# Just in case there are leftover futures from other views
	executor.shutdown()
	executor = reexecutor.ReExecutor()

	if "Custom" in field_indexes:
		field_index = "Custom"
	elif "Wide" in field_indexes:
		field_index = "Wide"
	else:
		field_index = list(field_indexes.keys())[0]

	fieldgenerator_args = {
		"field_index": field_index,
		"field_indexes": field_indexes,
		"fields": deep_get(views, DictPath(f"{view}#fields")),
		"denylist": denylist,
	}
	field_dict, field_names, sortcolumn, sortorder_reverse = generators.fieldgenerator(view = view,
											   selected_namespace = selected_namespace,
											   **fieldgenerator_args)

	uip = UIProps(stdscr)

	kind = deep_get(views, DictPath(f"{view}#kind"))

	windowheader = view

	if kind is None or kind[0].startswith("__"):
		is_namespaced = False
	else:
		is_namespaced = kh.is_kind_namespaced(kind)

	helptext = generate_helptext(view, "listview", [], [])
	activatedfun = deep_get(views, DictPath(f"{view}#activatedfun"), genericinfoloop)
	on_activation = deep_get(views, DictPath(f"{view}#on_activation"), {})
	# This is the timeout before starting a new fetch *once the old one has completed*.
	# In other words we're not spamming constant requests--there'll be at least update_delay
	# seconds between each request
	async_update_delay = deep_get(views, DictPath("{view}#async_update_delay"), 5)
	# This is the timeout before forcing a UI refresh
	update_delay = deep_get(views, DictPath("{view}#update_delay"), -1)

	is_taggable = deep_get(views, DictPath("{view}#is_taggable"), True) and deep_get(views, DictPath(f"{view}#actions")) is not None
	extra_vars = deep_get(views, DictPath("{view}#extra_vars"), {})

	uip.init_window(field_dict, view = kind, windowheader = windowheader,
			update_delay = update_delay, sortcolumn = sortcolumn, sortorder_reverse = sortorder_reverse,
			helptext = helptext, activatedfun = activatedfun, on_activation = on_activation)

	# For the status bar; position is always at the bottom of the screen and the entire width of the screen
	statusbar = uip.init_statusbar()

	# For the list
	headerpad, listpad = uip.init_listpad(listheight = 1, width = -1, ypos = 1, xpos = 1)

	label_selector = ""

	# These values can be toggled, so we need to read them first
	listview_args = copy.deepcopy(deep_get(views, DictPath(f"{view}#listview_args"), {}))

	listgetter = deep_get(views, DictPath(f"{view}#listgetter"))
	listgetter_async = deep_get(views, DictPath("{view}#listgetter_async"))
	listgetter_args = deep_get(views, DictPath("{view}#listgetter_args"), {})
	listgetter_args["label_selector"] = label_selector

	infogetter = deep_get(views, DictPath(f"{view}#infogetter"), generic_infogetter)
	infogetter_extra_vars = deep_get(views, DictPath(f"{view}#extra_vars#infogetter"), { "_view": view.strip("*") })
	infogetter_extra_vars["_field_index"] = field_index.lower()
	infogetter_extra_vars["_field_names"] = field_names
	infogetter_extra_vars["_field_dict"] = field_dict
	if "filters" in listview_args:
		infogetter_extra_vars["_filters"] = deep_get(listview_args, DictPath("filters"))

	uip.last_action = datetime.now()
	uip.idle_timeout = 5
	tagged_items = set()
	serverstatus = "ok"

	first_fetch = True

	while True:
		if len(executor) == 0:
			new_data = "false"
			uip.force_update()
			uip.listlen = 0
			# Temporary workaround
			if listgetter_async == get_inventory_list:
				hosts = list(deep_get(ansible_get_inventory_dict(), DictPath("all#hosts")).keys())
				# The inventory doesn't change all that often, but reading it every 10 seconds should be OK
				executor.trigger("hosts", 10, read_file_async, path = ANSIBLE_INVENTORY, filetype = "yaml")
				async_data["hosts"] = []
				async_data["hosts_lock"] = threading.Lock()
				match_key = "name"
			elif listgetter_async == get_context_list:
				vlist, hosts = get_context_list()
				match_key = "server_address"
			elif listgetter in (generic_listgetter, get_kubernetes_list_async):
				executor.trigger(".".join(kind), 5, get_kubernetes_list_async, get_kubernetes_list_async, kind = kind, namespace = selected_namespace, **listgetter_args)
			if listgetter_async in (get_inventory_list, get_context_list):
				# But the hosts can change status more frequently than that
				executor.trigger("pings", 5, run_ansible_play_async, playbook = FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("facts_ping.yaml"))), selection = hosts, interval = -1)

		# The asynchronous UI follows these rules:
		# Idle:
		#   No user activity within the last idle_timeout seconds
		# Force refresh:
		#   User pressed [F5], changed sort column, or opened/closed a dialog ([F1], [F2], [F8], etc)
		# Additional blockers:
		#   Items are tagged, menus are open, etc.
		if (result := executor.get(".".join(kind))) != ([], []):
			vlist, status = result
			infogetter_extra_vars["_vlist"] = vlist

			if status == 42503:
				serverstatus = "Server Unavailable"
			elif status == 42504:
				serverstatus = "Connection Timeout"
			else:
				serverstatus = str(status)
			if not uip.listlen:
				uip.force_update()
			new_data = "pending"
			uip.update_timestamp(update = new_data)
			first_fetch = False
			win = None

		if uip.is_idle() or uip.is_update_triggered():
			# We need to generate the list info even if the list is empty,
			# otherwise we'll crash elsewhere
			if not uip.listlen or new_data == "pending" and (uip.update_forced or not tagged_items):
				vinfo = infogetter(**infogetter_extra_vars)
				uip.update_info(vinfo)
				uip.force_update()
				new_data = "true"
				tagged_items = set()
				uip.update_forced = False
		if uip.is_update_triggered():
			linelen = update_field_widths(field_dict, field_names, uip.info)
			if is_taggable:
				linelen += len("✓ ")
			uip.resize_listpad(linelen)
			uip.list_needs_regeneration(True)
			uip.update_window(update = new_data)
			if new_data == "true":
				new_data = "false"

		if uip.refresh:
			# The data in some fields might become shorter, so we need to trigger a clear
			uip.statusbar.erase()

			statusarray1: List[Union[ThemeRef, ThemeString]] = []

			if view != "Contexts" and selected_namespace:
				statusarray1 += [ThemeString("Namespace: ", ThemeAttr("statusbar", "infoheader")),
						 ThemeString(f"{selected_namespace if len(selected_namespace) > 0 else '<All>'}", ThemeAttr("statusbar", "highlight"))]

			if len(statusarray1) > 0:
				statusarray1 += [ThemeRef("separators", "statusbar")]

			statusarray1 += [
				ThemeString("Fields: ", ThemeAttr("statusbar", "infoheader")),
				ThemeString(field_index, ThemeAttr("statusbar", "highlight"))
			]
			if len(label_selector) > 0:
				if len(statusarray1) > 0:
					statusarray1 += [ThemeRef("separators", "statusbar")]
				statusarray1 += [
					ThemeString("Label selector: ", ThemeAttr("statusbar", "infoheader")),
					ThemeString(f"{label_selector}", ThemeAttr("statusbar", "highlight"))
				]
			statusarray2: List[Union[ThemeRef, ThemeString]] = []
			if read_only_mode:
				statusarray2 += [ThemeString("Read Only Mode", ThemeAttr("statusbar", "highlight"))]

			if len(statusarray2) > 0:
				statusarray2 += [ThemeRef("separators", "statusbar")]
			statusarray2 += [
				ThemeString("API Status: ", ThemeAttr("statusbar", "infoheader")),
				# Here we should probably highlight when something is bad
				ThemeString(f"{serverstatus}", ThemeAttr("statusbar", "default")),
			]

			for status_data in deep_get(views, DictPath(f"{view}#statusmsg"), []):
				if len(status_data) == 2:
					key, path = status_data
					default_status = "<unset>"
				else:
					key, path, default_status = status_data

				# If path is a list the first item tells what source to use and the second
				# what path to fetch the value from
				if isinstance(path, list):
					if path[0] == "config":
						src_obj = cmtlib.cmtconfig
					#elif path[0] == "obj":
					#	value_path = obj
					elif path[0] == "var":
						src_obj = listview_args
					value_path = DictPath(path[1])
				else:
					src_obj = listview_args
					value_path = DictPath(path)

				value = str(deep_get(src_obj, value_path, default_status))
				if len(statusarray2) > 0:
					statusarray2 += [ThemeRef("separators", "statusbar")]
				statusarray2 += [
					ThemeString(key, ThemeAttr("statusbar", "infoheader")),
					ThemeString(value, ThemeAttr("statusbar", "default")),
				]

			uip.addthemearray(statusbar, statusarray1, y = 0, x = 0)
			uip.addthemearray(statusbar, statusarray2, y = 1, x = 0)

		uip.update_sorted_list()

		if uip.info:
			unique_match = uip.goto_first_match_by_name_namespace(initial_name, initial_namespace)
			initial_name = None
			initial_namespace = None
			if unique_match is not None:
				selected = uip.get_selected()
				if uip.activatedfun is not None:
					retval = uip.activatedfun(uip.stdscr, unique_match, kind)
					if retval == Retval.RETURNFULL:
						return retval
				uip.force_update()
				uip.refresh_all()
				continue

		uip.refresh_selected()
		if not uip.is_list_regenerated():
			generate_list_header(uip, headerpad, field_dict, is_taggable = is_taggable)
			for y in range(uip.yoffset, min(uip.yoffset + uip.mincurypos + uip.maxcurypos + 1, uip.listlen)):
				item = uip.sorted_list[y]
				is_tagged = item in tagged_items
				is_deleted = getattr(item, "__deleted", False)
				generate_list_row(uip, listpad, item, field_dict, y - uip.yoffset, uip.is_selected(item), is_taggable = is_taggable, is_tagged = is_tagged, is_deleted = is_deleted)
			uip.list_needs_regeneration(False)

		uip.refresh_window()
		uip.refresh_listpad()
		uip.refresh_statusbar()
		if first_fetch:
			win = curses_helper.notice(uip.listpad, uip.maxy // 2, uip.maxx // 2, message = "checking for data")
		curses.doupdate()

		uip.stdscr.timeout(100)
		c = uip.stdscr.getch()

		retval = uip.generic_keycheck(c)

		if retval == Retval.MATCH:
			continue
		if retval == Retval.RETURNONE:
			try:
				# This is to get the necessary stack info
				raise UserWarning
			except UserWarning:
				# Calling function; if we're at the top level view we shouldn't return further,
				# but we should clear selections
				caller = sys.exc_info()[2].tb_frame.f_back.f_code.co_name
				if caller in ("setupui",):
					tagged_items = set()
					uip.force_refresh()
				else:
					return Retval.RETURNDONE
		if retval == Retval.RETURNFULL:
			return retval

		if c == curses.KEY_F2:
			retval = selectwindow(uip)
			if retval == Retval.RETURNFULL:
				return retval
			uip.refresh_all()
		elif c == curses.KEY_F3:
			retval = selectwindow(uip, refresh_apis = True)
			if retval == Retval.RETURNFULL:
				return retval
			uip.refresh_all()
		elif c == ord("B"):
			uip.toggle_borders()
			uip.refresh_all()
			uip.force_update()
			uip.update_window(update = False)
		elif c == ord("W"):
			if len(field_indexes) == 0:
				continue

			_list = list(field_indexes.keys())
			_index = _list.index(field_index)
			field_index = _list[(_index + 1) % len(field_indexes)]

			fieldgenerator_args = {
				"field_index": field_index,
				"field_indexes": field_indexes,
				"fields": deep_get(views, DictPath(f"{view}#fields")),
				"denylist": denylist,
			}
			field_dict, field_names, sortcolumn, sortorder_reverse = generators.fieldgenerator(view = view,
													   selected_namespace = selected_namespace,
													   **fieldgenerator_args)
			update_field_widths(field_dict, field_names, uip.info)
			uip.reinit_window(field_dict, sortcolumn = sortcolumn)
			uip.resize_listpad(width = -1)
			uip.refresh_all()
			uip.force_update()
			uip.update_window(update = False)
		elif c == curses.KEY_F7:
			action_title = "Perform cluster-wide actions"
			action_src_list = listviewactions

			# Populate the list of actions
			actions, actionlist = populate_actionlist(action_list = action_src_list)

			if len(actions) == 0:
				continue

			tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, actions, title = action_title)
			selection = None
			if tmpselection is not None and tmpselection != "":
				selection = ""
				for i in range(0, len(tmpselection)):
					if len(tmpselection[i]) > 0:
						selection += str(tmpselection[i][0])
			uip.refresh_all()
			curses.doupdate()

			if selection is not None and selection != "":
				actionfunc = None

				# Map the description back to key
				action = None
				for action in actionlist:
					description = deep_get(actionlist, DictPath(f"{action}#description"))
					tmpdescription = ""
					if isinstance(description, str):
						tmpdescription = description
					else:
						for i in range(0, len(description)):
							tmpdescription += description[i][0]
					tmpmetadata = deep_get(actionlist, DictPath(f"{action}#metadata"), [])
					for metadata in tmpmetadata:
						tmpdescription += metadata[0]
					if tmpdescription == selection:
						actionfunc = deep_get(actionlist, DictPath(f"{action}#actionfunc"), command_hosts)
						if isinstance(actionfunc, str):
							actionfunc = deep_get(actionfunc_allowlist, DictPath(actionfunc))
						# These are only relevant for node and inventory view
						allowoncontrolplane = deep_get(actionlist, DictPath(f"{action}#allow_on_control_plane"), True)
						singleoncontrolplane = deep_get(actionlist, DictPath(f"{action}#single_on_control_plane"), False)
						confirm = deep_get(actionlist, DictPath(f"{action}#confirm"), False)
						query = deep_get(actionlist, DictPath(f"{action}#query"))
						queryval = deep_get(actionlist, DictPath(f"{action}#queryval"))
						queryfunc = deep_get(actionlist, DictPath(f"{action}#queryfunc"))
						extravars = deep_get(actionlist, DictPath(f"{action}#extravars"), {})
						break

				if actionfunc is None:
					continue

				selection_vars = extravars

				# This should be modified; we might want to ask multiple queries.
				# At the very least asking for one input plus confirmation.
				# A multi input box might be useful too.
				if queryfunc is not None and queryval is not None and query is not None:
					if queryfunc == "string":
						# Not supported by inputbox widget
						# querydefault = ""
						string = curses_helper.inputbox(uip.stdscr, uip.maxy // 2, 1, uip.maxy - 1, uip.maxx - 1, f"{query}: ")
						if string is None or string == "":
							continue
						selection_vars[queryval] = string
					elif queryfunc == "confirm":
						querydefault = False
						if not curses_helper.confirmationbox(uip.stdscr, uip.maxy // 2, uip.maxx // 2, title = f"{query}?", default = querydefault):
							continue
					elif queryfunc == "filechooser":
						# It is a programming error if either of these two are not set, so it is OK to get an exception
						listgetter = extravars["listgetter"]
						basedir = extravars["basedir"]
						selected_file = None
						selected_ptype = None

						while basedir is not None:
							tmp_file_list = listgetter(basedir)
							file_list = []
							for item in tmp_file_list:
								realpath, filename, ptype = item
								if ptype in ("File", "Configuration File", "Kustomization"):
									fmt = ThemeAttr("windowwidget", "default")
								elif ptype == "<dir>":
									fmt = ThemeAttr("windowwidget", "highlight")
								else:
									raise ValueError(f"Unknown ptype {ptype}")
								file_list.append({
									"lineattrs": WidgetLineAttrs.NORMAL,
									"columns": [[ThemeString(f"{filename}", fmt)], [ThemeString(f"{ptype}", ThemeAttr("windowwidget", "description"))]],
									"retval": filename,
								})
							tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, file_list, title = query, cursor = True)
							if tmpselection is None or tmpselection == "":
								# This will break out of the loop
								basedir = None
								selected_file = None
								continue
							selected_entry = tmpselection
							# Find entry in tmp_file_list
							for item in tmp_file_list:
								realpath, filename, ptype = item
								if filename == selected_entry:
									if ptype == "<dir>":
										basedir = realpath
										uip.refresh_all()
									elif ptype in ("File", "Configuration File", "Kustomization"):
										selected_file = realpath
										selected_ptype = ptype
										basedir = None
										break

						if selected_file is None:
							uip.force_update()
							continue
						selection_vars = extra_vars
						selection_vars["resource_path"] = (selected_file, selected_ptype)

				if confirm:
					if not curses_helper.confirmationbox(uip.stdscr, uip.maxy // 2, uip.maxx // 2, title = f"Perform “{description}“?", default = False):
						continue

				retval = actionfunc(uip, items = [], action = actionlist[action], values = selection_vars, kind = kind)
				if retval is not None and retval == Retval.RETURNFULL:
					return retval

				uip.force_update()
				continue
		elif c == ord("N"):
			if not is_namespaced:
				continue

			all_ns = "<All>"
			if selected_namespace == "":
				preselection = all_ns
			else:
				preselection = selected_namespace
			namespace_list = [{
				"lineattrs": WidgetLineAttrs.NORMAL,
				"columns": [[ThemeString(f"{all_ns}", ThemeAttr("windowwidget", "default"))]],
				"retval": all_ns,
			}]

			tmp, status = kh.get_list_by_kind_namespace(("Namespace", ""), "")
			if status == 200:
				for ns in (deep_get(item, DictPath("metadata#name")) for item in tmp):
					namespace_list.append({
						"lineattrs": WidgetLineAttrs.NORMAL,
						"columns": [[ThemeString(f"{ns}", ThemeAttr("windowwidget", "default"))]],
						"retval": ns,
					})

			tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, namespace_list, title = "Select Namespace", cursor = True, preselection = preselection)
			selection = None
			if tmpselection is not None and isinstance(tmpselection, str):
				selection = tmpselection

			if selection is not None and len(selection) > 0:
				if selection == all_ns:
					selected_namespace = ""
				else:
					selected_namespace = selection

			fieldgenerator_args = {
				"field_index": field_index,
				"field_indexes": field_indexes,
				"fields": deep_get(views, DictPath(f"{view}#fields")),
				"denylist": denylist,
			}
			field_dict, field_names, sortcolumn, sortorder_reverse = generators.fieldgenerator(view = view,
													   selected_namespace = selected_namespace,
													   **fieldgenerator_args)

			update_field_widths(field_dict, field_names, uip.info)
			tagged_items.clear()
			uip.reinit_window(field_dict, sortcolumn = sortcolumn)
			uip.resize_listpad(width = -1)
			uip.refresh_all()
			uip.update_info([])
			uip.force_update()
			if ".".join(kind) in executor:
				executor.update(".".join(kind), namespace = selected_namespace)
			uip.update_window(update = False)
			uip.list_needs_regeneration(True)
			infogetter_extra_vars["_vlist"] = []
		elif (c == ord("t") or c == ord(" ")) and is_taggable:
			selected = uip.get_selected()

			if selected is not None:
				if selected in tagged_items:
					tagged_items.discard(selected)
					uip.list_needs_regeneration(True)
				else:
					tagged_items.add(selected)
					uip.list_needs_regeneration(True)
				# After we tag an item we advance the cursor (when possible);
				# this way we can select multiple continuous items in a straight-forward manner
				uip.move_cur_with_offset(1)
		elif c == ord("T") and is_taggable:
			# Tag by pattern
			pattern = curses_helper.inputbox(uip.stdscr, uip.maxy // 2, 1, uip.maxy - 1, uip.maxx - 1, f"Tag “{(uip.sortcolumn).rstrip().lower()}“ matching: ")
			if pattern is None or pattern == "":
				continue
			compiled_pattern = re.compile(pattern)

			# XXX: This should search the specified sortcolumn, not always in name
			for item in uip.sorted_list:
				try:
					tmp = compiled_pattern.match(item.name)

					if tmp is not None and len(tmp[0]) > 0:
						if item not in tagged_items:
							tagged_items.add(item)
							uip.list_needs_regeneration(True)
				except re.error:
					continue
		elif c == ord("") and is_taggable:
			if len(tagged_items) == 0:
				continue

			# Untag by pattern
			pattern = curses_helper.inputbox(uip.stdscr, uip.maxy // 2, 1, uip.maxy - 1, uip.maxx - 1, f"Untag “{(uip.sortcolumn).rstrip().lower()}“ matching: ")
			if pattern is None or pattern == "":
				continue
			compiled_pattern = re.compile(pattern)

			# XXX: This should search the specified sortcolumn, not always in name
			for item in uip.sorted_list:
				try:
					tmp = compiled_pattern.match(item.name)

					if tmp is not None and len(tmp[0]) > 0:
						tagged_items.discard(item)
						uip.list_needs_regeneration(True)
				except re.error:
					continue
		elif c == ord("l") and is_taggable and vlist is not None and uip.listlen > 0:
			# List the union of all labels of the tagged objects (if the objects support labels)
			if len(tagged_items) == 0:
				selected = uip.get_selected()
				tagged_items.add(selected)
				uip.list_needs_regeneration(True)
			labellist = []
			labels = []
			if "namespace" in deep_get(vlist[0], DictPath("metadata"), "") and hasattr(item, "namespace"):
				itemlist = [ (item.namespace, item.name) for item in tagged_items ]
			else:
				itemlist = [ item.name for item in tagged_items ]

			if len(itemlist) == 0:
				continue

			for obj in vlist:
				if isinstance(itemlist[0], tuple):
					if (deep_get(obj, DictPath("metadata#namespace"), ""), deep_get(obj, DictPath("metadata#name"))) not in itemlist:
						continue
				else:
					if deep_get(obj, DictPath("metadata#name")) not in itemlist:
						continue

				labelref = deep_get(obj, DictPath("metadata#labels"), {})
				for key in labelref:
					if (key, labelref[key]) not in labels:
						labels.append((key, labelref[key]))
			if len(labels) == 0:
				tagged_items.clear()
				uip.list_needs_regeneration(True)
				continue
			for key, value in natsorted(labels):
				labellist.append({
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString(f"{key}", ThemeAttr("windowwidget", "default"))], [ThemeString(f"{value}", ThemeAttr("windowwidget", "default"))]],
				})
			label_headers = ["Label:", "Value:"]
			curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, labellist, headers = label_headers, title = "Labels", cursor = False)
			tagged_items.clear()
			uip.list_needs_regeneration(True)
			uip.refresh_all()
			curses.doupdate()
		elif c == ord("f") and is_taggable and vlist is not None and uip.listlen > 0:
			# List the union of all labels of the tagged objects and create a label selector
			# from the choices made by the user (if the objects support labels)
			if not tagged_items:
				selected = uip.get_selected()
				tagged_items.add(selected)
				uip.list_needs_regeneration(True)

			labellist = []
			labels = []
			if "namespace" in deep_get(vlist[0], DictPath("metadata"), ""):
				itemlist = [ (item.namespace, item.name) for item in tagged_items ]
			else:
				itemlist = [ item.name for item in tagged_items ]

			if not itemlist:
				continue

			for obj in vlist:
				if isinstance(itemlist[0], tuple):
					if (deep_get(obj, DictPath("metadata#namespace"), ""), deep_get(obj, DictPath("metadata#name"))) not in itemlist:
						continue
				else:
					if deep_get(obj, DictPath("metadata#name")) not in itemlist:
						continue

				labelref = deep_get(obj, DictPath("metadata#labels"), {})
				for key in labelref:
					if (key, labelref[key]) not in labels:
						labels.append((key, labelref[key]))
			if not labels:
				continue
			for key, value in labels:
				labellist.append({
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString(f"{key}", ThemeAttr("windowwidget", "default"))], [ThemeString(f"{value}", ThemeAttr("windowwidget", "default"))]],
				})
			label_headers = ["Label:", "Value:"]
			tagged_labels = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, labellist, headers = label_headers, title = "Labels", cursor = True, taggable = True)
			if len(tagged_labels) > 0:
				selectors = {}
				for i in range(0, len(labels)):
					if i in tagged_labels:
						selectors[labels[i][0]] = labels[i][1]
				label_selector = make_selector(selectors)
				uip.force_update()
			tagged_items.clear()
			uip.update_info([])
			uip.force_update()
			if ".".join(kind) in executor:
				executor.update(".".join(kind), label_selector = label_selector)
			uip.update_window(update = False)
			uip.list_needs_regeneration(True)
			infogetter_extra_vars["_vlist"] = []
		elif c == ord("A") and view == "Inventory" and len(tagged_items) == 0:
			selected = uip.get_selected()
			groups = ansible_get_groups(ANSIBLE_INVENTORY)
			inventory = ansible_get_inventory_dict()

			# These Ansible groups should not be possible to toggle on/off
			for skip in ["all", "controlplane", "controlplanes", "master", "node", "nodes"]:
				try:
					groups.remove(skip)
				except (KeyError, ValueError):
					pass
			host_groups = ansible_get_groups_by_host(inventory, selected.name)
			grouplist = []
			preselection = set()
			for i in range(0, len(groups)):
				grouplist.append({
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString(f"{groups[i]}", ThemeAttr("windowwidget", "default"))]],
				})
				if groups[i] in host_groups:
					preselection.add(i)
			group_headers = ["Ansible Groups:"]
			selection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, grouplist, headers = group_headers,
							       title = f"Toggle Ansible groups for {selected.name}:", cursor = True, taggable = True, preselection = preselection)
			new_groups = []
			for keep in ["all", "controlplane", "controlplanes", "master", "node", "nodes"]:
				if keep in host_groups:
					new_groups.append(keep)
			for i in selection:
				new_groups.append(groups[i])

			add_groups = set(new_groups) - set(host_groups)
			remove_groups = set(host_groups) - set(new_groups)

			for group in add_groups:
				retval = ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = [selected.name], group = group, skip_all = False)
			for group in remove_groups:
				retval = ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = [selected.name], group = group)

			if len(add_groups) > 0 or len(remove_groups) > 0:
				uip.force_update()
			uip.refresh_all()
			curses.doupdate()
		elif c == ord("F") and is_taggable:
			# Clear the label selector
			if label_selector:
				label_selector = ""
				uip.force_update()
				uip.refresh_all()
				curses.doupdate()
				tagged_items.clear()
				uip.update_info([])
				uip.force_update()
				if ".".join(kind) in executor:
					executor.update(".".join(kind), label_selector = label_selector)
				uip.update_window(update = False)
				uip.list_needs_regeneration(True)
				infogetter_extra_vars["_vlist"] = []
		elif c == ord("L") and is_taggable:
			# List tagged items
			taggeditemlist = []
			if len(tagged_items) == 0:
				continue
			# XXX: Currently windowwidget cannot handle ThemeRefs
			bullet = str(ThemeRef("separators", "widgetbullet"))
			for item in tagged_items:
				taggeditemlist.append({
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString(f"{bullet}{item.name}", ThemeAttr("windowwidget", "default"))]],
				})
			curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, taggeditemlist, title = "Tagged items", cursor = False)
			uip.refresh_all()
			curses.doupdate()
		elif c == ord(";") and is_taggable and uip.listlen > 0:
			cluster_available = True
			items = []
			autoitem = False
			control_plane = False

			if len(tagged_items) == 0:
				selected = uip.get_selected()
				tagged_items.add(selected)
				uip.list_needs_regeneration(True)
				autoitem = True

			for item in tagged_items:
				# XXX Once all infogetters have been fixed we do not need to check for <none>
				if len(item.name) == 0 or item.name == "<none>":
					break

				if hasattr(item, "kubernetes_roles"):
					if "control-plane" in item.kubernetes_roles:
						control_plane = True
					if "<unknown>" in item.kubernetes_roles:
						cluster_available = False
				if hasattr(item, "namespace"):
					items.append((item.namespace, item.name))
				else:
					items.append(item.name)

			if len(items) == 0:
				tagged_items.clear()
				uip.list_needs_regeneration(True)
				continue

			action_title = deep_get(views, DictPath(f"{view}#actions#title"), "Perform action on tagged items")
			tmp_action_src_list = deep_get(views, DictPath(f"{view}#actions#actionlist"), {})

			action_src_list = {
			}

			for action in tmp_action_src_list:
				# Override default actions by passing an empty action by the same name
				if action in action_src_list and tmp_action_src_list[action] == {}:
					action_src_list.pop(action)
				else:
					action_src_list[action] = tmp_action_src_list[action]

			# Populate the list of actions
			action_context = deep_get(views, DictPath(f"{view}#actions#actionlist#context"), None)
			actions, actionlist = populate_actionlist(context = action_context, action_list = action_src_list, control_plane_selected = control_plane, single_item = (len(items) == 1), cluster_available = cluster_available)

			# If there are playbook actions, add those too
			if len(deep_get(views, DictPath(f"{view}#actions#playbooklist"), {})) > 0:
				playbook_context = deep_get(views, DictPath(f"{view}#actions#playbooklist#context"), None)
				actions, actionlist = populate_playbooklist(context = playbook_context, actions = [], action_list = actionlist, control_plane_selected = control_plane, single_item = (len(items) == 1), cluster_available = cluster_available)

			if len(actions) == 0:
				if autoitem:
					tagged_items.clear()
					uip.list_needs_regeneration(True)
				continue

			tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, actions, title = action_title)
			selection = None
			if tmpselection is not None and tmpselection != "":
				selection = ""
				for i in range(0, len(tmpselection)):
					if len(tmpselection[i]) > 0:
						selection += str(tmpselection[i][0])
			uip.refresh_all()
			curses.doupdate()

			if selection is not None and selection != "":
				actionfunc = None

				# Map the description back to key
				for action in actionlist:
					description = deep_get(actionlist, DictPath(f"{action}#description"))
					tmpdescription = ""
					if isinstance(description, str):
						tmpdescription = description
					else:
						for i in range(0, len(description)):
							tmpdescription += description[i][0]
					tmpmetadata = deep_get(actionlist, DictPath(f"{action}#metadata"), [])
					for metadata in tmpmetadata:
						tmpdescription += metadata[0]
					if tmpdescription == selection:
						actiontype = deep_get(actionlist, DictPath(f"{action}#action"))
						if actiontype is not None:
							if actiontype == "execute":
								actionfunc = action_execute_command
						else:
							actionfunc = deep_get(actionlist, DictPath(f"{action}#actionfunc"), command_hosts)
							if isinstance(actionfunc, str):
								actionfunc = deep_get(actionfunc_allowlist, DictPath(actionfunc))
						action_args = deep_get(actionlist, DictPath(f"{action}#action_args"), {})
						# These are only relevant for node and inventory view
						allowoncontrolplane = deep_get(actionlist, DictPath(f"{action}#allow-on-control-plane"), True)
						singleoncontrolplane = deep_get(actionlist, DictPath(f"{action}#single-on-control-plane"), False)
						confirm = deep_get(actionlist, DictPath(f"{action}#confirm"), False)
						query = deep_get(actionlist, DictPath(f"{action}#query"))
						queryval = deep_get(actionlist, DictPath(f"{action}#queryval"))
						queryfunc = deep_get(actionlist, DictPath(f"{action}#queryfunc"))
						extravars = deep_get(actionlist, DictPath(f"{action}#extravars"), {})
						title = deep_get(actionlist, DictPath(f"{action}#title"))
						break

				if actionfunc is None:
					continue

				selection_vars = extravars

				# This should be modified; we might want to ask multiple queries.
				# At the very least asking for one input plus confirmation.
				# A multi input box might be useful too.
				if queryfunc is not None and queryval is not None and query is not None:
					if queryfunc == "string":
						# Not supported by inputbox widget
						# querydefault = ""
						string = curses_helper.inputbox(uip.stdscr, uip.maxy // 2, 1, uip.maxy - 1, uip.maxx - 1, f"{query}: ")
						if string is None or string == "":
							continue
						selection_vars[queryval] = string
					elif queryfunc == "confirm":
						querydefault = False
						if not curses_helper.confirmationbox(uip.stdscr, uip.maxy // 2, uip.maxx // 2, title = f"{query}?", default = querydefault):
							continue
					elif queryfunc == "filechooser":
						# It is a programming error if either of these two are not set, so it is OK to get an exception
						listgetter = extravars["listgetter"]
						basedir = extravars["basedir"]
						selected_file = None
						selected_ptype = None

						while basedir is not None:
							tmp_file_list = listgetter(basedir)
							file_list = []
							for item in tmp_file_list:
								realpath, filename, ptype = item
								if ptype in ("File", "Configuration File", "Kustomization"):
									fmt = ThemeAttr("windowwidget", "default")
								elif ptype == "<dir>":
									fmt = ThemeAttr("windowwidget", "highlight")
								else:
									raise ValueError(f"Unknown ptype {ptype}")
								file_list.append({
									"lineattrs": WidgetLineAttrs.NORMAL,
									"columns": [[ThemeString(f"{filename}", fmt)], [ThemeString(f"{ptype}", ThemeAttr("windowwidget", "description"))]],
									"retval": filename,
								})
							tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, file_list, title = query, cursor = True)
							if tmpselection is None or tmpselection == "":
								# This will break out of the loop
								basedir = None
								selected_file = None
								continue
							selected_entry = selection
							# Find entry in tmp_file_list
							for item in tmp_file_list:
								realpath, filename, ptype = item
								if filename == selected_entry:
									if ptype == "<dir>":
										basedir = realpath
										uip.refresh_all()
									elif ptype in ("File", "Configuration File", "Kustomization"):
										selected_file = realpath
										selected_ptype = ptype
										basedir = None
										break

						if selected_file is None:
							uip.force_update()
							continue
						selection_vars["resource_path"] = (selected_file, selected_ptype)

				if confirm:
					if not curses_helper.confirmationbox(uip.stdscr, uip.maxy // 2, uip.maxx // 2, title = f"Are you sure you want to perform “{description}“?", default = False):
						continue

				selection_vars["_tagged_items"] = list(tagged_items)
				selection_vars["action_args"] = action_args
				retval = actionfunc(uip, items, actionlist[action], values = selection_vars, kind = kind, title = title)
				if retval is not None and retval == Retval.RETURNFULL:
					return retval

				uip.force_update()
				tagged_items.clear()
				uip.list_needs_regeneration(True)
				continue
			tagged_items.clear()
			uip.list_needs_regeneration(True)

		shortcuts = deep_get(views, DictPath(f"{view}#shortcuts"), {})

		# Always include the shortcut for YAML dump, unless overridden
		if deep_get(views, DictPath(f"{view}#shortcuts#View YAML dump")) is None:
			shortcuts["View YAML dump of resource"] = {
				"shortcut": ord("y"),
				"read_only": True,
				"helptext": ("Y", "View YAML dump of resource"),
				"action": "call",
				"action_call": view_yaml,
				"action_args": {
					"title": "YAML dump",
					"_named_title": True,
					"_pass_obj": True,
				},
				"force_update": False,
				"force_refresh": True,
			}
		# Always include the shortcut for edit resource, unless overridden
		if deep_get(views, DictPath(f"{view}#shortcuts#Edit resource")) is None:
			shortcuts["Edit resource"] = {
				"shortcut": ord("e"),
				"read_only": False,
				"helptext": ("E", "Edit resource"),
				"action": "call",
				"action_call": edit_resource,
				"action_args": {
					"_pass_obj": True,
					"_pass_kind": True,
				},
				"force_update": False,
				"force_refresh": True,
			}

		for key, value in shortcuts.items():
			read_only = deep_get(value, DictPath("read_only"), False)
			if read_only_mode and not read_only:
				continue

			shortcut_keys = deep_get(value, DictPath("shortcut"))
			if shortcut_keys is None:
				continue

			if not isinstance(shortcut_keys, list):
				shortcut_keys = [shortcut_keys]

			if c not in shortcut_keys:
				continue

			query = deep_get(value, DictPath("query"))
			queryval = deep_get(value, DictPath("queryval"))
			queryfunc = deep_get(value, DictPath("queryfunc"))
			# Force update data
			force_update = deep_get(value, DictPath("force_update"), False)
			# Force update UI
			force_refresh = deep_get(value, DictPath("force_refresh"), False)

			selection_vars = None

			# This should be modified; we might want to ask multiple queries.
			# At the very least asking for one input plus confirmation.
			# A multi input box might be useful too.
			if queryfunc is not None and queryval is not None and query is not None:
				if queryfunc == "string":
					# Not supported by inputbox widget
					# querydefault = ""
					string = curses_helper.inputbox(uip.stdscr, uip.maxy // 2, 1, uip.maxy - 1, uip.maxx - 1, f"{query}: ")
					if string is None or string == "":
						continue
					selection_vars = { queryval: string }
				elif queryfunc == "confirm":
					querydefault = False
					if not curses_helper.confirmationbox(uip.stdscr, uip.maxy // 2, uip.maxx // 2, title = f"{query}?", default = querydefault):
						continue
			if deep_get(value, DictPath("confirm")):
				title = deep_get(value, DictPath("title"), "")

				uip.force_update()
				if not curses_helper.confirmationbox(uip.stdscr, uip.maxy // 2, uip.maxx // 2, title = title, default = False):
					continue

			selected = uip.get_selected()

			action = deep_get(value, DictPath("action"), None)
			if action is not None:
				action_args = deep_get(value, DictPath("action_args"), {})
				if "_pass_obj" in action_args and selected is not None:
					action_args["obj"] = selected.ref
				if "_pass_kind" in action_args:
					action_args["kind"] = kind
				if "_pass_selected" in action_args and selected is not None:
					action_args["selected"] = selected
				if "_pass_selection_vars" in action_args:
					action_args["selection_vars"] = selection_vars
				if "_parent_namespace_path" in action_args and selected is not None:
					parent_namespace_path = deep_get(action_args, DictPath("_parent_namespace_path"))
					action_args["_parent_namespace"] = deep_get(obj, parent_namespace_path, "")
				if "_named_title" in action_args:
					title = deep_get(action_args, DictPath("title"), "")
					title_name = ""
					if "_name_path" in action_args:
						title_name_path = deep_get(action_args, DictPath("_name_path"), "")
						title_name = deep_get(selected.ref, DictPath(title_name_path), "")
					elif selected is not None:
						title_name = getattr(selected, "name", "")
					if title_name != "":
						title_name = f" ({title_name})"
					action_args["named_title"] = f"{title}{title_name}"
				action_call = deep_get(value, DictPath("action_call"))
				if action == "toggle_var":
					var = deep_get(action_args, DictPath("var"))
					if var is not None:
						tmp = deep_get(listview_args, DictPath(var))
						deep_set(listview_args, DictPath(var), not tmp)
				elif action == "call" and action_call is not None:
					retval = action_call(uip.stdscr, **action_args)
					if retval is not None and retval == Retval.RETURNFULL:
						return retval
				elif action == "command" and action_args is not None:
					do_command(uip.stdscr, **action_args)
					changed = True

			if force_refresh:
				uip.force_refresh()

			if force_update:
				uip.force_update()

def __switch_resource_map(**kwargs):
	uip = deep_get(kwargs, DictPath("uip"))
	uip.refresh_all()
	return Retval.MATCH, {
		"selected_heatmap": deep_get(kwargs, DictPath("next_resource_map"))
	}

def __resource_map_cursor(**kwargs):
	uip = deep_get(kwargs, DictPath("uip"))
	keypress = deep_get(kwargs, DictPath("__keypress"))
	selected = deep_get(kwargs, DictPath("selected"))
	info = deep_get(kwargs, DictPath("info"))
	if info is None:
		return Retval.MATCH, {
			"selected": 0,
			"ypos": 0,
			"xpos": 0,
		}

	status_len = len(info)
	heatmap_width = deep_get(kwargs, DictPath("heatmap_width"))
	stride = deep_get(kwargs, DictPath("stride"), 1)

	maxval = status_len - 1
	oldval = selected

	if keypress == curses.KEY_LEFT:
		selected = clamp(oldval - 1, 0, maxval)
		uip.refresh_all()
	if keypress == curses.KEY_RIGHT:
		selected = clamp(oldval + 1, 0, maxval)
		uip.refresh_all()
	elif keypress == curses.KEY_UP:
		if (oldval - (heatmap_width + 1)) >= 0:
			selected = oldval - (heatmap_width + 1)
	elif keypress == curses.KEY_DOWN:
		if (oldval + heatmap_width + 1) <= maxval:
			selected = oldval + heatmap_width + 1
	elif keypress == curses.KEY_PPAGE:
		if (oldval - ((heatmap_width + 1) * stride)) >= 0:
			selected = oldval - (heatmap_width + 1) * stride
	elif keypress == curses.KEY_NPAGE:
		if (oldval + ((heatmap_width + 1) * stride)) <= maxval:
			selected = oldval + (heatmap_width + 1) * stride
	elif keypress == curses.KEY_HOME:
		selected = max((oldval // (heatmap_width + 1)) * (heatmap_width + 1), 0)
	elif keypress == curses.KEY_END:
		selected = min((oldval // (heatmap_width + 1)) * (heatmap_width + 1) + heatmap_width, maxval)
	elif keypress == curses.KEY_SHOME:
		selected = oldval - (oldval // (heatmap_width + 1)) * (heatmap_width + 1)
	elif keypress == curses.KEY_SEND:
		rowwidth = heatmap_width + 1
		if maxval > rowwidth:
			selected = (rowwidth * (maxval // rowwidth)) + (oldval % rowwidth)
			if selected > maxval:
				selected -= rowwidth
	elif keypress == ord("\t"):
		if oldval < maxval:
			for i in range(selected + 1, len(info)):
				if info[i].status_group != StatusGroup.OK:
					selected = i
					uip.force_update()
					break
	elif keypress == curses.KEY_BTAB:
		if oldval > 0:
			for i in range(1, selected):
				if info[selected - i].status_group != StatusGroup.OK:
					selected -= i
					uip.force_update()
					break

	xpos = selected % (heatmap_width + 1)
	ypos = selected // (heatmap_width + 1)
	return Retval.MATCH, {
		"selected": selected,
		"ypos": ypos,
		"xpos": xpos,
	}

def __open_reference(**kwargs):
	uip = deep_get(kwargs, DictPath("uip"))
	keypress = deep_get(kwargs, DictPath("__keypress"))
	pod_name = deep_get(kwargs, DictPath("pod_name"))
	namespace = deep_get(kwargs, DictPath("namespace"))
	node = deep_get(kwargs, DictPath("node"))

	if keypress == ord("d"):
		if node is None:
			return Retval.MATCH, {}
		name = node
		namespace = ""
		kind = ("Node", "")
	elif keypress == ord("N"):
		if namespace is None:
			return Retval.MATCH, {}
		name = namespace
		namespace = ""
		kind = ("Namespace", "")
	else:
		if pod_name is None:
			return Retval.MATCH, {}
		name = pod_name
		kind = ("Pod", "")

	ref = kh.get_ref_by_kind_name_namespace(kind, name, namespace)
	retval = resourceinfodispatch(uip.stdscr, ref, kind)
	if retval is not None and retval == Retval.RETURNFULL:
		return retval, {}
	uip.force_update()
	return Retval.MATCH, {}

def __fetch_package_versions(**kwargs):
	uip = deep_get(kwargs, DictPath("uip"))
	hostname = deep_get(kwargs, DictPath("hostname"))

	win = curses_helper.notice(uip.stdscr, uip.maxy // 2, uip.maxx // 2, message = "Fetching package versions...")
	_package_versions = get_package_versions(hostname)
	package_versions = []
	for package, version in _package_versions:
		if version == "N/A":
			fmt = ThemeAttr("windowwidget", "dim")
		else:
			fmt = ThemeAttr("windowwidget", "default")
		package_versions.append({
			"lineattrs": WidgetLineAttrs.NORMAL,
			"columns": [[ThemeString(f"{package}", ThemeAttr("windowwidget", "default"))], [ThemeString(f"{version}", fmt)]],
		})
	uip.refresh_window()
	uip.refresh_infopad()
	uip.refresh_listpad()
	uip.refresh_statusbar()
	curses.doupdate()
	if len(package_versions) == 0:
		return Retval.MATCH, {}
	title = "Package Versions:"
	headers = ["Package:", "Version:"]
	curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, package_versions, title = title, headers = headers, cursor = False)
	return Retval.MATCH, {}

clusteroverview_shortcuts = {
	"__common_shortcuts": [
		"Toggle mouse on/off",
		"Toggle borders",
		"Show this helptext",
		"Switch main view",
		"Switch main view (recheck available API resources)",
		"Show information about the program",
	],
	"Open info page for Node": {
		"helptext": ("D", "Open info page for Node"),
		"shortcut": ord("d"),
		"helpgroup": 2,
		"action": "key_callback",
		"action_call": __open_reference,
	},
	"Open info page for Namespace [Pod context only]": {
		"helptext": ("[Shift] + N", "Open info page for Namespace [Pod context only]"),
		"shortcut": ord("N"),
		"helpgroup": 2,
		"action": "key_callback",
		"action_call": __open_reference,
	},
	"Open info page for Pod [Pod context only]": {
		"helptext": ("[Shift] + P", "Open info page for Pod [Pod context only]"),
		"shortcut": ord("P"),
		"helpgroup": 2,
		"action": "key_callback",
		"action_call": __open_reference,
	},
	"Show package versions": {
		"helptext": ("[Shift] + V", "Show package versions"),
		"shortcut": ord("V"),
		"helpgroup": 2,
		"action": "key_callback",
		"action_call": __fetch_package_versions,
	},
	"Move cursor up / down / left / right within resource map": {
		"helptext": ("[Cursor keys]", "Move cursor up / down / left / right within resource map"),
		"shortcut": [curses.KEY_LEFT, curses.KEY_RIGHT, curses.KEY_UP, curses.KEY_DOWN],
		"helpgroup": 3,
		"action": "key_callback",
		"action_call": __resource_map_cursor,
	},
	"Move cursor 10 rows up / down within resource map": {
		"helptext": ("[Page Up]", "Move cursor 10 rows up / down within resource map"),
		"shortcut": [curses.KEY_PPAGE, curses.KEY_NPAGE],
		"helpgroup": 3,
		"action": "key_callback",
		"action_call": __resource_map_cursor,
		"action_args": {
			"stride": 10,
		}
	},
	"Switch to previous resource map": {
		"shortcut": curses.KEY_SLEFT,
		"helptext": ("[Shift] + [Left]", "Switch to previous resource map"),
		"helpgroup": 3,
		"action": "key_callback",
		"action_call": __switch_resource_map,
		"action_args": {
			"next_resource_map": "Node",
		}
	},
	"Switch to next resource map": {
		"helptext": ("[Shift] + [Right]", "Switch to next resource map"),
		"shortcut": curses.KEY_SRIGHT,
		"helpgroup": 3,
		"action": "key_callback",
		"action_call": __switch_resource_map,
		"action_args": {
			"next_resource_map": "Pod",
		}
	},
	"Jump to first column of resource map": {
		"helptext": ("[Home]", "Jump to first column of resource map"),
		"shortcut": curses.KEY_HOME,
		"helpgroup": 3,
		"action": "key_callback",
		"action_call": __resource_map_cursor,
	},
	"Jump to last column of resource map": {
		"helptext": ("[End]", "Jump to last column of resource map"),
		"shortcut": curses.KEY_END,
		"helpgroup": 3,
		"action": "key_callback",
		"action_call": __resource_map_cursor,
	},
	"Jump to next elevated severity in resource map": {
		"helptext": ("[Tab]", "Jump to next elevated severity in resource map"),
		"shortcut": ord("\t"),
		"helpgroup": 3,
		"action": "key_callback",
		"action_call": __resource_map_cursor,
	},
	"Jump to first row of resource map": {
		"helptext": ("[Shift] + [Home]", "Jump to first row of resource map"),
		"shortcut": curses.KEY_SHOME,
		"helpgroup": 3,
		"action": "key_callback",
		"action_call": __resource_map_cursor,
	},
	"Jump to last row of resource map": {
		"helptext": ("[Shift] + [End]", "Jump to last row of resource map"),
		"shortcut": curses.KEY_SEND,
		"helpgroup": 3,
		"action": "key_callback",
		"action_call": __resource_map_cursor,
	},
	"Jump to previous elevated severity in resource map": {
		"helptext": ("[Shift] + [Tab]", "Jump to previous elevated severity in resource map"),
		"shortcut": curses.KEY_BTAB,
		"helpgroup": 3,
		"action": "key_callback",
		"action_call": __resource_map_cursor,
	},
}

def read_file_async(*args, **kwargs) -> Tuple[List[Any], List[StatusGroup]]:
	path = deep_get(kwargs, DictPath("path"))
	filetype = deep_get(kwargs, DictPath("filetype"), "string")
	if filetype == "string":
		result = secure_read_string(path, directory_is_symlink = True)
	elif filetype == "yaml":
		result = secure_read_yaml(path, directory_is_symlink = True)
	status = StatusGroup.OK
	return result, status

def run_ansible_play_async(*args, **kwargs) -> Tuple[List[Any], List[StatusGroup]]:
	playbook = deep_get(kwargs, DictPath("playbook"))
	selection = deep_get(kwargs, DictPath("selection"))
	status, result = ansible_run_playbook_on_selection(playbook = playbook, selection = selection, verbose = False)
	return result, status

def get_kubernetes_list_async(*args, **kwargs) -> Tuple[List[Any], Union[int, List[StatusGroup]]]:
	kind = deep_get(kwargs, DictPath("kind"))
	namespace = deep_get(kwargs, DictPath("namespace"), "")
	label_selector = deep_get(kwargs, DictPath("label_selector"), "")
	field_selector = deep_get(kwargs, DictPath("field_selector"), "")
	fetch_args = deep_get(kwargs, DictPath("fetch_args"), {})
	sort_key = deep_get(fetch_args, DictPath("sort_key"), "")
	sort_reverse = deep_get(fetch_args, DictPath("sort_reverse"), False)
	postprocess = deep_get(fetch_args, DictPath("postprocess"), "")
	limit = deep_get(fetch_args, DictPath("limit"))
	extra_data = []

	vlist, status = kh.get_list_by_kind_namespace(kind, namespace, label_selector = label_selector, field_selector = field_selector)
	if len(sort_key) > 0:
		vlist = natsorted(vlist, key = lambda x: deep_get(x, DictPath(sort_key), ""), reverse = sort_reverse)
	if postprocess == "node":
		vlist = get_node_info(vlist, extra_vars = {})
		extra_data = [s.status_group for s in vlist]
	elif postprocess == "pod":
		vlist = get_pod_info(**{"_vlist": vlist, "in_depth_node_status": False})
		extra_data = [s.status_group for s in vlist]
	else:
		extra_data = status
	if limit is not None:
		vlist = vlist[:limit]
	return vlist, extra_data

def clusteroverviewloop(stdscr: curses.window, view):
	global executor

	# Just in case there are leftover futures from other views
	executor.shutdown()
	executor = reexecutor.ReExecutor()

	field_list, sortcolumn = (None, None)
	uip = UIProps(stdscr)

	windowheader = view
	activatedfun = views[view]["activatedfun"]
	on_activation = deep_get(views[view], DictPath("on_activation"), {})
	update_delay = views[view].get("update_delay", -1)

	sortorder_reverse = views[view].get("sortorder_reverse", False)

	uip.init_window(field_list, windowheader = windowheader, update_delay = update_delay, sortcolumn = sortcolumn, sortorder_reverse = sortorder_reverse, activatedfun = activatedfun, on_activation = on_activation)

	infopadheight = 11
	eventpadheight = 7

	# For generic information
	infopad = uip.init_infopad(height = infopadheight, width = -1, ypos = 1, xpos = 1)

	# For the status panes
	headerpad, listpad = uip.init_listpad(listheight = 1, width = -1, ypos = infopadheight + eventpadheight + 2, xpos = 1, header = False)

	# For the status bar; position is always at the bottom of the screen and the entire width of the screen
	statusbar = uip.init_statusbar()

	selected_heatmap = "Node"
	selected_node = 0
	selected_pod = 0

	# Get control plane node
	control_plane_node, control_plane_name = get_control_plane()
	control_plane_addresses = deep_get(control_plane_node, DictPath("status#addresses"), [])
	name, iips, eips = get_node_addresses(control_plane_name, control_plane_addresses)

	hostname = socket.gethostname()
	islocal = (hostname == name)

	stat_regex = re.compile(r"^[A-Za-z]+ +(\d+) +(\d+) +(\d+) +(\d+) (\d+) +(\d+) +(\d+) +(\d+) +(\d+) (\d+)$")

	loadavg_raw = []
	meminfo_raw = []
	stat_raw = []

	podinfo = []
	nodeinfo = []

	pod_curypos = 0
	pod_curxpos = 0
	node_curypos = 0
	node_curxpos = 0

	cpuutimeusernice = 0
	cputimeuser = 0
	cputimeusernice = 0
	cputimetotalsystem = 0
	cputimetotalguest = 0
	cputimetotal = 1
	cputimetotalused = 0
	memused = 0
	memcached = 0
	buffers = 0
	memtotal = 1
	swapused = 0
	running = 0
	tasks = 0
	loadavg_raw = []
	meminfo_raw = []
	stat_raw = []

	swaptotal = 0

	node_vlist = []
	pod_vlist = []
	event_vlist = []
	node_statuses = []
	node_heatmap = []
	nodeinfo = []
	pod_statuses = []
	podinfo = []
	pod_heatmap = []
	events = []

	if not islocal:
		executor.trigger("sysinfo", 5, run_ansible_play_async, playbook = FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("load_ping.yaml"))), selection = [control_plane_name])
	executor.trigger("node", 5, get_kubernetes_list_async, kind = ("Node", ""), namespace = "", fetch_args = { "sort_key": "metadata#name", "postprocess": "node" })
	executor.trigger("pod", 5, get_kubernetes_list_async, kind = ("Pod", ""), namespace = "", fetch_args = { "postprocess": "pod" })
	executor.trigger("event", 5, get_kubernetes_list_async, kind = ("Event", ""), namespace = "", fetch_args = { "sort_key": "lastTimestamp", "sort_reverse": True, "limit": 5 })

	while True:
		if (result := executor.get("sysinfo")) != ([], []):
			ansible_results, ansible_status = result
			if ansible_status == 0:
				for ansible_result in deep_get(ansible_results, DictPath(control_plane_name), []):
					task = deep_get(ansible_result, DictPath("task"), "")
					if task == "Fetching /proc/loadavg":
						loadavg_raw = deep_get(ansible_result, DictPath("stdout_lines"), [])
					elif task == "Fetching /proc/meminfo":
						meminfo_raw = deep_get(ansible_result, DictPath("stdout_lines"), [])
					elif task == "Fetching /proc/stat":
						stat_raw = deep_get(ansible_result, DictPath("stdout_lines"), [])
					uip.force_update()
		if (result := executor.get("node")) != ([], []):
			nodeinfo, node_statuses = result
		if (result := executor.get("pod")) != ([], []):
			podinfo, pod_statuses = result
		if (result := executor.get("event")) != ([], []):
			events, _status = result

		if uip.is_update_triggered():
			# The data in some fields might become shorter, so we need to trigger a clear
			uip.infopad.erase()
			uip.statusbar.erase()

			uip.update_window()

			if islocal:
				tmp = secure_read_string(FilePath("/proc/loadavg"))
				loadavg_raw = tmp.splitlines()
				tmp = secure_read_string(FilePath("/proc/meminfo"))
				meminfo_raw = tmp.splitlines()
				tmp = secure_read_string(FilePath("/proc/stat"))
				stat_raw = tmp.splitlines()

			if len(loadavg_raw) > 0:
				try:
					avg1min, avg5min, avg15min, tasks_running, _latest_pid = loadavg_raw[0].split()
					running, tasks = tasks_running.split("/")
				except ValueError:
					loadavg_raw = []

			if len(meminfo_raw) > 0:
				try:
					for tmp in meminfo_raw:
						values = tmp.split()
						if values[0] == "MemTotal:":
							memtotal = int(values[1])
						elif values[0] == "MemFree:":
							memfree = int(values[1])
						elif values[0] == "MemShared:":
							memshared = int(values[1])
						elif values[0] == "Buffers:":
							buffers = int(values[1])
						elif values[0] == "Cached:":
							memcached = int(values[1])
						elif values[0] == "SwapTotal:":
							swaptotal = int(values[1])
						elif values[0] == "SwapFree:":
							swapfree = int(values[1])
						elif values[0] == "Shmem:":
							memshared = int(values[1])
						elif values[0] == "SReclaimable:":
							sreclaimable = int(values[1])
				except (IndexError, ValueError):
					meminfo_raw = []

				# Total used mem; includes buffers and cache
				memused = memtotal - memfree
				memcached = memcached + sreclaimable - memshared
				swapused = swaptotal - swapfree
				# FIXME
				threads = 42

			# cpu  30175835 25947 13018006 435764225 200633 0   3229829 0     0     0
			# ...  normal   niced system   idle      iowait irq softirq steal guest guest_nice
			#      1        2     3        4         5      6   7       8     9     10
			if len(stat_raw) > 0:
				tmp = stat_regex.match(stat_raw[0])
				if tmp is not None:
					cputimeuser = int(tmp[1])
					cputimeusernice = int(tmp[2])
					cputimesystem = int(tmp[3])
					cputimeidle = int(tmp[4])
					cputimeiowait = int(tmp[5])
					cputimeirq = int(tmp[6])
					cputimesoftirq = int(tmp[7])
					cputimesteal = int(tmp[8])
					cputimeguest = int(tmp[9])
					cputimeguestnice = int(tmp[10])
					cputimeuser = cputimeuser - cputimeguest
					cputimeusernice = cputimeusernice - cputimeguestnice
					cputimetotalidle = cputimeidle + cputimeiowait
					cputimetotalsystem = cputimesystem + cputimeirq + cputimesoftirq
					cputimetotalguest = cputimeguest + cputimeguestnice
					cputimetotal = cputimeuser + cputimeusernice + cputimetotalsystem + cputimetotalidle + cputimesteal + cputimetotalguest
					cputimetotalused = cputimeuser + cputimeusernice + cputimetotalsystem + cputimesteal + cputimetotalguest
				else:
					stat_raw = []

			# We most likely have far more nodes than pods, so give the nodes 20% of the width and the pods 80% of the width;
			# even this is probably too much for the nodes, but we can adjust that later
			node_heatmap_width = ((uip.maxx - uip.minx - 1) // 5) - 2
			pod_heatmap_width = ((uip.maxx - uip.minx - 1) * 4 // 5) - 1

		k8s_distro = identify_k8s_distro()

		if k8s_distro is not None:
			k8s_distro_string = ThemeString(f"{k8s_distro}", ThemeAttr("types", "generic"))
		else:
			k8s_distro_string = ThemeString("<unknown>", ThemeAttr("types", "unset"))

		internal_ips_array = generators.format_list(iips, 0, 0, False, False)
		external_ips_array = generators.format_list(eips, 0, 0, False, False)

		infoarrays: List[List[Union[ThemeRef, ThemeString]]] = [
			[
				ThemeString("Control Plane: ", ThemeAttr("main", "infoheader")),
				ThemeString(f"{name}", ThemeAttr("types", "generic"))
			], [
				ThemeString("Cluster Name: ", ThemeAttr("main", "infoheader")),
				ThemeString(f"{kh.cluster_name}", ThemeAttr("types", "generic"))
			], [
				ThemeString("Cluster Context: ", ThemeAttr("main", "infoheader")),
				ThemeString(f"{kh.context_name}", ThemeAttr("types", "generic"))
			], [
				ThemeString("Kubernetes Distro: ", ThemeAttr("main", "infoheader")),
				k8s_distro_string,
			], [
				ThemeString("Internal IP-address(es): ", ThemeAttr("main", "infoheader")),
			] + internal_ips_array, [
				ThemeString("External IP-address(es): ", ThemeAttr("main", "infoheader")),
			] + external_ips_array, [
			# Kubernetes port
			# KubeDNS
			# control plane load, disk, mem, uptime (requires ansible or local)
			], [
			]
		]

		y = 0
		for i, row in enumerate(infoarrays):
			uip.addthemearray(infopad, row, y = y + i, x = 0)
		y += i

		# cpu usage:
		# low-priority (bold blue) / normal (green) / kernel (red) / virtualized (cyan)
		# This is aggregate over all CPUs
		percentagebar_cpu: List[Union[ThemeRef, ThemeString]] = curses_helper.percentagebar(8, 7, uip.infopadwidth - 10, cputimetotal, [
			(cputimeusernice, ThemeRef("strings", "cputime_user_nice")),
			(cputimeuser, ThemeRef("strings", "cputime_user")),
			(cputimetotalsystem, ThemeRef("strings", "cputime_total_system")),
			(cputimetotalguest, ThemeRef("strings", "cputime_total_guest"))
		])

		# memory usage:
		# used (green) / buffers (bold blue) / cache (yellow)
		percentagebar_mem: List[Union[ThemeRef, ThemeString]] = curses_helper.percentagebar(9, 7, uip.infopadwidth - 10, memtotal, [
			(memused - memcached - buffers, ThemeRef("strings", "mem")),
			(buffers, ThemeRef("strings", "buffers")),
			(memcached, ThemeRef("strings", "cached"))
		])

		# swap usage:
		# used (red)
		if swaptotal > 0:
			percentagebar_or_string_swap: List[Union[ThemeRef, ThemeString]] = curses_helper.percentagebar(9, 6, uip.infopadwidth - 10, swaptotal, [
				(swapused, ThemeRef("strings", "swap_used"))
			])
			percentagebar_or_string_swap += [
				ThemeString(f"{100 * swapused // swaptotal}", ThemeAttr("main", "dim")),
				ThemeRef("separators", "percentage"),
			]
		else:
			percentagebar_or_string_swap = [ThemeString("Disabled", ThemeAttr("types", "none"))]

		tasksarrays: List[List[Union[ThemeRef, ThemeString]]] = [
			[
				ThemeString("Tasks: ", ThemeAttr("main", "infoheader")),
				ThemeString(f"{running}", ThemeAttr("types", "numerical")),
				ThemeRef("separators", "fraction"),
				ThemeString(f"{tasks} ", ThemeAttr("types", "numerical")),
				ThemeString("running", ThemeAttr("types", "generic")),
			], [
				ThemeString("  CPU: ", ThemeAttr("main", "infoheader")),
				ThemeString("[", ThemeAttr("types", "generic"))
			] + percentagebar_cpu + [
				ThemeString("]", ThemeAttr("types", "generic")),
				ThemeString(f"{str(100 * cputimetotalused // cputimetotal).rjust(3)}", ThemeAttr("types", "numerical")),
				ThemeRef("separators", "percentage"),
			], [
				ThemeString("  Mem: ", ThemeAttr("main", "infoheader")),
				ThemeString("[", ThemeAttr("types", "generic"))
			] + percentagebar_mem + [
				ThemeString("]", ThemeAttr("types", "generic")),
				ThemeString(str(100 * memused // memtotal).rjust(3), ThemeAttr("types", "numerical")),
				ThemeRef("separators", "percentage"),
			], [
				ThemeString(" Swap: ", ThemeAttr("main", "infoheader")),
			] + percentagebar_or_string_swap,
		]

		if len(loadavg_raw) > 0 and len(meminfo_raw) > 0 and len(stat_raw) > 0:
			for i, row in enumerate(tasksarrays):
				uip.addthemearray(infopad, row, y = y + i, x = 0)
			y += i + 1
		else:
			y += len(tasksarrays)

		# Namespace, Name, Last Seen, Type, Reason, Message
		evheaders = [
			"Namespace:",
			"Name:",
			"Last Seen:",
			"Type:",
			"Reason:",
			"Message:",
		]

		# path(s), type
		evfields = [
			([DictPath("metadata#namespace")], "namespace"),
			([DictPath("metadata#name")], "str"),
			([DictPath("series#lastObservedTime"),
			  DictPath("deprecatedLastTimestamp"),
			  DictPath("lastTimestamp"),
			  DictPath("eventTime"),
			  DictPath("deprecatedFirstTimestamp"),
			  DictPath("firstTimestamp")],
			 "timestamp"),
			([DictPath("type")], "event_type"),
			([DictPath("reason")], "str"),
			([DictPath("message"), DictPath("note")], "str"),
		]

		evlens = [len(header) for header in evheaders]

		for event in events:
			for i, evfield in enumerate(evfields):
				paths, ptype = evfield
				val = deep_get_with_fallback(event, paths, "")
				if ptype == "timestamp":
					timestamp = timestamp_to_datetime(cast(str, val))
					formatted_timestamp = format_timestamp(timestamp)
					evlens[i] = max(evlens[i], themearray_len(formatted_timestamp))
				else:
					evlens[i] = max(evlens[i], len(val))

		# Draw the events over the bottom of the visible area of the listpad
		eventarrays: List[Union[ThemeRef, ThemeString]] = [
			[ThemeString("Events:", ThemeAttr("main", "listheader_compact"))],
		]

		tmp = []
		for i, header in enumerate(evheaders):
			tmp.append(ThemeString(header.ljust(evlens[i]), ThemeAttr("main", "listheader")))
			if i < len(evheaders):
				tmp.append(ThemeString("  ", ThemeAttr("main", "listheader")))
		eventarrays.append(tmp)

		for evindex in range(0, 5):
			tmp = []

			if evindex < len(events):
				event = events[evindex]
				for i, evfield in enumerate(evfields):
					paths, ptype = evfield
					val = deep_get_with_fallback(event, paths, "")
					if ptype == "timestamp":
						timestamp = timestamp_to_datetime(cast(str, val))
						formatted_timestamp = format_timestamp(timestamp)
						tmp += formatted_timestamp
						if evlens[i] - themearray_len(formatted_timestamp) > 0:
							tmp.append(ThemeString("".ljust(evlens[i] - themearray_len(formatted_timestamp)), ThemeAttr("main", "default")))
					elif ptype == "namespace":
						tmp.append(ThemeString(val.ljust(evlens[i]), ThemeAttr("types", "namespace")))
					elif ptype == "event_type":
						if val == "Error":
							event_type = "status_not_ok"
						elif val == "Warning":
							event_type = "status_admin"
						else:
							event_type = "status_ok"
						tmp.append(ThemeString(val.ljust(evlens[i]), ThemeAttr("main", event_type)))
					else:
						tmp.append(ThemeString(val.ljust(evlens[i]), ThemeAttr("main", "default")))

					if i < len(evheaders):
						tmp.append(ThemeString("  ", ThemeAttr("main", "default")))
			else:
				tmp.append(ThemeString("<none>", ThemeAttr("types", "none")))
			eventarrays.append(tmp)

		y += 1
		curses_helper.window_tee_hline(uip.stdscr, y = y, start = 0, end = uip.maxx)

		for i, row in enumerate(eventarrays):
			uip.addthemearray(uip.stdscr, row, y = y + i, x = 1)
		y += i + 1
		curses_helper.window_tee_hline(uip.stdscr, y = y, start = 0, end = uip.maxx)

		selected_pod = min(selected_pod, len(podinfo))
		selected_node = min(selected_node, len(nodeinfo))

		if len(nodeinfo) > 0 and len(podinfo) > 0:
			node_heatmap_xpos = 0
			pod_heatmap_xpos = uip.maxx - pod_heatmap_width - 2

			selectednodetaints = generators.format_list(nodeinfo[selected_node].taints, node_heatmap_width, 0, False, False, field_colors = [ThemeAttr("types", "key"), ThemeAttr("types", "value")], field_separators = [ThemeRef("separators", "keyvalue_taint")])

			nodearrays: List[List[Union[ThemeRef, ThemeString]]] = [
				[
					ThemeString(f"Node ({selected_node + 1}/{len(nodeinfo)}):", ThemeAttr("main", "listheader"), selected = selected_heatmap == "Node"),
					ThemeString("".ljust(node_heatmap_width), ThemeAttr("types", "generic")),
				], [
					ThemeString(" ", ThemeAttr("main", "listheader")),
					ThemeString("No", ThemeAttr("main", "listheader")),
					ThemeString("d", ThemeAttr("main", "listheader"), selected = selected_heatmap == "Node"),
					ThemeString("e: ", ThemeAttr("main", "listheader")),
					ThemeString(f"{nodeinfo[selected_node].name}".ljust(node_heatmap_width), ThemeAttr("main", "highlight")),
				], [
					ThemeString(" ", ThemeAttr("main", "listheader")),
					ThemeString("Status: ", ThemeAttr("main", "infoheader")),
					ThemeString(f"{nodeinfo[selected_node].status}".ljust(node_heatmap_width), color_status_group(nodeinfo[selected_node].status_group)),
				], [
					ThemeString(" ", ThemeAttr("main", "listheader")),
					ThemeString("Taints: ", ThemeAttr("main", "infoheader")),
				] + selectednodetaints, [
					# Empty line
				], [
					# Empty line
				],
			]

			node_heatmap = curses_helper.generate_heatmap(node_heatmap_width, node_statuses, selected_node)
			nodearrays += node_heatmap

			podarrays: List[List[Union[ThemeRef, ThemeString]]] = [
				[
					ThemeString(f"Pod ({selected_pod + 1}/{len(podinfo)}):", ThemeAttr("main", "listheader"), selected = selected_heatmap == "Pod"),
					ThemeString("".ljust(pod_heatmap_width), ThemeAttr("types", "generic")),
				], [
					ThemeString(" ", ThemeAttr("main", "listheader")),
					ThemeString("P", ThemeAttr("main", "listheader"), selected = selected_heatmap == "Pod"),
					ThemeString("od: ", ThemeAttr("main", "listheader")),
					ThemeString(f"{podinfo[selected_pod].name}".ljust(pod_heatmap_width), ThemeAttr("main", "highlight")),
				], [
					ThemeString(" ", ThemeAttr("main", "listheader")),
					ThemeString("N", ThemeAttr("main", "listheader"), selected = selected_heatmap == "Pod"),
					ThemeString("amespace: ", ThemeAttr("main", "listheader")),
					ThemeString(f"{podinfo[selected_pod].namespace}".ljust(pod_heatmap_width), ThemeAttr("main", "highlight")),
				], [
					ThemeString(" ", ThemeAttr("main", "listheader")),
					ThemeString("No", ThemeAttr("main", "infoheader")),
					ThemeString("d", ThemeAttr("main", "listheader"), selected = selected_heatmap == "Pod"),
					ThemeString("e: ", ThemeAttr("main", "infoheader")),
					ThemeString(f"{podinfo[selected_pod].node}".ljust(pod_heatmap_width), ThemeAttr("main", "highlight")),
				], [
					ThemeString(" ", ThemeAttr("main", "listheader")),
					ThemeString("Status: ", ThemeAttr("main", "infoheader")),
					ThemeString(f"{podinfo[selected_pod].status}".ljust(pod_heatmap_width), color_status_group(podinfo[selected_pod].status_group)),
				], [
					# Empty line
				]
			]

			pod_heatmap = curses_helper.generate_heatmap(pod_heatmap_width, pod_statuses, selected_pod)
			podarrays += pod_heatmap

			# Resize the list pad
			uip.resize_listpad(max(len(node_heatmap), len(pod_heatmap)))

			for y, row in enumerate(nodearrays):
				uip.addthemearray(listpad, row, y = y, x = node_heatmap_xpos)

			for y, row in enumerate(podarrays):
				uip.addthemearray(listpad, row, y = y, x = pod_heatmap_xpos)

		if selected_heatmap == "Pod":
			uip.maxcurypos = len(pod_heatmap) - 1
			uip.curypos = pod_curypos
			uip.maxyoffset = 0
			uip.yoffset = 0
		elif selected_heatmap == "Node":
			uip.maxcurypos = len(node_heatmap) - 1
			uip.curypos = node_curypos
			uip.maxyoffset = 0
			uip.yoffset = 0

		uip.refresh_window()
		uip.refresh_infopad()
		uip.refresh_listpad()
		uip.refresh_statusbar()
		curses.doupdate()

		if len(podinfo) > 0 and selected_heatmap == "Pod":
			__node_name = podinfo[selected_pod].node
			__pod_name = podinfo[selected_pod].name
			__namespace = podinfo[selected_pod].namespace
			__info = podinfo
			__selected = selected_pod
			heatmap_width = pod_heatmap_width
		elif len(nodeinfo) > 0:
			__node_name = nodeinfo[selected_node].name
			__namespace = None
			__pod_name = None
			__info = copy.deepcopy(nodeinfo)
			__selected = selected_node
			heatmap_width = node_heatmap_width
		else:
			__node_name = None
			__namespace = None
			__pod_name = None
			__info = None
			__selected = None
			heatmap_width = 0

		# These are arguments that *might* be needed by the callbacks
		input_args = {
			"uip": uip,
			"selectwindow": selectwindow,
			"read_only": read_only_mode,
			"hostname": control_plane_name,
			"node": __node_name,
			"pod_name": __pod_name,
			"namespace": __namespace,
			"selected_heatmap": selected_heatmap,
			"info": __info,
			"selected": __selected,
			"heatmap_width": heatmap_width,
		}

		retval, return_args = uip.generic_inputhandler(clusteroverview_shortcuts, **input_args)

		if "selected" in return_args:
			if selected_heatmap == "Pod":
				selected_pod = deep_get(return_args, DictPath("selected"))
				pod_curypos = deep_get(return_args, DictPath("ypos"), pod_curypos)
			else:
				selected_node = deep_get(return_args, DictPath("selected"))
				node_curypos = deep_get(return_args, DictPath("ypos"), node_curypos)
		if "selected_heatmap" in return_args:
			selected_heatmap = deep_get(return_args, DictPath("selected_heatmap"))

		if retval == Retval.MATCH:
			continue
		if retval == Retval.RETURNONE:
			return Retval.RETURNDONE
		if retval == Retval.RETURNFULL:
			return retval

# These are based on attributes of the name of the cmdata
cmdata_format = [
	# cm namespace, cm name prefix, cmdata prefix, cmdata suffix, dataformat
	# To do an exact match on cmdata set both cmdata prefix and cmdata suffix to the same string
	# (this will work unless you have a string that contains the same substring twice)
	("", "", "caBundle", "caBundle", "CRT"),
	("", "image-registry-certificates", "", "", "CRT"),
	("", "", "", ".crt", "CRT"),
	("", "", "", ".pem", "CRT"),
	("", "", "", "client-ca-file", "CRT"),
	("", "", "haproxy.cfg", "haproxy.cfg", "HAProxy"),
	("", "", "", ".ini", "INI"),
	("", "", "", ".ndjson", "NDJSON"),
	("", "", "", ".json", "JSON"),
	("", "", "mosquitto.conf", "mosquitto.conf", "mosquitto"),
	("", "", "", ".sh", "Shell Script"),
	("", "", "", ".toml", "TOML"),
	("", "", "", ".xml", "XML"),
	("", "", "", ".yaml", "YAML"),
	("", "", "", ".yml", "YAML"),
	("calico-system", "cni-config", "", "", "JSON"),
	("", "canal-config", "cni_network_config", "", "JSON"),
	("", "", "fluentbit.conf", "", "FluentBit"),
	("", "intel-iaa-config", "iaa.conf", "iaa.conf", "JSON"),
	("istio-system", "istio", "", "", "YAML"),
	("", "k10-k10-metering-config", "", "", "YAML"),
	("", "kubeapps-clusters-config", "clusters.conf", "", "JSON"),
	("", "kubeapps-internal-kubeappsapis-configmap", "plugins.conf", "", "JSON"),
	("kube-public", "cluster-info", "kubeconfig", "", "YAML"),
	("kube-public", "cluster-info", "jws-", "", "JWS"),
	("kube-system", "antrea", "antrea-agent", "", "YAML"),
	("kube-system", "antrea", "antrea-controller", "", "YAML"),
	("kube-system", "antrea", "antrea-cni", "", "JSON"),
	("kube-system", "cluster-config", "install-config", "", "YAML"),
	("kube-system", "", "cni_network_config", "", "JSON"),
	("", "coredns", "Corefile", "", "CaddyFile"),
	("kube-system", "rke2-coredns", "Corefile", "", "CaddyFile"),
	("kube-system", "rke2-coredns", "linear", "", "YAML"),
	("kube-system", "rke2-etcd-snapshots", "", "", "JSON"),
	("kube-system", "kubeadm-config", "", "", "YAML"),
	("kube-system", "kubeconfig-in-cluster", "kubeconfig", "", "YAML"),
	("kube-system", "kubelet-config", "", "", "YAML"),
	("kube-system", "kube-proxy", "", "config.conf", "YAML"),
	("kube-system", "scheduler-extender-policy", "policy.cfg", "", "JSON"),
	("", "", "nginx.conf", "nginx.conf", "NGINX"),
	("", "kubeshark-nginx", "default.conf", "default.conf", "NGINX"),
	("", "kubeapps", "vhost.conf", "vhost.conf", "NGINX"),
	("", "kubeapps", "k8s-api-proxy.conf", "k8s-api-proxy.conf", "NGINX"),
	("", "linkerd-config", "values", "", "YAML"),
	("", "nfd-worker-conf", "nfd-worker.conf", "", "YAML"),
	("", "trivy-operator", "nodeCollector.volumeMounts", "", "JSON"),
	("", "trivy-operator", "nodeCollector.volumes", "", "JSON"),
	("", "trivy-operator", "scanJob.podTemplateContainerSecurityContext", "", "JSON"),
	("", "", "", ".py", "Python"),
	# Openshift
	("", "dns-default", "Corefile", "", "CaddyFile"),
	("", "v4-0-config-system-cliconfig", "v4-0-config-system-cliconfig", "", "JSON"),
	("openshift-authentication", "v4-0-config-system-metadata", "oauthMetadata", "", "JSON"),
	("openshift-config-managed", "oauth-openshift", "oauthMetadata", "", "JSON"),
	("openshift-kube-apiserver", "check-endpoints-kubeconfig", "kubeconfig", "", "YAML"),
	("openshift-kube-apiserver", "config", "kubeconfig", "", "JSON"),
	("openshift-kube-apiserver", "control-plane-node-kubeconfig", "kubeconfig", "", "YAML"),
	("openshift-kube-apiserver", "kube-apiserver-cert-syncer-kubeconfig", "kubeconfig", "", "YAML"),
	("openshift-kube-apiserver", "oauth-metadata", "oauthMetadata", "", "JSON"),
	("openshift-kube-controller-manager", "controller-manager-kubeconfig", "kubeconfig", "", "JSON"),
	("openshift-kube-controller-manager", "kube-controller-cert-syncer-kubeconfig", "kubeconfig", "", "JSON"),
	("openshift-kube-scheduler", "kube-scheduler-cert-syncer-kubeconfig", "kubeconfig", "", "JSON"),
	("openshift-kube-scheduler", "scheduler-kubeconfig", "kubeconfig", "", "JSON"),
	("openshift-machine-config-operator", "coreos-bootimages", "stream", "", "JSON"),
	("openshift-operator", "applied-cluster", "applied", "", "JSON"),
	# Keep last; match everything that does not match anything
	("", "", "", "", "Text"),
]

# These are based on the data itself
cmdata_header = [
	("<?xml ", "XML"),
	("/bin/sh", "Shell Script"),
	("/usr/bin/env bash", "BASH"),
	("/usr/bin/env perl", "Perl"),
	("/usr/bin/env python", "Python"),
	("/bin/bash", "BASH"),
	("/bin/dash", "Shell Script"),
	("/bin/zsh", "ZSH"),
	("python", "Python"),
	("perl", "Perl"),
	("perl", "Ruby"),
	("-----BEGIN CERTIFICATE-----", "CRT"),
]

# Binary file headers
cmdata_bin_header = [
	(0, [0x1f, 0x8b], "gz / tar+gz"),
	(0, [0x1f, 0x9d], "lzw / tar+lzw"),
	(0, [0x1f, 0xa0], "lzh / tar+lzh"),
	(0, [0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x0], "xz / tar+xz"),
	(0, [0x42, 0x5a, 0x68], "bz2 / tar+bz2"),
	(0, [0x4c, 0x49, 0x50], "lzip"),
	(2, [0x2d, 0x68, 0x6c, 0x30, 0x2d], "lzh (no compression)"),
	(2, [0x2d, 0x68, 0x6c, 0x35, 0x2d], "lzh (8KiB sliding window)"),
	(0, [0x51, 0x46, 0x49], "qcow"),
	(0, [0x30, 0x37, 0x30, 0x37, 0x30, 0x37], "cpio"),
	(0, [0x28, 0xb5, 0x2f, 0xfd], "zstd"),
	(0, [0x50, 0x4b, 0x03, 0x04], "zip"),
	(0, [0x50, 0x4b, 0x05, 0x06], "zip (empty)"),
	(0, [0x50, 0x4b, 0x07, 0x08], "zip (spanned archive)"),
	(0, [0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x00], "rar (v1.50+)"),
	(0, [0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00], "rar (v5.00+)"),
	(0, [0x7f, 0x45, 0x4c, 0x46], "ELF"),
	(0x8001, [0x43, 0x44, 0x30, 0x30, 0x31], "ISO 9660"),
	(0x8801, [0x43, 0x44, 0x30, 0x30, 0x31], "ISO 9660"),
	(0x9001, [0x43, 0x44, 0x30, 0x30, 0x31], "ISO 9660"),
	(0, [0x75, 0x73, 0x74, 0x61, 0x72, 0x00, 0x30, 0x30], "tar"),
	(0, [0x75, 0x73, 0x74, 0x61, 0x72, 0x20, 0x20, 0x00], "tar"),
	(0, [0x78, 0x61, 0x72, 0x21], "xar"),
	(0, [0x21, 0x3c, 0x61, 0x72, 0x63, 0x68, 0x3e, 0x0a], "deb"),
	(0, [0xed, 0xab, 0xee, 0xdb], "rpm"),
]

def identify_cmdata(cmdata_name, cm_name, cm_namespace, data):
	if len(data) == 0:
		return "Empty", formatters.format_none

	uudata = False

	if "\n" not in data:
		try:
			decoded = base64.b64decode(data)
			if base64.b64encode(decoded) == bytes(data, encoding = "utf-8"):
				uudata = True
		except binascii.Error:
			pass

	if uudata:
		try:
			data = decoded.decode("utf-8")
		except UnicodeDecodeError:
			for offset, match_infix, dataformat in cmdata_bin_header:
				if len(decoded) < len(match_infix) + offset:
					continue

				if bytes(match_infix) == decoded[offset:len(match_infix) + offset]:
					return dataformat, formatters.format_binary
			return "Text or Base64 encoded binary", formatters.format_none

	splitmsg = split_msg(data)
	dataformat = ""

	# We are in luck; there is an interpreter signature
	# or other type of signature to help
	if len(splitmsg) > 0 and splitmsg[0].startswith(("#!", "-----")):
		for match_infix, dataformat in cmdata_header:
			if match_infix in data:
				break

	if len(dataformat) == 0:
		for match_cm_namespace, match_cm_name, match_cmdata_prefix, match_cmdata_suffix, dataformat in cmdata_format:
			if (len(match_cm_namespace) == 0 or match_cm_namespace == cm_namespace) and cm_name.startswith(match_cm_name) and cmdata_name.startswith(match_cmdata_prefix) and cmdata_name.endswith(match_cmdata_suffix):
				break

	formatter = formatters.map_dataformat(dataformat)

	return dataformat, formatter

def identify_formatter(dataformat, kind = None, obj = None, path = None):
	formatter = formatters.format_none

	if dataformat is None:
		if kind is not None and obj is not None and path is not None:
			if kind == ("ConfigMap", ""):
				cmdata_name = path
				cm_name = deep_get(obj, DictPath("metadata#name"))
				cm_namespace = deep_get(obj, DictPath("metadata#namespace"))
				data = deep_get(obj, DictPath(f"data#{path}"))
				dataformat, formatter = identify_cmdata(cmdata_name, cm_name, cm_namespace, data)
			else:
				raise ValueError(f"We do not know how to auto-identify data for kind {kind}")
		else:
			raise ValueError("identify_formatter was called without dataformat and kind, obj, or path=None")

	return formatter

def check_cni_updates(cni: str, current_version: str) -> str:
	"""
	Check whether there are newer versions of the CNI available

		Parameters:
			cni (str): The CNI
			current_version (str): The current version
		Returns:
			candidate_version (str): The newest available version
	"""

	candidate_version = None

	security_policy = SecurityPolicy.ALLOWLIST_RELAXED
	fallback_allowlist = ["/bin", "/sbin", "/usr/bin", "/usr/sbin", "/usr/local/bin", "/usr/local/sbin", f"{HOMEDIR}/bin"]

	if cni == "weave":
		# GET /report -H 'Accept: application/json'
		# This should be the IP address of the control plane
		# XXX: We probably need to do this locally on the control plane (via ansible) rather than remotely connecting to the control plane
		weaveaddr = "127.0.0.1"

		conn = http.client.HTTPConnection(weaveaddr, 6784)
		headers = {
			"Accept": "application/json"
		}

		try:
			conn.request("GET", "/report", headers = headers)
			r1 = conn.getresponse()
		except ConnectionRefusedError:
			return "<Version check failed>"

		if r1.status == 200:
			try:
				weavestatus = json.loads(r1.read())
				if deep_get(weavestatus, DictPath("VersionCheck#Enabled"), False) and deep_get(weavestatus, DictPath("VersionCheck#Success"), False):
					candidate_version = deep_get(weavestatus, DictPath("VersionCheck#NewVersion"), None)
			except DecodeException:
				# We got a response, but the data is malformed
				pass
		conn.close()
	elif cni == "cilium":
		try:
			cpath = secure_which(FilePath(os.path.join(BINDIR, "cilium")), fallback_allowlist = fallback_allowlist,
					     security_policy = security_policy)
		except FileNotFoundError:
			cpath = None

		if cpath is not None:
			args = [cpath, "version"]
			result = subprocess.run(args, stdout = PIPE, stderr = PIPE, universal_newlines = True, check = False)
			if result is not None:
				versionoutput = result.stdout.splitlines()
				version_regex = re.compile(r"^cilium image \(default\): (.*)")
				for line in versionoutput:
					tmp = version_regex.match(line)
					if tmp is not None:
						candidate_version = tmp[1]
						break
	else:
		candidate_version = "<Update check not implemented>"

	if candidate_version is not None:
		if versiontuple(current_version) < versiontuple(candidate_version):
			candidate_version = ""
		else:
			candidate_version = "No newer version found"

	return candidate_version

# pylint: disable-next=unused-argument
def update_cni(stdscr: curses.window, cni, current_version, candidate_version, dry_run = False) -> bool:
	"""
	Update the CNI

		Parameters:
			stdscr (opaque): A curses stdscr reference
			cni (str): The CNI
			current_version (str): The current version
			candidate_version (str): The candidate version
			dry_run (bool): If True just verify that the update method is valid
		Returns:
			bool: True on success, False on failure
	"""

	security_policy = SecurityPolicy.ALLOWLIST_RELAXED
	fallback_allowlist = ["/bin", "/sbin", "/usr/bin", "/usr/sbin", "/usr/local/bin", "/usr/local/sbin", f"{HOMEDIR}/bin"]

	retval = True

	if cni == "Unknown":
		retval = False
	elif cni == "weave":
		# XXX: Currently we do not have any reliable update method for weave
		retval = False
	elif cni == "cilium":
		try:
			cpath = secure_which(FilePath(os.path.join(BINDIR, "cilium")), fallback_allowlist = fallback_allowlist,
					     security_policy = security_policy)
		except FileNotFoundError:
			cpath = None

		if dry_run or cpath is None:
			return cpath is not None

		args = [cpath, "upgrade"]
		curses.endwin()
		_retval = clear_screen()

		ansithemeprint([ANSIThemeString("Updating Cilium:", "phase")])
		print()
		retval = execute_command(args)
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])

	return retval

def __update_cni(uip: UIProps, **kwargs):
	cni = deep_get(kwargs, DictPath("cni"))
	cni_version = deep_get(kwargs, DictPath("cni_version"))
	candidate_version = deep_get(kwargs, DictPath("candidate_version"))

	# If we do not recognise the CNI or we do not support updates we cannot update it
	if not update_cni(uip.stdscr, cni, cni_version, candidate_version, dry_run = True):
		return Retval.MATCH

	# Try to download and install an update
	if curses_helper.confirmationbox(uip.stdscr, uip.maxy // 2, uip.maxx // 2, title = f"Update {cni} to version {candidate_version}:", default = False):
		update_cni(uip.stdscr, cni, cni_version, candidate_version)
	uip.refresh_all()

	return Retval.MATCH, {}

cniloop_shortcuts = {
	"__common_shortcuts": [
		"Toggle mouse on/off",
		"Toggle borders",
		"Show this helptext",
		"Switch main view",
		"Switch main view (recheck available API resources)",
		"Refresh information",
		"Show information about the program",
	],
	"Update Cluster Network Interface": {
		"shortcut": ord("U"),
		"helptext": ("[Shift] + U", "Update Cluster Network Interface (if a newer candidate is available)"),
		"helpgroup": 3,
		"action": "key_callback",
		"action_call": __update_cni,
	},
}

def cniloop(stdscr: curses.window, view):
	global executor  # pylint: disable=global-statement

	# Just in case there are leftover futures from other views
	executor.shutdown()
	executor = reexecutor.ReExecutor()

	field_list, sortcolumn = (None, None)
	uip = UIProps(stdscr)

	windowheader = view
	activatedfun = views[view]["activatedfun"]
	on_activation = deep_get(views[view], DictPath("on_activation"), {})
	update_delay = views[view].get("update_delay", -1)

	uip.init_window(None, windowheader = windowheader, update_delay = update_delay, sortcolumn = None, activatedfun = activatedfun, on_activation = on_activation)

	# For generic information
	infopad = uip.init_infopad(height = 9, width = -1, ypos = 1, xpos = 1)

	# For the status bar; position is always at the bottom of the screen and the entire width of the screen
	statusbar = uip.init_statusbar()

	candidate_version = ""

	cni = None

	while True:
		if uip.is_update_triggered():
			# The data in some fields might become shorter, so we need to trigger a clear
			uip.infopad.erase()
			uip.statusbar.erase()

			uip.update_window()

			# Try to figure out which CNI we are using, if any
			_cnis = kh.identify_cni()

			if len(_cnis) == 0:
				cni = "<unknown>"
				cnistr: List[Union[ThemeRef, ThemeString]] = [
					ThemeString(f"{cni}", color_status_group(StatusGroup.UNKNOWN))
				]
				cni_version = "N/A"
				cni_version_str = [
					ThemeString(f"{cni_version}", color_status_group(StatusGroup.UNKNOWN))
				]
				cni_status = ("N/A", StatusGroup.UNKNOWN)
			elif len(_cnis) == 1:
				cni = _cnis[0][0]
				cnistr = [
					ThemeString(f"{cni}", ThemeAttr("types", "generic"))
				]
				cni_version = _cnis[0][1]
				cni_version_str = [
					ThemeString(f"{cni_version}", ThemeAttr("types", "version"))
				]
				cni_status = _cnis[0][2]
			else:
				cni = "<unknown>"
				cnistr = [
					ThemeString("Could not uniquely identify CNI ", ThemeAttr("main", "status_not_ok")),
					ThemeString("(", ThemeAttr("types", "generic")),
					ThemeString("Candidates: ", ThemeAttr("main", "infoheader"))]
				for i, _cni in enumerate(_cnis):
					cnistr += [
						ThemeString(f"{_cni[0]}", ThemeAttr("types", "generic")),
						ThemeRef("separators", "version"),
						ThemeString(f"{_cni[1]}", ThemeAttr("types", "version"))]
					if i < len(_cnis) - 1:
						cnistr.append(ThemeRef("separators", "list"))
				cnistr.append(ThemeString(")", ThemeAttr("types", "generic")))
				cni_version = "N/A"
				cni_version_str = [
					ThemeString(f"{cni_version[0]}", color_status_group(StatusGroup.UNKNOWN))
				]
				cni_status = ("N/A", StatusGroup.UNKNOWN)

			cni_status_str = [
				ThemeString(f"{cni_status[0]}", color_status_group(cni_status[1]))
			]

			versionarray: List[Union[ThemeRef, ThemeString]] = [
				ThemeString("Version: ", ThemeAttr("main", "infoheader")),
			]
			versionarray += cni_version_str
			candidateversionarray: List[Union[ThemeRef, ThemeString]] = [
				ThemeString("Candidate version: ", ThemeAttr("main", "infoheader")),
			]

			candidate_version = check_cni_updates(cni, cni_version)
			candidateversionarray.append(ThemeString(f"{candidate_version}", ThemeAttr("types", "version")))


			namearray: List[Union[ThemeRef, ThemeString]] = [
				ThemeString("Container Network Interface: ", ThemeAttr("main", "infoheader")),
			]
			namearray += cnistr
			statusarray: List[Union[ThemeRef, ThemeString]] = [
				ThemeString("Status: ", ThemeAttr("main", "infoheader")),
			]
			statusarray += cni_status_str

			uip.addthemearray(infopad, namearray, y = 0, x = 0)
			uip.addthemearray(infopad, versionarray, y = 1, x = 0)
			uip.addthemearray(infopad, candidateversionarray, y = 2, x = 0)
			uip.addthemearray(infopad, statusarray, y = 3, x = 0)

		uip.refresh_window()
		uip.refresh_infopad()
		uip.refresh_statusbar()
		curses.doupdate()

		# These are arguments that *might* be needed by the callbacks
		input_args = {
			"uip": uip,
			"selectwindow": selectwindow,
			"read_only": read_only_mode,
			"cni": cni,
			"cni_version": cni_version,
			"candidate_version": candidate_version,
		}

		retval, return_args = uip.generic_inputhandler(cniloop_shortcuts, **input_args)

		if retval == Retval.MATCH:
			continue
		if retval == Retval.RETURNONE:
			return Retval.RETURNDONE
		if retval == Retval.RETURNFULL:
			return retval

def decode_and_view_data(stdscr: curses.window, **kwargs):
	if "selected" in kwargs:
		bvalue = kwargs["selected"].value
		title = kwargs["selected"].key
		bvtype = kwargs["selected"].vtype
		vtype, value = decode_value(bvalue)
		if bvalue == value:
			vtype = bvtype
	elif "path" in kwargs:
		obj = deep_get(kwargs, DictPath("obj"), {})
		path = deep_get(kwargs, DictPath("path"), "")
		bvalue = deep_get(obj, DictPath(path), "")
		title = deep_get(kwargs, DictPath("title"), "")
		vtype, value = decode_value(bvalue)
	else:
		return None

	if vtype == "empty" or vtype.startswith(("base64-binary", "gzip")):
		return None

	if vtype.startswith("string"):
		obj = value
	elif vtype.startswith("base64-utf-8"):
		obj = base64.b64decode(value).decode("utf-8")
	else:
		raise TypeError(f"Trying to export unknown vtype: {vtype}")
	if title.endswith((".crt", "tls.key", ".pem", "CAKey")) or isinstance(obj, str) and obj.startswith(("-----BEGIN", "-----END")):
		formatter = formatters.format_crt
	else:
		formatter = formatters.format_none
	return resourceinfodispatch(stdscr, obj, ("__ResourceView", ""), title = title, formatter = formatter)

def decode_and_view_file_templates(stdscr: curses.window, **kwargs):
	selection = deep_get(kwargs, DictPath("selection"), {})
	if len(selection) == 0:
		return None
	obj = deep_get(kwargs, DictPath("obj"), {})
	if len(obj) == 0:
		return None
	name_path = deep_get(kwargs, DictPath("name_path"))
	name = selection[1][name_path][0]
	file_path = deep_get(kwargs, DictPath("file_path"))
	files = deep_get(obj, DictPath(file_path))
	for file in files:
		if deep_get(file, DictPath("path"), "") == name:
			break
	else:
		return None
	encoding = deep_get(file, DictPath("encoding"), "")
	content = deep_get(file, DictPath("content"))
	title = name
	if encoding == "":
		formatter = formatters.map_dataformat(title)
		return resourceinfodispatch(stdscr, content, ("__ResourceView", ""), title = title, formatter = formatter)

	vtype, value = decode_value(content)
	if vtype.startswith("string"):
		obj = value
	elif vtype.startswith("base64-utf-8"):
		obj = base64.b64decode(value).decode("utf-8")
	elif vtype.startswith(("base64-binary", "gzip")):
		return None
	formatter = formatters.map_dataformat(title)
	return resourceinfodispatch(stdscr, obj, ("__ResourceView", ""), title = title, formatter = formatter)

# pylint: disable-next=unused-argument
def export_data(stdscr: curses.window, **kwargs):
	selected = deep_get(kwargs, DictPath("selected"))
	obj = deep_get(kwargs, DictPath("obj"))

	if selected is None and obj is None:
		return

	extra_args = deep_get(kwargs, DictPath("_extra_args"), {})
	base_path = deep_get(extra_args, DictPath("base_path"))
	name_attr = deep_get(extra_args, DictPath("name_attr"), "value")
	raw_export = deep_get(extra_args, DictPath("raw_export"), False)

	value = None
	if selected is not None:
		value = getattr(selected, name_attr)
	if obj is not None:
		if value is not None:
			value = deep_get(obj, DictPath(f"{base_path}#{value}"))
		else:
			value = deep_get(obj, DictPath(f"{base_path}"))

	raw_filename = deep_get(kwargs, DictPath("result"))
	if "/" not in raw_filename:
		filename = FilePath(str(Path.cwd().joinpath(raw_filename)))
	else:
		filename = FilePath(raw_filename)

	vtype, value = decode_value(value)

	if vtype.startswith("string") or raw_export:
		secure_write_string(filename, value)
	elif vtype.startswith("base64-utf-8"):
		tmp = base64.b64decode(value).decode("utf-8")
		secure_write_string(filename, tmp)
	elif vtype.startswith(("base64-binary", "gzip")):
		tmp = base64.b64decode(value)
		secure_write_string(filename, tmp, write_mode = "wb")
	else:
		raise TypeError(f"Trying to export unknown vtype: {vtype}")

def generate_helptext(view, viewtype, additional_helptexts, shortcuts):
	helptext = []

	if viewtype == "infoview":
		helptext += helptexts.infoviewheader_part1

		if view not in infoviews:
			helptext += helptexts.infoviewheader_part2
			helptext += helptexts.spacer
			helptext += additional_helptexts
			return format_helptext(helptext)

		viewref = infoviews[view]

		if "listpad" in viewref:
			helptext += helptexts.togglewidth
			helptext += helptexts.infoviewheader_part2
			if deep_get(viewref, DictPath("activatedfun")) is not None:
				helptext.append(("[Enter]", "Open info page for selected resource"))

		if len(additional_helptexts) > 0:
			helptext += helptexts.spacer
			helptext += additional_helptexts

		if len(shortcuts) > 0:
			for shortcut in shortcuts:
				tmp = deep_get(shortcuts[shortcut], DictPath("helptext"))
				if tmp is not None:
					helptext.append(tmp)

		if "listpad" in viewref:
			helptext += helptexts.spacer

			if not deep_get(viewref, DictPath("reversible"), True):
				helptext += helptexts.irreversiblelistmovement
			else:
				helptext += helptexts.listmovement
		elif "logpad" in viewref:
			helptext += helptexts.linewrap
			helptext += helptexts.toggleformatter
			helptext += helptexts.spacer
			helptext += helptexts.logmovement
	elif viewtype == "listview":
		helptext += helptexts.listviewheader

		viewref = views[view]

		if viewref["kind"] in infoviews:
			helptext += helptexts.openresource

		# Always include the shortcut for YAML dump, unless overridden
		if "shortcuts" not in viewref or "View YAML dump" not in viewref["shortcuts"]:
			helptext.append(("Y", "View YAML dump of resource"))

		# Always include the shortcut for edit resource, unless overridden
		if "shortcuts" not in viewref or "Edit resource" not in viewref["shortcuts"]:
			helptext.append(("E", "Edit resource"))

		if "shortcuts" in viewref:
			for shortcut in deep_get(viewref, DictPath("shortcuts")):
				read_only = deep_get(viewref, DictPath(f"shortcuts#{shortcut}#read_only"), False)
				if read_only_mode and not read_only:
					continue
				tmp = deep_get(viewref, DictPath(f"shortcuts#{shortcut}#helptext"))
				if tmp is not None:
					helptext.append(tmp)
			helptext += helptexts.spacer

		if deep_get(viewref, DictPath("is_taggable"), True):
			helptext += helptexts.tagactions
			helptext += helptexts.spacer
			if deep_get(viewref, DictPath("labels"), True):
				helptext += helptexts.selectoractions
				helptext += helptexts.spacer

		helptext += helptexts.listmovement

	return format_helptext(helptext)

def genericinfoloop(stdscr: curses.window, obj, view: str, **kwargs):
	global initial_container  # pylint: disable=global-statement
	global executor  # pylint: disable=global-statement

	# Just in case there are leftover futures from other views
	executor.shutdown()
	executor = reexecutor.ReExecutor()

	# If obj is a tuple we got the object as obj[0]
	# params as obj[1]
	if isinstance(obj, tuple):
		objparams = obj[1]
		obj = obj[0]
	else:
		objparams = None

	# If we are using the logpad this can be used to format the data
	formatter_path = deep_get(kwargs, DictPath("formatter_path"))
	# formatter_path has precedence over formatter, to allow ConfigMaps to work properly
	formatter = deep_get(kwargs, DictPath("formatter"))
	if formatter_path is not None:
		formatter = deep_get(obj, DictPath(formatter_path))
	elif formatter is not None:
		if isinstance(formatter, str):
			_formatter = deep_get(formatter_allowlist, DictPath(formatter))
			if _formatter is None:
				raise ValueError(f"{formatter} is not in formatter_allowlist")
			formatter = _formatter
	obj_path = deep_get(kwargs, DictPath("obj_path"))
	title = None
	if obj_path is not None:
		title_path = deep_get(kwargs, DictPath("title_path"))
		if title_path is not None:
			title = deep_get(obj, DictPath(title_path))
		if obj_path != "":
			obj = deep_get(obj, DictPath(obj_path))
		else:
			obj = [obj]

	uip = UIProps(stdscr)

	if view not in infoviews:
		return Retval.NOMATCH

	viewref = infoviews[view]

	searchmatch = []

	objgetter = deep_get(viewref, DictPath("objgetter"))
	if objgetter is not None:
		obj = objgetter(obj)
		if obj is None or len(obj) == 0:
			return Retval.NOMATCH

	# XXX: For now we do not support custom fields for the lists on the info pages
	field_indexes = deep_get(viewref, DictPath("field_indexes"), {})
	field_index = "Normal"

	field_denylist = deep_get(viewref, DictPath("field_denylist"), [])
	fieldgenerator_args = {
		"field_index": field_index,
		"field_indexes": field_indexes,
		"fields": deep_get(viewref, DictPath(f"fields")),
		"denylist": field_denylist,
	}
	field_dict, field_names, sortcolumn, sortorder_reverse = generators.fieldgenerator(view = view,
											   selected_namespace = selected_namespace,
											   **fieldgenerator_args)

	windowheader = deep_get(viewref, DictPath("windowheader"), f"{view[0]} Info")

	# These values can be toggled, so we need to read them first
	infoview_args = copy.deepcopy(viewref.get("infoview_args", {}))

	# These are used for anything that uses ResourceViewer
	if title is not None:
		windowheader = title
	elif "title" in kwargs:
		windowheader = deep_get(kwargs, DictPath("title"))
	elif "title_path" in kwargs:
		windowheader = deep_get(obj, DictPath(title_path), windowheader)
	else:
		kind = deep_get(viewref, DictPath("kind"))
		if kind is not None and len(kind[1]) > 0:
			windowheader = f"{windowheader} ({kind[1]})"

	sortorder_reverse = deep_get(viewref, DictPath("sortorder_reverse"), False)
	reversible = deep_get(viewref, DictPath("reversible"), True)
	activatedfun = deep_get(viewref, DictPath("activatedfun"))
	on_activation = deep_get(viewref, DictPath("listpad#on_activation"), {})
	labels = deep_get(viewref, DictPath("labels"), "metadata#labels")
	annotations = deep_get(viewref, DictPath("annotations"), "metadata#annotations")
	extraref = deep_get(viewref, DictPath("extraref"))
	data = deep_get(viewref, DictPath("data"), None)
	if data is not None:
		data = obj
	viewoverride = deep_get(viewref, DictPath("viewoverride"), view)
	infopadheight = 0
	if "infopad" in viewref:
		if "name_path" in viewref:
			name_path = deep_get(viewref, DictPath("name_path"))
		else:
			name_path = "metadata#name"
		if "namespace_path" in viewref:
			namespace_path = deep_get(viewref, DictPath("namespace_path"))
		else:
			namespace_path = "metadata#namespace"
		if "creation_timestamp_path" in viewref:
			creation_timestamp_path = deep_get(viewref, DictPath("creation_timestamp_path"))
		else:
			creation_timestamp_path = "metadata#creationTimestamp"

		# Number of fields added conditionally
		if name_path is not None and len(name_path) > 0 and deep_get(obj, DictPath(name_path)) is not None:
			infopadheight += 1
		if namespace_path is not None and len(namespace_path) > 0 and deep_get(obj, DictPath(namespace_path)) is not None:
			infopadheight += 1
		if creation_timestamp_path is not None and len(creation_timestamp_path) > 0 and deep_get(obj, DictPath(creation_timestamp_path)) is not None:
			infopadheight += 1
		# Number of custom fields
		infopadheight += len(deep_get(viewref, DictPath("infopad"), {}))
		# If we *only* have an infopad, then it should cover at least the entire screen; if not it should be as big as needed;
		# it does not really matter if we allocate an infopad larger than the screen, but this should be correct.
		if "listpad" not in viewref and "logpad" not in viewref:
			maxyx = stdscr.getmaxyx()
			infopadheight = max(infopadheight, maxyx[0] - 3)

	shortcuts = copy.deepcopy(deep_get(viewref, DictPath("shortcuts"), {}))

	# Shortcuts
	# Always include the shortcut for namespaces, unless overriden
	# or the namespace_path returns None
	#
	# An override is necessary if metadata#namespace is not the correct path
	# or some other changes are necessary
	if deep_get(shortcuts, DictPath("Namespace")) is None and deep_get(obj, DictPath(namespace_path)) is not None:
		shortcuts["Namespace"] = {
			"shortcut": ord("N"),
			"read_only": True,
			"helptext": ("[Shift] + N", "Open info page for Namespace"),
			"call": resourceinfodispatch,
			"kind": ("Namespace", ""),
			"name_path": "metadata#namespace",
		}

	# Always include the shortcut for security contexts,
	# unless the path returns None
	if "securityContext" in deep_get(obj, DictPath("spec"), {}) or "securityContext" in deep_get(obj, DictPath("spec#template#spec"), {}):
		shortcuts["Show Security Context"] = {
			"shortcut": ord("x"),
			"read_only": True,
			"helptext": ("X", "Show security context information"),
			"widget": "windowwidget",
			"title": "Security Context Policies:",
			"headers": ["Policy:", "Value:"],
			"itemgetter": itemgetters.get_security_context,
			"formatting": [ThemeAttr("windowwidget", "default"), ThemeAttr("windowwidget", "highlight")],
		}

	# Always include the shortcut for conditions,
	# unless the path returns None
	if "conditions" in deep_get(obj, DictPath("status"), {}):
		shortcuts["Show Resource Conditions"] = {
			"shortcut": ord("c"),
			"read_only": True,
			"helptext": ("C", "Show resource conditions"),
			"widget": "windowwidget",
			"title": "Conditions:",
			"headers": ["Type:", "Status:", "Last Probe:", "Last Transition:", "Message:"],
			"itemgetter": itemgetters.get_conditions,
		}

	# Always include the shortcut for events unless overriden
	if deep_get(viewref, DictPath("shortcuts#Show Events")) is None:
		shortcuts["Show Events"] = {
			"shortcut": ord("e"),
			"read_only": True,
			"helptext": ("E", "Show events"),
			"widget": "windowwidget",
			"selectable": True,
			"action": "call",
			"action_call": resourceinfodispatch_with_lookup,
			"action_args": {
				"kind": "Event",
				"namespace_path": 0,
				"name_path": 1,
			},
			"title": "Events:",
			"headers": ["Namespace:", "Name:", "Last Seen:", "Status:", "Reason:", "Source:", "First Seen:", "Count:", "Message:"],
			"itemgetter": itemgetters.get_events,
		}

	# Always include the shortcut for YAML dump, unless overridden
	if deep_get(viewref, DictPath("shortcuts#YAML")) is None:
		shortcuts["View YAML dump of resource"] = {
			"shortcut": ord("y"),
			"read_only": True,
			"helptext": ("Y", "View YAML dump of resource"),
			"action": "call",
			"action_call": view_yaml,
			"action_args": {
				"title": "YAML dump",
				"_pass_obj": True,
			},
		}

	# Always include the shortcut for last applied configuration, unless overridden
	if deep_get(viewref, DictPath("shortcuts#Last Applied Configuration")) is None:
		shortcuts["Last Applied Configuration"] = {
			"shortcut": ord("L"),
			"read_only": True,
			"helptext": ("[Shift] + L", "Show last applied configuration"),
			"action": "call",
			"action_call": view_last_applied_configuration,
			"action_args": {
				"_pass_obj": True,
				"title": "Last applied configuration",
			}
		}

	if deep_get(cmtlib.cmtconfig, DictPath("Internal#sanity_check_views"), False):
		sanity = True
		_shortcuts = {}
		for shortcut in shortcuts:
			_shortcut = shortcuts[shortcut].get("shortcut")
			if _shortcut is None:
				continue
			if not isinstance(_shortcut, list):
				_shortcut = [_shortcut]
			for _sc in _shortcut:
				if _sc in _shortcuts:
					sys.exit(f"infoview {view}: The same keypress ({_sc}) is used for both “{shortcut}“ and “{_shortcuts[_sc]}“; aborting.")
				else:
					_shortcuts[_sc] = shortcut

	# Conditional helptexts
	additional_helptexts = []
	if deep_get(obj, DictPath(labels)) is not None:
		additional_helptexts += helptexts.labels
	if deep_get(obj, DictPath(annotations)) is not None:
		additional_helptexts += helptexts.annotations

	helptext = generate_helptext(view, "infoview", additional_helptexts, shortcuts = shortcuts)

	uip.init_window(field_dict, windowheader = windowheader, helptext = helptext,
			view = viewoverride,
			sortcolumn = sortcolumn, sortorder_reverse = sortorder_reverse, reversible = reversible,
			activatedfun = activatedfun, on_activation = on_activation, extraref = extraref, data = obj)

	# For generic information
	if infopadheight > 0:
		infopad = uip.init_infopad(height = infopadheight, width = -1, ypos = 1, xpos = 1, labels = deep_get(obj, DictPath(labels)), annotations = deep_get(obj, DictPath(annotations)))
	else:
		infopad = None

	# For the status bar; position is always at the bottom of the screen and the entire width of the screen
	statusbar = uip.init_statusbar()

	# For lists
	headerpad = None
	listpad = None
	if len(deep_get(viewref, DictPath("listpad"), {})) > 0:
		if infopadheight == 0:
			headerpad, listpad = uip.init_listpad(listheight = 1, width = -1, ypos = 1, xpos = 1)
		else:
			headerpad, listpad = uip.init_listpad(listheight = 1, width = -1, ypos = infopadheight + 2, xpos = 1)

	# For log pads; we cannot have both a logpad and a listpad simultaneously;
	# at least not with the current implementation
	logpad = deep_get(viewref, DictPath("logpad"))
	if logpad is not None:
		if listpad is not None:
			raise ValueError("We cannot have listpad and logpad simultaneously")

		show_timestamps = deep_get_with_fallback(viewref, [DictPath("logpad#timestamps"), DictPath("timestamps")], True)
		uip.toggle_timestamps(show_timestamps)
		if infopadheight == 0:
			tspad, logpad = uip.init_logpad(width = -1, ypos = 1, xpos = 1, timestamps = show_timestamps)
		else:
			tspad, logpad = uip.init_logpad(width = -1, ypos = infopadheight + 2, xpos = 1, timestamps = show_timestamps)

	wrap_lines = False
	raw_output = False

	first_fetch = True

	while True:
		# Output listpad if we have one
		if uip.is_update_triggered():
			# The data in some fields might become shorter, so we need to trigger a clear
			if infopad is not None:
				uip.infopad.erase()
			uip.statusbar.erase()

			statusarray1: List[Union[ThemeRef, ThemeString]] = [
				ThemeString("Fields: ", ThemeAttr("statusbar", "infoheader")),
				ThemeString(field_index, ThemeAttr("statusbar", "highlight"))
			]
			statusarray2: List[Union[ThemeRef, ThemeString]] = []

			for status_data in deep_get(viewref, DictPath("statusmsg"), []):
				if len(status_data) == 2:
					key, path = status_data
					default_status = "<unset>"
				else:
					key, path, default_status = status_data

				# If path is a list the first item tells what source to use and the second
				# what path to fetch the value from
				if isinstance(path, list):
					if path[0] == "config":
						src_obj = cmtlib.cmtconfig
					#elif path[0] == "obj":
					#	value_path = obj
					elif path[0] == "var":
						src_obj = infoview_args
					value_path = DictPath(path[1])
				else:
					src_obj = infoview_args
					value_path = DictPath(path)

				value = str(deep_get(src_obj, value_path, default_status))
				if len(statusarray2) > 0:
					statusarray2 += [ThemeRef("separators", "statusbar")]
				statusarray2 += [
					ThemeString(key, ThemeAttr("statusbar", "infoheader")),
					ThemeString(value, ThemeAttr("statusbar", "default")),
				]

			uip.addthemearray(statusbar, statusarray1, y = 0, x = 0)
			uip.addthemearray(statusbar, statusarray2, y = 1, x = 0)

			# Refresh obj whenever we reload, unless this is a special view or "no_reload_on_refresh" is true
			if not view[0].startswith("__") and not deep_get(viewref, DictPath("no_reload_on_refresh"), False):
				obj = kh.get_ref_by_kind_name_namespace(view, deep_get(obj, DictPath("metadata#name")), deep_get(obj, DictPath("metadata#namespace")))

				if obj is None:
					title = "Error!"
					errormsg = [{
						"lineattrs": 0,
						"columns": [[ThemeString("Resource not available; it may have been deleted", ThemeAttr("types", "generic"))]],
					}]
					curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, errormsg, title = title, cursor = False)
					return Retval.RETURNDONE

			uip.update_window()

			if listpad is not None:
				listgetter = deep_get(viewref, DictPath("listpad#listgetter"))
				listgetter_args = deep_get(viewref, DictPath("listpad#listgetter_args"), {})
				_kind = deep_get(listgetter_args, DictPath("_kind"))
				_kind_path = deep_get(listgetter_args, DictPath("_kind_path"))
				_api_family = deep_get(listgetter_args, DictPath("_api_family"))
				_api_family_path = deep_get(listgetter_args, DictPath("_api_family_path"))
				_label_selector_path = deep_get(listgetter_args, DictPath("_label_selector_path"))
				_label_selector_key_values = deep_get(listgetter_args, DictPath("_label_selector_key_values"))
				if _label_selector_path is not None:
					listgetter_args["label_selector"] = make_selector(deep_get(obj, DictPath(_label_selector_path)))
				elif _label_selector_key_values is not None:
					label_selectors = {}
					for label_key, label_value in _label_selector_key_values:
						if isinstance(label_value, str):
							label_selectors[label_key] = label_value
						elif isinstance(label_value, list):
							label_selectors[label_key] = deep_get_with_fallback(obj, label_value)
					listgetter_args["label_selector"] = make_selector(label_selectors)
				if len(deep_get(listgetter_args, DictPath("label_selector"), "")) == 0 and deep_get(listgetter_args, DictPath("_none_on_empty_selector"), False):
					listgetter = listgetter_noop
				_field_selector = deep_get(listgetter_args, DictPath("_field_selector"), {})
				if len(_field_selector) > 0:
					field_selectors = {}
					for field_key, field_value in _field_selector.items():
						if isinstance(field_value, list):
							field_selectors[field_key] = deep_get_with_fallback(obj, field_value)
						else:
							field_selectors[field_key] = field_value
					listgetter_args["field_selector"] = make_selector(field_selectors)
				if _kind is None:
					_kind = deep_get(obj, DictPath(_kind_path))
				if _api_family is None:
					_api_family = deep_get(obj, DictPath(_api_family_path), "")
				if _kind is not None:
					_kind = guess_kind((_kind, _api_family))
				_namespace = deep_get(listgetter_args, DictPath("namespace"))
				_namespace_path = deep_get(listgetter_args, DictPath("_namespace_path"), "")
				if _namespace is None:
					_namespace = deep_get(obj, DictPath(_namespace_path), "")
				listgetter_args["kind"] = _kind
				listgetter_args["namespace"] = _namespace
				if "_pass_obj" in listgetter_args:
					listgetter_args["_obj"] = obj


				# pylint: disable-next=comparison-with-callable
				if listgetter == generic_listgetter:
					uip.refresh_window()
					uip.refresh_statusbar()
					win = curses_helper.notice(uip.listpad, uip.maxy // 2, uip.maxx // 2, message = "Fetching data")
					curses.doupdate()
					vlist, status = listgetter(**listgetter_args)
					first_fetch = False
				else:
					uip.refresh_window()
					uip.refresh_statusbar()
					win = curses_helper.notice(uip.listpad, uip.maxy // 2, uip.maxx // 2, message = "Fetching data")
					curses.doupdate()
					vlist, status = listgetter(obj, **listgetter_args)
					first_fetch = False

				infogetter = deep_get(viewref, DictPath("listpad#infogetter"))
				infogetter_filters = deep_get(viewref, DictPath("listpad#infogetter_filters"), None)
				infogetter_args = deep_get(viewref, DictPath("listpad#infogetter_args"), {})

				filters = None
				if infogetter_filters is not None:
					filters = []
					if infogetter_filters is not None:
						for key, value in infogetter_filters:
							filters.append((ast.literal_eval(key), ast.literal_eval(value)))
				fields = deep_get(viewref, DictPath("fields"), [])

				infogetter_args.pop("_vlist", None)
				infogetter_args["_vlist"] = vlist

				infogetter_args.pop("_field_index", None)
				infogetter_args["_field_index"] = field_index

				infogetter_args.pop("_field_names", None)
				infogetter_args["_field_names"] = field_names

				infogetter_args.pop("_field_dict", None)
				infogetter_args["_field_dict"] = field_dict

				infogetter_args.pop("_filters", None)
				infogetter_args["_filters"] = filters

				infogetter_args.pop("_obj", None)
				infogetter_args["_obj"] = obj

				extra_data = {}
				for key, value in deep_get(infogetter_args, DictPath("_extra_data"), {}).items():
					if isinstance(value, list):
						tmp = deep_get_with_fallback(obj, value)
						extra_data[key] = tmp
					else:
						extra_data[key] = value
				infogetter_args["extra_data"] = extra_data
				info = infogetter(**infogetter_args)

				listlen = uip.update_info(info)
				linelen = update_field_widths(field_dict, field_names, uip.info)
				uip.resize_listpad(linelen)
			elif logpad is not None:
				if deep_get(infoview_args, DictPath("decoder#override_decoder")):
					decoder = deep_get(infoview_args, DictPath("decoder#decoder"))
					if decoder is not None:
						try:
							decoded_obj = copy.deepcopy(base64.b64decode(obj).decode("utf-8"))
						except (binascii.Error, TypeError, UnicodeDecodeError):
							decoded_obj = obj
				else:
					decoded_obj = obj

				if formatter is not None:
					formatted_obj = formatter(decoded_obj, raw = raw_output)
				else:
					formatted_obj = decoded_obj

				infogetter = deep_get(viewref, DictPath("logpad#infogetter"))
				infogetter_args = deep_get(viewref, DictPath("logpad#infogetter_args"), {})
				infogetter_args["_show_raw"] = raw_output

				if infogetter is not None:
					tmp = infogetter(formatted_obj, **infogetter_args)
					if isinstance(tmp, tuple):
						timestamps, facilities, severities, messages = tmp
					else:
						timestamps = None
						facilities = None
						severities = None
						messages = tmp
					uip.update_log_info(timestamps, facilities, severities, messages)
					uip.loglen = len(messages)

			if infopad is not None:
				y = 0
				if name_path is not None and len(name_path) > 0:
					fieldarray: List[Union[ThemeRef, ThemeString]] = [
						ThemeString("Name:", ThemeAttr("main", "infoheader")),
						ThemeString(f" {deep_get(obj, DictPath(name_path))}", ThemeAttr("types", "generic"))
					]
					uip.addthemearray(infopad, fieldarray, y = y, x = 0)
					y += 1

				if namespace_path is not None and len(namespace_path) > 0 and deep_get(obj, DictPath(namespace_path)) is not None:
					fieldarray = [
						ThemeString("N", ThemeAttr("main", "infoheader_shortcut")),
						ThemeString("amespace:", ThemeAttr("main", "infoheader")),
						ThemeString(f" {deep_get(obj, DictPath(namespace_path))}", ThemeAttr("types", "namespace"))
					]
					uip.addthemearray(infopad, fieldarray, y = y, x = 0)
					y += 1

				for key, value in deep_get(viewref, DictPath("infopad"), {}).items():
					# If there is a header field, this is from a view file; otherwise it is an old-style field
					fieldarray = []
					header = deep_get(value, DictPath("header"))

					if header is not None:
						fieldarray += header
						# Only add stuff if there's a path
						if "path" in value or "paths" in value:
							# Use generic_infogetter for this
							data = get_obj(obj = obj, field_dict = {key: value}, field_names = [key], field_index = "Normal", view = "", filters = {})
							_formatter = {key: generators.get_formatter(value)}
							_generator = deep_get(_formatter, DictPath(f"{key}#generator"))
							if _generator is not None:
								ralign = deep_get(_formatter, DictPath(f"{key}#ralign"))
								formatting = deep_get(_formatter, DictPath(f"{key}#formatting"))
								fieldarray += [ThemeString(" ", ThemeAttr("types", "generic"))]
								fieldarray += _generator(data, key, fieldlen = 0, pad = 0, ralign = ralign, selected = False, **formatting)
						uip.addthemearray(infopad, fieldarray, y = y, x = 0)

						y += 1
						continue

				if creation_timestamp_path is not None and len(creation_timestamp_path) > 0 and deep_get(obj, DictPath(creation_timestamp_path)) is not None:
					timestamp = deep_get(obj, DictPath(creation_timestamp_path))

					if timestamp is None:
						field = [ThemeRef("strings", "unset")]
					elif isinstance(timestamp, datetime):
						field = format_timestamp(timestamp)
					else:
						timestamp = timestamp_to_datetime(timestamp)
						field = format_timestamp(timestamp, localtimezone = True)
					fieldarray = [
						ThemeString("Created: ", ThemeAttr("main", "infoheader")),
					]
					fieldarray += field
					uip.addthemearray(infopad, fieldarray, y = y, x = 0)

		# Output listpad if we have one
		if listpad is not None:
			y = 0

			uip.update_sorted_list()
			if not uip.is_list_regenerated():
				generate_list_header(uip, headerpad, field_dict)
				# Output the visible part of the list
				uip.selected = None
				for y in range(uip.yoffset, min(uip.yoffset + uip.mincurypos + uip.maxcurypos + 1, uip.listlen)):
					item = uip.sorted_list[y]
					uip.select_if_y(y, item)
					generate_list_row(uip, listpad, item, field_dict, y - uip.yoffset, uip.is_selected(item))
				uip.list_needs_regeneration(False)

		# Output logpad if we have one
		if logpad is not None and uip.refresh:
			uip.logpad.erase()
			# This is needed in case we get a resize event or toggle borders
			uip.resize_logpad(uip.maxy - uip.logpadypos - 2, 0)
			maxx = 0
			yadd = 0

			for y in range(0, min(uip.logpadheight, len(messages))):
				facility = None
				if facilities is not None and uip.yoffset + y < len(facilities):
					fac = facilities[uip.yoffset + y]

					if len(fac) > 0:
						if isinstance(fac, tuple):
							fac0 = fac[0]
							fac1 = fac[1]
						else:
							fac0 = fac
							fac1 = ""

						facility = []
						if len(fac0.strip()) == 0:
							facility += [ThemeString("".ljust(len(ThemeRef("separators", "facility_prefix"))), ThemeAttr("logview", "facility")),
								     ThemeString(fac0, ThemeAttr("logview", "facility")),
								     ThemeString("".ljust(len(ThemeRef("separators", "facility_suffix"))), ThemeAttr("logview", "facility"))]
						else:
							facility += [ThemeRef("separators", "facility_prefix"),
								     ThemeString(fac0, ThemeAttr("logview", "facility")),
								     ThemeRef("separators", "facility_suffix")]
						if len(fac1) > 0:
							if len(fac1.strip()) == 0:
								facility += [ThemeString("".ljust(len(ThemeRef("separators", "facility_extended_prefix"))), ThemeAttr("logview", "facility")),
									     ThemeString(fac1, ThemeAttr("types", "facility_extended")),
									     ThemeString("".ljust(len(ThemeRef("separators", "facility_extended_suffix"))), ThemeAttr("logview", "facility"))]
							else:
								facility += [ThemeRef("separators", "facility_extended_prefix"),
									     ThemeString(fac1, ThemeAttr("types", "facility_extended")),
									     ThemeRef("separators", "facility_extended_suffix")]
						facility += [ThemeRef("separators", "facility_padding")]

				if timestamps is None or uip.yoffset + y >= len(timestamps):
					timestamp = "".ljust(uip.tspadwidth)
				else:
					timestamp = str(timestamps[uip.yoffset + y]).ljust(uip.tspadwidth)
					tsthemearray: List[Union[ThemeRef, ThemeString]] = [ThemeString(timestamp, ThemeAttr("logview", "timestamp"))]

				if severities is None or uip.yoffset + y >= len(severities):
					severity = LogLevel.INFO
				else:
					severity = severities[uip.yoffset + y]

				message = messages[uip.yoffset + y]
				current_match = False
				if len(uip.search_matches) > 0:
					line_match = uip.yoffset + y in uip.search_matches
					match_prefix: List[Union[ThemeRef, ThemeString]] = [ThemeRef("separators", "matchbullet")]
					if not line_match:
						match_prefix = [ThemeString("".ljust(len(themearray_to_string(match_prefix))), ThemeAttr("types", "generic"))]
					if uip.match_index is not None and uip.yoffset + y == uip.match_index:
						current_match = True
					message = match_prefix + message
				if wrap_lines:
					sideadjust = 0
					if not uip.borders:
						sideadjust = 2
					maxwidth = uip.logpadminwidth + sideadjust
				else:
					maxwidth = -1
				if isinstance(message, str):
					message = [ThemeString(message, color_log_severity(severity))]
				if facility is not None:
					message = facility + message
				untruncated_len = themearray_len(message)
				max_untruncated_len = 16384
				if wrap_lines or untruncated_len < max_untruncated_len:
					_lines = themearray_wrap_line(message, maxwidth, wrap_marker = (uip.borders or get_mousemask() != 0))
				else:
					_lines = [themearray_truncate(message, max_untruncated_len - 1)]
					_lines.append([ThemeString(f"Line too long ({untruncated_len} bytes); truncated to {max_untruncated_len} bytes (Use line wrapping to see the entire message)",
						       ThemeAttr("logview", f"severity_{loglevel_to_name(LogLevel.ERR).lower()}"))])

				for i, _line in enumerate(_lines):
					if y + yadd + i >= uip.logpadheight:
						break
					if i == 0 and timestamps is not None:
						uip.addthemearray(cast(curses.window, tspad), tsthemearray, y = y + yadd, x = 0)
					ypos, xpos = uip.addthemearray(logpad, _line, y = y + yadd + i, x = 0, selected = current_match)
					maxx = max(maxx, xpos)
				yadd += i
			uip.resize_logpad(-1, maxx)
			uip.update_window()

		uip.refresh_window()
		uip.refresh_infopad()
		uip.refresh_listpad()
		uip.refresh_logpad()
		uip.refresh_statusbar()
		curses.doupdate()
		uip.refresh = False

		# XXX: Handle initial containers and configmaps
		#      This should be done by the same code path as a regular activation; this solution is too ugly for words
		if initial_container is not None:
			match = None

			if len(uip.info) > 0:
				match_count = 0

				obj_path = deep_get(viewref, DictPath("listpad#on_activation#obj_path"))
				for item in uip.info:
					# If we are dealing with a config map we are interested in non-binary types
					# If we are dealing with a pod we are interested in containers
					if hasattr(item, "type") and item.type in ("[container]", "[init_container]"):
						name = item.ref["name"]
						ikind = item.type
					elif view == ("ConfigMap", "") and item.type in (rtype[4] for rtype in cmdata_format):
						name = item.data
						ikind = deep_get(viewref, DictPath("listpad#on_activation#kind"), "")
						if isinstance(ikind, str):
							iapi_family = deep_get(viewref, DictPath("listpad#on_activation#api_family"), "")
							ikind = guess_kind((ikind, iapi_family))
					else:
						continue

					# If name is not set we skip
					if name is None:
						continue

					# If we have an exact match we do not care about partial matches
					if name == initial_container:
						if view == ("ConfigMap", ""):
							match = item.data
						else:
							match = item.ref
						match_count = 1
						break

					if name.startswith(initial_container):
						# Since the exact match might occur later than the partial we cannot abort
						# on partial matches; instead just save the match and continue searching.
						# If we get more than one partial match we ignore the partial matches.
						if match_count == 0:
							if view == ("ConfigMap", ""):
								match = item.data
							else:
								match = item.ref
						match_count += 1

				initial_container = None

				if match is not None and match_count == 1:
					on_activation_args = {}
					formatter_path = deep_get(viewref, DictPath("listpad#on_activation#formatter_path"))
					if deep_get(viewref, DictPath("listpad#on_activation#formatter"), "") == "identify":
						formatter = identify_formatter(None, kind = view, obj = obj, path = match)
						on_activation_args["formatter"] = formatter
					else:
						formatter = deep_get(viewref, DictPath("listpad#on_activation#formatter"))
						formatter_path = deep_get(viewref, DictPath("listpad#on_activation#formatter_path"))
						on_activation_args["formatter"] = formatter
						on_activation_args["formatter_path"] = formatter_path
					if view == ("ConfigMap", ""):
						retval = uip.activatedfun(uip.stdscr, deep_get(obj, DictPath(f"data#{match}"), ""), ikind, info = None, title = name, **on_activation_args)
					else:
						retval = uip.activatedfun(uip.stdscr, match, ikind, info = obj, **on_activation_args)
					if retval == Retval.RETURNFULL:
						return retval
					uip.force_update()
					uip.refresh_all()
					continue

		uip.stdscr.timeout(100)
		c = uip.stdscr.getch()
		retval = uip.generic_keycheck(c)

		if retval == Retval.MATCH:
			continue
		if retval == Retval.RETURNONE:
			return Retval.RETURNDONE
		if retval == Retval.RETURNFULL:
			return retval

		if c == curses.KEY_F2:
			retval = selectwindow(uip)
			if retval == Retval.RETURNFULL:
				return retval
			uip.refresh_all()
		elif c == curses.KEY_F3:
			retval = selectwindow(uip, refresh_apis = True)
			if retval == Retval.RETURNFULL:
				return retval
			uip.refresh_all()
		elif c == ord("B"):
			uip.toggle_borders()
			uip.refresh_all()
			uip.force_update()
		elif c == ord("W") and listpad is not None:
			if len(field_indexes) == 0:
				continue

			_list = list(field_indexes.keys())
			_index = _list.index(field_index)
			field_index = _list[(_index + 1) % len(field_indexes)]

			fieldgenerator_args = {
				"field_index": field_index,
				"field_indexes": field_indexes,
				"fields": deep_get(viewref, DictPath(f"fields")),
				"denylist": [],
			}
			field_dict, field_names, sortcolumn, sortorder_reverse = generators.fieldgenerator(view = view,
													   selected_namespace = selected_namespace,
													   **fieldgenerator_args)

			uip.reinit_window(field_dict, sortcolumn = sortcolumn)
			uip.resize_listpad(width = -1)
			uip.refresh_all()
			uip.force_update()
		elif c == ord("R") and logpad is not None:
			raw_output = not raw_output
			uip.refresh_all()
			uip.force_update()
		elif c == ord("W") and logpad is not None:
			wrap_lines = not wrap_lines
			uip.refresh_all()
			uip.force_update()
		elif c == ord("T"):
			uip.toggle_timestamps()
			uip.refresh_all()
			uip.force_update()

		for key, value in shortcuts.items():
			shortcut_keys = deep_get(value, DictPath("shortcut"))
			if shortcut_keys is None:
				continue

			if not isinstance(shortcut_keys, list):
				shortcut_keys = [shortcut_keys]

			if c not in shortcut_keys:
				continue

			widget = deep_get(value, DictPath("widget"))
			force_update = deep_get(value, DictPath("force_update"), True)
			changed = False
			tmpselection = None
			if widget is not None:
				if widget == "windowwidget":
					w_title = deep_get(value, DictPath("title"), "")
					w_headers = deep_get(value, DictPath("headers"))
					w_itemgetter = deep_get(value, DictPath("itemgetter"))
					if w_itemgetter is None:
						continue
					if isinstance(w_itemgetter, str):
						w_itemgetter = deep_get(itemgetter_allowlist, DictPath(w_itemgetter))
					w_itemgetter_args = deep_get(value, DictPath("itemgetter_args"), {})
					w_selectable = deep_get(value, DictPath("selectable"), False)
					# w_kind = deep_get(value, DictPath("kind"), view)
					if "_slow_task_msg" in w_itemgetter_args:
						_w_win = curses_helper.notice(uip.stdscr, uip.maxy // 2, uip.maxx // 2, message = deep_get(w_itemgetter_args, DictPath("_slow_task_msg")))
					w_items = w_itemgetter(kh, obj, **w_itemgetter_args)

					# If the first element is an integer we assume that we've been provided
					# a pre-formatted list. Otherwise we apply formatting if available.
					# If not available we try to provide some sensible defaults.
					# pylint: disable-next=unidiomatic-typecheck
					if w_items is not None and len(w_items) > 0 and (isinstance(w_items[0], dict) or isinstance(w_items[0], (list, tuple)) and type(w_items[0][0]) != int):  # noqa: E721
						tmp_items = []
						w_formatting = deep_get(value, DictPath("formatting"), [ThemeAttr("windowwidget", "default")])
						lineattrs = WidgetLineAttrs.NORMAL
						# w_item is a line
						for w_item in w_items:
							ref = None
							if isinstance(w_item, dict):
								ref = deep_get(w_item, DictPath("ref"))
								w_item = deep_get(w_item, DictPath("fields"))
							# w_item[i] is a column
							tmp = []
							for i in range(0, len(w_item)):
								tmp.append([ThemeString(w_item[i], w_formatting[min(i, len(w_formatting) - 1)])])

							tmp_items.append({
								"lineattrs": lineattrs,
								"columns": tmp,
								"retval": ref,
							})
						w_items = tmp_items

					if w_items is not None and len(w_items) > 0:
						w_sortcolumn = deep_get(value, DictPath("sortcolumn"))
						tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2,
											  items = w_items, headers = w_headers, title = w_title,
											  cursor = w_selectable, sortcolumn = w_sortcolumn)
						if len(tmpselection) == 0:
							continue
						changed = True
				elif widget == "inputbox":
					selected = uip.get_selected()
					w_title = deep_get(value, DictPath("inputtitle"), "")
					w_result = curses_helper.inputbox(uip.stdscr, uip.maxy // 2, 1, uip.maxy - 1, uip.maxx - 1, w_title)
					if w_result is None or len(w_result) == 0 or w_title == "":
						continue
					# This is necessary because we never go through the normal update cycle for the listpad and infopad
					uip.refresh_infopad()
					uip.refresh_listpad()
					uip.refresh_logpad()
					uip.refresh_statusbar()
					curses.doupdate()
					# Check this condition before confirming
					w_confirm = deep_get(value, DictPath("confirm"), False)
					if isinstance(w_confirm, str):
						if w_confirm == "path_exists":
							w_confirm = os.path.exists(w_result)
						else:
							sys.exit("Unknown value for w_confirm; must be either boolean or path_exists")
					if w_confirm:
						curses.doupdate()
						w_confirmtitle = deep_get(value, DictPath("confirmtitle"))
						if not curses_helper.confirmationbox(uip.stdscr, uip.maxy // 2, uip.maxx // 2, title = w_confirmtitle, default = False):
							continue
				elif widget == "command":
					w_args = deep_get(value, DictPath("widget_args"), {})
					if "_pass_obj" in w_args:
						w_args["obj"] = obj
					elif "_pass_selected_obj" in w_args:
						selected = uip.get_selected()
						if selected is not None:
							w_args["obj"] = getattr(selected, "ref")
					do_command(uip.stdscr, **w_args)
					changed = True
				elif widget == "executecommand":
					selected = uip.get_selected()
					w_kinds = deep_get_with_fallback(value, [DictPath("widget_args#kinds"), DictPath("kinds")])
					if w_kinds is None:
						continue
					w_ref = None
					if selected is not None:
						w_ref = getattr(selected, "ref", None)
					if w_kinds != ["<native>"] and [deep_get(w_ref, DictPath("kind"), ""), deep_get(w_ref, DictPath("api_group"), "")] not in w_kinds and w_kinds != [("", "")]:
						continue

					w_inputtitle = deep_get_with_fallback(value, [DictPath("widget_args#inputtitle"), DictPath("inputtitle")])
					if w_inputtitle is not None:
						w_input = curses_helper.inputbox(uip.stdscr, uip.maxy // 2, 1, uip.maxy - 1, uip.maxx - 1, title = w_inputtitle)
						w_command = w_input.split()
					else:
						w_command = deep_get_with_fallback(value, [DictPath("widget_args#command"), DictPath("command")], [])
					if len(w_command) == 0:
						continue

					w_waitforkeypress = deep_get(value, DictPath("widget_args#wait_for_keypress"), False)
					if not (w_kinds == ["<native>"] and w_command == ["<dnsutils>"]):
						containername = deep_get(w_ref, DictPath("name"), "")
					if w_command == [ "<ephemeral>" ]:
						ephemeral_image = deep_get(cmtlib.cmtconfig, DictPath("Debug#ephemeral_image"), "busybox")
						msg = [ANSIThemeString("Creating ephemeral ", "action"),
						       ANSIThemeString(ephemeral_image, "programname"),
						       ANSIThemeString(" container sharing process namespace with ", "action"),
						       ANSIThemeString(f"{containername}", "path")]
					elif w_command == [ "<dnsutils>" ]:
						node_name = deep_get(obj, DictPath("metadata#name"))
						containername = None
						msg = [ANSIThemeString("Opening dnsutils container on ", "action"),
						       ANSIThemeString(node_name, "hostname")]
					else:
						msg = [ANSIThemeString("Executing ", "action"),
						       ANSIThemeString(w_command[0], "programname"),
						       ANSIThemeString(" inside ", "action"),
						       ANSIThemeString(containername, "path")]
					executecommand(uip.stdscr, obj, containername, msg, command = w_command, waitforkeypress = w_waitforkeypress)
					changed = True
			if "action" in value:
				selected = uip.get_selected()
				action = deep_get(value, DictPath("action"), "")
				if action == "from_ref":
					ref = tmpselection
					action = deep_get(ref, DictPath("action"))
					action_call = deep_get(ref, DictPath("action_call"))
					_action_call = deep_get(action_call_allowlist, DictPath(action_call))
					if _action_call is None:
						sys.exit(f"{action_call} is not in the action_call allow list")
					action_call = _action_call
					action_args = deep_get(ref, DictPath("action_args"), {})
				else:
					action_call = deep_get(value, DictPath("action_call"))
					action_args = deep_get(value, DictPath("action_args"), {})
				if "_pass_obj" in action_args:
					action_args["obj"] = obj
				if "_pass_result" in action_args:
					action_args["result"] = w_result
				if "_pass_selected" in action_args and selected is not None:
					action_args["selected"] = selected
				if "_pass_selected_obj" in action_args and selected is not None:
					action_args["selected_obj"] = getattr(selected, "ref", None)
				if "_parent_namespace_path" in action_args:
					parent_namespace_path = deep_get(action_args, DictPath("_parent_namespace_path"))
					action_args["_parent_namespace"] = deep_get(obj, DictPath(parent_namespace_path), "")
				if "_named_title" in action_args:
					title = deep_get(action_args, DictPath("title"), "")
					title_name = ""
					if selected is not None:
						ref = getattr(selected, "ref", None)
					elif tmpselection is not None:
						ref = tmpselection
					if "_name_path" in action_args and ref is not None:
						title_name_path = deep_get(action_args, DictPath("_name_path"), "")
						title_name = deep_get(ref, DictPath(title_name_path), "")
					elif selected is not None:
						title_name = getattr(selected, "name", "")
					if title_name != "":
						title_name = f" ({title_name})"
					action_args["named_title"] = f"{title}{title_name}"

				if tmpselection is not None:
					action_args["selection"] = tmpselection
				if action == "call" and action_call is not None:
					retval = action_call(uip.stdscr, **action_args)
					if retval is not None and retval == Retval.RETURNFULL:
						return retval
				elif action == "toggle_var":
					var = deep_get(action_args, DictPath("var"))
					if var is not None:
						tmp = deep_get(infoview_args, DictPath(var))
						deep_set(infoview_args, DictPath(var), not tmp)
				elif action == "execute":
					_command = deep_get(action_args, DictPath("command"), [])
					# replace paths with data
					if len(_command) > 0:
						command = []
						for _cmd in _command:
							if isinstance(_cmd, list):
								command.append(deep_get_with_fallback(obj, _cmd))
							else:
								command.append(_cmd)
					# Check this condition before confirming
					w_confirm = deep_get(value, DictPath("confirm"), False)
					if isinstance(w_confirm, str):
						if w_confirm == "path_exists":
							w_confirm = os.path.exists(w_result)
						else:
							sys.exit("Unknown value for w_confirm; must be either boolean or path_exists")
					if w_confirm:
						curses.doupdate()
						w_confirmtitle = deep_get(value, DictPath("confirmtitle"))
						if not curses_helper.confirmationbox(uip.stdscr, uip.maxy // 2, uip.maxx // 2, title = w_confirmtitle, default = False):
							continue
					_values = {}
					_values = {
						"action_args": {
							"command": command,
							"iterate": True,
						}
					}
					items = [(deep_get(obj, DictPath("metadata#namespace"), ""), deep_get(obj, DictPath("metadata#name")))]
					action_execute_command(uip, items = items, action = {}, values = _values, kind = None, title = "")
			else:
				call = deep_get(value, DictPath("call"))
				call_name = None
				owner_references_path = deep_get(value, DictPath("owner_references_path"))
				owner_references_kind = deep_get(value, DictPath("owner_references_kind"))
				holder_identity_path = deep_get(value, DictPath("holder_identity_path"))
				if owner_references_path is not None:
					owner_reference = deep_get(obj, DictPath(owner_references_path), [])
					if holder_identity_path is not None:
						if len(owner_reference) == 0:
							continue
						call_name = deep_get(obj, DictPath(holder_identity_path))
						kind = get_holder_kind_from_owner_references(owner_reference, call_name)
					elif owner_references_kind is not None:
						call_name = get_name_by_kind_from_owner_references(owner_reference, owner_references_kind)
						kind = owner_references_kind
					else:
						kind, call_name = get_controller_from_owner_references(owner_reference)
					if kind == ("", "") or len(call_name) == 0:
						continue
				else:
					call_name_path = deep_get(value, DictPath("name_path"))
					kind = deep_get(value, DictPath("kind"))
					if kind is None:
						kind_path = deep_get(value, DictPath("kind_path"), "")
						if isinstance(kind_path, tuple):
							kind = (deep_get(obj, DictPath(kind_path[0])), deep_get(obj, DictPath(kind_path[1])))
						else:
							kind = deep_get(obj, DictPath(kind_path))
					if call_name_path is not None:
						call_name = deep_get(obj, DictPath(call_name_path))

				call_namespace_path = deep_get(value, DictPath("namespace_path"))
				call_namespace = ""
				if call_namespace_path is not None:
					call_namespace = deep_get(obj, DictPath(call_namespace_path))

				if call is not None and call_name is not None:
					if kind is None or kind == ("", ""):
						retval = call(uip.stdscr, **{"selected": call_name})
						if retval is not None and retval == Retval.RETURNFULL:
							return retval
					elif len(kind) > 0:
						if isinstance(kind, str):
							kind = guess_kind(kind)
						ref = kh.get_ref_by_kind_name_namespace(kind, call_name, call_namespace)
						retval = call(uip.stdscr, ref, kind)
						if retval is not None and retval == Retval.RETURNFULL:
							return retval
					changed = True
			if force_update:
				uip.force_update()

def eventdispatch(stdscr: curses.window, **kwargs):
	obj = deep_get(kwargs, DictPath("obj"))
	if obj is None:
		return Retval.RETURNDONE

	kind_path = deep_get(kwargs, DictPath("kind_path"))
	kind = deep_get_with_fallback(obj, kind_path)
	api_version_path = deep_get(kwargs, DictPath("api_version_path"))
	api_version = deep_get_with_fallback(obj, api_version_path, "")
	# Is this a core API?
	if "/" not in api_version:
		api_family = ""
	else:
		api_family = api_version.split("/")[0]
	kind = (kind, api_family)

	name_path = deep_get(kwargs, DictPath("name_path"))
	name = deep_get_with_fallback(obj, name_path)
	namespace_path = deep_get(kwargs, DictPath("namespace_path"))
	namespace = deep_get_with_fallback(obj, namespace_path + ["metadata#namespace"], "")
	ref = kh.get_ref_by_kind_name_namespace(kind, name, namespace)
	return resourceinfodispatch(stdscr, ref, kind)

# pylint: disable-next=too-many-arguments
def log_add_line(timestamps, facilities, severities, messages, timestamp, facility, severity, message, facility_extended):
	if timestamp is not None and timestamp != none_timestamp():
		timestamps.append(timestamp.astimezone())
	else:
		timestamps.append("")
	if facility_extended is None:
		facilities.append(facility)
	else:
		facilities.append((facility_extended, facility))
	severities.append(severity)
	messages.append(message)

	return timestamps, facilities, severities, messages

def containerinfoloop(stdscr: curses.window, container, kind, obj, **kwargs):
	global executor  # pylint: disable=global-statement
	global override_tail_lines  # pylint: disable=global-statement

	# Just in case there are leftover futures from other views
	executor.shutdown()
	executor = reexecutor.ReExecutor()

	multilog_containers_full = deep_get(kwargs, DictPath("multilog_containers_full"), [])
	multilog_containers = deep_get(kwargs, DictPath("multilog_containers"), [])
	all_same_namespace = deep_get(kwargs, DictPath("all_same_namespace"), False)
	multilog_prefix = ["namespace", "podname", "container"]
	facility_extended = None

	uip = UIProps(stdscr)

	helptext = format_helptext(helptexts.containerinfo)
	uip.init_window(field_list = None, windowheader = "Container Info", helptext = helptext)

	# For generic information
	infopad = uip.init_infopad(height = 7, width = -1, ypos = 1, xpos = 1)

	# For the pod log
	tspad, logpad = uip.init_logpad(width = -1, ypos = 9, xpos = 1)

	# For the status bar; position is always at the bottom of the screen and the entire width of the screen
	statusbar = uip.init_statusbar()

	# Number of lines of log to show by default
	if override_tail_lines is None:
		override_tail_lines = deep_get(cmtlib.cmtconfig, DictPath("Pod#logsize"), default_tail_lines)

	tail_lines = override_tail_lines

	uip.continuous_log = False
	merge_repeats = deep_get(cmtlib.cmtconfig, DictPath("Pod#merge_repeated_messages"), False)
	saved_merge_repeats = merge_repeats
	raw_logs = False
	tmp_log_level = deep_get(cmtlib.cmtconfig, DictPath("Pod#loglevel"), "Info")
	log_level = name_to_loglevel(tmp_log_level)
	show_borders = deep_get(cmtlib.cmtconfig, DictPath("Pod#show_borders"), True)
	uip.toggle_borders(show_borders)
	show_timestamps = deep_get(cmtlib.cmtconfig, DictPath("Pod#show_timestamps"), True)
	uip.toggle_timestamps(show_timestamps)
	# Currently not working properly
	compact_timestamps = False
	# Currently not working properly
	only_new_dates = False
	# Currently not working properly
	highlight_new_dates = False
	wrap_lines = False
	# Show severity as text
	severity_prefix = deep_get(cmtlib.cmtconfig, DictPath("Pod#severity_prefix"), [])
	# Backwards compatibility
	# pylint: disable-next=unidiomatic-typecheck
	if type(severity_prefix) == bool:  # noqa: E721
		if not severity_prefix:
			severity_prefix = []
		else:
			severity_prefix = ["[", "4LETTER", "] "]

	# This decides whether or not compound log messages,
	# such as Python dicts and JSON, should be expanded
	fold_msg = deep_get(cmtlib.cmtconfig, DictPath("Pod#fold_msg"), True)
	saved_fold_msg = fold_msg

	# This decides whether or not to show the facility,
	# and if so how it is to be displayed
	show_facility = deep_get(cmtlib.cmtconfig, DictPath("Pod#show_facility"), "Full")
	override_parser = None
	_parser = None

	reload = False

	uip.update_window()
	uip.force_update()
	uip.refresh_window()
	uip.refresh_statusbar()
	curses.doupdate()

	facility_regex = re.compile(r"^.*/(.*)")

	while True:
		if uip.is_update_triggered():
			# When following the log we update the log continuously, but tail lines is limited to the number of lines
			# that fits on the screen, and cursor movements are disabled; as soon as the user presses a key the log
			# will stop scrolling and the whole log (default number of tail lines) will be loaded
			if uip.continuous_log:
				tail_lines = uip.logpadheight

			if len(multilog_containers) == 0:
				pod_info = get_pod_info(**{"_vlist": [obj]})[0]
				podname = pod_info.name
				namespace = pod_info.namespace
				containername = deep_get(container, DictPath("name"))

				if kind == ("InitContainer", ""):
					src_statuses = deep_get(pod_info.ref, DictPath("status#initContainerStatuses"), [])
					container_type = "init_container"
				else:
					src_statuses = deep_get(pod_info.ref, DictPath("status#containerStatuses"), [])
					container_type = "container"
				container_status = None
				for container_status in src_statuses:
					if deep_get(container_status, DictPath("name")) == containername:
						break
				if container_status is not None:
					image_id = deep_get(container_status, DictPath("imageID"), "")
					image = deep_get(container_status, DictPath("image"), "")
					if image.startswith("sha256:"):
						image = image_id
				else:
					image = "<unavailable>"

			# We do not want the "Fetching Log" notification every few seconds; we are just loading a few lines...
			if not uip.continuous_log:
				notice = curses_helper.notice(None, y = uip.maxy // 2, x = uip.maxx // 2, message = "Fetching log")
			if len(multilog_containers) == 0:
				rawmsg, internal_error = get_pod_log_by_name_namespace_container(podname, namespace, containername, tail_lines = tail_lines)
				splitmsg = split_msg(rawmsg)
			else:
				container_type = "container"
				splitmsg = []
				image_id = None
				for namespace, podname, containername, image_id in multilog_containers_full:
					if len(multilog_containers) == 1:
						facility_extended = None
					elif multilog_prefix == ["container"]:
						facility_extended = [
							ThemeRef("separators", "facility_extended_prefix"),
							ThemeString(f"{containername}", ThemeAttr("types", "facility_extended")),
							ThemeRef("separators", "facility_extended_suffix"),
						]
					elif multilog_prefix == ["podname", "container"] or multilog_prefix == ["namespace", "podname", "container"] and all_same_namespace:
						facility_extended = [
							ThemeRef("separators", "facility_extended_prefix"),
							ThemeString(f"{podname}", ThemeAttr("types", "facility_extended")),
							ThemeRef("separators", "container"),
							ThemeString(f"{containername}", ThemeAttr("types", "facility_extended")),
							ThemeRef("separators", "facility_extended_suffix"),
						]
					elif multilog_prefix == ["namespace", "podname", "container"]:
						facility_extended = [
							ThemeRef("separators", "facility_extended_prefix"),
							ThemeString(f"{namespace}", ThemeAttr("types", "facility_extended")),
							ThemeRef("separators", "namespace"),
							ThemeString(f"{podname}", ThemeAttr("types", "facility_extended")),
							ThemeRef("separators", "container"),
							ThemeString(f"{containername}", ThemeAttr("types", "facility_extended")),
							ThemeRef("separators", "facility_extended_suffix"),
						]
					rawmsg, internal_error = get_pod_log_by_name_namespace_container(podname, namespace, containername, tail_lines = tail_lines)
					if internal_error:
						splitmsg = split_msg(rawmsg)
						break
					# Now we have one per line; now we need to add (podname, containername, image, facility_extended) to each line, to allow the logparser
					# to function without guessing
					for line in split_msg(rawmsg):
						splitmsg.append((line, podname, containername, image_id, facility_extended))
				splitmsg = natsorted(splitmsg, key = itemgetter(0))

			if not uip.continuous_log:
				del notice
			uip.refresh_window()
			uip.refresh_infopad()
			uip.refresh_logpad()
			uip.refresh_statusbar()
			curses.doupdate()

			timestamps = []
			facilities = []
			severities = []
			messages = []
			parser = None
			prev_timestamp = None
			prev_facility = ""
			prev_severity = LogLevel.INFO
			prev_message = [ThemeString("", ThemeAttr("types", "generic"))]
			prev_remnants = None
			repeat_count = 0

			total_msgs = 0
			hidden_msgs = 0
			merged_lines = 0

			linecount = len(splitmsg)
			linepercent = int(linecount * 0.1)

			progressbar = None
			if linecount > 1000:
				progressbar = curses_helper.progressbar(None, y = uip.maxy // 2, minx = (uip.minx + 8), maxx = (uip.maxx - 8), progress = 0, title = "Parsing log")

			i = 0
			while i < len(splitmsg):
				_line = splitmsg[i]

				# We probably need a progress bar once we reach this many lines
				if linecount > 1000 and (i % linepercent) == 0:
					curses_helper.progressbar(progressbar, y = uip.maxy // 2, minx = (uip.minx + 8), maxx = (uip.maxx - 8), progress = 100 - 100 * ((linecount - i) // linecount))
					progressbar.timeout(10)
					c = progressbar.getch()
					if c == 27:	# ESCAPE
						return Retval.RETURNDONE

				if isinstance(_line, tuple):
					line, podname, containername, image, facility_extended = _line
					# We need to identify parser again and again and again for every line
					_parser = None
				else:
					line = _line
				if internal_error:
					timestamp, facility, severity, message, remnants, parser, _parser = logparser("internal_error", "", "", message = line, container_type = container_type, line = i)
				elif raw_logs:
					timestamp, facility, severity, message, remnants, parser, _parser = logparser("raw", "", "", message = line, container_type = container_type, line = i)
				elif override_parser is not None or _parser is None or parser is None:
					timestamp, facility, severity, message, remnants, parser, _parser = logparser(podname, containername, image, message = line, fold_msg = fold_msg, override_parser = override_parser, container_type = container_type, line = i)
				else:
					timestamp, facility, severity, message, remnants = logparser_initialised(parser = _parser, message = line, fold_msg = fold_msg, line = i)

				i += 1

				# In some cases rather than expanding a single line into multiple lines,
				# we want to parse multiple lines as a single block;
				# we signal this by returning message == ["start_block", processor],
				# then continue parsing until we either get ["end_block", *],
				# ["break", *], or reach the end of the file
				if isinstance(message, tuple) and message[0] == "start_block" and not raw_logs:
					_logentries = [(timestamp, facility, severity, remnants)]
					processor = message
					options = processor[2]
					_block_state = "none"
					for j in range(i, len(splitmsg)):
						processor, _logentry = processor[1](splitmsg[j], fold_msg = fold_msg, options = options)
						_block_state = processor[0]
						if _block_state != "end_block_not_processed":
							_logentries.append(_logentry)

						if _block_state in ("end_block", "end_block_not_processed"):
							# OK, we've got a block; start by appending the first line
							if len(_logentries) > 0:
								timestamps, facilities, severities, messages = log_add_line(timestamps, facilities, severities, messages, timestamp, facility, severity, _logentries[0][3], facility_extended)
							if len(_logentries) > 1:
								for _timestamp, _facility, _severity, _message in _logentries[1:]:
									timestamps, facilities, severities, messages = log_add_line(timestamps, facilities, severities, messages, _timestamp, "".ljust(len(facility)), severity, _message, facility_extended)
								break
						elif _block_state == "break":
							# We got something indicating that this is not a valid block; abort
							break
					else:
						if len(_logentries) > 0 and deep_get(options, DictPath("eof"), "break") == "end_block":
							for _timestamp, _facility, _severity, _message in _logentries:
								timestamps, facilities, severities, messages = log_add_line(timestamps, facilities, severities, messages, _timestamp, "".ljust(len(facility)), severity, _message, facility_extended)
							_block_state = "end_block"
						else:
							_block_state = "break"

					if _block_state == "end_block":
						# We got a block and it has been appended, so go on
						i = j + 1
						continue

					if _block_state == "end_block_not_processed":
						# We got a block and it has been appended, but the last line needs processing again
						i = j
						continue

					message = remnants
					remnants = None

				total_msgs += 1

				if severity > log_level:
					hidden_msgs += 1
					continue

				if prev_message == message and prev_facility == facility and prev_severity == severity and \
				   (themearray_len(prev_message) > 0 or prev_remnants is not None) and prev_remnants == remnants:
					repeat_count += 1
					prev_timestamp = timestamp
					if merge_repeats:
						merged_lines += 1
						continue
				else:
					if repeat_count > 0 and merge_repeats:
						timestamps, facilities, severities, messages =\
							log_add_line(timestamps, facilities, severities, messages, prev_timestamp, prev_facility, prev_severity,
								     [ThemeString("[previous message repeated ", color_log_severity(prev_severity)),
								      ThemeString(f"{repeat_count}", ThemeAttr("logview", "repeat_count")),
								      ThemeString(" times]", color_log_severity(prev_severity))],
								     facility_extended)
					repeat_count = 0
					prev_timestamp = timestamp
					prev_facility = facility
					prev_severity = severity
					prev_message = message
					prev_remnants = remnants

				timestamps, facilities, severities, messages = \
						log_add_line(timestamps, facilities, severities, messages, timestamp, facility, severity, message, facility_extended)

				if remnants is not None and len(remnants) > 0:
					# Remnants are used for unfolding multi-line messages that have been folded into one,
					# such as YAML/JSON, etc.
					#
					# Remnants can, for the time being, be either:
					# (list of string, severity)
					# (string(newline separated strings), severity)
					# or
					# [(string, severity), ...]
					if isinstance(remnants, tuple):
						tmpmessages, severity = remnants

						if isinstance(tmpmessages, list):
							for message in tmpmessages:
								timestamps, facilities, severities, messages = log_add_line(timestamps, facilities, severities, messages, None, "".ljust(len(facility)), severity, message, facility_extended)
						else:
							for message in tmpmessages.split("\n"):
								timestamps, facilities, severities, messages = log_add_line(timestamps, facilities, severities, messages, None, "".ljust(len(facility)), severity, message, facility_extended)
					else:
						for message, severity in remnants:
							timestamps, facilities, severities, messages = log_add_line(timestamps, facilities, severities, messages, None, "".ljust(len(facility)), severity, message, facility_extended)

			reload = True

			# The data in some fields might become shorter, so we need to trigger a clear
			uip.infopad.erase()
			uip.statusbar.erase()

			del progressbar

			# If the last message in the log is a repeat we need to add the repeat signature
			if repeat_count > 0 and merge_repeats:
				timestamps, facilities, severities, messages =\
					log_add_line(timestamps, facilities, severities, messages, prev_timestamp, prev_facility, prev_severity,
						     [ThemeString("[previous message repeated ", color_log_severity(prev_severity)),
						      ThemeString(f"{repeat_count}", ThemeAttr("logview", "repeat_count")),
						      ThemeString(" times]", color_log_severity(prev_severity))],
						     facility_extended)

			uip.update_log_info(timestamps, facilities, severities, messages)
			uip.loglen = len(messages)
			uip.update_window()

			if len(multilog_containers) == 0:
				containertypearray = f" [Type: {kind[0]}]"
				if kind == ("InitContainer", ""):
					src_statuses = deep_get(pod_info.ref, DictPath("status#initContainerStatuses"))
				else:
					src_statuses = deep_get(pod_info.ref, DictPath("status#containerStatuses"))

				if src_statuses is None or len(src_statuses) == 0:
					break

				for container_status in src_statuses:
					if deep_get(container_status, DictPath("name")) == containername:
						break

				status, status_group, restarts, message, _age = datagetters.get_container_status(src_statuses, containername)
				containerarray: List[Union[ThemeRef, ThemeString]] = [
					ThemeString("Container: ", ThemeAttr("main", "infoheader")),
					ThemeString(f"{containername}{containertypearray}", ThemeAttr("types", "generic"))
				]
				statusarray: List[Union[ThemeRef, ThemeString]] = [
					ThemeString("Status: ", ThemeAttr("main", "infoheader")),
					ThemeString(f"{status}", color_status_group(status_group))
				]
				if message != "":
					statusarray.append(ThemeString(f" ({message})", ThemeAttr("types", "generic")))
				restartsarray: List[Union[ThemeRef, ThemeString]] = [
					ThemeString("Restarts: ", ThemeAttr("main", "infoheader")),
					ThemeString(f"{restarts}", ThemeAttr("types", "numerical"))
				]
				podarray: List[Union[ThemeRef, ThemeString]] = [
					ThemeString("Pod: ", ThemeAttr("main", "infoheader")),
					ThemeString(f"{pod_info.name}", ThemeAttr("types", "generic")),
				]
				containeridarray: List[Union[ThemeRef, ThemeString]] = [
					ThemeString("Container ID: ", ThemeAttr("main", "infoheader")),
					ThemeString(f"{deep_get(container_status, DictPath('containerID'))}", ThemeAttr("types", "generic")),
				]
				image_name, image_version = get_image_tuple(deep_get(container_status, DictPath("image")))
				imagearray: List[Union[ThemeRef, ThemeString]] = [
					ThemeString("Image: ", ThemeAttr("main", "infoheader")),
					ThemeString(f"{image_name}", ThemeAttr("types", "generic")),
					ThemeRef("separators", "version"),
					ThemeString(f"{image_version}", ThemeAttr("types", "version")),
				]
				image_id = deep_get(container_status, DictPath("imageID"))
				imageidarray: List[Union[ThemeRef, ThemeString]] = [
					ThemeString("I", ThemeAttr("main", "infoheader_shortcut")),
					ThemeString("mage ID: ", ThemeAttr("main", "infoheader")),
					ThemeString(f"{image_id}", ThemeAttr("types", "generic")),
				]
				uip.addthemearray(infopad, containerarray, y = 0, x = 0)
				uip.addthemearray(infopad, statusarray, y = 1, x = 0)
				uip.addthemearray(infopad, restartsarray, y = 2, x = 0)
				uip.addthemearray(infopad, podarray, y = 3, x = 0)
				uip.addthemearray(infopad, containeridarray, y = 4, x = 0)
				uip.addthemearray(infopad, imagearray, y = 5, x = 0)
				uip.addthemearray(infopad, imageidarray, y = 6, x = 0)
			else:
				if len(multilog_containers) == 1:
					containerarray = [
						ThemeString("Container: ", ThemeAttr("main", "infoheader")),
						ThemeString(f"{containername}", ThemeAttr("types", "generic")),
					]
					podarray = [
						ThemeString("Pod: ", ThemeAttr("main", "infoheader")),
						ThemeString(f"{podname}", ThemeAttr("types", "generic")),
					]
					namespacearray: List[Union[ThemeRef, ThemeString]] = [
						ThemeString("Namespace: ", ThemeAttr("main", "infoheader")),
						ThemeString(f"{namespace}", ThemeAttr("types", "namespace")),
					]
					containeridarray = [
						ThemeString("I", ThemeAttr("main", "infoheader_shortcut")),
						ThemeString("mage ID: ", ThemeAttr("main", "infoheader")),
						ThemeString(f"{image_id}", ThemeAttr("types", "generic")),
					]
					uip.addthemearray(infopad, podarray, y = 1, x = 0)
					uip.addthemearray(infopad, namespacearray, y = 2, x = 0)
					uip.addthemearray(infopad, containeridarray, y = 3, x = 0)
				else:
					containerarray = [
						ThemeString("Containers: ", ThemeAttr("main", "infoheader")),
					]
					containerarray += generators.format_list(multilog_containers, 0, 0, False, False,
										 field_colors = [
											ThemeAttr("types", "namespace"),
											ThemeAttr("types", "generic"),
											ThemeAttr("types", "generic")
										 ],
										 field_separators = [
											ThemeRef("separators", "namespace"),
											ThemeRef("separators", "container")
										 ],
										 ellipsise = 3)
					if all_same_namespace:
						namespacearray = [
							ThemeString("Namespace: ", ThemeAttr("main", "infoheader")),
							ThemeString(f"{namespace}", ThemeAttr("types", "namespace")),
						]
						uip.addthemearray(infopad, namespacearray, y = 1, x = 0)
				uip.addthemearray(infopad, containerarray, y = 0, x = 0)

			uip.refresh = True

		if uip.refresh:
			# FIXME: the status stuff should be done by curses_helper
			theme = get_theme_ref()
			uip.statusbar.erase()

			if uip.continuous_log:
				interval = "Follow"
			else:
				interval = "Manual"

			if tail_lines == sys.maxsize:
				loglimit = "Unlimited"
			else:
				loglimit = f"{tail_lines}"

			loglevel_str = loglevel_to_name(log_level)

			# We have two different widths of the statusbar
			if uip.maxx - uip.minx > 108:
				# Wide version
				statusarray1: List[Union[ThemeRef, ThemeString]] = [
					ThemeString("Updates: ", ThemeAttr("statusbar", "infoheader")),
					ThemeString(f"{interval}", ThemeAttr("statusbar", "highlight")),
					ThemeRef("separators", "statusbar"),
					ThemeString("Loglvl: ", ThemeAttr("statusbar", "infoheader")),
					ThemeString(f"{loglevel_str}", ThemeAttr("statusbar", "highlight")),
					ThemeRef("separators", "statusbar"),
					ThemeString("Log length: ", ThemeAttr("statusbar", "infoheader")),
					ThemeString(f"{uip.loglen} ", ThemeAttr("statusbar", "highlight")),
					ThemeString("lines (", ThemeAttr("statusbar", "default")),
				]
				if hidden_msgs > 0:
					statusarray1 += [
						ThemeString(f"{hidden_msgs}", ThemeAttr("statusbar", "highlight")),
						ThemeString(" messages hidden)", ThemeAttr("statusbar", "dim")),
						ThemeString("; ", ThemeAttr("statusbar", "default")),
					]
				statusarray1 += [
					ThemeString("limit: ", ThemeAttr("statusbar", "default")),
					ThemeString(f"{loglimit}", ThemeAttr("statusbar", "highlight")),
					ThemeString(")", ThemeAttr("statusbar", "default")),
				]
				statusarray2: List[Union[ThemeRef, ThemeString]] = []
				if not fold_msg:
					statusarray2 += [
						ThemeString("Unfolding messages", ThemeAttr("statusbar", "highlight")),
						ThemeRef("separators", "statusbar"),
					]
				if merge_repeats:
					statusarray2 += [
						ThemeString("Repeats merged", ThemeAttr("statusbar", "highlight")),
						ThemeRef("separators", "statusbar"),
					]

				statusarray2 += [
					ThemeString("Facility: ", ThemeAttr("statusbar", "infoheader")),
					ThemeString(f"{show_facility}", ThemeAttr("statusbar", "highlight")),
					ThemeRef("separators", "statusbar"),
					ThemeString("Format: ", ThemeAttr("statusbar", "infoheader")),
				]
			else:
				# Compact version
				statusarray1 = [
					ThemeString("Updates: ", ThemeAttr("statusbar", "infoheader")),
					ThemeString(f"{interval}", ThemeAttr("statusbar", "highlight")),
					ThemeRef("separators", "statusbar_compact"),
					ThemeString("Loglvl: ", ThemeAttr("statusbar", "infoheader")),
					ThemeString(f"{loglevel_str}", ThemeAttr("statusbar", "highlight")),
					ThemeRef("separators", "statusbar_compact"),
					ThemeString(f"{uip.loglen} ", ThemeAttr("statusbar", "highlight")),
					ThemeString("lines (", ThemeAttr("statusbar", "default")),
				]
				if hidden_msgs > 0:
					statusarray1 += [
						ThemeString(f"{hidden_msgs}", ThemeAttr("statusbar", "highlight")),
						ThemeString(" hidden", ThemeAttr("statusbar", "dim")),
						ThemeString("; ", ThemeAttr("statusbar", "default")),
					]
				statusarray1 += [
					ThemeString("max: ", ThemeAttr("statusbar", "default")),
					ThemeString(f"{loglimit}", ThemeAttr("statusbar", "highlight")),
					ThemeString(")", ThemeAttr("statusbar", "default")),
				]
				statusarray2 = [
				]
				if not fold_msg:
					statusarray2 += [
						ThemeString("Unfolding", ThemeAttr("statusbar", "highlight")),
						ThemeRef("separators", "statusbar_compact"),
					]
				if merge_repeats:
					statusarray2 += [
						ThemeString("Repeats merged", ThemeAttr("statusbar", "highlight")),
						ThemeRef("separators", "statusbar_compact"),
					]

				statusarray2 += [
					ThemeString("Facility: ", ThemeAttr("statusbar", "infoheader")),
					ThemeString(f"{show_facility}", ThemeAttr("statusbar", "highlight")),
					ThemeRef("separators", "statusbar_compact"),
					ThemeString("Format: ", ThemeAttr("statusbar", "infoheader")),
				]

			if len(rawmsg) == 0:
				statusarray2 += [
					ThemeString("Empty", ThemeAttr("main", "format_empty")),
				]
			elif parser is None or parser[0] == "unknown":
				statusarray2 += [
					ThemeString("Unknown", ThemeAttr("main", "format_unknown")),
				]
			elif raw_logs:
				statusarray2 += [
					ThemeString("Raw", ThemeAttr("main", "format_raw")),
				]
			else:
				if uip.maxx - uip.minx > 118:
					statusarray2 += [
						ThemeString(f"{parser[0]}:{parser[1]}", ThemeAttr("statusbar", "highlight")),
					]
				else:
					statusarray2 += [
						ThemeString(f"{parser[0]}", ThemeAttr("statusbar", "highlight")),
					]
				if uip.maxx - uip.minx > 128 and logparser_configuration.using_bundles:
					statusarray2 += [
						ThemeString(" (Bundle)", ThemeAttr("statusbar", "dim")),
					]

			uip.addthemearray(statusbar, statusarray1, y = 0, x = 0)
			uip.addthemearray(statusbar, statusarray2, y = 1, x = 0)

			maxlen = 0
			latest_facility_len = -1

			uip.tspad.erase()
			uip.logpad.erase()
			# This is needed in case we get a resize event or toggle borders
			uip.resize_logpad(uip.maxy - uip.logpadypos - 2, 0)
			new_date = False
			if timestamps is not None and len(timestamps) > 0:
				current_datestamp = str(timestamps[0])[0:len("YYYY-MM-DD")]
				new_date = True
			yadd = 0
			for y in range(0, min(uip.logpadheight, uip.loglen)):
				if uip.yoffset + y >= len(timestamps):
					timestamp = "".ljust(uip.tspadwidth)
				else:
					timestamp = str(timestamps[uip.yoffset + y]).ljust(uip.tspadwidth)
					datestamp = timestamp[0:len("YYYY-MM-DD ")]
					if current_datestamp is not None and isinstance(timestamps[uip.yoffset + y], datetime) and datestamp != current_datestamp:
						current_datestamp = datestamp
						new_date = True
				hourstamp = timestamp[len("YYYY-MM-DD "):]

				if new_date and highlight_new_dates:
					datetype = "timestamp_newdate"
				else:
					datetype = "timestamp"

				if not compact_timestamps:
					hourxpos = len("YYYY-MM-DD ")
				else:
					hourxpos = 0

				if y + yadd > uip.logpadheight:
					continue

				tsstrarray = None
				# FIXME
				if only_new_dates:
					if new_date:
						tsthemearray: List[Union[ThemeRef, ThemeString]] = [ThemeString(datestamp, ThemeAttr("logview", datetype))]
						new_date = False
						# If we do empty lines for new dates we need something like this
						# uip.addstr(logpad, "", y = y + yadd, x = 0)
						# yadd += 1
				else:
					tsthemearray = [ThemeString(datestamp, ThemeAttr("logview", datetype))]

				tsthemearray += [ThemeString(hourstamp, ThemeAttr("logview", "timestamp"))]

				new_date = False

				if show_facility == "None" or uip.yoffset + y >= len(facilities):
					facility_extended = ""
					facility = ""
				elif show_facility == "Short":
					_facility = facilities[uip.yoffset + y]
					if isinstance(_facility, tuple):
						facility_extended, _facility = _facility
					if _facility is None:
						_facility = ""
					tmp = facility_regex.match(_facility)
					if tmp is not None:
						facility = tmp[1]
						latest_facility_len = len(facility)
					elif len(_facility.strip()) != len(_facility) and len(_facility.strip()) == 0:
						if latest_facility_len == -1:
							facility = _facility
						else:
							facility = _facility[0:latest_facility_len]
					else:
						facility = _facility
				else:
					facility = facilities[uip.yoffset + y]
					if isinstance(facility, tuple):
						facility_extended, facility = facility
					if facility is None:
						facility = ""

				if uip.yoffset + y >= len(severities):
					severity = LogLevel.INFO
				else:
					severity = severities[uip.yoffset + y]

				msgstrarray: List[ThemeRef, ThemeString] = []

				if len(severity_prefix) > 0:
					_prefix, _severity_type, _suffix = severity_prefix
					if _severity_type.lower() == "letter":
						_severity_str = lvl_to_letter_severity(severity)
					elif _severity_type.lower() == "4letter":
						_severity_str = lvl_to_4letter_severity(severity)
					elif _severity_type.lower() == "full":
						_severity_str = lvl_to_word_severity(severity)

					if _severity_type.startswith(("LE", "4LE", "FU")):
						_severity_str = f"{_prefix}{_severity_str.upper()}{_suffix}"
					elif _severity_type.startswith(("Le", "4Le", "Fu")):
						_severity_str = f"{_prefix}{_severity_str.capitalize()}{_suffix}"
					else:
						_severity_str = f"{_prefix}{_severity_str.lower()}{_suffix}"

					if len(timestamp.strip()) != 0 or y >= len(timestamps):
						msgstrarray.append(ThemeString(f"{_severity_str}", color_log_severity(severity)))
					else:
						msgstrarray.append(ThemeString("".ljust(len(f"{_severity_str}")), color_log_severity(severity)))

				if facility_extended is not None and len(facility_extended) > 0:
					msgstrarray += facility_extended

				if facility != "":
					facilitystr: List[Union[ThemeRef, ThemeString]] = [
						ThemeRef("separators", "facility_prefix"),
						ThemeString(facility, ThemeAttr("logview", "facility")),
						ThemeRef("separators", "facility_suffix"),
						ThemeRef("separators", "facility_padding"),
					]
					# We do not actually want any prefix, but we want empty padding of the same length
					if facility.rstrip() == "":
						facilitystr = [ThemeString("".ljust(themearray_len(facilitystr)), ThemeAttr("logview", "severity_debug"))]
					msgstrarray += facilitystr

				msg = messages[uip.yoffset + y]
				if not isinstance(msg, list):
					msgstrarray.append(ThemeString(msg, color_log_severity(severity)))
				else:
					msgstrarray += msg
				if wrap_lines:
					sideadjust = 0
					if not uip.borders:
						sideadjust = 2
					maxwidth = uip.maxx - uip.logpadxpos + sideadjust
				else:
					maxwidth = -1
				msgstrarrays = themearray_wrap_line(msgstrarray, maxwidth, wrap_marker = (uip.borders or get_mousemask() != 0))
				for i, msgstrarray in enumerate(msgstrarrays):
					if y + yadd + i >= uip.logpadheight:
						break
					if i == 0 and tspad is not None:
						uip.addthemearray(tspad, tsthemearray, y = y + yadd, x = 0)
					cury, curx = uip.addthemearray(logpad, msgstrarray, y = y + yadd + i, x = 0)
					maxlen = max(maxlen, themearray_len(msgstrarray))
				yadd += i
			uip.resize_logpad(-1, maxlen)

			uip.refresh_window()
			uip.refresh_infopad()
			uip.refresh_logpad()
			uip.refresh_statusbar()
			curses.doupdate()
			uip.refresh = False

		uip.stdscr.timeout(100)
		c = uip.stdscr.getch()
		retval = uip.generic_keycheck(c)

		if retval == Retval.MATCH:
			continue
		if retval == Retval.RETURNONE:
			return Retval.RETURNDONE
		if retval == Retval.RETURNFULL:
			return retval

		if c == curses.KEY_F2:
			retval = selectwindow(uip)
			if retval == Retval.RETURNFULL:
				return retval
			uip.refresh_all()
		elif c == curses.KEY_F3:
			retval = selectwindow(uip, refresh_apis = True)
			if retval == Retval.RETURNFULL:
				return retval
			uip.refresh_all()
		elif c == ord("B"):
			uip.toggle_borders()
			uip.refresh_all()
			uip.force_update()
		elif c == curses.KEY_F4:
			if uip.continuous_log:
				# Disable log tailing
				uip.continuous_log = False
				tail_lines = override_tail_lines
				uip.set_update_delay(-1)
				# When we disable tailing we would ideally want to be at the end, but we do not know where the end is
				# so, stay on top...
			else:
				# Enable log tailing
				uip.continuous_log = True
				tail_lines = uip.logpadheight
				uip.set_update_delay(10)
			uip.yoffset = 0
			uip.xoffset = 0
			uip.force_update()
		elif c == curses.KEY_F8:
			if uip.continuous_log:
				continue

			# Toggle full logs; this might be VERY slow
			uip.continuous_log = False

			if tail_lines == override_tail_lines:
				if curses_helper.confirmationbox(uip.stdscr, uip.maxy // 2, uip.maxx // 2, title = "Show full log (Potentially very slow):", default = False):
					tail_lines = sys.maxsize
			else:
				tail_lines = override_tail_lines

			uip.refresh_infopad()
			uip.refresh_logpad()
			uip.refresh_statusbar()
			curses.doupdate()
			uip.force_update()
		elif c == ord("I"):
			# XXX: This is very inefficient
			_vlist = get_container_info()
			retval = None
			for _obj in _vlist:
				if _obj.name == containername and _obj.image_id == image_id:
					retval = resourceinfodispatch(stdscr, _obj.ref, ("__Container", ""))
					uip.force_update()
					break
			if retval is not None and retval == Retval.RETURNFULL:
				return retval
		elif c == ord("O"):
			option_list = [
				{
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Pop timestamps", ThemeAttr("windowwidget", "default"))]],
					"retval": "pop_ts",
				},
				{
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Pop severity", ThemeAttr("windowwidget", "default"))]],
					"retval": "pop_severity",
				},
				{
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Pop facility", ThemeAttr("windowwidget", "default"))]],
					"retval": "pop_facility",
				},
				{
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Extract message", ThemeAttr("windowwidget", "default"))]],
					"retval": "msg_extract",
				},
				{
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Message first", ThemeAttr("windowwidget", "default"))]],
					"retval": "msg_first",
				},
				{
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Override severity", ThemeAttr("windowwidget", "default"))]],
					"retval": "override_severity",
				},
				{
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Replace bullets", ThemeAttr("windowwidget", "default"))]],
					"retval": "msg_realbullets",
				},
				{
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Collector bullets", ThemeAttr("windowwidget", "default"))]],
					"retval": "bullet_collectors",
				},
				{
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Merge starting version", ThemeAttr("windowwidget", "default"))]],
					"retval": "merge_starting_version",
				},
				{
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Expand newlines (WIP)", ThemeAttr("windowwidget", "default"))]],
					"retval": "expand_newlines",
				},
				{
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Expand tabs (WIP)", ThemeAttr("windowwidget", "default"))]],
					"retval": "expand_tabs",
				},
			]
			preselection = set()

			for i, option in enumerate(option_list):
				retval = False
				option_path = deep_get(option, DictPath("retval"))
				if option_path is not None:
					retval = getattr(logparser_configuration, option_path, False)
				if retval:
					preselection.add(i)

			tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, option_list, title = "Parser options", cursor = True, preselection = preselection, taggable = True)
			selection = None
			if tmpselection is not None and tmpselection != "":
				selection = tmpselection
			uip.refresh_all()

			# Some option changed, so we need to re-render the log
			if selection is not None and preselection != selection:
				# Perform the changes
				modified_options = preselection.symmetric_difference(selection)
				for i in modified_options:
					option_path = deep_get(option_list[i], DictPath("retval"))
					value = not getattr(logparser_configuration, option_path, False)
					setattr(logparser_configuration, option_path, value)

				uip.yoffset = 0
				uip.xoffset = 0
				uip.force_update()
		elif c == ord("R"):
			if uip.continuous_log:
				continue

			if not raw_logs:
				saved_fold_msg = fold_msg
				saved_merge_repeats = merge_repeats
				fold_msg = True
				merge_repeats = False
			else:
				fold_msg = saved_fold_msg
				merge_repeats = saved_merge_repeats
			raw_logs = not raw_logs
			uip.yoffset = 0
			uip.xoffset = 0
			uip.force_update()
		elif c == ord("P"):
			parserlist = [{
				"lineattrs": WidgetLineAttrs.NORMAL,
				"columns": [[ThemeString("<autodetect>", ThemeAttr("windowwidget", "default"))]],
				"retval": "<autodetect>",
			}]
			for parser in natsorted(get_parser_list()):
				parserlist.append({
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString(f"{parser}", ThemeAttr("windowwidget", "default"))]],
					"retval": parser,
				})

			if override_parser is None:
				preselection = "<autodetect>"
			else:
				preselection = override_parser
			tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, parserlist, title = "Override Logparser", cursor = True, preselection = preselection)
			selection = None
			if tmpselection is not None and tmpselection != "":
				selection = tmpselection
			uip.refresh_all()
			if selection is not None and len(selection) > 0:
				if selection == "<autodetect>":
					override_parser = None
				else:
					override_parser = selection
				_parser = None
			uip.yoffset = 0
			uip.xoffset = 0
			uip.force_update()
		elif c == ord("L"):
			loglevellist = []
			for lvl in get_loglevel_names():
				if lvl.startswith("Diff"):
					continue
				loglevellist.append({
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString(f"{lvl}", ThemeAttr("windowwidget", "default"))]],
					"retval": lvl,
				})

			tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, loglevellist, title = "Select Loglevel", cursor = True, preselection = loglevel_to_name(log_level))
			selection = None
			if tmpselection is not None and tmpselection != "":
				selection = tmpselection
			uip.refresh_all()
			if selection is not None and len(selection) > 0:
				log_level = name_to_loglevel(selection)
			uip.yoffset = 0
			uip.xoffset = 0
			uip.force_update()
		elif c == ord("W"):
			wrap_lines = not wrap_lines
			uip.yoffset = 0
			uip.xoffset = 0
			uip.force_update()
		elif c == ord("F"):
			if uip.continuous_log or raw_logs:
				continue

			fold_msg = not fold_msg
			uip.yoffset = 0
			uip.xoffset = 0
			uip.force_update()
		elif c == ord("D"):
			if uip.continuous_log or raw_logs:
				continue

			merge_repeats = not merge_repeats
			uip.yoffset = 0
			uip.xoffset = 0
			uip.force_update()
		elif c == ord("T"):
			uip.toggle_timestamps()
			uip.refresh_all()
			uip.force_update()
		elif c == ord("V"):
			facilitylist = [
				{
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Full", ThemeAttr("windowwidget", "default"))]],
					"retval": "Full",
				}, {
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("Short", ThemeAttr("windowwidget", "default"))]],
					"retval": "Short",
				}, {
					"lineattrs": WidgetLineAttrs.NORMAL,
					"columns": [[ThemeString("None", ThemeAttr("windowwidget", "default"))]],
					"retval": "None",
				}
			]

			tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, facilitylist, title = "Select Facility Level", cursor = True, preselection = show_facility)
			selection = None
			if tmpselection is not None and tmpselection != "":
				selection = tmpselection
			uip.refresh_all()
			if selection is not None and len(selection) > 0:
				show_facility = selection
			uip.yoffset = 0
			uip.xoffset = 0
			uip.force_update()
		elif c == ord("E"):
			if uip.continuous_log:
				continue

			uip.refresh = True
			if raw_logs:
				rawprefix = "Raw "
			else:
				rawprefix = ""
			filename = curses_helper.inputbox(uip.stdscr, uip.maxy // 2, 1, uip.maxy - 1, uip.maxx - 1, f"Export {rawprefix}log to file: ")
			if filename is None or filename == "":
				continue

			# This is necessary because we never go through the normal update cycle for the logpad and infopad
			uip.refresh_infopad()
			uip.refresh_logpad()
			curses.doupdate()

			if os.path.exists(filename):
				curses.doupdate()
				if not curses_helper.confirmationbox(uip.stdscr, uip.maxy // 2, uip.maxx // 2, title = f"File “{filename}“ already exists; overwrite?:", default = False):
					continue

			data = ""

			for y in range(0, uip.loglen):
				# Even when the log is raw we want the first timestamp
				if y >= len(timestamps) or isinstance(timestamps[y], str):
					timestamp = "".ljust(uip.tspadwidth)
				else:
					timestamp = str(timestamps[y])[0:uip.tspadwidth]

				if y >= len(facilities) or facilities[y] == "":
					facility = ""
				else:
					if facilities[y].strip() == "":
						facility = f" {facilities[y]}  "
					else:
						facility = f"<{facilities[y]}> "

				if uip.yoffset + y >= len(severities):
					severity_str = f"{lvl_to_4letter_severity(LogLevel.INFO)}: "
				else:
					severity_str = f"{lvl_to_4letter_severity(severities[y])}: "

				message = themearray_to_string(messages[y])

				if raw_logs:
					data += f"{timestamp}  {message}\n"
				else:
					data += f"{timestamp}  {severity_str}{facility}{message}\n"

			secure_write_string(FilePath(filename), data, allow_relative_path = True)

def do_command(stdscr: curses.window, **kwargs) -> None:
	"""
	Execute a command on localhost
	XXX: This should be renamed

		Parameters:
			stdscr (opaque): A curses stdscr reference
			kwargs (dict): Additional parameters
	"""

	security_policy = SecurityPolicy.ALLOWLIST_RELAXED
	fallback_allowlist = ["/bin", "/sbin", "/usr/bin", "/usr/sbin", "/usr/local/bin", "/usr/local/sbin", f"{HOMEDIR}/bin"]

	_args = deep_get(kwargs, DictPath("command"))
	input_path = deep_get(kwargs, DictPath("input_path"))

	if len(_args) == 0:
		return

	obj = deep_get(kwargs, DictPath("obj"), {})

	if input_path is not None:
		if len(input_path) > 0:
			command_input = deep_get(obj, DictPath(input_path))
		else:
			command_input = obj
		if not isinstance(command_input, str):
			command_input = None
		else:
			command_input = command_input.encode("utf-8")
	else:
		command_input = None

	args = []
	for arg in _args:
		if isinstance(arg, str):
			args.append(arg)
		elif isinstance(arg, list):
			for path in arg:
				tmp = deep_get(obj, DictPath(path))
				if isinstance(tmp, str):
					args.append(tmp)
				elif isinstance(tmp, list):
					args += tmp
				else:
					sys.exit("widget_args: command requested incorrect data type; only str and list are valid")

	waitforkeypress = deep_get(kwargs, DictPath("wait_for_keypress"), False)

	msg = deep_get(kwargs, DictPath("msg"), "")

	curses.endwin()
	_retval = clear_screen()
	if len(msg) > 0:
		ansithemeprint(msg)
		print()

	try:
		cpath = secure_which(FilePath(args[0]), fallback_allowlist = fallback_allowlist,
				     security_policy = security_policy)
	except FileNotFoundError:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": “", "default"),
				ANSIThemeString(f"{args[0]}", "programname"),
				ANSIThemeString("“ does not exist.\n", "default")], stderr = True)
		waitforkeypress = True
	else:
		_retval = subprocess.run(args, check = False, input = command_input).returncode

	if waitforkeypress:
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])
	stdscr.refresh()

# pylint: disable-next=too-many-arguments
def executecommand(stdscr: curses.window, obj, container, msg, command, waitforkeypress):
	"""
	Executes a command in a container
	XXX: This should be renamed
	"""

	try:
		kubectl_path = secure_which(FilePath("/usr/bin/kubectl"), fallback_allowlist = ["/etc/alternatives"], security_policy = SecurityPolicy.ALLOWLIST_RELAXED)
	except FileNotFoundError:
		curses.endwin()
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Could not find ", "default"),
				ANSIThemeString("kubectl", "path"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# This should probably be done using connect_get_namespaced_pod_exec()
	curses.endwin()
	_retval = clear_screen()
	ansithemeprint(msg)
	print()
	if obj is not None:
		obj_name = deep_get(obj, DictPath("metadata#name"))
		obj_namespace = deep_get(obj, DictPath("metadata#namespace"))
		# This is a request to create a new ephemeral container
		if command == ["<ephemeral>"]:
			ephemeral_image = deep_get(cmtlib.cmtconfig, DictPath("Debug#ephemeral_image"), "busybox")
			args = [kubectl_path, "debug", obj_name, "--target", container, "-n", obj_namespace, "-i", "-t", "--image", ephemeral_image]
			_result = subprocess.run(args, check = False)
		elif command == ["<dnsutils>"]:
			dnsutils_image = deep_get(cmtlib.cmtconfig, DictPath("Debug#network_image"), "registry.k8s.io/e2e-test-images/jessie-dnsutils:1.7")
			args = [kubectl_path, "debug", f"node/{obj_name}", "-n", "default", "-i", "-t", "--image", dnsutils_image, "--attach=false"]
			result = subprocess.run(args, stdout = PIPE, stderr = STDOUT, check = False)
			if result.returncode != 0:
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": Failed to create debug image", "default")], stderr = True)
			else:
				output = result.stdout.decode("utf-8", errors = "replace")
				tmp = re.match(r"^Creating debugging pod (\S+) with container (\S+) .*", output)
				if tmp is not None:
					pod_name = tmp[1]
					container_name = tmp[2]
				else:
					sys.exit(f"executecommand failed to parse output; {output}; aborting.")

				# Wait for the pod to be ready
				ansithemeprint([ANSIThemeString("Waiting for debug pod to be ready (timeout: 60s).", "default")])
				args = [kubectl_path, "wait", "--for=condition=ready", "--timeout=60s", "-n", "default", "pod", pod_name]
				result = subprocess.run(args, stdout = PIPE, stderr = STDOUT, check = False)
				if result.returncode != 0:
					ansithemeprint([ANSIThemeString("Error", "error"),
							ANSIThemeString(": The pod failed to become ready before timeout.", "default")], stderr = True)
				else:
					# Attach to the debug container
					args = [kubectl_path, "attach", "-n", "default", pod_name, "-c", container_name, "-i", "-t", "--pod-running-timeout=1m0s"]
					_result = subprocess.run(args, check = False)

				# Delete the pod
				ansithemeprint([ANSIThemeString("Forcibly deleting pod.", "default")])
				message, status = kh.delete_obj_by_kind_name_namespace(("Pod", ""), pod_name, "default", force = True)
		else:
			args = [kubectl_path, "exec", obj_name, "-n", obj_namespace, "-i", "-t", "--container", container, "--"] + command
			_result = subprocess.run(args, check = False).returncode
	else:
		sys.exit("Called executecommand() with obj == None")

	if waitforkeypress:
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])
	stdscr.refresh()

def listviewdispatch(stdscr: curses.window, **kwargs):
	obj = deep_get(kwargs, DictPath("obj"))
	selection = deep_get(kwargs, DictPath("selection"))
	if obj is None and selection is None:
		return Retval.RETURNDONE

	kind = deep_get(kwargs, DictPath("kind"))
	kind_path = deep_get(kwargs, DictPath("kind_path"))
	if kind_path is not None:
		if isinstance(kind_path, str):
			kind_path = [kind_path]
			kind = deep_get_with_fallback(obj, kind_path)
		elif isinstance(kind_path, int) and selection is not None and len(selection) > 0:
			tmp = selection[kind_path]
			if tmp is not None:
				kind = themearray_to_string(tmp)
	api_family = deep_get_with_fallback(kwargs, [DictPath("api_family"), DictPath("api_group")])
	api_group_path = deep_get_with_fallback(kwargs, [DictPath("api_family_path"), DictPath("api_group_path")])
	if api_group_path is not None:
		if isinstance(api_group_path, str):
			api_group_path = [api_group_path]
			api_family = deep_get_with_fallback(obj, api_group_path)
		else:
			tmp = selection[api_group_path]
			if tmp is not None:
				api_family = themearray_to_string(tmp)

	if kind is None:
		return Retval.RETURNDONE
	if api_family is None:
		api_family = ""
	if "/" in api_family:
		api_family, _api_version = api_family.split("/")
	else:
		# Is the api_family only a version#? Then it's a core API
		tmp = re.match(r"^v\d+(alpha\d+|beta\d+|)", api_family)
		if tmp is not None:
			api_family = ""

	view = checkforview((kind, api_family))

	if view is not None:
		if "viewfunc" in views[view]:
			viewfunc = views[view]["viewfunc"]
		else:
			viewfunc = genericlistloop
		return viewfunc(stdscr, view)

	return Retval.RETURNDONE

# pylint: disable-next=unused-argument
def patch_object(stdscr: curses.window, **kwargs):
	kind = deep_get(kwargs, DictPath("kind"))
	name = deep_get(kwargs, DictPath("name"))
	namespace = deep_get(kwargs, DictPath("namespace"))
	patch = deep_get(kwargs, DictPath("args#patch"))
	subresource = deep_get(kwargs, DictPath("args#subresource"), "")
	strategic_merge = deep_get(kwargs, DictPath("args#strategic_merge"), False)

	_message, _status = kh.patch_obj_by_kind_name_namespace(kind, name, namespace, patch, subresource = subresource, strategic_merge = strategic_merge)

	return Retval.RETURNDONE

# This dispatches to info views; as soon as one is added this function will
# dispatch to that view.
def resourceinfodispatch(stdscr: curses.window, obj, kind, info = None, **kwargs):
	if obj is None:
		return None

	if kind == ("", ""):
		kind = deep_get(obj, DictPath("kind"), "")
		if isinstance(kind, str):
			api_version = deep_get(obj, DictPath("apiVersion"), "")
			# Is this a core API?
			if "/" not in api_version:
				api_family = ""
			else:
				api_family = api_version.split("/")[0]
			kind = (kind, api_family)

	if kind in infoviews:
		return genericinfoloop(stdscr, obj, kind, **kwargs)

	# Exceptions
	if kind in (("Container", ""), ("InitContainer", ""), ("EphemeralContainer", "")):
		# Do not try to open pending containers
		if deep_get(info, DictPath("status#phase")) in ("Pending", "Failed"):
			return None
		return containerinfoloop(stdscr, obj, kind, info)

	return None

def resourceinfodispatch_from_pod_resource_list(stdscr: curses.window, obj = None, kind = None, info = None, **kwargs):
	kind = deep_get(obj, DictPath("kind"))
	api_family = deep_get(obj, DictPath("api_group"), "")
	obj = deep_get(obj, DictPath("ref"))
	return resourceinfodispatch(stdscr, obj, (kind, api_family), info, **kwargs)

# Do not pass both direct and _path versions at the same time
def resourceinfodispatch_with_lookup(stdscr: curses.window, **kwargs):
	obj = deep_get(kwargs, DictPath("obj"))
	if obj is None:
		if "selected_obj" in kwargs:
			obj = deep_get(kwargs, DictPath("selected_obj"))
		elif "selected" in kwargs:
			selected = deep_get(kwargs, DictPath("selected"))
			if "_selected_objs" in kwargs:
				obj = {}
				for key, attribute in deep_get(kwargs, DictPath("_selected_objs"), []).items():
					if isinstance(attribute, list):
						tmp = getattr(selected, attribute[0])
						if tmp is not None:
							obj[key] = tmp[attribute[1]]
						else:
							obj[key] = None
					else:
						obj[key] = getattr(selected, attribute)
			else:
				obj = selected

	selection = deep_get(kwargs, DictPath("selection"))

	name = deep_get(kwargs, DictPath("name"))
	namespace = deep_get(kwargs, DictPath("namespace"))
	namespaced_name = deep_get(obj, DictPath("namespacedName"))

	name_path = deep_get(kwargs, DictPath("name_path"))
	if name_path is not None and isinstance(name_path, str):
		name_path = [name_path]
	namespace_path = deep_get(kwargs, DictPath("namespace_path"), "")
	if namespace_path is not None and isinstance(namespace_path, str):
		namespace_path = [namespace_path]
	namespaced_name_path = deep_get(kwargs, DictPath("namespaced_name_path"), "")
	if namespaced_name_path is not None and isinstance(namespaced_name_path, str):
		namespaced_name_path = [namespaced_name_path]

	kind = deep_get(kwargs, DictPath("kind"))
	kind_path = deep_get(kwargs, DictPath("kind_path"))
	if kind_path is not None:
		if isinstance(kind_path, str):
			kind_path = [kind_path]
		elif isinstance(kind_path, int) and selection is not None and len(selection) > 0:
			tmp = selection[kind_path]
			if tmp is not None:
				kind = themearray_to_string(tmp)

	api_group = deep_get_with_fallback(kwargs, [DictPath("api_family"), DictPath("api_group")])
	api_group_path = deep_get_with_fallback(kwargs, [DictPath("api_family_path"), DictPath("api_group_path")])
	if api_group_path is not None:
		if isinstance(api_group_path, str):
			api_group_path = [api_group_path]
		elif isinstance(api_group_path, int) and selection is not None and len(selection) > 0:
			tmp = selection[api_group_path]
			if tmp is not None:
				api_group = themearray_to_string(tmp)

	api_version_path = deep_get(kwargs, DictPath("api_version_path"))
	if api_version_path is not None:
		if isinstance(api_version_path, str):
			api_version_path = [api_version_path]
		elif isinstance(api_version_path, int) and selection is not None and len(selection) > 0:
			tmp = selection[api_version_path]
			if tmp is not None:
				api_version = themearray_to_string(tmp)
				if api_version is not None:
					if "/" in api_version:
						api_group = api_version.split("/")[0]
					else:
						api_group = ""

	owner_reference_path = deep_get(kwargs, DictPath("owner_reference_path"))
	holder_identity_path = deep_get(kwargs, DictPath("holder_identity_path"))

	# When a path is an integer it references a field in selected
	if isinstance(name_path, int) and selection is not None and len(selection) > 0:
		tmp = selection[name_path]
		if tmp is not None:
			name = themearray_to_string(tmp)
	if isinstance(namespace_path, int) and selection is not None and len(selection) > 0:
		tmp = selection[namespace_path]
		if tmp is not None:
			namespace = themearray_to_string(tmp)

		# If an integer namespace is empty, the namespace is (most likely)
		# the same namespace as the parent. This should not interfere with non-namespaced
		# APIs, since they ignore the namespace
		if namespace is None or len(namespace) == 0:
			namespace = deep_get(kwargs, DictPath("_parent_namespace"), "")

	if obj is not None:
		kind = deep_get_with_fallback(obj, kind_path, kind)
		if kind is not None and len(kind) > 0 and isinstance(api_version_path, str):
			api_version = deep_get_with_fallback(obj, api_version_path)
			if api_version is not None:
				if "/" in api_version:
					api_group = api_version.split("/")[0]
				else:
					api_group = ""
			api_group = deep_get_with_fallback(obj, api_group_path, api_group)

	if not isinstance(kind, tuple):
		if api_group is None:
			api_group = ""
		kind = (kind, api_group)

	controller = None
	non_controller = None

	holder_identity = None
	if holder_identity_path is not None:
		holder_identity = deep_get(obj, DictPath(holder_identity_path))

	if owner_reference_path is not None and obj is not None:
		# Search for a controller, or the first reference that matches the kind if specified
		owner_references = deep_get(obj, DictPath(owner_reference_path), [])
		for ref in owner_references:
			ref_name = deep_get(ref, DictPath("name"))

			# We only want to dispatch if there's an owner reference
			# that matches the holder identity
			if holder_identity is not None and ref_name != holder_identity:
				continue

			ref_kind = deep_get(ref, DictPath("kind"))
			ref_api_version = deep_get(ref, DictPath("apiVersion"))
			if "/" in ref_api_version:
				ref_api_family = ref_api_version.split("/")[0]
			else:
				ref_api_family = ""
			ref_kind = (ref_kind, ref_api_family)
			accept_only_owner = deep_get(kwargs, DictPath("accept_only_owner"), False)
			if deep_get(ref, DictPath("controller"), False):
				controller = (ref_kind, ref_name)
			elif kind is not None and kind == ref_kind or holder_identity is not None or accept_only_owner and len(owner_references) == 1:
				if non_controller is None:
					non_controller = (ref_kind, ref_name)

	if controller is not None:
		kind, name = controller
	elif non_controller is not None:
		kind, name = non_controller
	else:
		if name is None and obj is not None:
			name = deep_get_with_fallback(obj, name_path)
			# This is needed since CiliumID, for instance, is an integer
			if name is not None:
				name = str(name)

	if kind is None or isinstance(kind, tuple) and kind[0] is None:
		return None

	if name is None:
		if namespaced_name_path is not None:
			namespaced_name = deep_get_with_fallback(obj, DictPath(namespaced_name_path))
		if namespaced_name is not None:
			tmp = namespaced_name.split("/")
			if len(tmp) == 2:
				namespace, name = tmp

	if name is None or len(name) == 0:
		return None

	if namespace is None and obj is not None:
		namespace = deep_get_with_fallback(obj, namespace_path)

	parent_namespace = deep_get(kwargs, DictPath("_parent_namespace"), "")
	if namespace is None and parent_namespace is not None:
		namespace = parent_namespace

        # If the kind is unknown we will get NameError;
	# in this case we probably do not want to crash
	try:
		kind = guess_kind(kind)
	except NameError:
		obj = None

        # If the kind is unknown we will get NameError;
	# in this case we probably don not want to crash
	try:
		obj = kh.get_ref_by_kind_name_namespace(kind, name, namespace)
	except NameError:
		obj = None

	return resourceinfodispatch(stdscr, obj, kind)

def resourceinfodispatch_with_lookup_on_activation(stdscr: curses.window, obj, kind, **kwargs):
	if "obj" not in kwargs:
		kwargs["obj"] = obj
	if kind not in kwargs:
		kwargs["kind"] = kind
	return resourceinfodispatch_with_lookup(stdscr, **kwargs)

def listgetter_namespaced_resources(obj, **kwargs):
	vlist = []
	status = 200

	namespaced_resources = deep_get(kwargs, DictPath("resources"), kh.get_list_of_namespaced_resources())

	kind = ("Namespace", "")
	namespace = deep_get(obj, DictPath("metadata#name"))

	# 10 is randomly picked; this can be adjusted as we go along
	executor = concurrent.futures.ThreadPoolExecutor()
	executors = {}
	for kind in namespaced_resources:
		joined_kind = ".".join(kind)
		executors[kind] = executor.submit(get_kubernetes_list_async, kind = kind, namespace = namespace)
	for kind, ex in executors.items():
		_vlist, _status = ex.result()
		if _status != 200:
			status = _status
			continue
		if len(_vlist) == 0:
			continue
		# We are (potentially) listing a lot of different types of resources,
		# and they do not contain kind/apiVersion, so it will be tricky to tell them apart...
		for obj in _vlist:
			obj["__kind_tuple"] = kind
		vlist += _vlist
	executor.shutdown()
	return vlist, status

# Iterate over the list of items and execute command on all of them
def executecommand_multiple(stdscr: curses.window, msg, command, items, waitforkeypress) -> None:
	item = None

	curses.endwin()
	_retval = clear_screen()
	print(msg + "\n")

	for item in items:
		args = command + [item]
		retval = subprocess.run(args, check = False).returncode
		if retval != 0:
			break

	if waitforkeypress or retval > 0:
		if retval > 0:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default")] +
				       format_commandline(args) +
				       [ANSIThemeString(" returned ", "default"),
					ANSIThemeString(f"{retval}", "errorvalue")], stderr = True)
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])
	stdscr.refresh()

def __run_playbook(playbookpath: FilePath, nodes: List[str], values: Optional[Dict] = None) -> int:
	http_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), "")
	https_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), "")
	no_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), "")
	verbose = deep_get(cmtlib.cmtconfig, DictPath("Ansible#verbose"), False)

	use_proxy = "no"
	if (http_proxy is not None and len(http_proxy) > 0) or (https_proxy is not None and len(https_proxy) > 0):
		use_proxy = "yes"
	values["use_proxy"] = use_proxy
	values["http_proxy"] = http_proxy
	values["https_proxy"] = https_proxy
	values["no_proxy"] = no_proxy

	retval, ansible_results = ansible_run_playbook_on_selection(playbookpath, selection = nodes, values = values, verbose = verbose)
	if verbose:
		ansithemeprint([ANSIThemeString("", "default")])

	ansible_print_play_results(retval, ansible_results, verbose = verbose)

	return retval

def run_playbook(playbook: Dict, nodes: List[str], values: Optional[Dict] = None) -> Tuple[int, Dict]:
	return __run_playbook(FilePath(cast(str, playbook.get("playbook"))), nodes, values = values)

def view_obj(stdscr: curses.window, **kwargs):
	selection = deep_get(kwargs, DictPath("selection"))
	if selection is not None:
		obj = selection
	else:
		obj = deep_get(kwargs, DictPath("obj"))
	if obj is None:
		return None
	title = deep_get_with_fallback(kwargs, [DictPath("named_title"), DictPath("title")])
	title_path = deep_get(kwargs, DictPath("title_path"))
	if title_path is not None:
		title = deep_get(obj, DictPath(title_path))
	path = deep_get(kwargs, DictPath("path"))
	formatter = deep_get(kwargs, DictPath("formatter"), formatters.format_yaml)
	if path is not None:
		if deep_get(kwargs, DictPath("include_root"), False):
			obj = [{f"{path.rsplit('#')[-1]}": deep_get(obj, DictPath(path))}]
		# pylint: disable-next=comparison-with-callable
		elif formatter == formatters.format_yaml:
			obj = [deep_get(obj, DictPath(path))]
		else:
			obj = deep_get(obj, DictPath(path))
	else:
		obj = [obj]
	if isinstance(formatter, str):
		_formatter = deep_get(formatter_allowlist, DictPath(formatter))
		if _formatter is None:
			raise ValueError(f"{formatter} is not in formatter_allowlist")
		formatter = _formatter
	return resourceinfodispatch(stdscr, obj, ("__ResourceView", ""), title = title, formatter = formatter)

def view_yaml(stdscr: curses.window, **kwargs):
	selection = deep_get(kwargs, DictPath("selection"))
	if selection is not None:
		obj = selection
	else:
		obj = deep_get(kwargs, DictPath("obj"))

	if obj is None:
		return None
	path = deep_get(kwargs, DictPath("path"))
	if path is not None:
		if deep_get(kwargs, DictPath("include_root"), False):
			_obj = {f"{path.rsplit('#')[-1]}": deep_get(obj, DictPath(path))}
		else:
			_obj = deep_get(obj, DictPath(path))
		if _obj is None:
			return None
		obj = [_obj]
	else:
		obj = [obj]
	title = deep_get_with_fallback(kwargs, [DictPath("named_title"), DictPath("title")])
	formatter = formatters.format_yaml
	return resourceinfodispatch(stdscr, obj, ("__ResourceView", ""), title = title, formatter = formatter)

def view_pod_logs(stdscr: curses.window, **kwargs):
	containers = []
	containers_full = []
	items = deep_get(kwargs, DictPath("_tagged_items"), [])
	selected = deep_get(kwargs, DictPath("selected"))
	if selected is not None:
		items = [selected]
	namespaces = set()
	for obj in items:
		namespace = getattr(obj, "namespace")
		namespaces.add(namespace)
		name = getattr(obj, "name")
		container_name = getattr(obj, "container")
		image_id = getattr(obj, "image_id")
		containers.append((namespace, name, container_name))
		containers_full.append((namespace, name, container_name, image_id))

	multilog_args = {
		"multilog_containers": containers,
		"multilog_containers_full": containers_full,
		"all_same_namespace": len(namespaces) == 1
	}

	return containerinfoloop(stdscr, container = None, kind = None, obj = None, **multilog_args)

# pylint: disable=unused-argument
def action_view_pod_logs(uip: UIProps, items, action, values, kind, **kwargs):
	return view_pod_logs(uip.stdscr, **values)

def view_last_applied_configuration(stdscr: curses.window, **kwargs):
	obj = deep_get(kwargs, DictPath("obj"))

	last_applied_configuration = deep_get(obj, DictPath("metadata#annotations#kubectl.kubernetes.io/last-applied-configuration"), {})
	if last_applied_configuration is None or len(last_applied_configuration) == 0:
		return None

	try:
		data = json.loads(last_applied_configuration)
	except DecodeException:
		return None

	title = deep_get(kwargs, DictPath("title"))
	# themearrays = formatters.format_yaml([data])
	formatter = formatters.format_yaml
	return resourceinfodispatch(stdscr, [data], ("__ResourceView", ""), title = title, formatter = formatter)

# pylint: disable=unused-argument
def delete_resource(uip: UIProps, items, action, values, kind, **kwargs):
	success = True
	force = deep_get(values, DictPath("__force"), False)

	for item in items:
		if isinstance(item, tuple):
			namespace, name = item
		else:
			namespace = None
			name = item
		message, status = kh.delete_obj_by_kind_name_namespace(kind, name, namespace, force = force)
		if status != 200:
			# Status messages can be very verbose; delete everything from URL and on
			tmp = re.match(r"^(.+?), URL:.*", message)
			if tmp is not None:
				message = tmp[1]
			win = curses_helper.alert(uip.stdscr, uip.maxy // 2, uip.maxx // 2, message = message)
			success = False
			break

	# We successfully deleted everything
	if success:
		win = curses_helper.notice(uip.stdscr, uip.maxy // 2, uip.maxx // 2, message = "Successfully deleted all specified resources")

	# Wait for a keypress
	while True:
		uip.stdscr.timeout(100)
		c = uip.stdscr.getch()
		if c != -1:
			del win
			break

# pylint: disable=unused-argument
def force_delete_resource(uip: UIProps, items, action, values, kind, **kwargs):
	values["__force"] = True
	return delete_resource(uip, items = items, action = action, values = values, kind = kind)

def create_namespace(stdscr: curses.window, **kwargs):
	selection_vars = deep_get(kwargs, DictPath("selection_vars"))
	name = deep_get(selection_vars, DictPath("namespace"))

	curses.endwin()
	_retval = clear_screen()

	# Verify that the name of the new namespace is valid
	if not validate_name("dns-label", name):
		msg = [ANSIThemeString("Error: ", "error"),
		       ANSIThemeString("“", "default"),
		       ANSIThemeString(name, "argument"),
		       ANSIThemeString("“ is not a valid name", "default")]
		ansithemeprint(msg, stderr = True)
	elif kh.get_ref_by_kind_name_namespace(("Namespace", ""), name, "") is not None:
		msg = [ANSIThemeString("Error: ", "error"),
		       ANSIThemeString("namespace “", "default"),
		       ANSIThemeString(name, "argument"),
		       ANSIThemeString("“ already exists", "default")]
		ansithemeprint(msg, stderr = True)
	else:
		msg = [ANSIThemeString("Creating namespace “", "default"),
		       ANSIThemeString(name, "argument"),
		       ANSIThemeString("“", "default")]
		ansithemeprint(msg)
		_msg, _status = kh.create_namespace(name)

	print("\n")

	waitforkeypress = True
	if waitforkeypress:
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])
	stdscr.refresh()

# Valid kinds:
# ("DaemonSet", "apps")
# ("Deployment", "apps")
# ("StatefulSet", apps")
def __restart_resource(kind, namespace, name):
	try:
		kubectl_path = secure_which(FilePath("/usr/bin/kubectl"), fallback_allowlist = ["/etc/alternatives"], security_policy = SecurityPolicy.ALLOWLIST_RELAXED)
	except FileNotFoundError:
		curses.endwin()
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Could not find ", "default"),
				ANSIThemeString("kubectl", "path"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	args = [kubectl_path, "rollout", "restart", f"{kind[0]}.{kind[1]}/{name}", f"--namespace={namespace}"]
	result = subprocess.run(args, stdout = PIPE, stderr = PIPE, universal_newlines = True, check = False)
	return result

def __get_resource_scale(kind, namespace, name):
	obj = kh.get_ref_by_kind_name_namespace(kind, name, namespace)
	return deep_get(obj, DictPath("status#replicas"))

# Valid kinds:
# ("Deployment", "apps")
# ("ReplicaSet", "apps")
# ("ReplicationController", "")
# ("StatefulSet", apps")
def __scale_replicas(kind, namespace, name, scale):
	try:
		kubectl_path = secure_which(FilePath("/usr/bin/kubectl"), fallback_allowlist = ["/etc/alternatives"], security_policy = SecurityPolicy.ALLOWLIST_RELAXED)
	except FileNotFoundError:
		curses.endwin()
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Could not find ", "default"),
				ANSIThemeString("kubectl", "path"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	args = [kubectl_path, "scale", f"{kind[0]}.{kind[1]}/{name}", f"--namespace={namespace}", f"--replicas={scale}"]
	result = subprocess.run(args, stdout = PIPE, stderr = PIPE, universal_newlines = True, check = False)
	return result

def __edit_resource(kind, namespace, name):
	try:
		kubectl_path = secure_which(FilePath("/usr/bin/kubectl"), fallback_allowlist = ["/etc/alternatives"], security_policy = SecurityPolicy.ALLOWLIST_RELAXED)
	except FileNotFoundError:
		curses.endwin()
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Could not find ", "default"),
				ANSIThemeString("kubectl", "path"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if namespace is None:
		args = [kubectl_path, "edit", f"{kind[0]}.{kind[1]}/{name}"]
	else:
		args = [kubectl_path, "edit", f"{kind[0]}.{kind[1]}/{name}", f"--namespace={namespace}"]
	result = subprocess.run(args, universal_newlines = True, check = False)
	return result.returncode, args

# pylint: disable=unused-argument
def perform_action_on_configuration(uip: UIProps, items, action, values, kind, **kwargs):
	try:
		kubectl_path = secure_which(FilePath("/usr/bin/kubectl"), fallback_allowlist = ["/etc/alternatives"], security_policy = SecurityPolicy.ALLOWLIST_RELAXED)
	except FileNotFoundError:
		curses.endwin()
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Could not find ", "default"),
				ANSIThemeString("kubectl", "path"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if (resource_url := deep_get(values, DictPath("resource_url"))) is not None:
		if not resource_url.startswith(("http://", "https://")):
			return Retval.MATCH
		resource_path = resource_url
		rtype = deep_get(action, DictPath("extravars#rtype"))
	else:
		resource_path, rtype = values["resource_path"]

	configuration_action = deep_get(action, DictPath("extravars#action"))
	if configuration_action is None:
		raise ProgrammingError("perform_action_on_configuration() called without action'")
	if configuration_action not in ("delete", "create", "apply"):
		raise ProgrammingError(f"perform_action_on_configuration() does not support the action '{configuration_action}'")

	curses.endwin()
	_retval = clear_screen()

	kubectl_major_version, kubectl_minor_version, _kubectl_git_version, _server_major_version, _server_minor_version, _server_git_version = kubectl_get_version()
	if kubectl_major_version is None or kubectl_minor_version is None:
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Could not extract ", "default"),
				ANSIThemeString("kubectl", "programname"),
				ANSIThemeString(" version; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)
	args = [kubectl_path]
	extra_options = []

	if configuration_action == "apply":
		if kubectl_major_version <= 1 and kubectl_minor_version < 22:
			configuration_action = "create"
		else:
			extra_options = ["--server-side"]

	args.append(configuration_action)
	args += extra_options

	if rtype == "Configuration File":
		args.append("-f")
	elif rtype == "Kustomization":
		args.append("-k")
	else:
		raise TypeError(f"Unknown resource type {rtype}; this is a programming error.")

	args.append(resource_path)
	result = subprocess.run(args, universal_newlines = True, check = False)
	return result.returncode, args

def __summarise_resources(path):
	resources = []
	dicts = secure_read_yaml_all(path)
	for d in dicts:
		kind, api_group = kh.kind_api_version_to_kind(deep_get(d, DictPath("kind")), deep_get(d, DictPath("apiVersion")))
		if api_group == "":
			merged_kind = kind
		else:
			merged_kind = f"{kind}.{api_group}"
		name = deep_get(d, DictPath("metadata#name"))
		namespace = deep_get(d, DictPath("metadata#namespace"), "")
		resources.append((merged_kind, namespace, name))

	return resources

# pylint: disable=unused-argument
def diff_resource_configuration(uip: UIProps, items, action, values, kind, **kwargs):
	if (resource_url := deep_get(values, DictPath("resource_url"))) is not None:
		if not resource_url.startswith(("http://", "https://")):
			return Retval.MATCH
		resource_path = resource_url
		rtype = deep_get(action, DictPath("extravars#rtype"))
	else:
		resource_path, rtype = values["resource_path"]

	try:
		kubectl_path = secure_which(FilePath("/usr/bin/kubectl"), fallback_allowlist = ["/etc/alternatives"], security_policy = SecurityPolicy.ALLOWLIST_RELAXED)
	except FileNotFoundError:
		curses.endwin()
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Could not find ", "default"),
				ANSIThemeString("kubectl", "path"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if rtype == "Configuration File":
		args = [kubectl_path, "diff", "-f", resource_path]
	elif rtype == "Kustomization":
		args = [kubectl_path, "diff", "-k", resource_path]
	else:
		raise TypeError(f"Unknown resource type {rtype}; this is a programming error.")

	result = subprocess.run(args, stdout = PIPE, stderr = PIPE, universal_newlines = True, check = False)

	indent = deep_get(cmtlib.cmtconfig, DictPath("Global#indent"), 2)

	diff = []

	if len(result.stdout) == 0:
		return Retval.MATCH

	diff_regex = re.compile(r"^(\s*)(.*)")

	for line in result.stdout.splitlines():
		if line.startswith("+"):
			fmt = ThemeAttr("windowwidget", "diffplus")
		elif line.startswith("-"):
			fmt = ThemeAttr("windowwidget", "diffminus")
		elif line.startswith("@@"):
			fmt = ThemeAttr("windowwidget", "diffatat")
		elif line.startswith("diff "):
			fmt = ThemeAttr("windowwidget", "diffheader")
		else:
			fmt = ThemeAttr("windowwidget", "diffsame")

		# kubectl shows the diff with a 2-space indent;
		# if a different indent is configured we have to modify this
		if indent != 2:
			prefix = line[0]
			tmp = diff_regex.match(line[1:])
			if tmp is not None and len(tmp[1]) % 2 == 0:
				line = prefix + "".ljust(int(len(tmp[1]) / 2) * indent) + tmp[2]

		diff.append({
			"lineattrs": WidgetLineAttrs.NORMAL,
			"columns": [[ThemeString(line, fmt)]],
		})

	_tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, diff, title = "Difference if applying new configuration:", cursor = False)
	return Retval.MATCH

def format_commandline(args: List[str], implicit_command: bool = True) -> List[ANSIThemeString]:
	"""
	Given a command line as an array of strings, format it as an array of ANSIThemeString

		Parameters:
			args (list[str]): The commandline
			implicit_command (bool): Is the first non-option command the command?
		Returns:
			themearray (list[ANSIThemeString]): A list of ANSIThemeString
	"""

	themearray = []

	command = implicit_command

	for i, arg in enumerate(args):
		# The first argument is the program name
		if i == 0:
			themearray += [ANSIThemeString(arg, "programname")]
		# This is an option
		elif arg.startswith(("-")):
			themearray += [ANSIThemeString(f" {arg}", "option")]
		# The first non-option argument is the command
		elif not command:
			themearray += [ANSIThemeString(f" {arg}", "command")]
			command = True
		else:
			themearray += [ANSIThemeString(f" {arg}", "argument")]

	return themearray

def edit_resource(stdscr: curses.window, **kwargs) -> None:
	obj = deep_get(kwargs, DictPath("obj"))
	kind = deep_get(kwargs, DictPath("kind"))
	name = deep_get(obj, DictPath("metadata#name"))
	namespace = deep_get(obj, DictPath("metadata#namespace"), "")
	if name is None:
		return

	curses.endwin()
	_retval = clear_screen()
	retval, args = __edit_resource(kind, namespace, name)

	waitforkeypress = False
	if waitforkeypress or retval > 0:
		if retval > 0:
			ansithemeprint([ANSIThemeString("\nError", "error"),
					ANSIThemeString(": ", "default")] +
				       format_commandline(args, implicit_command = False) +
				       [ANSIThemeString(" returned ", "default"),
					ANSIThemeString(f"{retval}", "errorvalue")], stderr = True)
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])
	stdscr.refresh()

# pylint: disable=unused-argument
def patch_resource(uip: UIProps, items, action, values, kind, **kwargs):
	curses.endwin()
	_retval = clear_screen()
	action_str = deep_get(values, DictPath("action_str"))
	args = deep_get(values, DictPath("args"), {})

	for item in items:
		namespace, name = item

		if action_str is not None:
			msg = [ANSIThemeString(f"{action_str} {kind[0]}.{kind[1]} “", "default"),
			       ANSIThemeString(namespace, "argument"),
			       ANSIThemeString("::", "separator"),
			       ANSIThemeString(name, "argument"),
			       ANSIThemeString("“", "default")]
			ansithemeprint(msg)

		patch_object(uip.stdscr, **{"kind": kind, "name": name, "namespace": namespace, "args": args})

	print("\n")

	waitforkeypress = True
	if waitforkeypress:
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])
	uip.stdscr.refresh()

# pylint: disable=unused-argument
def restart_resource_rescale(uip: UIProps, items, action, values, kind, **kwargs):
	curses.endwin()
	_retval = clear_screen()

	for item in items:
		namespace, name = item
		old_scale = __get_resource_scale(kind, namespace, name)
		__scale_replicas(kind, namespace, name, scale = 0)
		__scale_replicas(kind, namespace, name, scale = old_scale)
		msg = [ANSIThemeString(f"Restarting {kind[0]}.{kind[1]} “", "default"),
		       ANSIThemeString(namespace, "argument"),
		       ANSIThemeString("::", "separator"),
		       ANSIThemeString(name, "argument"),
		       ANSIThemeString("“ scale: ", "default"),
		       ANSIThemeString(f"{old_scale}", "emphasis")]
		ansithemeprint(msg)

	print("\n")

	waitforkeypress = True
	if waitforkeypress:
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])
	uip.stdscr.refresh()

# pylint: disable=unused-argument
def restart_resource_rollout(uip: UIProps, items, action, values, kind, **kwargs):
	curses.endwin()
	_retval = clear_screen()

	for item in items:
		namespace, name = item
		__restart_resource(kind, namespace, name)
		msg = [ANSIThemeString(f"Restarting {kind[0]}.{kind[1]} “", "default"),
		       ANSIThemeString(namespace, "argument"),
		       ANSIThemeString("::", "separator"),
		       ANSIThemeString(name, "argument"),
		       ANSIThemeString("“", "default")]
		ansithemeprint(msg)

	print("\n")

	waitforkeypress = True
	if waitforkeypress:
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])
	uip.stdscr.refresh()

# pylint: disable=unused-argument
def rescale_resource(uip: UIProps, items, action, values, kind, **kwargs):
	curses.endwin()
	_retval = clear_screen()

	for item in items:
		namespace, name = item
		scale = values["scale"]
		old_scale = __get_resource_scale(kind, namespace, name)
		__scale_replicas(kind, namespace, name, scale)
		msg = [ANSIThemeString(f"Rescaling {kind[0]}.{kind[1]} “", "default"),
		       ANSIThemeString(namespace, "argument"),
		       ANSIThemeString("::", "separator"),
		       ANSIThemeString(name, "argument"),
		       ANSIThemeString("“ scale: ", "default"),
		       ANSIThemeString(f"{old_scale}", "emphasis"),
		       ANSIThemeString(" => ", "default"),
		       ANSIThemeString(f"{scale}", "emphasis")]
		ansithemeprint(msg)

	print("\n")

	waitforkeypress = True
	if waitforkeypress:
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])
	uip.stdscr.refresh()

# Valid kinds:
# ("Deployment", "apps")
# pylint: disable=unused-argument
def stop_resource_rescale(uip: UIProps, items, action, values, kind, **kwargs):
	curses.endwin()
	_retval = clear_screen()

	for item in items:
		namespace, name = item
		old_scale = __get_resource_scale(kind, namespace, name)
		__scale_replicas(kind, namespace, name, 0)
		msg = [ANSIThemeString(f"Stopping {kind[0]}.{kind[1]} “", "default"),
		       ANSIThemeString(namespace, "argument"),
		       ANSIThemeString("::", "separator"),
		       ANSIThemeString(name, "argument"),
		       ANSIThemeString("“ scale: ", "default"),
		       ANSIThemeString(f"{old_scale}", "emphasis"),
		       ANSIThemeString(" => ", "default"),
		       ANSIThemeString("0", "emphasis")]
		ansithemeprint(msg)

	print("\n")

	waitforkeypress = True
	if waitforkeypress:
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])
	uip.stdscr.refresh()

# pylint: disable=unused-argument
def delete_logs(uip: UIProps, items, action, values, kind, **kwargs):
	for item in items:
		ansible_delete_log(item)

# pylint: disable=unused-argument
def action_execute_command(uip: UIProps, items, action, values, kind, **kwargs) -> None:
	tmpargs = deep_get(values, DictPath("action_args#command"), [])
	iterate = deep_get(values, DictPath("action_args#iterate"), False)
	if len(tmpargs) == 0:
		return

	args = []

	for arg in tmpargs:
		if arg == "<<<items>>>":
			args += items
		elif arg.startswith("<<<items:"):
			separator = arg[len("<<<items:"):-len(">>>")]
			args.append(separator.join(items))
		else:
			args.append(arg)

	description = action.get("description")
	if description is None:
		description = " ".join(args)
	msg = [ANSIThemeString("Executing “", "action"),
	       ANSIThemeString(description, "argument"),
	       ANSIThemeString("“\n", "action")]

	curses.endwin()
	_retval = clear_screen()

	ansithemeprint(msg)

	if iterate:
		iterations = items
	else:
		iterations = [items]

	for item in iterations:
		substitutions = {}
		if isinstance(item, tuple):
			for i, subitem in enumerate(item):
				substitutions[f"<<<item.{i}>>>"] = subitem
		else:
			substitutions["<<<item>>>"] = item
		iterargs = substitute_list(args, substitutions)

		try:
			result = subprocess.run(iterargs, check = False)
			retval = result.returncode
		except FileNotFoundError:
			ansithemeprint([ANSIThemeString("Error", "error"),
				  ANSIThemeString(": Command “", "default"),
				  ANSIThemeString(f"{args[0]}", "programname"),
				  ANSIThemeString("“ not found", "default")])
			retval = 2

	waitforkeypress = True
	if waitforkeypress or retval > 0:
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])
	uip.stdscr.refresh()

# pylint: disable=unused-argument
def command_hosts(uip: UIProps, items, action, values, kind, **kwargs) -> None:
	values.pop("_tagged_items", None)
	msg = [ANSIThemeString("Executing playbook “", "action"),
	       ANSIThemeString(action.get("description"), "argument"),
	       ANSIThemeString("“ on the following hosts: ", "action")] +\
	       ansithemestring_join_tuple_list(items, formatting = "hostname", separator = ANSIThemeString(", ", "separator")) +\
	       [ANSIThemeString("\n", "action")]

	curses.endwin()
	_retval = clear_screen()

	if action.get("requires_cluster_info"):
		gather_cluster_info()

	ansithemeprint(msg)

	# If run_before is set we have one or several playbooks that need to be run before this one
	runbefore = action.get("run_before", [])

	retval = 0

	for preplaybook in runbefore:
		preplaybookpath = get_playbook_path(FilePath(f"{preplaybook}.yaml"))
		tmpretval = __run_playbook(preplaybookpath, items, values = values)
		if retval == 0:
			retval = tmpretval
		else:
			break

	# If all pre-requisites completed successfully we perform the main task
	if retval == 0:
		retval = run_playbook(action, items, values = values)

	# If everything was successful it is time for the run_after playbooks
	if retval == 0:
		runafter = action.get("run_after", [])

		for postplaybook in runafter:
			postplaybookpath = get_playbook_path(FilePath(f"{postplaybook}.yaml"))
			tmpretval = __run_playbook(postplaybookpath, items, values = values)
			if retval == 0:
				retval = tmpretval
			else:
				break

	# If everything was successful we execute the add_to_groups/remove_from_groups actions
	if retval == 0:
		for group in action.get("add_to_groups", []):
			ansible_add_hosts(ANSIBLE_INVENTORY, items, group = group, skip_all = True)

		for group in action.get("remove_from_groups", []):
			ansible_remove_hosts(ANSIBLE_INVENTORY, items, group = group)

	waitforkeypress = True
	if waitforkeypress or retval > 0:
		ansithemeinput([ANSIThemeString("\nPress Enter to continue...", "default")])
	uip.stdscr.refresh()

# pylint: disable=unused-argument
def cordon_node(uip: UIProps, items, action, values, kind, **kwargs):
	for node in items:
		kh.cordon_node(node)

# pylint: disable=unused-argument
def uncordon_node(uip: UIProps, items, action, values, kind, **kwargs):
	for node in items:
		kh.uncordon_node(node)

nodeplaybooks = {} # type: ignore

def ssh_to_host(stdscr: curses.window, **kwargs):
	if "selected" in kwargs:
		selected = deep_get(kwargs, DictPath("selected"))
		if isinstance(selected, tuple):
			host = selected[0]
		elif isinstance(selected, str):
			host = selected
		else:
			ref = getattr(selected, "ref")
			_kind = deep_get(ref, DictPath("kind"), "")
			_api_group = deep_get(ref, DictPath("api_group"), "")
			try:
				kind = guess_kind((_kind, _api_group))
			except NameError:
				# If we cannot guess the kind we return
				return

			if kind != ("Node", ""):
				# If this is not a Node object, return
				return
			host = deep_get(ref, DictPath("name"), "")
	elif "obj" in kwargs:
		obj = deep_get(kwargs, DictPath("obj"))
		name_path = deep_get(kwargs, DictPath("name_path"))
		name = deep_get(obj, DictPath(name_path))
		host = deep_get(kwargs, DictPath("name"), name)

	if host is None or len(host) == 0:
		return

	msg = [ANSIThemeString("SSH:ing to ", "action"),
	       ANSIThemeString(host, "hostname"),
	       ANSIThemeString(":\n", "action")]

	inventory = ansible_get_inventory_dict()

	# ansible_user in the inventory overrides that defined in cmt.yaml
	# thus we get these in ascending over of priority
	# if no user is specified we assume that we are to use the user we are running as
	sshuser = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_user"))
	sshuser = deep_get(inventory, DictPath("all#vars#ansible_user"), sshuser)
	sshuser = deep_get(inventory, DictPath(f"all#hosts#{host}#ansible_user"), sshuser)

	curses.endwin()
	_retval = clear_screen()
	ansithemeprint(msg)

	try:
		ssh_path = secure_which(SSH_BIN_PATH, fallback_allowlist = [])
	except FileNotFoundError:
		# Once we have support for logging we should probably just log an error
		# and return here instead
		curses.endwin()
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Could not find ", "default"),
				ANSIThemeString("ssh", "path"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if sshuser is not None:
		host = f"{sshuser}@{host}"

	relaxed_ssh_hosts = deep_get(cmtlib.cmtconfig, DictPath("Network#relaxed_ssh_hosts"), [])
	if relaxed_ssh_hosts == ["ALL"] or host in relaxed_ssh_hosts:
		SSH_ARGS = SSH_ARGS_RELAXED
	else:
		SSH_ARGS = SSH_ARGS_STRICT
	args = [ssh_path] + SSH_ARGS + [host]

	subprocess.run(args, check = False)

	stdscr.refresh()

def list_configuration_files(basedir):
	# Always provide a means to navigate up in the directory tree
	plist = []
	directories = []
	kustomizations = []
	files = []

	if os.path.isdir(basedir):
		for filename in os.listdir(basedir):
			if filename.startswith(("~", ".")):
				continue

			# real path, display name, type
			if filename.endswith((".yaml", ".yml")):
				files.append((f"{basedir}/{filename}", filename, "Configuration File"))
			elif os.path.isdir(f"{basedir}/{filename}"):
				if os.path.isfile(f"{basedir}/{filename}/kustomization.yaml"):
					files.append((f"{basedir}/{filename}", filename, "Kustomization"))
				else:
					files.append((f"{basedir}/{filename}", filename, "<dir>"))
			else:
				continue

	plist = [(f"{os.path.dirname(basedir)}", "..", "<dir>")]
	plist += natsorted(directories)
	plist += natsorted(kustomizations)
	plist += natsorted(files)

	return plist

# pylint: disable=unused-argument
def populate_actionlist(context = None, action_list = None, control_plane_selected = False, single_item = False, cluster_available = True):
	actions = []
	order = []
	for item in action_list:
		context_types = deep_get(action_list, DictPath(f"{item}#context_types"))
		if context is not None and context_types != [] and context not in context_types:
			continue

		description = deep_get(action_list, DictPath(f"{item}#description"))
		category = deep_get(action_list, DictPath(f"{item}#category"), "")
		name = item
		order.append((description, category, name))

	currentcategory = ""
	for item in natsorted(order, key = itemgetter(1, 0)):
		action = item[0]
		category = item[1]
		allowoncontrolplane = deep_get(action_list, DictPath(f"{item[2]}#allow_on_control_plane"), True)
		singleoncontrolplane = deep_get(action_list, DictPath(f"{item[2]}#single_on_control_plane"), False)
		singleonly = deep_get(action_list, DictPath(f"{item[2]}#single_only"), False)
		readonly = deep_get(action_list, DictPath(f"{item[2]}#read_only"), False)
		metadata = deep_get(action_list, DictPath(f"{item[2]}#metadata"), [])
		tmp = []
		for md in metadata:
			if isinstance(md, ThemeString):
				tmp.append(md)
			elif isinstance(md[1], list):
				tmp.append(ThemeString(md[0], ThemeAttr(md[1][0], md[1][1])))
			else:
				raise ValueError(f"Unknown type for metadata {type(md)} for metadata {md}; expected ThemeString(str, ThemeAttr) or [str, [str, str]]")
		metadata = tmp
		if singleonly and not single_item:
			continue
		if singleoncontrolplane and control_plane_selected and not single_item:
			continue
		if not allowoncontrolplane and control_plane_selected:
			continue
		if not readonly and read_only_mode:
			continue

		if currentcategory != category:
			actions.append({
				"lineattrs": WidgetLineAttrs.SEPARATOR,
				"columns": [[ThemeString(f" {category} ", ThemeAttr("windowwidget", "default"))],
					    [ThemeString("", ThemeAttr("windowwidget", "default"))]],
			})
			currentcategory = category
		actions.append({
			"lineattrs": WidgetLineAttrs.NORMAL,
			"columns": [[ThemeString(f"{action}", ThemeAttr("windowwidget", "default"))], metadata],
		})

	return actions, action_list

def __populate_playbooklist(path: FilePath, action_list: Optional[Dict]) -> Optional[Dict]:
	if not os.path.isdir(path):
		return None

	if action_list is None:
		action_list = {}

	yaml_regex = re.compile(r"^(.*)\.ya?ml$")

	for playbookpath in Path(path).iterdir():
		if playbookpath.name.startswith(("~", ".")):
			continue

		tmp = yaml_regex.match(playbookpath.name)
		if tmp is None:
			continue

		playbookname = str(tmp[1])

		# Check if the playbook already exists in the action list,
		if playbookname in action_list:
			continue

		description = None

		try:
			d = secure_read_yaml(FilePath(str(playbookpath)), directory_is_symlink = True)
		except yaml.YAMLError:
			# This entry could not be parsed; add a dummy entry
			action_list[playbookname] = {
				"description": playbookpath,
				"playbook": FilePath(str(playbookpath)),
				"category": "__INVALID__",
				"comments": "Failed to parse (Not valid YAML)",
			}
			continue

		# Empty files are used to disable playbooks completely
		if d is None or len(d) == 0:
			action_list[playbookname] = {
				"description": playbookpath,
				"playbook": FilePath(str(playbookpath)),
				"category": "__DISABLED__",
			}
			continue

		if not isinstance(d, list):
			# This entry could not be parsed; add a dummy entry
			action_list[playbookname] = {
				"description": playbookpath,
				"playbook": FilePath(str(playbookpath)),
				"category": "__INVALID__",
				"comments": "Failed to parse (Not a list of plays)",
			}
			continue

		description = deep_get(d[0], DictPath("vars#metadata#description"))

		# Ignore all playbooks that lack a description;
		# typically they are internal playbooks
		if description is None:
			continue

		query = deep_get(d[0], DictPath("vars#metadata#query#string"))
		queryval = deep_get(d[0], DictPath("vars#metadata#query#variable"))
		queryfunc = deep_get(d[0], DictPath("vars#metadata#query#function"))

		# Sanity check
		if queryfunc is not None:
			if queryfunc not in ("string", "yesno", "filechooser"):
				raise ValueError(f"unknown queryfunc “{queryfunc}“ provided")

		confirm = deep_get(d[0], DictPath("vars#metadata#confirm"), False)
		tmpallowoncontrolplane = deep_get(d[0], DictPath("vars#metadata#allow_on_control_plane"))
		if tmpallowoncontrolplane is None or tmpallowoncontrolplane == "always":
			allowoncontrolplane = True
			singleoncontrolplane = False
		elif tmpallowoncontrolplane.lower() == "single":
			allowoncontrolplane = True
			singleoncontrolplane = True
		elif tmpallowoncontrolplane.lower() == "never":
			allowoncontrolplane = False
			singleoncontrolplane = False
		else:
			raise ValueError(f"{playbookpath}: Invalid values for allow-on-control-plane")

		requiresclusterinfo = deep_get_with_fallback(d[0], [DictPath("vars#metadata#requires_cluster_info"), DictPath("vars#metadata#requires-cluster-info")], False)
		runbefore = deep_get_with_fallback(d[0], [DictPath("vars#metadata#run_before"), DictPath("vars#metadata#run-before")], [])
		runafter = deep_get_with_fallback(d[0], [DictPath("vars#metadata#run_after"), DictPath("vars#metadata#run-after")], [])
		addtogroups = deep_get_with_fallback(d[0], [DictPath("vars#metadata#add_to_groups"), DictPath("vars#metadata#add-to-groups")], [])
		removefromgroups = deep_get_with_fallback(d[0], [DictPath("vars#metadata#remove_from_groups"), DictPath("vars#metadata#remove-from-groups")], [])
		category = deep_get(d[0], DictPath("vars#metadata#category"), "Uncategorized")
		playbooktypes = deep_get_with_fallback(d[0], [DictPath("vars#metadata#playbook_types"), DictPath("vars#metadata#playbook-types")], [])
		comments = deep_get(d[0], DictPath("vars#metadata#comments"), "")
		readonly = deep_get_with_fallback(d[0], [DictPath("vars#metadata#read_only"), DictPath("vars#metadata#read-only")], False)
		extravars = {
			"quiet": deep_get(d[0], DictPath("vars#metadata#quiet"), False),
		}

		action_list[playbookname] = {
			"description": description,
			"playbook": FilePath(str(playbookpath)),
			"query": query,
			"queryval": queryval,
			"queryfunc": queryfunc,
			"confirm": confirm,
			"allow_on_control_plane": allowoncontrolplane,
			"single_on_control_plane": singleoncontrolplane,
			"requires_cluster_info": requiresclusterinfo,
			"run_before": runbefore,
			"run_after": runafter,
			"add_to_groups": addtogroups,
			"remove_from_groups": removefromgroups,
			"category": category,
			"playbook_types": playbooktypes,
			"comments": comments,
			"read_only": readonly,
			"extravars": extravars,
		}

	return action_list

# pylint: disable-next=too-many-arguments
def populate_playbooklist(context, actions, action_list, control_plane_selected, single_item = False, cluster_available = True):
	local_playbooks = deep_get(cmtlib.cmtconfig, DictPath("Ansible#local_playbooks"), [])
	for playbook_path in local_playbooks:
		# Substitute {HOME}/ for {HOMEDIR}
		if playbook_path.startswith(("{HOME}/", "{HOME}\\")):
			playbook_path = FilePath(str(PurePath(HOMEDIR).joinpath(playbook_path[len('{HOME}/'):])))
		# Skip non-existing playbook paths
		if not os.path.isdir(playbook_path):
			continue
		action_list = __populate_playbooklist(playbook_path, action_list = action_list)
	action_list = __populate_playbooklist(ANSIBLE_PLAYBOOK_DIR, action_list = action_list)

	order = []
	for item in action_list:
		playbooktypes = action_list[item].get("playbook_types", [])
		if context is not None and playbooktypes != [] and context not in playbooktypes:
			continue

		description = action_list[item].get("description")
		category = action_list[item].get("category", "")
		name = item
		order.append((description, category, name))

	currentcategory = ""
	for item in natsorted(order, key = itemgetter(1, 0)):
		action = item[0]
		category = item[1]
		allowoncontrolplane = action_list[item[2]].get("allow_on_control_plane", True)
		singleoncontrolplane = action_list[item[2]].get("single_on_control_plane", True)
		readonly = action_list[item[2]].get("read_only", False)
		comments = action_list[item[2]].get("comments", "")
		lineattrs = WidgetLineAttrs.NORMAL
		if read_only_mode and not readonly:
			continue
		if singleoncontrolplane and control_plane_selected and not single_item:
			continue
		if not allowoncontrolplane and control_plane_selected:
			continue

		if action_list[item[2]].get("requires_cluster_info", False) and not cluster_available:
			metadata = []
			if len(comments) > 0:
				metadata.append(ThemeString(f"{comments},", ThemeAttr("windowwidget", "highlight")))
			metadata.append(ThemeString("<cluster not available>", ThemeAttr("windowwidget", "alert")))
			lineattrs = WidgetLineAttrs.UNSELECTABLE
		elif category == "__INVALID__":
			lineattrs = WidgetLineAttrs.UNSELECTABLE & WidgetLineAttrs.INVALID
			metadata = [ThemeString(comments, ThemeAttr("windowwidget", "alert"))]
		elif category == "__DISABLED__":
			continue
		else:
			metadata = [ThemeString(comments, ThemeAttr("windowwidget", "highlight"))]

		if currentcategory != category:
			if category == "__INVALID__":
				actions.append({
					"lineattrs": WidgetLineAttrs.SEPARATOR,
					"columns": [[ThemeString(" INVALID ", ThemeAttr("windowwidget", "bright"))], [ThemeString("", ThemeAttr("windowwidget", "default"))]],
				})
				currentcategory = category
			else:
				actions.append({
					"lineattrs": WidgetLineAttrs.SEPARATOR,
					"columns": [[ThemeString(f" {category} ", ThemeAttr("windowwidget", "default"))], [ThemeString("", ThemeAttr("windowwidget", "default"))]],
				})
				currentcategory = category
		if currentcategory == "__INVALID__":
			actions.append({
				"lineattrs": lineattrs,
				"columns": [[ThemeString(f"{action}", ThemeAttr("windowwidget", "alert"))], metadata],
			})
		else:
			actions.append({
				"lineattrs": lineattrs,
				"columns": [[ThemeString(f"{action}", ThemeAttr("windowwidget", "default"))], metadata],
			})

	return actions, action_list

force_refresh_apis = False

def format_selection_list(uip: UIProps, refresh_apis = False):
	global force_refresh_apis  # pylint: disable=global-statement

	if force_refresh_apis:
		force_refresh_apis = False
		refresh_apis = True

	hide_unavailable = deep_get_with_fallback(cmtlib.cmtconfig, [DictPath("__Selector#hide_unavailable_apis"), DictPath("Global#hide_unavailable_apis")], True)
	categorise = deep_get(cmtlib.cmtconfig, DictPath("__Selector#categorise"), True)
	sortcolumn = deep_get(cmtlib.cmtconfig, DictPath("__Selector#sortcolumn"), "family")

	if sortcolumn == "family":
		if categorise:
			sortkey1 = 1
			sortkey2 = 2
		else:
			sortkey1 = 2
			sortkey2 = 0
	elif sortcolumn == "name":
		if categorise:
			sortkey1 = 1
			sortkey2 = 0
		else:
			sortkey1 = 0
			sortkey2 = 2
	else:
		sys.exit(f"Invalid sortcolumn {sortcolumn} for Selector; aborting.")

	if refresh_apis:
		_notice = curses_helper.notice(None, y = uip.maxy // 2, x = uip.maxx // 2, message = "Refreshing list of available APIs")
		# Repopulate the list of views, on the offhand chance that a view file has been added
		populate_views(force_refresh = refresh_apis)
		curses.doupdate()

	if kubernetes_support:
		available_api_families, _status, _modified = kh.get_available_kinds()
	else:
		available_api_families = {}

	items = []
	order = []

	# Find the correct sort order
	for viewkey, viewref in views.items():
		kind = None
		if deep_get(viewref, DictPath("skip"), False):
			continue
		if hide_unavailable:
			kind = deep_get(viewref, DictPath("kind"), ("", ""))
			if kind is not None and kind != ("", ""):
				if not kind[0].startswith("__") and (kind not in available_api_families or not deep_get(available_api_families[kind], DictPath("available"), False)):
					continue
			check_availability = deep_get(viewref, DictPath("check_availability"), None)
			if check_availability is not None:
				if not check_availability():
					continue
		group = deep_get(viewref, DictPath("group"))
		# XXX: Do override in a nicer manner; perhaps we want all "built-in" groups first?
		if group == "Administration":
			group = "0"
		elif group == "Core":
			group = "1"
		elif group == "Workloads":
			group = "2"
		elif "(Deprecated)" in group:
			# This should ensure that all deprecated groups end up last, but still sorted
			group = "ZZZZZ" + group

		view_name = deep_get(viewref, DictPath("windowheader"))

		if kind is not None:
			api_group = kind[1]
		else:
			api_group = ""

		if group is None:
			raise ValueError(f"group should not be None unless skip=True; view: {view_name}")

		order.append((view_name, group, api_group))

	currentgroup = ""
	for item in natsorted(order, key = itemgetter(sortkey1, sortkey2)):
		view = item[0]
		viewkey = view
		api_group = item[2]
		if len(api_group) > 0:
			viewkey = f"{view} ({api_group})"
		viewref = views[viewkey]

		# This allows us to override the sort order
		group = deep_get(viewref, DictPath("group"), "")
		kind = deep_get(viewref, DictPath("kind"), ("", ""))
		if kind is not None:
			api_group = kind[1]
		else:
			api_group = ""

		if currentgroup != group and categorise:
			items.append({
				"lineattrs": WidgetLineAttrs.SEPARATOR,
				"columns": [[ThemeString(f" {group} ", ThemeAttr("windowwidget", "highlight"))],
					    [ThemeString("", ThemeAttr("windowwidget", "default"))]],
			})
			currentgroup = group
		lineattrs = WidgetLineAttrs.NORMAL
		if kind is not None and kind != ("", "") and not kind[0].startswith("__") and (kind not in available_api_families or not deep_get(available_api_families[kind], DictPath("available"), False)):
			lineattrs = WidgetLineAttrs.UNSELECTABLE
		if api_group == "":
			items.append({
				"lineattrs": lineattrs,
				"columns": [[ThemeString(f"{view}", ThemeAttr("windowwidget", "default"))],
					    [ThemeString("", ThemeAttr("windowwidget", "dim"))]],
				"retval": viewkey,
			})
		else:
			items.append({
				"lineattrs": lineattrs,
				"columns": [[ThemeString(f"{view}", ThemeAttr("windowwidget", "default"))],
					    [ThemeString(f"<{api_group}>", ThemeAttr("windowwidget", "dim"))]],
				"retval": viewkey,
			})

	return items

def selectwindow(uip: UIProps, refresh_apis = False) -> Retval:
	# Ideally we want to return to the same selection
	global defaultview  # pylint: disable=global-statement

	uip.refresh_all()
	items = format_selection_list(uip, refresh_apis)
	title = "Choose view"

	selection = None

	categorise = deep_get(cmtlib.cmtconfig, DictPath("__Selector#categorise"), True)

	while selection is None:
		extra_args = { "KEY_F6": True }
		tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2, items, title = title, preselection = defaultview, **extra_args)
		if tmpselection is not None:
			# pylint: disable-next=unidiomatic-typecheck
			if type(tmpselection) == int and tmpselection < 0:  # noqa: E721
				if tmpselection == -curses.KEY_F6:
					categorise = not categorise
					deep_set(cmtlib.cmtconfig, DictPath("__Selector#categorise"), categorise, create_path = True)
					items = format_selection_list(uip, refresh_apis)
					uip.refresh_all()
					continue
			selection = tmpselection

	if selection != "":
		defaultview = selection
		return Retval.RETURNFULL

	return Retval.NOMATCH

def selectorloop(stdscr: curses.window, view: str) -> Retval:
	field_list, sortcolumn = (None, None)
	uip = UIProps(stdscr)

	windowheader = deep_get(views, DictPath(f"{view}#windowheader"), view)

	uip.init_window(field_list = field_list, windowheader = windowheader, sortcolumn = sortcolumn)

	while True:
		retval = selectwindow(uip)
		if retval == Retval.RETURNFULL:
			return retval

listviewactions = {
	"Apply configuration (local)": {
		"description": "Apply configurations from file/Kustomization (autodetected)",
		"confirm": True,
		"actionfunc": perform_action_on_configuration,
		"query": "Choose file or Kustomization to apply:",
		"queryval": "resource_path",
		"queryfunc": "filechooser",
		"extravars": {
			"action": "apply",
			"listgetter": list_configuration_files,
			"basedir": DEPLOYMENT_DIR,
		},
		#"confirmfunc":
		#"confirmstring": "The following changes will be performed:",
	},
	"Create resources (local)": {
		"description": "Create resources from file/Kustomization (autodetected)",
		"actionfunc": perform_action_on_configuration,
		"query": "Choose file or Kustomization to create:",
		"queryval": "resource_path",
		"queryfunc": "filechooser",
		"extravars": {
			"action": "create",
			"listgetter": list_configuration_files,
			"basedir": DEPLOYMENT_DIR,
		},
	},
	"Apply configuration (URL to file)": {
		"description": "Apply configurations from URL (file)",
		"confirm": True,
		"actionfunc": perform_action_on_configuration,
		"query": "URL to apply",
		"queryval": "resource_url",
		"queryfunc": "string",
		"extravars": {
			"action": "apply",
			"rtype": "Configuration File",
		},
		#"confirmfunc":
		#"confirmstring": "The following changes will be performed:",
	},
	"Apply configuration (URL to Kustomization)": {
		"description": "Apply configurations from URL (Kustomization)",
		"confirm": True,
		"actionfunc": perform_action_on_configuration,
		"query": "URL to apply",
		"queryval": "resource_url",
		"queryfunc": "string",
		"extravars": {
			"action": "apply",
			"rtype": "Kustomization",
		},
		#"confirmfunc":
		#"confirmstring": "The following changes will be performed:",
	},
	"Create resources (URL to file)": {
		"description": "Create resources from URL (file)",
		"actionfunc": perform_action_on_configuration,
		"query": "URL to create resource from",
		"queryval": "resource_url",
		"queryfunc": "string",
		"extravars": {
			"action": "create",
			"rtype": "Configuration File",
		},
	},
	"Create resources (URL to Kustomization)": {
		"description": "Create resources from URL (Kustomization)",
		"actionfunc": perform_action_on_configuration,
		"query": "URL to create resource from",
		"queryval": "resource_url",
		"queryfunc": "string",
		"extravars": {
			"action": "create",
			"rtype": "Kustomization",
		},
	},
	"Delete resources (file)": {
		"description": "Delete resource by reverting configuration file/Kustomization (autodetected)",
		"actionfunc": perform_action_on_configuration,
		"query": "Choose file or Kustomization to delete:",
		"queryval": "resource_path",
		"queryfunc": "filechooser",
		"extravars": {
			"action": "delete",
			"listgetter": list_configuration_files,
			"basedir": DEPLOYMENT_DIR,
		},
	},
	"Delete resources (URL to file)": {
		"description": "Delete resource by reverting configuration URL (file)",
		"actionfunc": perform_action_on_configuration,
		"query": "URL to configuration file to revert",
		"queryval": "resource_url",
		"queryfunc": "string",
		"extravars": {
			"action": "delete",
			"rtype": "Configuration File",
		},
	},
	"Delete resources (URL to Kustomization)": {
		"description": "Delete resource by reverting configuration URL (Kustomization)",
		"actionfunc": perform_action_on_configuration,
		"query": "URL to configuration Kustomization to revert",
		"queryval": "resource_url",
		"queryfunc": "string",
		"extravars": {
			"action": "delete",
			"rtype": "Kustomization",
		},
	},
	"Diff resource creation (local)": {
		"description": "Show what changes applying file or Kustomization would make (autodetect)",
		"actionfunc": diff_resource_configuration,
		"query": "Choose file or Kustomization to show difference against:",
		"queryval": "resource_path",
		"queryfunc": "filechooser",
		"extravars": {
			"listgetter": list_configuration_files,
			"basedir": DEPLOYMENT_DIR,
		},
	},
	"Diff resource creation (URL to file)": {
		"description": "Show what changes applying URL would make (file)",
		"actionfunc": diff_resource_configuration,
		"query": "URL to file to show difference against",
		"queryval": "resource_url",
		"queryfunc": "string",
		"extravars": {
			"rtype": "Configuration File",
		},
	},
	"Diff resource creation (URL to Kustomization)": {
		"description": "Show what changes applying URL would make (Kustomization)",
		"actionfunc": diff_resource_configuration,
		"query": "URL to Kustomization to show difference against",
		"queryval": "resource_url",
		"queryfunc": "string",
		"extravars": {
			"rtype": "Kustomization",
		},
	},
}

infoviews = {} # type: ignore

# These functions are used to check whether an API is available
def is_kubernetes_supported() -> bool:
	return kubernetes_support

def is_cluster_reachable() -> bool:
	reachable = False

	if kubernetes_support and kh is not None:
		reachable = kh.is_cluster_reachable()
	return reachable

availability_checker_allowlist = {
	"is_cluster_reachable": is_cluster_reachable,
	"is_kubernetes_supported": is_kubernetes_supported,
}

# action calls acceptable for direct use in view files
action_call_allowlist = {
	"create_namespace": create_namespace,
	"decode_and_view_data": decode_and_view_data,
	"decode_and_view_file_templates": decode_and_view_file_templates,
	"eventdispatch": eventdispatch,
	"export_data": export_data,
	"listviewdispatch": listviewdispatch,
	"patch_object": patch_object,
	"resourceinfodispatch_from_pod_resource_list": resourceinfodispatch_from_pod_resource_list,
	"resourceinfodispatch_with_lookup": resourceinfodispatch_with_lookup,
	"set_cluster_context": set_cluster_context,
	"ssh_to_host": ssh_to_host,
	"view_obj": view_obj,
	"view_pod_logs": view_pod_logs,
	"view_yaml": view_yaml,
}

# Actionfuncs acceptable for direct use in view files
actionfunc_allowlist = {
	"action_view_pod_logs": action_view_pod_logs,
	"cordon_node": cordon_node,
	"delete_logs": delete_logs,
	"delete_resource": delete_resource,
	"force_delete_resource": force_delete_resource,
	"patch_resource": patch_resource,
	"rescale_resource": rescale_resource,
	"restart_resource_rescale": restart_resource_rescale,
	"restart_resource_rollout": restart_resource_rollout,
	"stop_resource_rescale": stop_resource_rescale,
	"uncordon_node": uncordon_node,
}

# Activatedfuns acceptable for direct use in view files
activatedfun_allowlist = {
	"resourceinfodispatch": resourceinfodispatch,
	"resourceinfodispatch_from_pod_resource_list": resourceinfodispatch_from_pod_resource_list,
	"resourceinfodispatch_with_lookup_on_activation": resourceinfodispatch_with_lookup_on_activation,
}

# Infogetters acceptable for direct use in view files
infogetter_allowlist = {
	# Used by listview, infopad, and listpad
	"generic_infogetter": generic_infogetter,
	# Used by listview
	"get_container_info": get_container_info,
	"get_log_info": get_log_info,
	# Used by listpad
	"get_auth_rule_info": get_auth_rule_info,
	"get_eps_subsets_info": get_eps_subsets_info,
	"get_key_value_info": get_key_value_info,
	"get_limit_info": get_limit_info,
	"get_promrules_info": get_promrules_info,
	"get_rq_item_info": get_rq_item_info,
	"get_sas_info": get_sas_info,
	"get_strategy_info": get_strategy_info,
	"get_subsets_info": get_subsets_info,
	"get_svcmon_endpoints_info": get_svcmon_endpoints_info,
	# Used by logpad
	"logpad_formatted": logpad_formatted,
	# XXX: We should aim to replace this with logpad_formatted
	"logpad_msg_getter": logpad_msg_getter,
	# XXX: We should aim to replace this with logpad_formatted
	"logpad_yaml": logpad_yaml,
	"logpad_files": logpad_files,
	"get_journalctl_log": get_journalctl_log,
	"get_task_log": get_task_log,
	"get_cmt_log": get_cmt_log,
	"get_themearrays": get_themearrays,
	"get_traceflow": get_traceflow,
}

# Listgetters acceptable for direct use in view files
listgetter_allowlist = {
	# Used by listview, listpad
	"generic_listgetter": generic_listgetter,
	"get_metrics_list": get_metrics_list,
	"get_pod_containers_list": get_pod_containers_list,
	"listgetter_files": listgetter_files,
	"listgetter_dir": listgetter_dir,
	# Used by listpad
	"get_hpa_metrics": get_hpa_metrics,
	"get_ingress_rule_list": get_ingress_rule_list,
	"get_netpol_rule_list": get_netpol_rule_list,
	"get_pod_resource_list": get_pod_resource_list,
	"get_resource_info_by_last_applied_configuration": get_resource_info_by_last_applied_configuration,
	"get_sidecar_rule_list": get_sidecar_rule_list,
	"get_virtsvc_rule_list": get_virtsvc_rule_list,
	"listgetter_ansible_volumes": listgetter_ansible_volumes,
	"listgetter_configmap_data": listgetter_configmap_data,
	"listgetter_dict_list": listgetter_dict_list,
	"listgetter_field": listgetter_field,
	"listgetter_join_dicts_to_list": listgetter_join_dicts_to_list,
	"listgetter_join_lists": listgetter_join_lists,
	"listgetter_matchrules": listgetter_matchrules,
	"listgetter_namespaced_resources": listgetter_namespaced_resources,
	"listgetter_noop": listgetter_noop,
	"listgetter_feature_gates": listgetter_feature_gates,
	"listgetter_path": listgetter_path,
	"listgetter_policy_rules": listgetter_policy_rules,
}

# Asynchronous listgetters acceptable for direct use in view files
listgetter_async_allowlist = {
	# Used by listpad
	"get_kubernetes_list_async": get_kubernetes_list_async,
	"get_context_list": get_context_list,
	"get_inventory_list": get_inventory_list,
}

# These views are always defined internally and cannot be disabled
views_special = {
	"Selector": {
		"windowheader": "Selector",
		"kind": ("__Selector", ""),
		"commandline": ["selector"],
		"viewfunc": selectorloop,
		"fields": None,
		"skip": True,
		"is_taggable": False,
	},
	"Cluster Overview": {
		"windowheader": "Cluster Overview",
		"kind": ("__ClusterOverview", ""),
		"commandline": ["clusteroverview", "clusterinfo", "overview", "co", "ci"],
		"group": "Administration",
		"viewfunc": clusteroverviewloop,
		"fields": None,
		"update_delay": 5,
		"sortcolumn": None,
		"activatedfun": None,
		"listgetter": None,
		"infogetter": None,
		"is_taggable": False,
		"check_availability": is_cluster_reachable,
	},
	"Container Network Interface Info": {
		"windowheader": "Container Network Interface Info",
		"kind": ("__ContainerNetworkInterface", ""),
		"commandline": ["cni"],
		"group": "Administration",
		"viewfunc": cniloop,
		"fields": None,
		"sortcolumn": None,
		"activatedfun": None,
		"listgetter": None,
		"infogetter": None,
		"check_availability": is_cluster_reachable,
	},
}

views = {**views_special}

key_mappings = {
	"f1": curses.KEY_F1,
	"f2": curses.KEY_F2,
	"f3": curses.KEY_F3,
	"f4": curses.KEY_F4,
	"f5": curses.KEY_F5,
	"f6": curses.KEY_F6,
	"f7": curses.KEY_F7,
	"f8": curses.KEY_F8,
	"f9": curses.KEY_F9,
	"f10": curses.KEY_F10,
	"f11": curses.KEY_F11,
	"f12": curses.KEY_F12,
	"f13": curses.KEY_F13,
	"f14": curses.KEY_F14,
	"f15": curses.KEY_F15,
	"f16": curses.KEY_F16,
	"f17": curses.KEY_F17,
	"f18": curses.KEY_F18,
	"f19": curses.KEY_F19,
	"f20": curses.KEY_F20,
	"f21": curses.KEY_F21,
	"f22": curses.KEY_F22,
	"f23": curses.KEY_F23,
	"f24": curses.KEY_F24,
}

def map_key(view_file: str, shortcut: str, activatedfun, key: str, modifier: str) -> Tuple[Union[int, List[int]], str]:
	if len(modifier) > 0 and modifier not in ("ctrl", "shift"):
		sys.exit(f"View-file {view_file} is invalid: unknown modifier {modifier}; valid modifiers are shift, ctrl; aborting")

	if key in ("f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12") and len(modifier) == 0:
		shortcut_key = deep_get(key_mappings, DictPath(key))
		help_key = f"[{key.upper()}]"
	elif key in ("f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12") and modifier == "shift":
		_key = key[0] + str(int(key[1:]) + 12)
		num = int(key[1:]) + 12
		shortcut_key = deep_get(key_mappings, DictPath(_key))
		help_key = f"[Shift] + [{key.upper()}] / [{key[0].upper()}{num}]"
	elif key in ("f13", "f14", "f15", "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23", "f24") and len(modifier) == 0:
		num = int(key[1:]) - 12
		_key = key[0] + str(num)
		shortcut_key = deep_get(key_mappings, DictPath(key))
		help_key = f"[Shift] + [{key[0].upper()}{num}] / [{key.upper()}]"
	elif key in ("enter", "return"):
		if len(modifier) > 0:
			help_key = "[Enter]"
			shortcut_key = [curses.KEY_ENTER, 10, 13]
		if len(modifier) > 0 or activatedfun is None:
			help_key = "[Enter]"
			shortcut_key = [curses.KEY_ENTER, 10, 13]
		else:
			sys.exit(f"View-file “{view_file}“ is invalid: the listview shortcut “{shortcut}“ uses “enter“ as key; this conflicts with built-in shortcut for “on_activation“.")
	elif len(modifier) > 0:
		if modifier == "shift":
			help_key = f"[Shift] + {key.upper()}"
			shortcut_key = ord(key.upper())
		elif modifier == "ctrl":
			help_key = f"[Ctrl] + {key.upper()}"
			shortcut_key = ord(key) - 96
	else:
		help_key = f"{key.upper()}"
		shortcut_key = ord(key)

	return shortcut_key, help_key

def populate_views(force_refresh: bool = False) -> None:
	global views  # pylint: disable=global-statement

	if kubernetes_support:
		tmp_available_api_families, _status, _modified = kh.get_available_kinds(force_refresh = force_refresh)
	else:
		tmp_available_api_families = {}

	available_api_families = set()
	for kind, kind_data in tmp_available_api_families.items():
		if deep_get(kind_data, DictPath("available"), False):
			available_api_families.add(kind)

	viewdir = os.path.join(VIEW_DIR)
	if not os.path.isdir(viewdir):
		sys.exit(f"{viewdir} does not exist; please re-run {about.INSTALL_PROGRAM_NAME}")

	# Get a full list of views from all view directories
	# Start by adding files from the views directory
	view_dirs = []
	view_dirs += deep_get(cmtlib.cmtconfig, DictPath("General#local_views"), [])

	views = {**views_special}

	view_dirs.append(viewdir)

	view_files = []

	yaml_regex = re.compile(r"^(.*)\.ya?ml$")

	for view_dir in view_dirs:
		if view_dir.startswith("{HOME}"):
			view_dir = view_dir.replace("{HOME}", HOMEDIR, 1)

		if not os.path.isdir(view_dir):
			continue

		for filename in natsorted(os.listdir(view_dir)):
			if filename.startswith(("~", ".")):
				continue
			if not filename.endswith((".yaml", ".yml")):
				continue

			match_tmp = yaml_regex.match(filename)
			tmp = match_tmp[1]
			if "." in tmp:
				kind, api_family = tmp.split(".", 1)
			else:
				kind = tmp
				api_family = ""
			if (kind, api_family) in available_api_families or kind.startswith("__"):
				view_files.append(os.path.join(view_dir, filename))

	for view_file in view_files:
		has_listview = False
		has_infoview = False

		try:
			d = secure_read_yaml(FilePath(view_file), directory_is_symlink = True)
		except yaml.parser.ParserError:
			sys.exit(f"View-file {view_file} is invalid; aborting.")

		kind = deep_get(d, DictPath("kind"), "<missing>")
		default_command = deep_get(d, DictPath("default_command"), "<missing>")
		if kind is None or default_command is None or "<missing>" in (kind, default_command):
			sys.exit(f"View-file {view_file} is invalid: the following fields cannot be missing or None:\n"
				 f"kind: {kind}\n"
				 f"default_command: {default_command}\n"
				  "Aborting.")

		api_family = deep_get(d, DictPath("api_family"), "")
		# Use a set to avoid duplicates
		_command = set()
		if not kind.startswith("__"):
			# If there's a "." in the command it means the plural or singular is not unique without api_family;
			# do not add the lowercase form of kind automagically
			if "." not in default_command:
				_command.add(kind.lower())
		if len(deep_get(d, DictPath("command"), [])) > 0:
			_command = set.union(_command, set(deep_get(d, DictPath("command"), [])))
		# OK, we've got all commands we wanted; now we want the preferred form first
		_command.discard(default_command)
		_command = [default_command] + list(_command)
		# Finally, now that we have a list, add variants with api_family suffixed
		command = list(_command)
		if len(api_family) > 0:
			for item in _command:
				command.append(f"{item}.{api_family}")

		listview_entry = None

		if "listview" not in d and "infoview" not in d:
			sys.exit(f"View-file {view_file} lacks both listview and infoview; there might be typo somewhere")

		if "listview" in d:
			# Do we need to override kind?
			if deep_get(d, DictPath("listview#kind")) is not None:
				kind = deep_get(d, DictPath("listview#kind"))
				api_family = deep_get(d, DictPath("listview#api_family"), "")
			name = deep_get(d, DictPath("listview#name"), "<missing>")
			group = deep_get(d, DictPath("listview#group"))

			check_availability = deep_get(d, DictPath("listview#check_availability"), None)
			if check_availability is not None:
				if isinstance(check_availability, str):
					check_availability = deep_get(availability_checker_allowlist, DictPath(check_availability))

			sortcolumn = deep_get(d, DictPath("listview#sortcolumn"))
			reversible = deep_get(d, DictPath("listview#reversible"), True)
			sortorder_reverse = deep_get(d, DictPath("listview#sortorder_reverse"), False)
			fields = deep_get(d, DictPath("listview#fields"), {})

			field_indexes = {}
			_indexes = deep_get(d, DictPath("listview#field_indexes"), {})
			confkind = kind
			viewname = name
			if len(api_family) > 0:
				confkind = f"{confkind}.{api_family}"
				viewname = f"{viewname} ({api_family})"

			custom_index = deep_get(cmtlib.cmtconfig, DictPath(f"Views#{confkind}#listview#field_indexes#Custom"), [])
			if len(custom_index) > 0:
				_indexes["Custom"] = custom_index

			if len(_indexes) == 0:
				sys.exit(f"View-file {view_file} is invalid: field_indexes is either missing or empty for the list view. Aborting.")

			field_indexes = copy.deepcopy(_indexes)

			# Allow for overriding the default sortcolumn and sortorder_reverse
			for field_index, data in field_indexes.items():
				if field_index in deep_get(cmtlib.cmtconfig, DictPath(f"Views#{confkind}#listview#field_indexes"), {}):
					default_field_index_sortcolumn = deep_get(data, DictPath("sortcolumn"), sortcolumn)
					default_field_index_sortorder_reverse = deep_get(data, DictPath("sortorder_reverse"), sortorder_reverse)
					field_index_sortcolumn = deep_get(cmtlib.cmtconfig, DictPath(f"Views#{confkind}#listview#field_indexes#{field_index}#sortcolumn"), default_field_index_sortcolumn)
					field_index_sortorder_reverse = deep_get(cmtlib.cmtconfig, DictPath(f"Views#{confkind}#listview#field_indexes#{field_index}#sortorder_reverse"), default_field_index_sortorder_reverse)
					field_indexes[field_index]["sortcolumn"] = field_index_sortcolumn
					field_indexes[field_index]["sortorder_reverse"] = field_index_sortorder_reverse

			if name is None or group is None or "<missing>" in (name, group):
				sys.exit(f"View-file {view_file} is invalid: the following fields cannot be missing, empty or None:\n"
					  "listview:\n"
					 f"  name: {name}\n"
					 f"  group: {group}\n"
					  "Aborting.")

			if viewname in views:
				conflicting_kind = deep_get(views[viewname], DictPath("kind"))
				sys.exit(f"Error when processing view-file {view_file} for kind: {(kind, api_family)}; a view named {viewname} already exists (for the kind: {conflicting_kind})")

			# This complexity is required because if the key is missing we want to use the default,
			# but if the key is explicitly None we do not want any fallback
			if "infogetter" in deep_get(d, DictPath("listview")):
				infogetter = deep_get(d, DictPath("listview#infogetter"))
				if infogetter is not None:
					infogetter = deep_get(infogetter_allowlist, DictPath(infogetter), generic_infogetter)
			else:
				infogetter = generic_infogetter

			# This complexity is required because if the key is missing we want to use the default,
			# but if the key is explicitly None we do not want any fallback
			if "listgetter" in deep_get(d, DictPath("listview")):
				listgetter = deep_get(d, DictPath("listview#listgetter"))
				if listgetter is not None:
					listgetter = deep_get(listgetter_allowlist, DictPath(listgetter))
			else:
				listgetter = generic_listgetter

			# No fallback here, so no complexities needed
			listgetter_async = deep_get(d, DictPath("listview#listgetter_async"))
			if listgetter_async is not None:
				listgetter_async = deep_get(listgetter_async_allowlist, DictPath(listgetter_async))

			listgetter_args = deep_get(d, DictPath("listview#listgetter_args"), {})

			on_activation = deep_get(d, DictPath("listview#on_activation"))
			if on_activation is None or "call" not in on_activation:
				activatedfun = genericinfoloop
			else:
				activatedfun = deep_get(on_activation, DictPath("call"))
				if isinstance(activatedfun, str):
					_activatedfun = deep_get(activatedfun_allowlist, DictPath(cast(str, activatedfun)))
					if _activatedfun is None:
						sys.exit(f"{activatedfun} is not in the activatedfun allow list")
					activatedfun = _activatedfun

			listview_entry = {
				"kind": (kind, api_family),
				"commandline": command,
				"windowheader": name,
				"group": group,
				"check_availability": check_availability,
				"field_indexes": field_indexes,
				"fields": fields,
				"activatedfun": activatedfun,
				"listview_args": deep_get(d, DictPath("listview#listview_args"), {}),
				"statusmsg": deep_get(d, DictPath("listview#statusmsg"), {}),
				"is_taggable": deep_get(d, DictPath("listview#is_taggable"), True),
				"listgetter": listgetter,
				"listgetter_async": listgetter_async,
				"listgetter_args": listgetter_args,
				"reversible": reversible,
				"infogetter": infogetter,
				"infogetter_args": deep_get(d, DictPath("listview#infogetter_args"), {}),
				"actions": deep_get(d, DictPath("listview#actions"), {}),
			}

			shortcuts = {}

			_shortcuts = deep_get(d, DictPath("listview#shortcuts"), {})
			for shortcut in _shortcuts:
				# If the shortcut is empty we are disabling a default shortcut
				if _shortcuts[shortcut] is None or len(_shortcuts[shortcut]) == 0:
					shortcuts[shortcut] = {}
					continue

				key = deep_get(_shortcuts[shortcut], DictPath("key"), "<missing>")
				modifier = deep_get(_shortcuts[shortcut], DictPath("modifier"), "")
				helptext = deep_get(_shortcuts[shortcut], DictPath("helptext"), "<missing>")
				action = deep_get(_shortcuts[shortcut], DictPath("action"), "<missing>")
				action_args = deep_get(_shortcuts[shortcut], DictPath("action_args"), {})
				action_call = deep_get(_shortcuts[shortcut], DictPath("action_call"))
				queryfunc = deep_get(_shortcuts[shortcut], DictPath("queryfunc"))
				queryval = deep_get(_shortcuts[shortcut], DictPath("queryval"))
				query = deep_get(_shortcuts[shortcut], DictPath("query"))
				read_only = deep_get(_shortcuts[shortcut], DictPath("read_only"), False)
				force_update = deep_get(_shortcuts[shortcut], DictPath("force_update"), True)
				force_refresh = deep_get(_shortcuts[shortcut], DictPath("force_refresh"), True)

				if key is None or helptext is None or action is None or "<missing>" in (key, helptext, action):
					sys.exit(f"View-file {view_file} is invalid: the following fields cannot be missing or None for a shortcut:\n"
						 f"key: {key}\n"
						 f"helptext: {helptext}\n"
						 f"action: {action}\n"
						  "Aborting.")

				key = key.lower()
				modifier = modifier.lower()

				shortcut_key, help_key = map_key(view_file, shortcut, activatedfun, key, modifier)

				shortcuts[shortcut] = {
					"shortcut": shortcut_key,
					"helptext": (help_key, helptext),
					"action": action,
					"action_args": action_args,
					"action_call": action_args,
					"queryfunc": queryfunc,
					"queryval": queryval,
					"query": query,
					"read_only": read_only,
					"force_update": force_update,
					"force_refresh": force_refresh,
				}
				if action == "call":
					_action_call = deep_get(action_call_allowlist, DictPath(action_call))
					if _action_call is None:
						sys.exit(f"{action_call} is not in the action_call allow list")
					shortcuts[shortcut]["action_call"] = _action_call

			if len(shortcuts) > 0:
				listview_entry["shortcuts"] = shortcuts

			# Replace existing listviews with the same name
			views.pop(name, None)

			# Add the new view
			has_listview = True
			views[viewname] = listview_entry

		infoview_entry = None

		if "infoview" in d:
			# Default kind and api_family unless overriden
			kind = deep_get(d, DictPath("kind"), "<missing>")
			api_family = deep_get(d, DictPath("api_family"), "")

			# Do we need to override kind?
			if deep_get(d, DictPath("infoview#kind")) is not None:
				kind = deep_get(d, DictPath("infoview#kind"))
				api_family = deep_get(d, DictPath("infoview#api_family"), "")
			name = deep_get(d, DictPath("infoview#name"), "<missing>")
			infopad = deep_get(d, DictPath("infoview#infopad"), {})

			row_indexes = {}
			row_fields = {}

			_indexes = deep_get(infopad, DictPath("row_indexes"))

			if _indexes is not None:
				if len(_indexes) == 0:
					sys.exit(f"View-file {view_file} is invalid: row_indexes is empty for the info view. Aborting.")

				# We are not using row_indexes in the same way field_indexes are used; we do not support multiple profiles;
				# since dicts are ordered by insertion we get the rows in the right order if we order by row_indexes,
				# and we do not support resorting, so we do not need to include the row_indexes
				row_indexes = copy.deepcopy(deep_get(_indexes, DictPath("Normal#fields"), []))

				# Rows need to be reformatted
				infopad_rows = deep_get(infopad, DictPath("rows"), {})

				for row in row_indexes:
					if row not in infopad_rows:
						sys.exit(f"View {name}: row “{row}“ cannot be found in infoview\nInfoview rows: {infopad_rows}\nrow names: {row_indexes}")
					row_fields[row] = copy.deepcopy(deep_get(infopad_rows, DictPath(row), {}))
					# We need to reformat the header
					_header = deep_get(infopad_rows, DictPath(f"{row}#header"), [["<unset>", ["types", "unset"]]])
					header: List[Union[ThemeRef, ThemeString]] = []
					try:
						for string, formatting in _header:
							header.append(ThemeString(string, ThemeAttr(formatting[0], formatting[1])))
					except ValueError as e:
						if str(e) == "not enough values to unpack (expected 2, got 1)":
							sys.exit(f"Invalid header for info-header row \"{row}\" in file \"{view_file}\"; this header doesn't seem to be a valid ThemeArray")
					row_fields[row]["header"] = header

			listpad = deep_get(d, DictPath("infoview#listpad"), {})

			on_activation = deep_get(listpad, DictPath("on_activation"))
			activatedfun = deep_get(on_activation, DictPath("call"))
			if isinstance(activatedfun, str):
				_activatedfun = deep_get(activatedfun_allowlist, DictPath(activatedfun))
				if _activatedfun is None:
					sys.exit(f"{activatedfun} is not in the activatedfun allow list")
				activatedfun = _activatedfun
			override_kind = deep_get(on_activation, DictPath("kind"))
			override_api_family = deep_get(on_activation, DictPath("api_family"), "")
			on_activation_extraref = deep_get(on_activation, DictPath("extraref"))
			on_activation_data = deep_get(on_activation, DictPath("data"))
			if override_kind is None:
				viewoverride = (kind, api_family)
			else:
				viewoverride = (override_kind, override_api_family)
				on_activation["kind"] = viewoverride
				on_activation.pop("api_family", "")

			annotations = deep_get(d, DictPath("infoview#annotations"))

			sortcolumn = deep_get(listpad, DictPath("sortcolumn"))
			reversible = deep_get(listpad, DictPath("reversible"), True)
			sortorder_reverse = deep_get(listpad, DictPath("sortorder_reverse"), False)

			listpad_fields = deep_get(listpad, DictPath("fields"), {})

			listpad_field_indexes = {}
			_indexes = deep_get(listpad, DictPath("field_indexes"), {})
			confkind = kind
			if len(api_family) > 0:
				confkind = f"{confkind}.{api_family}"
			custom_index = deep_get(cmtlib.cmtconfig, DictPath(f"Views#{confkind}#infoview#listpad#field_indexes#Custom"), [])
			if len(custom_index) > 0:
				_indexes["Custom"] = custom_index

			for key in _indexes:
				if isinstance(_indexes[key], list):
					listpad_field_indexes[key] = {}
					listpad_field_indexes[key]["fields"] = copy.deepcopy(_indexes[key])
					listpad_field_indexes[key]["sortcolumn"] = sortcolumn
					listpad_field_indexes[key]["sortorder_reverse"] = sortorder_reverse
				else:
					listpad_field_indexes = copy.deepcopy(_indexes)

			infoview_entry = {
				"kind": (kind, api_family),
				"windowheader": name,
				"field_indexes": listpad_field_indexes,
				"fields": listpad_fields,
				"activatedfun": activatedfun,
				"infoview_args": deep_get(d, DictPath("infoview#infoview_args"), {}),
				"statusmsg": deep_get(d, DictPath("infoview#statusmsg"), {}),
				"viewoverride": viewoverride,
				"extraref": on_activation_extraref,
				"data": on_activation_data,
				"infopad": row_fields,
				"listpad": {},
				"reversible": reversible,
				"annotations": annotations,
				"shortcuts": {},
				"no_reload_on_refresh": deep_get(d, DictPath("infoview#no_reload_on_refresh"), False),
			}
			objgetter = deep_get(infopad, DictPath("objgetter"))
			if objgetter is not None:
				infoview_entry["objgetter"] = deep_get(objgetter_allowlist, DictPath(objgetter))

			if len(listpad) > 0:
				infoview_entry["listpad"]["on_activation"] = on_activation

			if infopad is not None:
				if "name_path" in infopad:
					infoview_entry["name_path"] = deep_get(infopad, DictPath("name_path"))
				if "namespace_path" in infopad:
					infoview_entry["namespace_path"] = deep_get(infopad, DictPath("namespace_path"))
				if "creation_timestamp_path" in infopad:
					infoview_entry["creation_timestamp_path"] = deep_get(infopad, DictPath("creation_timestamp_path"))

			list_listgetter = deep_get(listpad, DictPath("listgetter"))
			list_listgetter_args = deep_get(listpad, DictPath("listgetter_args"), {})
			list_infogetter = deep_get(listpad, DictPath("infogetter"))
			list_infogetter_args = deep_get(listpad, DictPath("infogetter_args"))
			if list_infogetter is None:
				if len(listpad) > 0:
					raise ValueError("View-file {view_file} is invalid: listpad specified, but no infogetter is provided")
			else:
				infoview_entry["listpad"]["infogetter"] = deep_get(infogetter_allowlist, DictPath(list_infogetter))
				if infoview_entry["listpad"]["infogetter"] is None:
					raise ValueError("View-file {view_file} is invalid: infogetter {list_infogetter} for listpad is not in infogetter_allowlist")
				infoview_entry["listpad"]["infogetter_args"] = list_infogetter_args
			if list_listgetter is None:
				if len(listpad) > 0:
					raise ValueError("View-file {view_file} is invalid: listpad specified, but no listgetter is provided")
			else:
				infoview_entry["listpad"]["listgetter"] = deep_get(listgetter_allowlist, DictPath(list_listgetter))
				if infoview_entry["listpad"]["listgetter"] is None:
					raise ValueError("View-file {view_file} is invalid: listgetter {list_listgetter} for listpad is not in listgetter_allowlist")
				infoview_entry["listpad"]["listgetter_args"] = list_listgetter_args

			shortcuts = {}

			_shortcuts = deep_get(d, DictPath("infoview#shortcuts"), {})
			for shortcut in _shortcuts:
				# If the shortcut is empty we are disabling a default shortcut
				if _shortcuts[shortcut] is None or len(_shortcuts[shortcut]) == 0:
					shortcuts[shortcut] = {}
					continue

				key = deep_get(_shortcuts[shortcut], DictPath("key"), "<missing>")
				modifier = deep_get(_shortcuts[shortcut], DictPath("modifier"), "")
				helptext = deep_get(_shortcuts[shortcut], DictPath("helptext"), "<missing>")
				action = deep_get(_shortcuts[shortcut], DictPath("action"), "<missing>")
				action_args = deep_get(_shortcuts[shortcut], DictPath("action_args"), {})
				action_call = deep_get(_shortcuts[shortcut], DictPath("action_call"))
				queryfunc = deep_get(_shortcuts[shortcut], DictPath("queryfunc"))
				queryval = deep_get(_shortcuts[shortcut], DictPath("queryval"))
				query = deep_get(_shortcuts[shortcut], DictPath("query"))
				widget = deep_get(_shortcuts[shortcut], DictPath("widget"))
				widget_args = deep_get(_shortcuts[shortcut], DictPath("widget_args"))
				inputtitle = deep_get(_shortcuts[shortcut], DictPath("inputtitle"))
				confirm = deep_get(_shortcuts[shortcut], DictPath("confirm"))
				confirmtitle = deep_get(_shortcuts[shortcut], DictPath("confirmtitle"))
				w_title = deep_get(_shortcuts[shortcut], DictPath("title"))
				w_headers = deep_get(_shortcuts[shortcut], DictPath("headers"))
				w_selectable = deep_get(_shortcuts[shortcut], DictPath("selectable"))
				w_itemgetter = deep_get(_shortcuts[shortcut], DictPath("itemgetter"))
				if w_itemgetter is not None:
					if isinstance(w_itemgetter, str):
						w_itemgetter = deep_get(itemgetter_allowlist, DictPath(w_itemgetter))
				w_itemgetter_args = deep_get(_shortcuts[shortcut], DictPath("itemgetter_args"), {})
				_w_formatting = deep_get(_shortcuts[shortcut], DictPath("formatting"))
				w_formatting = None
				if _w_formatting is not None:
					w_formatting = []
					for fmt in _w_formatting:
						w_formatting.append(fmt)
				w_sortcolumn = deep_get(_shortcuts[shortcut], DictPath("sortcolumn"), {})

				if key is None or helptext is None or action is None or "<missing>" in (key, helptext):
					sys.exit(f"View-file {view_file} is invalid: the following fields cannot be missing or None for a shortcut:\n"
						 f"key: {key}\n"
						 f"helptext: {helptext}\n"
						  "Aborting.")

				if widget is None and "<missing>" == action:
					sys.exit(f"View-file {view_file} is invalid: at least one of [widget, action] needs to be specified.\n"
						  "Aborting.")

				key = key.lower()
				modifier = modifier.lower()

				shortcut_key, help_key = map_key(view_file, shortcut, activatedfun, key, modifier)

				shortcuts[shortcut] = {
					"shortcut": shortcut_key,
					"helptext": (help_key, helptext),
					"action": action,
					"action_args": action_args,
					"action_call": action_args,
					"queryfunc": queryfunc,
					"queryval": queryval,
					"query": query,
					"widget": widget,
					"widget_args": widget_args,
					"inputtitle": inputtitle,
					"confirm": confirm,
					"confirmtitle": confirmtitle,
					"title": w_title,
					"headers": w_headers,
					"itemgetter": w_itemgetter,
					"itemgetter_args": w_itemgetter_args,
					"selectable": w_selectable,
					"formatting": w_formatting,
					"sortcolumn": w_sortcolumn,
				}
				if action == "call":
					_action_call = deep_get(action_call_allowlist, DictPath(action_call))
					if _action_call is None:
						sys.exit(f"{action_call} is not in the action_call allow list")
					shortcuts[shortcut]["action_call"] = _action_call

			logpad = deep_get(d, DictPath("infoview#logpad"), {})

			if len(logpad) > 0:
				if len(deep_get(infoview_entry, DictPath("listpad"), {})) > 0:
					sys.exit(f"View-file “{view_file}“ is invalid: listpad and logpad cannot be used concurrently.")

				log_infogetter = deep_get(logpad, DictPath("infogetter"))
				if log_infogetter is None:
					if len(logpad) > 0:
						raise ValueError("View-file {view_file} is invalid: logpad specified, but no infogetter is provided")
				logpad["infogetter"] = deep_get(infogetter_allowlist, DictPath(log_infogetter))
				infoview_entry["logpad"] = copy.deepcopy(logpad)

			if len(infoview_entry["listpad"]) == 0:
				infoview_entry.pop("listpad")

			if len(shortcuts) > 0:
				infoview_entry["shortcuts"] = shortcuts

			# Replace existing listviews with the same name
			infoviews.pop((kind, api_family), None)

			# Add the new view
			infoviews[(kind, api_family)] = infoview_entry
			has_infoview = True

		if kubernetes_support:
			kh_update_api_status((kind, api_family), listview = has_listview, infoview = has_infoview)

def setupui(stdscr: curses.window) -> None:
	# Hide the cursor
	curses.curs_set(False)
	# Disable CTRL+C, CTRL+Z, etc.
	curses.raw()
	# Enable mouse support
	enable_mouse = deep_get(cmtlib.cmtconfig, DictPath("Mouse#enable"), True)
	if enable_mouse:
		curses_helper.set_mousemask(-1)
	else:
		curses_helper.set_mousemask(0)
	curses_helper.init_curses()

	while True:
		if deep_get(views, DictPath(defaultview)) is not None:
			viewfunc = deep_get(views, DictPath(f"{defaultview}#viewfunc"))
			if viewfunc is None:
				viewfunc = genericlistloop
			check_availability = deep_get(views, DictPath(f"{defaultview}#check_availability"))
			if check_availability is not None and not check_availability():
				curses.endwin()
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": The requested view “", "default"),
						ANSIThemeString(defaultview, "argument"),
						ANSIThemeString("“ is not available; ", "default"),
						ANSIThemeString("the cluster may be offline or the API disabled.", "default")])
				sys.exit(errno.ENOTSUP)
			viewfunc(stdscr, defaultview)
		else:
			curses.endwin()
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": Unknown view “", "default"),
					ANSIThemeString(defaultview, "argument"),
					ANSIThemeString("“; check “", "default"),
					ANSIThemeString(CMT_CONFIG_FILE, "path"),
					ANSIThemeString("“ and all files in “", "default"),
					ANSIThemeString(CMT_CONFIG_FILE_DIR, "path"),
					ANSIThemeString("“ for typos.", "default")], stderr = True)
			sys.exit(errno.ENOENT)

# pylint: disable-next=unused-argument
def list_namespaces(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	List all available namespaces
	"""

	color = "auto"

	# Valid formats:
	# default = Normal output format (default)
	# csv = Comma-separated values
	# ssv = Space-separated values
	# tsv = Tab-separated values
	output_format = "default"

	for opt, optarg in options:
		if opt == "--color":
			color = optarg
		elif opt == "--format":
			output_format = optarg

	init_kubernetes_client()

	tmp, status = kh.get_list_by_kind_namespace(("Namespace", ""), "")
	if status in (42503, 42504):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": API-server unavailable", "default")], stderr = True)
		sys.exit(errno.ENOENT)
	elif status != 200:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": API-server returned ", "default"),
				ANSIThemeString(f"{status}", "errorvalue")], stderr = True)
		sys.exit(errno.EINVAL)

	namespaces = [deep_get(item, DictPath("metadata#name")) for item in tmp]

	if output_format == "default":
		ansithemeprint([ANSIThemeString("Valid namespaces: ", "default")] +
			       ansithemestring_join_tuple_list(namespaces, formatting = "namespace", separator = ANSIThemeString(", ", "separator")) +
			       [ANSIThemeString(".", "separator")], color = color)
	else:
		if output_format == "csv":
			separator = ","
		elif output_format == "ssv":
			separator = " "
		elif output_format == "tsv":
			separator = "\t"

		ansithemeprint(ansithemestring_join_tuple_list(namespaces, formatting = "namespace", separator = ANSIThemeString(separator, "separator")), color = color)

# pylint: disable-next=unused-argument
def list_views(options: List[Tuple[str, str]], args: List[str]) -> None:
	"""
	List available views and their supported fields and default sort column
	"""

	viewfields = []
	maxviewlen = 0
	maxkindlen = 0

	# Customises the list views
	ansithemeprint([ANSIThemeString("Stand by, updating list of supported views...\n", "default")])

	init_kubernetes_client()
	populate_views()
	customise_listviews()

	for view in natsorted(views):
		viewref = views[view]
		if "skip" in viewref:
			continue
		if "kind" not in viewref or viewref["kind"] is None:
			continue
		if "fields" not in viewref:
			continue

		fields = []
		fieldset = set()
		sortcolumn = ""
		# This is necessary because of built-in fields
		for values in deep_get(viewref, DictPath("field_indexes"), {}).values():
			fieldset.update(deep_get(values, DictPath("fields"), []))
			if len(sortcolumn) == 0:
				sortcolumn = deep_get(values, DictPath("sortcolumn"), "")
		fieldset.union(set(deep_get(viewref, DictPath("fields"), {}).keys()))

		for fieldname in fieldset:
			if sortcolumn == "" and fieldname == "name":
				fields.append(ANSIThemeString(f"[{fieldname}]", "note"))
			elif fieldname == sortcolumn:
				fields.append(ANSIThemeString(f"<{fieldname}>", "emphasis"))
			else:
				fields.append(ANSIThemeString(fieldname, "default"))
		kind = viewref["kind"][0]
		api_group = viewref["kind"][1]
		if api_group == "":
			viewfields.append((view, f"{kind}", fields))
			maxkindlen = max(maxkindlen, len(f"{kind}"))
		else:
			viewfields.append((view, f"{kind}.{api_group}", fields))
			maxkindlen = max(maxkindlen, len(f"{kind}.{api_group}"))
		maxviewlen = max(maxviewlen, len(view))

	ansithemeprint([ANSIThemeString("View:", "header"),
			ANSIThemeString(f"{''.ljust(maxviewlen + 2 - len('View:'))}", "default"),
			ANSIThemeString("Kind:", "header"),
			ANSIThemeString(f"{''.ljust(maxkindlen + 2 - len('Kind:'))}", "default"),
			ANSIThemeString("Supported fields:", "header")])
	for view, kind, fields in viewfields:
		joined_fields = ansithemestring_join_tuple_list(fields, separator = ANSIThemeString(", ", "separator"))
		ansithemeprint([ANSIThemeString(f"{view.ljust(maxviewlen + 2)}{kind.ljust(maxkindlen + 2)}", "default")] + joined_fields)

	ansithemeprint([ANSIThemeString("\nList views can be customised to only show select fields by editing “", "default"),
			ANSIThemeString(CMT_CONFIG_FILE, "path"),
			ANSIThemeString("“.\n", "default")])
	ansithemeprint([ANSIThemeString("Simply add “", "default"),
			ANSIThemeString("field:", "emphasis"),
			ANSIThemeString("“ followed by a list of the fields you want the list to a section named like", "default")])
	ansithemeprint([ANSIThemeString("the list view you want to customise.\n", "default")])

	ansithemeprint([ANSIThemeString("Note that the fields “", "default"),
			ANSIThemeString("name", "emphasis"),
			ANSIThemeString("“ and, if applicable “", "default"),
			ANSIThemeString("namespace", "emphasis"),
			ANSIThemeString("“, will unconditionally", "default")])
	ansithemeprint([ANSIThemeString("be included even if the list of fields does not include them; including them", "default")])
	ansithemeprint([ANSIThemeString("in the list will only allow reordering the fields.\n", "default")])

	ansithemeprint([ANSIThemeString("The fields in this list are those supported by ", "default"),
			ANSIThemeString(f"{about.UI_PROGRAM_NAME}", "programname"),
			ANSIThemeString("; it is NOT an exhaustive list", "default")])
	ansithemeprint([ANSIThemeString("of fields available in the resource.\n", "default")])

	ansithemeprint([ANSIThemeString("If a field is marked ", "default"),
			ANSIThemeString("<field>", "emphasis"),
			ANSIThemeString(" it is the explicit sortcolumn.", "default")])
	ansithemeprint([ANSIThemeString("If the field is marked ", "default"),
			ANSIThemeString("[field]", "note"),
			ANSIThemeString(" it is the implicit sortcolumn.", "default")])
	ansithemeprint([ANSIThemeString("Note: the brackets (“<“, “>“, “[“, and “]“) are not part of the field names.", "default")])

def checkforview(arg: Union[str, Tuple[str, str]]) -> Optional[str]:
	"""
	Check whether a view exists

		Parameters:
			arg (union(str, (str, str))): Either the name of a view or a (kind, api_family) tuple
		Returns:
			view (str): The key for the matching view, or None if no such view was found
	"""

	for view, viewref in views.items():
		if isinstance(arg, str):
			if arg in deep_get(viewref, DictPath("commandline"), []):
				return view
		else:
			if arg == deep_get(viewref, DictPath("kind"), ("", "")):
				return view

	return None

def customise_listviews() -> None:
	"""
	Apply user-provided customisation to the list views
	"""

	for view in views:
		viewref = views[view]
		if "skip" in viewref:
			continue
		if "kind" not in viewref or viewref["kind"] is None:
			continue
		if "fields" not in viewref:
			continue

		# OK, we've now (hopefully) skipped all views that do not have a list view
		fields: List[str] = deep_get(cmtlib.cmtconfig, DictPath(f"Views#{view}#fields"), [])
		if len(fields) == 0:
			continue

		custom_fields: Dict = {}

		if "namespace" in cast(List[str], viewref["fields"]) and "namespace" not in fields:
			custom_fields["namespace"] = None
		if "name" not in fields:
			custom_fields["name"] = None

		for field in fields:
			if field not in fields:
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": “", "default"),
						ANSIThemeString(field, "option"),
						ANSIThemeString("“ is not a valid field for the view “", "default"),
						ANSIThemeString(view, "argument"),
						ANSIThemeString("“; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
			elif field in custom_fields:
				ansithemeprint([ANSIThemeString("Warning", "warning"),
						ANSIThemeString(": “", "default"),
						ANSIThemeString(field, "option"),
						ANSIThemeString("“ is specified twice (or more) for the view “", "default"),
						ANSIThemeString(view, "argument"),
						ANSIThemeString("“; ignoring.", "default")], stderr = True)
				continue
			custom_fields[field] = None
		viewref["fields_custom"] = list(custom_fields)

		# Next up it is time for the field denylist
		if "denylist" in deep_get(cmtlib.cmtconfig, DictPath(f"Views#{view}"), {}):
			denylist = deep_get(cmtlib.cmtconfig, DictPath(f"Views#{view}#fields"), [])
			viewref["field_denylist"] = denylist

	# As a special case, the configuration option "Inventory#ping_hosts"
	# modifies the denylist, but *only* if the field denylist is unset
	ping_hosts = deep_get(cmtlib.cmtconfig, DictPath("__Inventory#ping_hosts"), "Lazy")
	if ping_hosts == "Never" and "field_denylist" not in viewref:
		viewref["field_denylist"] = ["status"]

def open_view(options: List[Tuple[str, str]], args: List[str]) -> None:
	global initial_name  # pylint: disable=global-statement
	global initial_namespace  # pylint: disable=global-statement
	global initial_container  # pylint: disable=global-statement
	global read_only_mode  # pylint: disable=global-statement
	global selected_namespace  # pylint: disable=global-statement
	global defaultview  # pylint: disable=global-statement
	global kubernetes_support  # pylint: disable=global-statement

	tmpdefaultview = deep_get(cmtlib.cmtconfig, DictPath("Global#defaultview"), "")

	for opt, optarg in options:
		if opt == "--namespace":
			selected_namespace = optarg
		elif opt == "--read-only":
			read_only_mode = True
		elif opt == "--disable-kubernetes":
			kubernetes_support = False

	init_kubernetes_client()

	# Customises the list views
	ansithemeprint([ANSIThemeString("Populating list of supported views...\n", "default")])

	populate_views()
	customise_listviews()

	if len(args) > 0:
		tmpview = checkforview(args[0].lower())
		if tmpview is None:
			ansithemeprint([ANSIThemeString("Unsupported or unavailable view “", "default"),
					ANSIThemeString(f"{args[0].lower()}", "command"),
					ANSIThemeString("“;", "default")], stderr = True)
			ansithemeprint([ANSIThemeString("Use “", "default"),
					ANSIThemeString(f"{about.UI_PROGRAM_NAME} ", "programname"),
					ANSIThemeString("list-views", "command"),
					ANSIThemeString("“ to list available views.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		defaultview = tmpview
	else:
		if tmpdefaultview is not None and tmpdefaultview != "":
			defaultview = tmpdefaultview
		else:
			defaultview = "Selector"

	if len(args) > 1:
		# The argument is either OBJECT, NAMESPACE/OBJECT, OBJECT:MEMBER, or NAMESPACE/OBJECT:MEMBER
		initial_name = args[1]
		if "/" in initial_name:
			initial_namespace, initial_name = initial_name.split("/")
		if ":" in initial_name:
			initial_name, initial_container = initial_name.split(":")

		if initial_container is not None and len(initial_container) > 0 and defaultview not in ("Pods", "Config Maps"):
			ansithemeprint([ANSIThemeString(f"{about.UI_PROGRAM_NAME}", "programname"),
					ANSIThemeString(": invalid syntax;", "default")], stderr = True)
			ansithemeprint([ANSIThemeString("Specifying a member", "description"),
					ANSIThemeString(" is only supported for ", "default"),
					ANSIThemeString("pod", "command"),
					ANSIThemeString(" and ", "description"),
					ANSIThemeString("configmap", "command"),
					ANSIThemeString(" view.", "default")], stderr = True)
			ansithemeprint([ANSIThemeString("Try “", "default"),
					ANSIThemeString(f"{about.UI_PROGRAM_NAME} ", "programname"),
					ANSIThemeString("help", "command"),
					ANSIThemeString("“ for more information.", "default")], stderr = True)
			sys.exit(errno.EINVAL)

	# We do not need escape sequences, so cut down on the delay to 25ms
	os.environ.setdefault('ESCDELAY', '25')

	init_kubernetes_client()
	ansithemeprint([ANSIThemeString("Checking available Kubernetes APIs\n", "default")])
	if kubernetes_support:
		_available_api_families, _status, _modified = kh.get_available_kinds()

	# Customises the list views if necessary
	if len(infoviews) == 0:
		ansithemeprint([ANSIThemeString("Populating list of supported views...\n", "default")])
		populate_views()
		customise_listviews()

	try:
		wrapper(setupui)
	except curses.error as e:
		# We don't really know *why* if failed to close the window,
		# but we don't really care, since we're about to close down anyway
		if str(e) == "endwin() returned ERR":
			pass

COMMANDLINE = {
	# This is purely for the benefit of the helptext generator
	"View": {
		"command": ["VIEW"],
		"description": [ANSIThemeString("start in ", "description"),
				ANSIThemeString("VIEW", "command")],
	},
	"View [NAMESPACE/]OBJECT[:MEMBER]": {
		"command": ["VIEW"],
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("NAMESPACE/", "argument"),
			   ANSIThemeString("]", "separator"),
			   ANSIThemeString("OBJECT", "argument"),
			   ANSIThemeString("[", "separator"),
			   ANSIThemeString(":", "argument"),
			   ANSIThemeString("[", "separator"),
			   ANSIThemeString("MEMBER", "argument"),
			   ANSIThemeString("]]", "separator")],
		"description": [ANSIThemeString("start in ", "description"),
				ANSIThemeString("VIEW", "command"),
				ANSIThemeString(" for ", "description"),
				ANSIThemeString("OBJECT", "argument")],
		"extended_description": [
			[ANSIThemeString("Sometimes ", "description"),
			 ANSIThemeString("OBJECT", "argument"),
			 ANSIThemeString(" may need to be qualified by using ", "description")],
			[ANSIThemeString("NAMESPACE", "argument"),
			 ANSIThemeString(", but if there's only one unique match", "description")],
			[ANSIThemeString(about.UI_PROGRAM_NAME, "programname"),
			 ANSIThemeString(" will open that match. If an object has members", "description")],
			[ANSIThemeString("(containers or configmaps), these can be opened", "description")],
			[ANSIThemeString("using the ", "description"),
			 ANSIThemeString(":MEMBER", "argument"),
			 ANSIThemeString(" syntax. If there's only one", "description")],
			[ANSIThemeString("member specifying ", "description"),
			 ANSIThemeString(":", "argument"),
			 ANSIThemeString(" is sufficient", "description")],
		],
	},
	"spacer1": {
		"command": [""],
		"description": [ANSIThemeString("", "description")],
	},
	"List Namespaces": {
		"command": ["list-namespaces"],
		"description": [ANSIThemeString("List valid namespaces and exit", "description")],
		"callback": list_namespaces,
		"options": {
			"--color": {
				"values": [ANSIThemeString("WHEN", "argument")],
				"description": [ANSIThemeString("WHEN should the output use ANSI-colors", "description")],
				"extended_description": [
					[ANSIThemeString("Valid arguments are: ", "description")],
					[ANSIThemeString("always", "argument"),
					 ANSIThemeString(" (always color the output)", "description")],
					[ANSIThemeString("auto", "argument"),
					 ANSIThemeString(" (color the output when outputting", "description")],
					[ANSIThemeString("to a terminal)", "description")],
					[ANSIThemeString("never", "argument"),
					 ANSIThemeString(" (never color the output)", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": [
						"always",
						"auto",
						"never",
					],
				},
			},
			"--format": {
				"values": [ANSIThemeString("FORMAT", "argument")],
				"description": [ANSIThemeString("Format the output as ", "description"),
						ANSIThemeString("FORMAT", "description")],
				"extended_description": [
					[ANSIThemeString("Valid formats are: ", "description")],
					[ANSIThemeString("default", "argument"),
					 ANSIThemeString(" (default format)", "description")],
					[ANSIThemeString("csv", "argument"),
					 ANSIThemeString(" (comma-separated values)", "description")],
					[ANSIThemeString("ssv", "argument"),
					 ANSIThemeString(" (space-separated values)", "description")],
					[ANSIThemeString("tsv", "argument"),
					 ANSIThemeString(" (tab-separated values)", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": [
						"default",
						"csv",
						"ssv",
						"tsv",
					],
				},
			},
		},
	},
	"List Views": {
		"command": ["list-views"],
		"description": [ANSIThemeString("List view information and exit", "description")],
		"callback": list_views,
	},
	"__*": {
		"command": ["*"],
		"command_alias": "VIEW",
		"values": [ANSIThemeString("[", "separator"),
			   ANSIThemeString("NAMESPACE/", "argument"),
			   ANSIThemeString("]", "separator"),
			   ANSIThemeString("OBJECT", "argument"),
			   ANSIThemeString("[", "separator"),
			   ANSIThemeString(":", "argument"),
			   ANSIThemeString("[", "separator"),
			   ANSIThemeString("MEMBER", "argument"),
			   ANSIThemeString("]]", "separator")],
		"description": [ANSIThemeString("start in ", "description"),
				ANSIThemeString("VIEW", "command"),
				ANSIThemeString(" for ", "description"),
				ANSIThemeString("OBJECT", "argument")],
		"extended_description": [
			[ANSIThemeString("Sometimes ", "description"),
			 ANSIThemeString("OBJECT", "argument"),
			 ANSIThemeString(" may need to be qualified by using ", "description")],
			[ANSIThemeString("NAMESPACE", "argument"),
			 ANSIThemeString(", but if there's only one unique match", "description")],
			[ANSIThemeString(about.UI_PROGRAM_NAME, "programname"),
			 ANSIThemeString(" will open that match. If an object has members", "description")],
			[ANSIThemeString("(containers or configmaps), these can be opened", "description")],
			[ANSIThemeString("using the ", "description"),
			 ANSIThemeString(":MEMBER", "argument"),
			 ANSIThemeString(" syntax. If there's only one", "description")],
			[ANSIThemeString("member specifying ", "description"),
			 ANSIThemeString(":", "argument"),
			 ANSIThemeString(" is sufficient", "description")],
		],
		"optional_args": [
			{
				"name": "view",
				"string": [ANSIThemeString("VIEW", "command")],
				"validation": {
					"validator": "regex",
					"regex": r"^[a-zA-Z][a-zA-Z0-9.-]*?[a-zA-Z0-9]$"
				},
			},
			{
				"name": "object_namespace_member",
				"string": [ANSIThemeString("NAME", "argument")],
				"validation": {
					"validator": "regex",
					# In order:
					# object (RFC-1123 dns-subdomain)
					# object (RFC-1123 dns-subdomain):container (RFC-1123 dns-label)
					# namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain)
					# namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain):container (RFC-1123 dns-label)
					"regex": r"^(" \
					         r"[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?|" \
					         r"[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?:|" \
					         r"[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?:[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]?|" \
					         r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]/[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?|" \
					         r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]/[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?:|" \
					         r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]/[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?:[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]?" \
					         r")$",
				},
			},
			{
				"name": "namespace",
				"string": [ANSIThemeString("NAMESPACE", "command")],
				"validation": {
					"validator": "regex",
					# namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain)
					"regex": r"^(" \
					         r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]|" \
					         r")$",
				},
			},
			{
				"name": "member",
				"string": [ANSIThemeString("CONTAINER", "command"),
					   ANSIThemeString("/", "separator"),
					   ANSIThemeString("CONFIGMAP", "command")],
				"validation": {
					"validator": "regex",
					# namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain)
					"regex": r"^(" \
					         r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]?|" \
					         r")$",
				},
			},
		],
		"callback": open_view,
	},
	"extended_description": [
		[ANSIThemeString("If ", "description"),
		 ANSIThemeString("VIEW", "argument"),
		 ANSIThemeString(" is not specified ", "description"),
		 ANSIThemeString(about.UI_PROGRAM_NAME, "programname"),
		 ANSIThemeString(" will show a list with all available views", "description")],
		[ANSIThemeString("", "separator")],
		[ANSIThemeString("Note", "note"),
		 ANSIThemeString(": ", "description"),
		 ANSIThemeString(CMT_CONFIG_FILENAME, "path"),
		 ANSIThemeString(" or a file in ", "description"),
		 ANSIThemeString(CMT_CONFIG_FILE_DIRNAME, "path"),
		 ANSIThemeString(" can be used to set a ", "description"),
		 ANSIThemeString("VIEW", "argument"),
		 ANSIThemeString(" to use", "description")],
		[ANSIThemeString("if no view is specified.", "description"),
		 ANSIThemeString(" To override this and open the selector instead,", "description")],
		[ANSIThemeString("simply use “", "description"),
		 ANSIThemeString(about.UI_PROGRAM_NAME, "programname"),
		 ANSIThemeString(" selector", "argument"),
		 ANSIThemeString("“.", "description")],
	],
	"spacer2": {
		"command": [""],
		"description": [ANSIThemeString("", "description")],
	},
	"__global_options": {
		"command": ["__global_options"],
		"description": [ANSIThemeString("", "")],
		"options": {
			"--read-only": {
				"description": [ANSIThemeString("disable all commands that modify state", "description")],
			},
			"--disable-kubernetes": {
				"description": [ANSIThemeString("disable Kubernetes support", "description")],
				"extended_description": [
					[ANSIThemeString("This option disables Kubernetes support; ", "description")],
					[ANSIThemeString("this is typically only useful if you use", "description")],
					[ANSIThemeString(about.UI_PROGRAM_NAME, "programname"),
					 ANSIThemeString(" to manage an Ansible inventory", "description")],
				],
			},
			"--kube-config": {
				"values": [ANSIThemeString("PATH", "argument")],
				"description": [ANSIThemeString("PATH", "argument"),
						ANSIThemeString(" to kubeconfig file to use", "description")],
				"extended_description": [
					[ANSIThemeString("Use ", "description"),
					 ANSIThemeString("PATH", "argument"),
					 ANSIThemeString(" as kubeconfig; by default ", "description")],
					[ANSIThemeString(KUBE_CONFIG_FILE, "path"),
					 ANSIThemeString(" is used", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "path",
				},
			},
			"--namespace": {
				"values": [ANSIThemeString("NAMESPACE", "argument")],
				"description": [ANSIThemeString("only show objects in namespace ", "description"),
						ANSIThemeString("NAMESPACE", "argument")],
				"requires_arg": True,
				"validation": {
					"validator": "regex",
					# namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain)
					"regex": r"^(" \
					         r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]|" \
					         r")$",
				},
			},
			"--theme": {
				"values": [ANSIThemeString("THEME", "argument")],
				"description": [ANSIThemeString("THEME", "argument"),
						ANSIThemeString(" to use", "description")],
				"requires_arg": True,
			},
		},
	},
	"spacer3": {
		"command": [""],
		"description": [ANSIThemeString("", "description")],
	},
}

def main() -> None:
	"""
	Main function for the program
	"""
	global auditlog  # pylint: disable=global-statement
	global debuglog  # pylint: disable=global-statement

	# Before doing anything else, make sure that the user is not running as root
	if os.geteuid() == 0:
		sys.exit("CRITICAL: This program should not be run as the root user; aborting.")

	# Now initialise the audit log and the debug log
	auditlog = CMTLog(CMTLogType.AUDIT)
	debuglog = CMTLog(CMTLogType.DEBUG)

	# Then initialise the configuration file
	read_cmtconfig()

	defaultthemefile = DEFAULT_THEME_FILE

	themeindex = None
	try:
		themeindex = sys.argv.index("--theme")
		if themeindex + 1 < len(sys.argv):
			tmpthemefile = sys.argv[themeindex + 1]
		sys.argv.pop(themeindex)
		sys.argv.pop(themeindex)
	except ValueError:
		pass

	if themeindex is None:
		tmpthemefile = deep_get(cmtlib.cmtconfig, DictPath("Global#theme"))
	themefile, theme_path_found = expand_path(path = tmpthemefile, search_paths = [os.getcwd(), THEME_DIR], suffixes = [".yaml"], fallback = defaultthemefile)

	read_theme(themefile, defaultthemefile)

	curses_configuration.abouttext = helptexts.about
	curses_configuration.mousescroll_enable = deep_get(cmtlib.cmtconfig, DictPath("Mouse#enablescroll"), False)
	# These values are ignored when scrolling is disabled, so the defaults do not matter
	curses_configuration.mousescroll_up = deep_get(cmtlib.cmtconfig, DictPath("Mouse#scrollup"), 0)
	curses_configuration.mousescroll_down = deep_get(cmtlib.cmtconfig, DictPath("Mouse#scrolldown"), 0)
	# Used by the ansible module
	ansible_configuration["ansible_forks"] = deep_get(cmtlib.cmtconfig, DictPath("Ansible#forks"), 10)
	ansible_user = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_user"))
	if ansible_user is None or len(ansible_user) == 0:
		ansible_user = getuser()
	ansible_configuration["ansible_user"] = ansible_user
	ansible_configuration["ansible_password"] = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_password"))
	ansible_configuration["disable_strict_host_key_checking"] = deep_get(cmtlib.cmtconfig, DictPath("Node#disablestricthostkeychecking"), False)
	ansible_configuration["save_logs"] = deep_get(cmtlib.cmtconfig, DictPath("Ansible#save_logs"), True)

	command, options, args = parse_commandline(about.UI_PROGRAM_NAME, about.UI_PROGRAM_VERSION, PROGRAMDESCRIPTION, PROGRAMAUTHORS, sys.argv,
						   COMMANDLINE, default_command = "*", theme = themefile)

	for opt, optarg in options:
		if opt == "--developer-mode":
			cmtlib.cmtconfig["Debug#developer_mode"] = True
		# Currently we only support --kube-config, but in case
		# we add option aliases (which we probably should) this
		# is a good thing to have
		elif opt in ("--kubeconfig", "--kube-config"):
			global kube_config_file
			kube_config_file = optarg

	if themeindex and not theme_path_found:
		ansithemeprint([ANSIThemeString("Warning", "warning"),
				ANSIThemeString(": could not find theme “", "default"),
				ANSIThemeString(f"{tmpthemefile}", "path"),
				ANSIThemeString("“; using “", "default"),
				ANSIThemeString(f"{defaultthemefile}", "path"),
				ANSIThemeString("“ instead.\n", "default")])

	return command(options, args)

if __name__ == "__main__":
	main()
