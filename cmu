#! /bin/sh
# vim: ts=4 filetype=python expandtab shiftwidth=4 softtabstop=4 syntax=python
''''eval version=$( ls /usr/bin/python3.* | \
    grep '.*[0-9]$' | sort -nr -k2 -t. | head -n1 ) && \
    version=${version##/usr/bin/python3.} && [ ${version} ] && \
    [ ${version} -ge 9 ] && exec /usr/bin/python3.${version} "$0" "$@" || \
    exec /usr/bin/env python3 "$0" "$@"' #'''
# The above hack is to handle distros where /usr/bin/python3
# doesn't point to the latest version of python3 they provide

# Requires: ansible
# Requires: python3 (>= 3.9)
# Requires: python3-natsort
# Requires: python3-openssl
# Recommends: python3-ujson
#
# Copyright the Cluster Management Toolkit for Kubernetes contributors.
# SPDX-License-Identifier: MIT

# pylint: disable=too-many-lines

import ast
import base64
import binascii
import copy
import curses
from curses import wrapper
from datetime import datetime, timedelta, timezone
import errno
from getpass import getuser
import http.client
# ujson is much faster than json,
# but it might not be available
try:  # pragma: no cover
    import ujson as json
# The exception raised by ujson when parsing fails is different
# from what json raises
    DecodeException = ValueError
except ModuleNotFoundError:  # pragma: no cover
    import json  # type: ignore
    DecodeException = json.decoder.JSONDecodeError  # type: ignore
from operator import itemgetter
import os
from pathlib import Path
import re
import socket
import subprocess  # nosec
from subprocess import PIPE, STDOUT  # nosec
import sys
from typing import Any, Callable, cast, Optional, Sequence, Type
try:
    import yaml
except ModuleNotFoundError:  # pragma: no cover
    sys.exit("ModuleNotFoundError: Could not import yaml; "
             "you may need to (re-)run `cmt-install` or `pip3 install PyYAML`; aborting.")

try:
    from natsort import natsorted
except ModuleNotFoundError:  # pragma: no cover
    sys.exit("ModuleNotFoundError: Could not import natsort; "
             "you may need to (re-)run `cmt-install` or `pip3 install natsort`; aborting.")

from clustermanagementtoolkit.cmttypes import deep_get, deep_get_list, deep_get_with_fallback
from clustermanagementtoolkit.cmttypes import deep_get_str_tuple_paths, deep_set, DictPath
from clustermanagementtoolkit.cmttypes import FilePath, Retval
from clustermanagementtoolkit.cmttypes import SecurityPolicy, SecurityStatus, StatusGroup
from clustermanagementtoolkit.cmttypes import ProgrammingError, FilePathAuditError

from clustermanagementtoolkit import cmtpaths
from clustermanagementtoolkit.cmtpaths import BINDIR, KUBE_CONFIG_FILE, HOMEDIR, DEPLOYMENT_DIR
from clustermanagementtoolkit.cmtpaths import CMT_CONFIG_FILE_DIR, THEME_DIR
from clustermanagementtoolkit.cmtpaths import DEFAULT_THEME_FILE
from clustermanagementtoolkit.cmtpaths import ANSIBLE_PLAYBOOK_DIR, SYSTEM_ANSIBLE_PLAYBOOK_DIR
from clustermanagementtoolkit.cmtpaths import CMT_CONFIG_FILE_DIRNAME, CMT_CONFIG_FILE
from clustermanagementtoolkit.cmtpaths import CMT_CONFIG_FILENAME
from clustermanagementtoolkit.cmtpaths import SSH_ARGS_RELAXED, SSH_ARGS_STRICT, SSH_BIN_PATH

from clustermanagementtoolkit import cmtio
from clustermanagementtoolkit.cmtio import execute_command, execute_command_with_response
from clustermanagementtoolkit.cmtio import expand_path
from clustermanagementtoolkit.cmtio import secure_read_string, secure_which, secure_write_string
from clustermanagementtoolkit.cmtio_yaml import secure_read_yaml, secure_read_yaml_all
# from cmtlog import auditlog, debuglog, CMTLogType, CMTLog
# from cmtlog import debuglog, CMTLogType, CMTLog

from clustermanagementtoolkit.cmtvalidators import validate_name

from clustermanagementtoolkit.commandparser import parse_commandline

import clustermanagementtoolkit.logparser as logparsers

from clustermanagementtoolkit.logparser import logparser, logparser_initialised
from clustermanagementtoolkit.logparser import LogLevel, LogparserConfiguration
from clustermanagementtoolkit.logparser import lvl_to_letter_severity, lvl_to_4letter_severity
from clustermanagementtoolkit.logparser import lvl_to_word_severity
from clustermanagementtoolkit.logparser import loglevel_to_name, get_loglevel_names
from clustermanagementtoolkit.logparser import name_to_loglevel, get_parser_list

from clustermanagementtoolkit import curses_helper

from clustermanagementtoolkit import cmtlib
from clustermanagementtoolkit.cmtlib import decode_value, clamp, get_package_versions
from clustermanagementtoolkit.cmtlib import identify_k8s_distro, make_set_expression_list
from clustermanagementtoolkit.cmtlib import make_label_selector
from clustermanagementtoolkit.cmtlib import none_timestamp, timestamp_to_datetime, get_since
from clustermanagementtoolkit.cmtlib import split_msg, versiontuple, read_cmtconfig, substitute_list
from clustermanagementtoolkit.cmtlib import normalise_cpu_usage_to_millicores
from clustermanagementtoolkit.cmtlib import normalise_mem_to_bytes, normalise_mem_bytes_to_str
from clustermanagementtoolkit.cmtlib import check_allowlist

from clustermanagementtoolkit.curses_helper import CursesConfiguration, color_log_severity
from clustermanagementtoolkit.curses_helper import format_helptext, get_mousemask
from clustermanagementtoolkit.curses_helper import color_status_group
from clustermanagementtoolkit.curses_helper import UIProps, WidgetLineAttrs
from clustermanagementtoolkit.curses_helper import get_theme_ref, read_theme
from clustermanagementtoolkit.curses_helper import themearray_wrap_line, themearray_to_string
from clustermanagementtoolkit.curses_helper import themearray_len
from clustermanagementtoolkit.curses_helper import themearray_truncate
from clustermanagementtoolkit.curses_helper import ThemeAttr, ThemeRef, ThemeStr

from clustermanagementtoolkit import listgetters
from clustermanagementtoolkit.listgetters import listgetter_allowlist

from clustermanagementtoolkit import listgetters_async
from clustermanagementtoolkit.listgetters_async import listgetter_async_allowlist

from clustermanagementtoolkit import datagetters
from clustermanagementtoolkit.datagetters import datagetter_allowlist

from clustermanagementtoolkit import generators
from clustermanagementtoolkit.generators import generator_allowlist, default_processor

from clustermanagementtoolkit import infogetters

from clustermanagementtoolkit import itemgetters
from clustermanagementtoolkit.itemgetters import itemgetter_allowlist

from clustermanagementtoolkit.objgetters import objgetter_allowlist

from clustermanagementtoolkit import formatters
from clustermanagementtoolkit.formatters import formatter_allowlist

from clustermanagementtoolkit.fieldgetters import fieldgetter_allowlist

from clustermanagementtoolkit.ansible_helper import ansible_configuration
from clustermanagementtoolkit.ansible_helper import ansible_get_inventory_dict
from clustermanagementtoolkit.ansible_helper import ansible_get_groups, ansible_get_groups_by_host
from clustermanagementtoolkit.ansible_helper import ansible_add_hosts, ansible_remove_hosts
from clustermanagementtoolkit.ansible_helper import ansible_set_vars
from clustermanagementtoolkit.ansible_helper import ansible_run_playbook_on_selection
from clustermanagementtoolkit.ansible_helper import ansible_get_logs, ansible_delete_log
from clustermanagementtoolkit.ansible_helper import ansible_print_play_results, get_playbook_path
from clustermanagementtoolkit.ansible_helper import ANSIBLE_INVENTORY

from clustermanagementtoolkit import helptexts

from clustermanagementtoolkit.kubernetes_helper import KubernetesHelper, KubernetesResourceCache
from clustermanagementtoolkit.kubernetes_helper import get_controller_from_owner_references
from clustermanagementtoolkit.kubernetes_helper import get_image_version
from clustermanagementtoolkit.kubernetes_helper import kubectl_get_version
from clustermanagementtoolkit.kubernetes_helper import update_api_status as kh_update_api_status
from clustermanagementtoolkit.kubernetes_helper import guess_kind

from clustermanagementtoolkit import checks

from clustermanagementtoolkit.ansithemeprint import ANSIThemeStr, ansithemestr_join_list
from clustermanagementtoolkit.ansithemeprint import clear_screen, ansithemeinput, ansithemeprint

from clustermanagementtoolkit import reexecutor

from clustermanagementtoolkit import about

PROGRAMDESCRIPTION = "UI for managing Kubernetes clusters"
PROGRAMAUTHORS = "Written by David Weinehall."

# If the user passes an object (and optionally namespace for that object)
# on the command line, they are stored here
# For pods a container can be appended too
initial_name = None  # pylint: disable=invalid-name
initial_namespace = None  # pylint: disable=invalid-name
initial_container = None  # pylint: disable=invalid-name

# Is cmu running in read only-mode?
read_only_mode = False  # pylint: disable=invalid-name

# Is Kubernetes support enabled
kubernetes_support = True  # pylint: disable=invalid-name
kube_config_file = None  # pylint: disable=invalid-name

# Namespace
selected_namespace = ""  # pylint: disable=invalid-name

# defaults
defaultview = ""  # pylint: disable=invalid-name

kh: KubernetesHelper = None  # type: ignore
kh_cache: KubernetesResourceCache = None  # type: ignore

executor = reexecutor.ReExecutor()
async_data: dict = {}

override_tail_lines = None  # pylint: disable=invalid-name
DEFAULT_TAIL_LINES = 4000

force_refresh_apis = False  # pylint: disable=invalid-name


def init_kubernetes_client() -> None:
    """
    Initialise the Kubernetes client.
    """
    global kh  # pylint: disable=global-statement
    global kh_cache  # pylint: disable=global-statement

    if kubernetes_support:
        kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION,
                              config_path=kube_config_file)
        kh_cache = KubernetesResourceCache()


# pylint: disable-next=too-many-locals
def gather_cluster_info(**kwargs: Any) -> None:
    """
    Gather information about the cluster necessary for running playbooks.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                kubernetes_helper (KubernetesHelper): A reference to a KubernetesHelper object
    """
    if (kh_ := deep_get(kwargs, DictPath("kubernetes_helper"))) is None:
        raise ProgrammingError("gather_cluster_info() called without kubernetes_helper")

    # Set global variables that need to be available when executing playbooks
    join_token = kh_.get_join_token()
    ca_cert_hash = kh_.get_ca_cert_hash()
    control_plane_ip, control_plane_port, control_plane_path = kh_.get_control_plane_address()
    _control_plane_node, control_plane_name = get_control_plane()

    # This is tricky: we get this from the distro packages;
    # since we cannot assume that we are running cmu on the [main] control plane
    # we have to ask the [main] control plane, via ansible, what version of kubeadm it is running
    package_versions = get_package_versions(control_plane_name)
    control_plane_k8s_version = ""
    for package, version in package_versions:
        if package == "kubeadm":
            control_plane_k8s_version = version
    if not control_plane_k8s_version:
        sys.exit(f"Failed to get kubeadm version from control plane “{control_plane_name}“; "
                 "aborting.")

    http_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), None)
    https_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), None)
    no_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), None)
    insecure_registries = deep_get(cmtlib.cmtconfig, DictPath("Docker#insecure_registries"), [])
    registry_mirrors = deep_get(cmtlib.cmtconfig, DictPath("Containerd#registry_mirrors"), [])
    packages = deep_get(cmtlib.cmtconfig, DictPath("Packages"), {})

    values = {
        "control_plane_ip": control_plane_ip,
        "control_plane_port": control_plane_port,
        "control_plane_path": control_plane_path,
        "join_token": join_token,
        "ca_cert_hash": ca_cert_hash,
        "control_plane_k8s_version": control_plane_k8s_version,
        "ntp_server": control_plane_ip,
        "http_proxy": http_proxy,
        "https_proxy": https_proxy,
        "no_proxy": no_proxy,
        "insecure_registries": insecure_registries,
        "registry_mirrors": registry_mirrors,
        "packages": packages,
    }

    ansible_set_vars(ANSIBLE_INVENTORY, "all", values)


def format_timestamp(timestamp: datetime,
                     localtimezone: bool = False) -> list[ThemeRef | ThemeStr]:
    """
    Takes datetime and formats it as a YYYY-MM-DD HH:MM:SS themearray.

        Parameters:
            timestamp (datetime): The timestamp
            localtimezone (bool): IS the timestamp in local time
        Returns:
            ([ThemeRef | ThemeStr]): A formatted timestamp
    """
    array = []

    if timestamp is None:
        array = [ThemeRef("strings", "none")]
    else:
        if localtimezone:
            ftimestamp = f"{timestamp.astimezone():%Y-%m-%d %H:%M:%S}"
        else:
            ftimestamp = f"{timestamp:%Y-%m-%d %H:%M:%S}"
        array = generators.format_numerical_with_units(ftimestamp, "timestamp", False)

    return array


# pylint: disable-next=too-many-locals
def update_field_widths(field_dict: dict, field_names: list[str], objects: list[Type]) -> int:
    """
    Process the fields for a line; calcute how wide each field should be,
    then return the total line length.

        Parameters:
            field_dict (dict): The dict containing the description of the field
            field_names ([str]): The names of the fields to populate
            objects ([InfoClass]): An InfoClass object with the data
                                   for all fields in the field_names list
        Returns:
            (int): The total length of all the fields of a line
    """
    linelen = 0
    pos = 0

    for field_name in field_names:
        field_dict[field_name]["pos"] = pos
        field_dict[field_name]["fieldlen"] = 0

        # These are necessary to calculate width of list items
        item_separator = \
            field_dict[field_name].get("item_separator", ThemeRef("separators", "list"))
        field_separators = \
            field_dict[field_name].get("field_separators", [ThemeRef("separators", "field")])
        ellipsise = field_dict[field_name].get("ellipsise", -1)
        ellipsis = field_dict[field_name].get("ellipsis", ThemeRef("separators", "ellipsis"))
        field_prefixes = field_dict[field_name].get("field_prefixes", [])
        field_suffixes = field_dict[field_name].get("field_suffixes", [])
        formatting = deep_get(field_dict, DictPath(f"{field_name}#formatting"), {})

        tmplen = 0

        for obj in objects:
            generator = field_dict[field_name].get("generator")
            processor = field_dict[field_name].get("processor")

            if processor is None:
                processor = default_processor.get(generator)

            if processor is not None:
                if processor in (generators.processor_list, generators.processor_list_with_status):
                    tmp = processor(obj, field_name,
                                    item_separator=item_separator,
                                    field_separators=field_separators,
                                    ellipsise=ellipsise, ellipsis=ellipsis,
                                    field_prefixes=field_prefixes,
                                    field_suffixes=field_suffixes)
                # pylint: disable-next=comparison-with-callable
                elif processor == generators.processor_timestamp_with_age:
                    tmp = processor(obj, field_name, formatting)
                else:
                    tmp = processor(obj, field_name)
            else:
                tmp = getattr(obj, field_name)

            tmplen = max(len(str(tmp)), field_dict[field_name].get("fieldlen", 0))

            field_dict[field_name]["fieldlen"] = tmplen

        field_dict[field_name]["fieldlen"] = max(tmplen, len(field_dict[field_name]["header"]))

        linelen += field_dict[field_name].get("fieldlen") + len(ThemeRef("separators", "pad"))
        pos = linelen

    # The last element should not be padded
    if linelen:
        linelen -= len(ThemeRef("separators", "pad"))

    return linelen


def get_image_tuple(image: str) -> tuple[str, str]:
    """
    Given the name of a container, return the name and the version field.

        Paramters:
            image (str): The full container name
        Returns:
            (str, str):
                (str): The container name
                (str): The container version
    """
    tmp = re.match(r"^(.*):(.*)", image)
    if tmp is not None:
        image_name = f"{tmp[1]}"
        image_version = f"{tmp[2]}"
    else:
        image_name = f"{image}"
        image_version = "<undefined>"
    return image_name, image_version


# We should probably have a real type for container_type here
def __get_container_info(obj: dict, container_type: str,
                         spec_path: DictPath, status_path: DictPath) -> dict:
    containers: dict = {}

    for container in deep_get(obj, spec_path, []):
        container_name = deep_get(container, DictPath("name"))
        container_image = deep_get(container, DictPath("image"))
        image_version = get_image_version(container_image)

        # To get the image ID we need to cross-reference container_image
        # against status#{status_path}->image"
        image_id = None
        for item in deep_get(obj, status_path, []):
            if deep_get(item, DictPath("name"), "") == container_name:
                image_id = deep_get(item, DictPath("imageID"))
        # This (most likely) means that the pod has not managed to instantiate a container
        if image_id is None:
            image_id = "<unknown>"
        key = (container_name, container_type, image_version, image_id)

        # If this container is in the dict already, just add a pod reference
        # This is unlikely to ever happen (this would mean that the same pod
        # uses the same image multiple times which seems unlikely), but better safe than sorry
        if key not in containers:
            containers[key] = {}
            containers[key]["pod_references"] = []
            containers[key]["instances"] = 0

        containers[key]["pod_references"].append(obj)
        containers[key]["instances"] += 1

    return containers


# pylint: disable-next=too-many-locals
def get_container_info(**kwargs: Any) -> list[Type]:
    """
    Infogetter for containers.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                kubernetes_helper (KubernetesHelper): A reference to a KubernetesHelper object
        Returns:
            ([InfoClass]): A list with info
    """
    if (kh_ := deep_get(kwargs, DictPath("kubernetes_helper"))) is None:
        raise ProgrammingError("get_container_info() called without kubernetes_helper")
    kh_cache_ = deep_get(kwargs, DictPath("kh_cache"))

    info: list[Type] = []
    containers: dict = {}

    # There's no direct way to get a list of unique containers
    # as defined by the tuple (name, type, version, image_id),
    # so we need to iterate the list of all pods and extract this
    # information.
    vlist, status = kh_.get_list_by_kind_namespace(("Pod", ""), "", resource_cache=kh_cache_)
    if status != 200:
        return info

    for obj in vlist:
        tmp = __get_container_info(obj, "InitContainer",
                                   DictPath("spec#initContainers"),
                                   DictPath("status#initContainerStatuses"))
        for key, value in tmp.items():
            instances = value["instances"]
            pod_references = value["pod_references"]
            if key not in containers:
                containers[key] = {}
                containers[key]["instances"] = 0
                containers[key]["pod_references"] = []

            containers[key]["instances"] += instances
            containers[key]["pod_references"] += pod_references
        tmp = __get_container_info(obj, "Container",
                                   DictPath("spec#containers"),
                                   DictPath("status#containerStatuses"))
        for key, value in tmp.items():
            instances = value["instances"]
            pod_references = value["pod_references"]
            if key not in containers:
                containers[key] = {}
                containers[key]["instances"] = 0
                containers[key]["pod_references"] = []

            containers[key]["instances"] += instances
            containers[key]["pod_references"] += pod_references

    for name, container_type, image_version, image_id in containers:
        pod_references = containers[(name, container_type,
                                     image_version, image_id)]["pod_references"]
        pods = []
        for pod in pod_references:
            pods.append((deep_get(pod, DictPath("metadata#namespace")),
                         deep_get(pod, DictPath("metadata#name"))))
        instances = containers[(name, container_type, image_version, image_id)]["instances"]
        info.append(type("InfoClass", (), {
            "name": name,
            # This replaces ref
            "ref": {
                "name": name,
                "container_type": container_type,
                "image_version": image_version,
                "image_id": image_id,
                "pod_references": pod_references,
            },
            "container_type": container_type,
            "image_version": image_version,
            "instances": instances,
            "image_id": image_id,
            "pods": pods,
            "pod_references": pod_references,
        }))
    return info


# pylint: disable-next=unused-argument,too-many-locals
def get_log_info(**kwargs: Any) -> list[Type]:
    """
    Infogetter for logs.

        Parameters:
            **kwargs (dict): Additional parameters
        Returns:
            ([InfoClass]): A list with info
    """
    info: list[Type] = []

    # Fetch kubelet log, if available (for now only useful if run on the control plane)
    sudo_path = secure_which(FilePath("sudo"),
                             fallback_allowlist=["/bin", "/usr/bin"],
                             security_policy=SecurityPolicy.ALLOWLIST_STRICT)
    journalctl_path = secure_which(FilePath(os.path.join(BINDIR, "journalctl")),
                                   fallback_allowlist=["/bin", "/usr/bin"],
                                   security_policy=SecurityPolicy.ALLOWLIST_STRICT)
    args = [sudo_path, journalctl_path, "--no-pager", "-o", "json"]

    logs = [
        ("Latest boot, last 1h", "[dmesg]",
         ["-k", "-b", "--since", "1 hour ago", "--lines", "10000"], "glog"),
        ("Latest 1000 lines", "[kubelet]",
         ["--lines", "1000", "-u", "kubelet"], "glog"),
        ("Latest 1000 lines", "[containerd]",
         ["--lines", "1000", "-u", "containerd"], "key_value"),
        ("Latest 1000 lines", "[cri-o]",
         ["--lines", "1000", "-u", "crio"], "key_value"),
    ]

    try:
        for name, action, log, parser in logs:
            response = execute_command_with_response(args + log)
            if not response:
                continue

            # The first entry in the obj list holds metadata
            split_response: list[dict[str, Any]] = [{
                "parser": parser,
            }]
            split_response += response.splitlines()
            latestentry = split_response[1]

            d = json.loads(latestentry)

            split_response[0]["name"] = deep_get(d, DictPath("SYSLOG_IDENTIFIER"), "<unknown>")
            hostname = deep_get(d, DictPath("_HOSTNAME"), "<unknown>")
            split_response[0]["host"] = hostname
            created_at = \
                datetime.fromtimestamp(int(deep_get(d, DictPath("__REALTIME_TIMESTAMP"))) / 1000000)
            split_response[0]["created_at"] = created_at

            info.append(type("InfoClass", (), {
                "name": f"<dynamic> {hostname}: {name}",
                "ref": {
                    "ref": split_response,
                    "kind": "__JournalctlLogView",
                },
                "action": action,
                "message": deep_get(d, DictPath("MESSAGE"), ""),
                "created_at": created_at,
                "log_type": "journalctl",
            }))
    except FileNotFoundError:
        pass

    # Get the list of available Ansible logs
    ansible_logs = ansible_get_logs()

    # TODO: Here we might possibly want to insert other logs?

    for name, action, ref, created_at in ansible_logs:
        log_type = "Ansible Play"
        info.append(type("InfoClass", (), {
            "name": name,
            "ref": {
                "ref": ref,
                "kind": "__AnsibleLog",
            },
            "action": action,
            "created_at": created_at,
            "log_type": log_type,
        }))
    return info


def __process_string(value: str, replace_quotes: str) -> str:
    # We do not want any newlines, and extra trailing whitespace
    if value is None:
        value = ""
    if isinstance(value, str):
        value = value.replace("\n", "\\n").rstrip()
        if replace_quotes == "pretty":
            value = value.replace("\\\"", "“")
        elif replace_quotes == "same":
            value = value.replace("\\\"", "\"")
    return value


def __process_sum_numerical(value: Sequence[int | float]) -> float | int:
    return sum(value)


def __process_stringify_list(values: Sequence[Any]) -> list[str]:
    tmp: list[str] = []
    for value in values:
        tmp.append(str(value))
    return tmp


def __process_sum_cpu_usage(values: list[str]) -> str:
    cpu_usage_sum = 0.0
    for value in values:
        cpu_usage_sum += normalise_cpu_usage_to_millicores(value)
    return f"{cpu_usage_sum:0.1f}"


def __process_sum_mem_usage(values: list[str]) -> str:
    mem_usage_sum = 0
    for value in values:
        mem_usage_sum += normalise_mem_to_bytes(value)
    return normalise_mem_bytes_to_str(mem_usage_sum)


def __process_timestamp(value: Sequence[int | str] | str,
                        action: str, formatter: str) -> datetime | int:
    new_value: Any = None

    if action in ("earliest", "latest") and isinstance(value, (list, tuple)):
        tmp_timestamp: datetime = none_timestamp()
        for tmp1 in value:
            if tmp1 is None or tmp1 == -1:
                continue
            # The only valid integer value is -1
            timestamp = timestamp_to_datetime(cast(str, tmp1))
            if tmp_timestamp == none_timestamp():
                tmp_timestamp = timestamp
            else:
                if timestamp < tmp_timestamp and action == "earliest":
                    tmp_timestamp = timestamp
                elif timestamp > tmp_timestamp and action == "latest":
                    tmp_timestamp = timestamp
        new_value = tmp_timestamp
    else:
        if value == -1:
            new_value = none_timestamp()
        elif isinstance(value, str) and value.startswith("<") and value.endswith(">"):
            new_value = value
        else:
            new_value = timestamp_to_datetime(cast(str, value))

    if formatter == "age":
        # If we are gonna format this as age we want this passed through get_since()
        return get_since(new_value)

    return new_value


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def process_value(value: Any, vtype: str, **kwargs: Any) -> \
        int | float | str | list[str] | list[tuple[str]] | datetime | None:
    """
    Reformat values; returns data in a format suitable for further processing.

        Parameters:
            value (Any): The value to process
            vtype (str): The value-type
            **kwargs (dict[str, Any]): Keyword arguments
                action (str): Additional actions to perform when processing
                field_index (str): The field index for formatting of a particular kind
                field_name (str): The name of the field the data originates from
                formatter (str): Formatter to use (specifically used when processing timestamps)
                replace_quotes (str): Quote replacement policy (no, pretty, same)
                view (str): The view being processed
        Returns:
            (int|float|str|[str]|datetime): The processed value
    """
    action: str = deep_get(kwargs, DictPath("action"))
    field_index: str = deep_get(kwargs, DictPath("field_index"))
    field_name: str = deep_get(kwargs, DictPath("field_name"))
    formatter: str = deep_get(kwargs, DictPath("formatter"))
    replace_quotes: str = deep_get(kwargs, DictPath("replace_quotes"))
    view: str = deep_get(kwargs, DictPath("view"))

    override_kind = \
        deep_get_with_fallback(cmtlib.cmtconfig,
                               [DictPath(f"Views#{view}#kind_format_{field_index}"),
                                DictPath(f"Views#{view}#kind_format"),
                                DictPath(f"Global#kind_format_{field_index}"),
                                DictPath("Global#kind_format")], "mixed")

    new_value: int | float | str | list[str] | datetime | None = None

    if vtype == "str":
        new_value = __process_string(value, replace_quotes)
    elif vtype in ("float", "int", "bool"):
        if isinstance(value, (list, tuple)) and action == "sum":
            new_value = __process_sum_numerical(value)
        elif isinstance(value, tuple):
            new_value = __process_stringify_list(value)
        else:
            new_value = str(value)
    elif vtype in ("cpu_usage", "cpu_usage_round"):
        if isinstance(value, list) and action == "sum":
            new_value = __process_sum_cpu_usage(value)
        elif vtype == "cpu_usage_round":
            tmp_float = normalise_cpu_usage_to_millicores(value)
            new_value = f"{int(tmp_float / 1000)}"
        else:
            tmp_float = normalise_cpu_usage_to_millicores(value)
            new_value = f"{tmp_float:0.1f}"
    elif vtype == "mem_usage":
        if isinstance(value, list) and action == "sum":
            new_value = __process_sum_mem_usage(value)
        else:
            tmp_int = normalise_mem_to_bytes(value)
            new_value = normalise_mem_bytes_to_str(tmp_int)
    elif vtype == "disk_usage":
        new_value = cmtlib.disksize_to_human(value)
    elif vtype == "len":
        if value is None:
            new_value = "0"
        else:
            new_value = str(len(cast(str | Sequence, value)))
    elif vtype == "unix_timestamp":
        new_value = datetime.fromtimestamp(value)
    elif vtype == "timestamp":
        new_value = __process_timestamp(value, action, formatter)
    elif isinstance(vtype, list):
        if not isinstance(value, (list, tuple)):
            raise ValueError(f"Field {field_name}: type({value}) is {vtype}; "
                             f"for type {vtype} pathtype must be a multi-element type")
        _values = []
        override_kind = deep_get_with_fallback(cmtlib.cmtconfig,
                                               [DictPath(f"Views#{view}#kind_format_{field_index}"),
                                                DictPath(f"Views#{view}#kind_format"),
                                                DictPath(f"Global#kind_format_{field_index}"),
                                                DictPath("Global#kind_format")], "mixed")
        for i, data in enumerate(value):
            if i < len(vtype):
                _vtype = vtype[i]
            else:
                _vtype = "raw"
            if _vtype in ("raw", "name"):
                _values.append(data)
            elif _vtype == "kind":
                if override_kind == "skip":
                    _values.append("")
                else:
                    _values.append(data)
            elif _vtype == "api_group":
                if override_kind == "skip":
                    _values.append("")
                    continue

                if data is not None and "/" in data:
                    if override_kind == "full" or override_kind == "mixed" and "." in data:
                        _values.append(data.split("/", maxsplit=1)[0])
                    else:
                        _values.append("")
                else:
                    _values.append("")
            elif _vtype == "skip":
                _values.append("")
            else:
                raise ValueError(f"Field {field_name}: type[{i}] ({vtype}) is unknown")
        if isinstance(value, list):
            new_value = _values
        elif isinstance(value, tuple):
            new_value = tuple(cast(list, _values))
    elif vtype == "raw":
        # Do not convert this type
        new_value = value
    else:
        theme = get_theme_ref()

        # Is a custom type used for theming?
        if vtype not in theme["types"]:
            raise ValueError(f"Unknown value type {vtype}; the view file is probably invalid")
        new_value = value
    return new_value


def transform_filter(transformations: dict, value: DictPath) -> Any:
    """
    Given a transformation dictionary,
    look up and return the corresponding value.

        Parameters:
            transformations (dict[str, Any]): The transformation dictionary
            value (DictPath): The value to look up
        Returns:
            (Any): The transformed value
    """
    if transformations and value in transformations:
        value = deep_get(transformations, value)
    return value


# pylint: disable-next=too-many-return-statements,too-many-locals,too-many-branches,too-many-statements # noqa: E501
def when_filter(when_path: dict, item: dict, key: Optional[str] = None, value: Any = None) -> bool:
    """
    A filter used by infogetters. Given a dictionary of when-conditions,
    # and either a dict or a key/value pair, return True if all conditions
    # evaluate to true, or False if at least one condition evaluates to false.

        Parameters:
            when_path (dict[str, list[dict[str, Any]]]): A dictionary of when-conditions
            item (dict[str, Any]): An item to filter
            key (str): A key
            value (Any): A value
        Returns:
            (bool): True if all conditions evaluated to True,
                    False if at least one condition evaluated to False
    """
    when_conditions = deep_get(when_path, DictPath("when"), [])

    _key = key
    _value = value

    for when_condition in when_conditions:
        # These apply to the key
        if _key is None:
            key = deep_get(when_condition, DictPath("key"))

        # These do not make sense when using when#key, since we already know the key
        when_key_eq = deep_get(when_condition, DictPath("key_eq"))
        when_key_ne = deep_get(when_condition, DictPath("key_ne"))
        when_key_in = deep_get(when_condition, DictPath("key_in"))
        when_key_notin = deep_get(when_condition, DictPath("key_notin"))
        when_key_startswith = deep_get(when_condition, DictPath("key_startswith"))
        when_key_notstartswith = deep_get(when_condition, DictPath("key_notstartswith"))
        when_key_endswith = deep_get(when_condition, DictPath("key_endswith"))
        when_key_notendswith = deep_get(when_condition, DictPath("key_notendswith"))
        if when_key_eq is not None and when_key_eq != key:
            return False
        if when_key_ne is not None and when_key_eq == key:
            return False
        if when_key_in is not None and key not in when_key_in:
            return False
        if when_key_notin is not None and key in when_key_notin:
            return False
        if when_key_startswith is not None and not key.startswith(when_key_startswith):
            return False
        if when_key_notstartswith is not None and key.startswith(when_key_notstartswith):
            return False
        if when_key_endswith is not None and not key.endswith(when_key_endswith):
            return False
        if when_key_notendswith is not None and key.endswith(when_key_notendswith):
            return False

        # Check for none
        if _value is None:
            if key is None:
                raise ValueError("key is None")
            value = deep_get(item, DictPath(key))

        # These check whether the key has a value
        when_none = deep_get(when_condition, DictPath("none"))
        when_notnone = deep_get(when_condition, DictPath("notnone"))

        # All these check the value
        when_eq = deep_get(when_condition, DictPath("eq"))
        when_ne = deep_get(when_condition, DictPath("ne"))
        when_lt = deep_get(when_condition, DictPath("lt"))
        when_lte = deep_get(when_condition, DictPath("lte"))
        when_gt = deep_get(when_condition, DictPath("gt"))
        when_gte = deep_get(when_condition, DictPath("gte"))
        when_in = deep_get(when_condition, DictPath("in"))
        when_notin = deep_get(when_condition, DictPath("notin"))
        when_missing = deep_get(when_condition, DictPath("missing"))
        when_notmissing = deep_get(when_condition, DictPath("notmissing"))

        # These check dict values
        when_isdict = deep_get(when_condition, DictPath("isdict"))
        when_notisdict = deep_get(when_condition, DictPath("notisdict"))
        when_dicthaskey = deep_get(when_condition, DictPath("dicthaskey"))
        when_notdicthaskey = deep_get(when_condition, DictPath("notdicthaskey"))

        # Check for existance
        if when_missing is not None and when_missing in item:
            return False
        if when_notmissing is not None and when_notmissing not in item:
            return False

        if when_notnone is not None and value is None:
            return False
        if when_none is not None and value is not None:
            return False

        # dict-based checks
        if when_isdict is not None and not isinstance(value, dict):
            return False
        if when_notisdict is not None and isinstance(value, dict):
            return False
        if when_dicthaskey is not None \
                and (not isinstance(value, dict) or when_dicthaskey not in value):
            return False
        if when_notdicthaskey is not None \
                and (not isinstance(value, dict) or when_notdicthaskey in value):
            return False

        # Set-based checks
        if when_in is not None and value not in when_in:
            return False
        if when_notin is not None and value in when_notin:
            return False

        # Check for equality
        if when_eq is not None and (value is None or value != type(value)(when_eq)):
            return False
        if when_ne is not None and (value is None or value == type(value)(when_ne)):
            return False

        if when_lt is not None and not value < type(value)(when_lt):
            return False
        if when_lte is not None and not value <= type(value)(when_lte):
            return False
        if when_gt is not None and not value > type(value)(when_gt):
            return False
        if when_gte is not None and value >= type(value)(when_gte):
            return False

    return True


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def transform_list(vlist: list | dict, transform: dict) -> list:
    sort: bool = deep_get(transform, DictPath("sorted"), False)
    key_regexes: list[str] = deep_get(transform, DictPath("key#regex"), [])
    key_groups: list[int] = deep_get(transform, DictPath("key#groups"), [])
    key_join = deep_get(transform, DictPath("key#join"))
    key_defaults: list = deep_get(transform, DictPath("key#default"), [])
    value_regexes: list[str] = deep_get(transform, DictPath("value#regex"), [])
    value_groups: list[int] = deep_get(transform, DictPath("value#groups"), [])
    value_join = deep_get(transform, DictPath("value#join"))
    value_defaults: list = deep_get(transform, DictPath("value#default"), [])
    output: list[str] = deep_get(transform, DictPath("output"), ["key", "value"])

    result: list = []

    # This handles both lists and dicts
    # pylint: disable-next=too-many-nested-blocks
    for key in vlist:
        if not isinstance(vlist, dict):
            value = None
        else:
            value = vlist[key]

        key_data = []

        if key is None:
            continue

        key = str(key)

        if not key_regexes:
            key_data.append(key)
        else:
            for _regex in key_regexes:
                _tmp = re.match(_regex, key)
                if _tmp is not None:
                    for group in key_groups:
                        if group < len(_tmp.groups()):
                            _tmp2 = _tmp.groups()[group]
                            if _tmp2 is None and group < len(key_defaults):
                                key_data.append(key_defaults[group])
                            else:
                                key_data.append(_tmp2)
                if key_join is not None and len(key_data) > 1:
                    tmp = ""
                    for i, element in enumerate(key_data):
                        tmp += element
                        if i < len(key_data) - 1:
                            tmp += key_join[min(i, len(key_join) - 1)]
                    key_data = [tmp]

        value_data = []
        for _regex in value_regexes:
            if value is None:
                continue

            value = str(value)

            _tmp = re.match(_regex, value)
            if _tmp is not None:
                for group in value_groups:
                    if group < len(_tmp.groups()):
                        _tmp2 = _tmp.groups()[group]
                        if _tmp2 is None and group < len(value_defaults):
                            value_data.append(value_defaults[group])
                        else:
                            value_data.append(_tmp2)
            if value_join is not None and len(value_data) > 1:
                tmp = ""
                for i, element in enumerate(value_data):
                    tmp += element
                    if i < len(value_data) - 1:
                        tmp += value_join[min(i, len(value_join) - 1)]
                value_data = [tmp]

        tmp3 = []
        for _output in output:
            if _output == "key":
                if len(key_data) == 1:
                    tmp3.append(key_data[0])
                else:
                    tmp3.append(tuple(key_data))
            elif _output == "value":
                if len(value_data) == 1:
                    tmp3.append(value_data[0])
                else:
                    tmp3.append(tuple(value_data))
        if len(tmp3) == 1:
            tmp3 = tmp3[0]
        else:
            tmp3 = tuple(tmp3)
        result.append(tmp3)

    if sort:
        return natsorted(result)

    return result


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def get_obj(obj: dict, field_dict: dict, field_names: list[str],
            field_index: str, view: str, **kwargs: Any) -> Type:
    """
    Extract data for all fields in a list row from an object.

        Parameters:
            obj (dict): The object to extract data from
            field_dict (dict): The dict containing the description of the field
            field_names ([str]): The names of the fields to populate
            field_index (str): The index for the field list
            view (str): The name of the view
            **kwargs (dict[str, Any]): Keyword arguments
                filters (dict): The filters to apply
                deleted (bool): Is the entry deleted?
                caller_obj (dict): Used for lookups when doing path substitutions
        Returns:
            (InfoClass): An InfoClass object with the data for all fields in the field_names list
    """
    d = {}

    filters: dict[str, Any] = deep_get(kwargs, DictPath("filters"), {})
    deleted: bool = deep_get(kwargs, DictPath("deleted"), False)
    caller_obj: dict = deep_get(kwargs, DictPath("caller_obj"), {})
    duration: int = -1

    # fields both specify formatting and where to get the data from;
    # here we are only concerned with the data
    # pylint: disable-next=too-many-nested-blocks
    for field_name in field_names:
        name = field_name
        field = field_dict[name]
        path = deep_get(field, DictPath("path"))
        paths = deep_get(field, DictPath("paths"), [])
        path_substitutions = deep_get(field, DictPath("path_substitutions"), {})
        unique_values = deep_get(field, DictPath("unique"), False)
        if caller_obj and path_substitutions:
            substitutions = {}
            for subst, subst_with in path_substitutions.items():
                if isinstance(subst_with, list):
                    subst_with = deep_get_with_fallback(caller_obj, subst_with)
                substitutions[subst] = subst_with
            path = cmtlib.substitute_string(path, substitutions)
        datagetter = deep_get(field, DictPath("datagetter"))
        if datagetter is not None:
            if isinstance(datagetter, str):
                datagetter = deep_get(datagetter_allowlist, DictPath(datagetter))
        if "default" not in field:
            default = ""
        else:
            default = deep_get(field, DictPath("default"))
        global_default = default
        fallback_on_empty = deep_get(field, DictPath("fallback_on_empty"), False)
        formatter = deep_get(field, DictPath("formatter"))
        action = None
        replace_quotes = None

        if (path is None and not paths or path is not None and paths) and datagetter is None:
            raise ValueError(f"Field {name}: exactly one of path and paths must be non-empty "
                             f"unless a datagetter is specified\npath={path}\n"
                             f"paths={paths}\ndatagetter={datagetter}")

        if datagetter is not None:
            d[name], extradata = datagetter(obj, kubernetes_helper=kh, path=path, default=default)
            for key, value in extradata.items():
                d[key] = value
        else:
            _values = []

            if path is not None:
                if deep_get(field, DictPath("type")) is None:
                    raise ValueError(f"Field {name}: the path field has no default type; "
                                     "type must always be specified")
                tmp_value = deep_get(obj, DictPath(path), global_default)
                if tmp_value is not None and isinstance(tmp_value, (str, list)) \
                        and not tmp_value and fallback_on_empty:
                    tmp_value = global_default
                _values.append((tmp_value, deep_get(field, DictPath("type"))))

            _path = None
            for _path in paths:
                default = deep_get(_path, DictPath("default"))
                vtype = deep_get(_path, DictPath("type"), "raw")
                path = deep_get(_path, DictPath("path"))
                mpaths = deep_get(_path, DictPath("paths"))
                if path is not None and mpaths is not None or path is None and mpaths is None:
                    raise ValueError(f"Field {name}: exactly one of path & paths must be used "
                                     f"in a 'paths:' block\npath={path}\npaths={paths}")

                if mpaths is None:
                    if isinstance(path, str):
                        path = [path]
                    mpaths = [path]

                ptype = deep_get(_path, DictPath("pathtype"), "list")
                limit = deep_get(_path, DictPath("limit"))
                action = deep_get(_path, DictPath("action"), "")
                subpath = deep_get(_path, DictPath("subpath"), "")
                subpaths = deep_get(_path, DictPath("subpaths"), [])
                fallback_on_empty = deep_get(_path, DictPath("fallback_on_empty"), False)
                replace_quotes = deep_get(_path, DictPath("replace_quotes"), "no")
                if ptype == "list":
                    tmp = deep_get_with_fallback(obj, path, default=default,
                                                 fallback_on_empty=fallback_on_empty)
                    if deep_get(_path, DictPath("sorted"), False) and tmp is not None:
                        tmp = natsorted(tmp)

                    if tmp is not None and tmp in ("None", ["None"]) \
                            and deep_get(_path, DictPath("none_str_as_none"), False):
                        tmp = default

                    # Just return the list, unless a subset has been requested
                    if limit is not None and tmp is not None:
                        value = tmp[0:limit]
                    else:
                        value = tmp

                    _values.append((value, vtype))
                elif ptype == "dictlist":
                    _raw = deep_get_with_fallback(obj, path, default=default,
                                                  fallback_on_empty=fallback_on_empty)
                    transform = deep_get(_path, DictPath("transform"), {})
                    if _raw is not None:
                        for tmp in transform_list(_raw, transform=transform):
                            _values.append((tmp, vtype))
                # This takes a list of paths as indata, and--for all numerical entries in the list,
                # builds ranges; all non-numerical entries are included as is
                elif ptype == "ranges":
                    rawvals = []
                    for p in path:
                        tmp = deep_get(obj, DictPath(p))
                        if tmp is not None:
                            rawvals += tmp
                    rangevals = []
                    if tmp is not None:
                        firstnum = None
                        lastnum = None
                        sortedvals = natsorted(tmp)
                        for i, sortedval in enumerate(sortedvals):
                            # The range is sorted; this means that we add everything as is except
                            # None until we reach the first numerical, create ranges for
                            # the numericals, then add everything as is except None until the end
                            if sortedval is None:
                                continue
                            # pylint: disable-next=unidiomatic-typecheck
                            if type(sortedval) == int:  # noqa: E721
                                if firstnum is None:
                                    firstnum = sortedval
                                else:
                                    if lastnum is None or sortedval == lastnum + 1:
                                        lastnum = sortedval
                                    else:
                                        # Flush and start a new range
                                        rangevals.append((f"{firstnum}", f"{lastnum}", ""))
                                        firstnum = sortedval
                                        lastnum = None
                            else:
                                if firstnum is not None:
                                    if lastnum is None:
                                        rangevals.append((f"{firstnum}", "", ""))
                                    else:
                                        rangevals.append((f"{firstnum}", f"{lastnum}", ""))
                                        lastnum = None
                                    firstnum = None
                                rangevals.append(("", "", sortedval))
                        if firstnum is not None:
                            if lastnum is None:
                                rangevals.append((f"{firstnum}", "", ""))
                            else:
                                rangevals.append((f"{firstnum}", f"{lastnum}", ""))
                    _values.append((rangevals, "raw"))
                elif ptype == "key_value":
                    value = []
                    tmp = deep_get_with_fallback(obj, path, {})
                    if isinstance(tmp, list):
                        tmp2 = {}
                        for item in tmp:
                            if not isinstance(item, dict):
                                break
                            tmp2 = {**tmp2, **item}
                        tmp = tmp2
                    for _key, _value in tmp.items():
                        subpaths = deep_get(_path, DictPath("subpaths"), [])
                        if subpaths:
                            _value = deep_get_with_fallback(_value, subpaths)
                        if not when_filter(_path, item=None, key=_key, value=_value):
                            continue
                        _regexes_key = deep_get(_path, DictPath("key#regex"), [])
                        _regexes_value = deep_get(_path, DictPath("value#regex"), [])
                        if isinstance(_regexes_key, str):
                            _regexes_key = [_regexes_key]
                        if isinstance(_regexes_value, str):
                            _regexes_value = [_regexes_value]
                        _key = transform_filter(deep_get(_path,
                                                         DictPath("key#transform"), {}), _key)
                        _value = transform_filter(deep_get(_path,
                                                           DictPath("value#transform"), {}), _value)
                        # A regex for key/value is required to capture only one group;
                        # (though conceivably there might be scenario for joining),
                        # thus the first non-None capture group will exit the match;
                        # when using multiple regexes the first matching regex exits
                        match = False
                        for _regex in _regexes_key:
                            _tmp = re.match(_regex, _key)
                            if _tmp is None:
                                continue

                            for group in _tmp.groups():
                                if group is not None:
                                    _key = group
                                    match = True
                            if match:
                                break
                        match = False
                        for _regex in _regexes_value:
                            _tmp = re.match(_regex, _value)
                            if _tmp is None:
                                continue

                            for group in _tmp.groups():
                                if group is not None:
                                    _value = group
                                    match = True
                            if match:
                                break
                        # A transform might yield multiple identical key/value pairs;
                        # ignore all except the first one
                        if (_key, _value) in value:
                            continue
                        value.append((_key, _value))
                    if not value:
                        if default is None:
                            value = []
                        else:
                            value = default
                    for tmp in value:
                        _values.append((tmp, vtype))
                elif ptype == "match_expression":
                    tmp = deep_get_with_fallback(obj, path)
                    if isinstance(tmp, list):
                        value = []
                        subpath = deep_get(_path, DictPath("subpath"))
                        if subpath is None:
                            value = make_set_expression_list(tmp)
                        else:
                            value = make_set_expression_list(tmp)
                            for _tmp in tmp:
                                __tmp = deep_get(_tmp, DictPath(subpath), _tmp)
                                value.append(make_set_expression_list(__tmp))
                        if len(value) == 1:
                            _values.append((value[0], "raw"))
                        else:
                            for tmp in value:
                                _values.append((tmp, "raw"))
                    elif isinstance(tmp, dict):
                        value = make_set_expression_list(tmp)
                        _values.append((value, "raw"))
                    else:
                        _values.append((default, "raw"))
                elif ptype == "lookup":
                    lookup_kind, lookup_api_group, lookup_namespace, \
                        lookup_name, tmp_lookup_selector = path
                    if isinstance(lookup_kind, list):
                        lookup_kind = deep_get_with_fallback(obj, lookup_kind, "")
                    if isinstance(lookup_api_group, list):
                        lookup_api_group = deep_get_with_fallback(obj, lookup_api_group, "")
                    if isinstance(lookup_namespace, list):
                        lookup_namespace = deep_get_with_fallback(obj, lookup_namespace, "")
                    if isinstance(lookup_name, list):
                        lookup_name = deep_get_with_fallback(obj, lookup_name, "")
                    if not tmp_lookup_selector:
                        lookup_selector = ""
                    else:
                        _lookup_selector = {}
                        for ls in tmp_lookup_selector:
                            ls_key = ls[0]
                            ls_value = ls[1]
                            if isinstance(ls_value, list):
                                ls_value = deep_get_with_fallback(obj, ls_value)
                            _lookup_selector[ls_key] = ls_value
                        lookup_selector = make_label_selector(_lookup_selector)

                    try:
                        if not lookup_name:
                            lookup_obj, _status = \
                                kh.get_list_by_kind_namespace((lookup_kind, lookup_api_group),
                                                              lookup_namespace,
                                                              label_selector=lookup_selector,
                                                              resource_cache=kh_cache)
                        else:
                            lookup_obj = \
                                kh.get_ref_by_kind_name_namespace((lookup_kind, lookup_api_group),
                                                                  lookup_name, lookup_namespace,
                                                                  resource_cache=kh_cache)
                    except NameError:
                        unknown = deep_get(_path, DictPath("unknown"), "Unknown Kind")
                        _values.append((unknown, "raw"))
                        continue
                    if lookup_obj is None \
                            or isinstance(lookup_obj, dict) and not when_filter(_path,
                                                                                item=lookup_obj):
                        _values.append((default, "raw"))
                        continue
                    subpaths = deep_get(_path, DictPath("subpaths"), [])
                    value = []
                    if subpaths:
                        tmp = []
                        if isinstance(lookup_obj, dict):
                            lookup_obj = [lookup_obj]

                        for _lookup_obj in lookup_obj:
                            for i, subpath in enumerate(subpaths):
                                tmp.append(deep_get(_lookup_obj, DictPath(subpath)))
                        if len(tmp) == 1:
                            value.append(tmp[0])
                        else:
                            value.append(tuple(tmp))

                    if not value:
                        value = default

                    substitute = deep_get(_path, DictPath("substitute"))
                    if substitute is not None:
                        value = substitute
                    _values.append((value, "raw"))
                elif ptype == "remap":
                    value = []
                    substitutions = deep_get(_path, DictPath("substitutions"), "")
                    tmp = deep_get_with_fallback(obj, path)
                    if tmp is None:
                        tmp = []

                    if type(tmp) in (bool, int, str):
                        tmp = [tmp]

                    if isinstance(tmp, list):
                        for _tmp in tmp:
                            if isinstance(_tmp, bool):
                                _tmp = f"__{str(_tmp)}"

                            if _tmp in substitutions:
                                value.append(substitutions.get(_tmp))
                            elif "__default" in substitutions:
                                value.append(substitutions.get("__default"))
                            else:
                                value.append(_tmp)
                    else:
                        raise ValueError(f"remap is not supported yet for type {type(tmp)}")
                    if not value:
                        if default is None:
                            continue
                        value.append(default)
                    for tmp in value:
                        _values.append((tmp, vtype))
                elif ptype == "substitution":
                    value = []
                    substitute = deep_get(_path, DictPath("substitute"), "")
                    tmp = deep_get_with_fallback(obj, path)
                    if tmp is None:
                        tmp = []
                    if isinstance(tmp, dict):
                        tmp = [tmp]
                    for _tmp in tmp:
                        if not when_filter(_path, item=_tmp):
                            continue
                        value.append(substitute)
                        break
                    else:
                        if "else" in _path:
                            tmp = deep_get(_path, DictPath("else"))
                            if isinstance(tmp, list):
                                tmp = deep_get_with_fallback(obj, tmp)
                            if tmp:
                                value.append(tmp)
                    if not value:
                        if default is None:
                            continue
                        value.append(default)
                    for tmp in value:
                        _values.append((tmp, vtype))
                elif ptype == "transform":
                    transform = deep_get(_path, DictPath("transform"), {})
                    tmp = deep_get_with_fallback(obj, path)
                    tmp_type = type(tmp)
                    if not isinstance(tmp, (dict, list)):
                        tmp = [tmp]
                    tmp = transform_list(tmp, transform)
                    if tmp_type not in (dict, list) and len(tmp) == 1:
                        tmp = tmp[0]
                    _values.append((tmp, vtype))
                elif ptype == "timediff":
                    if len(mpaths) != 2:
                        raise ValueError(f"Field {name}: when using pathtype: 'timediff' "
                                         "path must be [start_time_path(s), end_time_path(s)]")
                    start_time = deep_get_with_fallback(obj, mpaths[0], default=None)
                    end_time = deep_get_with_fallback(obj, mpaths[1], default=None)
                    if end_time is None or start_time is None:
                        duration = -1
                    else:
                        datetime_start = timestamp_to_datetime(start_time)
                        if isinstance(end_time, int):
                            datetime_end = start_time + timedelta(seconds=end_time)
                        else:
                            datetime_end = timestamp_to_datetime(end_time)
                        timediff = datetime_end - datetime_start
                        duration = int(timediff.total_seconds())
                        _values.append((duration, "raw"))
                elif ptype == "comparison":
                    # Input is two paths; output is the value of the first path
                    # and -2/-1/0/1 (for type mismatch, lt, eq, gt)
                    if isinstance(default, list) and len(default) == 2:
                        _default1 = default[0]
                        _default2 = default[1]
                    else:
                        _default1 = default
                        _default2 = default
                    val1 = deep_get(obj, DictPath(path[0]), _default1)
                    val2 = deep_get(obj, DictPath(path[1]), _default2)
                    # pylint: disable-next=unidiomatic-typecheck
                    if type(val1) != type(val2):  # noqa: E721
                        res = -2
                    elif val1 == val2:
                        res = 0
                    elif val1 < val2:
                        res = -1
                    else:
                        res = 1
                    _values.append(((val1, res), "raw"))
                elif ptype == "timestamp_with_age":
                    # The first array is assumed to be the start time, the second array the end time
                    start_time = None
                    end_time = None
                    start_time_index = -1
                    end_time_index = -1
                    for i, mpath in enumerate(mpaths):
                        if isinstance(mpath, list):
                            if start_time_index == -1:
                                start_time_index = i
                                start_time = deep_get_with_fallback(obj, mpath, default=None)
                            elif end_time_index == -1:
                                end_time_index = i
                                end_time = deep_get_with_fallback(obj, mpath, default=None)
                            else:
                                raise ValueError(f"{field_name} received too many timestamp paths; "
                                                 "the view file is most likely malformed")
                    if end_time is None or start_time is None:
                        end_time = None
                        duration = -1
                    else:
                        timediff = \
                            timestamp_to_datetime(end_time) - timestamp_to_datetime(start_time)
                        if (duration := timediff.days * 24 * 60 * 60 + timediff.seconds) == 0:
                            duration = 1
                        # If the task completes so quickly that start_time == end_time
                        # duration will end up as 0. The result of this would be that
                        # it's represented as <unset>.
                        # To work around this we set duration to 1 if duration == 0.
                    __values = []
                    for i, mpath in enumerate(mpaths):
                        if i == start_time_index:
                            __values.append(end_time)
                        elif i == end_time_index:
                            __values.append(duration)
                        else:
                            __values.append(mpath)
                    _values.append((tuple(__values), "raw"))
                elif ptype == "fieldgetter":
                    fieldgetter_data = deep_get_with_fallback(obj, path, {})
                    if not fieldgetter_data:
                        continue
                    fieldgetter_tmp = deep_get(fieldgetter_data, DictPath("fieldgetter"))
                    fieldgetter = deep_get(fieldgetter_allowlist, DictPath(fieldgetter_tmp))
                    if fieldgetter is None:
                        raise ValueError(f"{fieldgetter_tmp} is not a valid fieldgetter; "
                                         "the view-file is probably incorrect.")
                    fieldgetter_args = deep_get(fieldgetter_data, DictPath("fieldgetter_args"), {})
                    tmp = fieldgetter(**fieldgetter_args, kubernetes_helper=kh)
                    _values.append((tmp, vtype))
                elif ptype in ("items", "appenditems"):
                    if subpath:
                        if subpaths:
                            raise ValueError(f"Field {name}: when using action: 'items' exactly "
                                             "one of subpath and subpaths must be specified")
                        subpaths = [subpath]
                    value = []
                    items = []
                    index = deep_get(_path, DictPath("index"))
                    for mpath in mpaths:
                        if isinstance(mpath, str):
                            mpath = [mpath]
                        tmp = deep_get_list(obj, mpath, default=[],
                                            fallback_on_empty=fallback_on_empty)
                        if index is not None:
                            try:
                                tmp = [tmp[index]]
                            except IndexError:
                                pass
                        # XXX: This is to avoid breaking anything
                        # Ideally the "appenditems" behaviour should be the only one,
                        # but requires rewriting a lot of files
                        if ptype == "items":
                            items += tmp
                        else:
                            items.append(tmp)
                    for item in items:
                        if not when_filter(_path, item):
                            continue

                        tmp = []
                        for i, subpath in enumerate(subpaths):
                            if isinstance(default, list):
                                if i < len(default):
                                    _default = default[i]
                                else:
                                    _default = None
                            else:
                                _default = default

                            if (vtype in ("int", "float") or action in ["sum"]) \
                                    and type(default) not in (int, float):
                                _default = 0

                            if isinstance(subpath, dict):
                                _subpath = deep_get(subpath, DictPath("str"))
                                if _subpath is not None:
                                    tmp.append(_subpath)
                                else:
                                    _subpath = deep_get(subpath, DictPath("subpath"))
                                    if isinstance(_subpath, str):
                                        _subpath = [_subpath]
                                    _regexes = deep_get(subpath, DictPath("regex"), [])
                                    if isinstance(_regexes, str):
                                        _regexes = [_regexes]
                                    _raw = deep_get_with_fallback(item, _subpath, _default)
                                    _raw = transform_filter(deep_get(subpath,
                                                            DictPath("transform"), {}), _raw)
                                    for _regex in _regexes:
                                        _tmp = re.match(_regex, _raw)
                                        if _tmp is not None:
                                            for group in _tmp.groups():
                                                if group is not None:
                                                    tmp.append(group)
                                            break
                                        tmp.append("")
                            else:
                                prefix = deep_get(_path, DictPath("prefix"), [])
                                suffix = deep_get(_path, DictPath("suffix"), [])
                                _subpath = subpath
                                if isinstance(_subpath, str):
                                    _subpath = [_subpath]
                                _tmp = deep_get_with_fallback(item, _subpath, _default)
                                if isinstance(prefix, str):
                                    if isinstance(_tmp, str):
                                        _tmp = prefix + _tmp
                                    else:
                                        _tmp = [prefix] + _tmp
                                else:
                                    tmp += prefix

                                if isinstance(suffix, str):
                                    if isinstance(_tmp, str):
                                        _tmp += suffix
                                    else:
                                        _tmp += [suffix]

                                tmp.append(_tmp)

                                if isinstance(suffix, list):
                                    tmp += suffix
                        if len(tmp) == 1:
                            value.append(tmp[0])
                        else:
                            value.append(tuple(tmp))
                    if not value:
                        value = default
                    if value is not None:
                        if action in ("sum", "latest", "earliest"):
                            _values.append((value, vtype))
                        else:
                            for tmp in value:
                                _values.append((tmp, vtype))
                elif ptype == "count":
                    count = 0
                    for p in path:
                        count += len(deep_get(obj, DictPath(p), {}))
                    _values.append((count, vtype))
                elif ptype == "split":
                    value = []
                    separator = deep_get(_path, DictPath("separator"), ",")
                    _raw = deep_get_with_fallback(obj, path, "")
                    if _raw is not None:
                        for tmp in _raw.split(separator):
                            _values.append((tmp, vtype))
                elif ptype == "regex":
                    value = []
                    _raw = deep_get_with_fallback(obj, path, "")
                    _regexes = deep_get(_path, DictPath("regex"), [])
                    if isinstance(_regexes, str):
                        _regexes = [_regexes]
                    if _raw is not None and _raw:
                        for _regex in _regexes:
                            _tmp = re.match(_regex, _raw)
                            if _tmp is not None:
                                for group in _tmp.groups():
                                    if group is not None:
                                        value.append(group)
                                break
                    elif default:
                        value = default
                    value = tuple(value)
                    _values.append((value, "raw"))
                elif ptype == "tuple":
                    value = []
                    if not when_filter(_path, item=obj):
                        continue
                    for i, element in enumerate(path):
                        if isinstance(default, list):
                            if i < len(default):
                                _default = default[i]
                            else:
                                _default = None
                        else:
                            _default = default

                        if vtype in ("int", "float") and type(default) not in (int, float):
                            _default = 0

                        # This is a literal string, not a path
                        if isinstance(element, str):
                            tmp = element
                        else:
                            tmp = deep_get_with_fallback(obj, element, default=_default,
                                                         fallback_on_empty=fallback_on_empty)

                        if vtype == "api_group":
                            override_paths = [DictPath(f"Views#{view}#kind_format_{field_index}"),
                                              DictPath(f"Views#{view}#kind_format"),
                                              DictPath(f"Global#kind_format_{field_index}"),
                                              DictPath("Global#kind_format")]
                            override_kind = \
                                deep_get_with_fallback(cmtlib.cmtconfig, override_paths, "mixed")
                            if override_kind == "skip" \
                                    or override_kind == "mixed" and "." not in tmp:
                                tmp = ""
                            vtype = "kind"
                        value.append(tmp)
                    if isinstance(deep_get(_path, DictPath("substitute")), list):
                        value = deep_get(_path, DictPath("substitute"))
                    value = tuple(value)
                    _values.append((value, vtype))
                elif ptype == "status_tuple":
                    if "lookup" in _path:
                        lookup_kind = deep_get(_path, DictPath("lookup#kind"))
                        lookup_api_family = deep_get(_path, DictPath("lookup#api_family"))
                        lookup_status = deep_get(_path, DictPath("lookup#status"))
                    else:
                        raise ValueError(f"Field {name}: currently status_tuple "
                                         "only supports 'lookup'")
                    path = deep_get(_path, DictPath("path"))
                    value = deep_get(obj, DictPath(path))
                    tmp = kh.get_ref_by_kind_name_namespace((lookup_kind, lookup_api_family),
                                                            value, "", resource_cache=kh_cache)
                    if lookup_status == "highlight":
                        if tmp is None:
                            status_group = StatusGroup.NOT_OK
                        else:
                            status_group = StatusGroup.OK
                        value = (value, status_group)
                    elif lookup_status == "message":
                        if tmp is None:
                            value = (deep_get(_path, DictPath("lookup#messages#not_ok")),
                                     StatusGroup.NEUTRAL)
                        else:
                            value = (deep_get(_path, DictPath("lookup#messages#ok")),
                                     StatusGroup.NEUTRAL)
                    _values.append((value, "raw"))
                elif ptype == "dictkeys":
                    for mpath in mpaths:
                        tmp = list(deep_get_with_fallback(obj, mpath, {}).keys())
                        if tmp:
                            _values.append((tmp, "raw"))
                elif ptype == "dictfields":
                    subpaths = deep_get_with_fallback(_path, [DictPath("subpaths"),
                                                              DictPath("subpath")], [])
                    if isinstance(subpaths, str):
                        subpaths = [[subpaths]]
                    for mpath in mpaths:
                        tmp = deep_get_with_fallback(obj, mpath)
                        if not when_filter(_path, item=tmp):
                            continue
                        value = []
                        for key in subpaths:
                            if isinstance(key, str):
                                value.append(key)
                            else:
                                value.append(deep_get_with_fallback(tmp, key, default))
                        if len(value) == 1:
                            _values.append((value[0], "raw"))
                        else:
                            _values.append((tuple(value), "raw"))
                else:
                    value = deep_get_with_fallback(obj, path, default,
                                                   fallback_on_empty=fallback_on_empty)
                    _values.append((value, vtype))
            values = []

            processor_args = {
                "action": action,
                "field_index": field_index,
                "field_name": name,
                "formatter": formatter,
                "regex_": deep_get(_path, DictPath("regex")),
                "replace_quotes": replace_quotes,
                "view": view,
            }
            if unique_values:
                unique = []
                _values = [unique.append(x) for x in _values if x not in unique]
                _values = unique
            for value, vtype_ in _values:
                if isinstance(vtype_, list):
                    if value is None or not value:
                        value = []
                if isinstance(value, list) and vtype_ == "raw":
                    values += value
                    continue
                if isinstance(value, list) and isinstance(vtype_, list):
                    tmp = []
                    for value_ in value:
                        tmp.append(process_value(value_, vtype_, **processor_args))
                else:
                    tmp = process_value(value, vtype_, **processor_args)
                values.append(tmp)

            if not values:
                values = global_default

            if isinstance(values, list) and len(values) == 1 and formatter != "list":
                d[name] = values[0]
            else:
                d[name] = values

    # We've got all the information we can get now; time to apply filters
    skip = False
    for f in filters:
        if not deep_get(filters[f], DictPath("enabled"), True):
            continue

        # If len(allow) > 0, we only allow fields that match
        allow = deep_get(filters[f], DictPath("allow"), [])
        # If len(block) > 0, we skip fields that match
        block = deep_get(filters[f], DictPath("block"), [])
        source = deep_get(filters[f], DictPath("source"), "")
        if source == "object":
            src = obj
        else:
            src = d
        if allow:
            # If all field + value pairs match we allow
            for rule in allow:
                key = deep_get(rule, DictPath("key"), "")
                values = deep_get(rule, DictPath("values"), "")

                if deep_get(src, DictPath(key), "").rstrip() not in values:
                    skip = True
                    break
        if block:
            # If all field + value pairs match we block
            for rule in block:
                key = deep_get(rule, DictPath("key"), "")
                values = deep_get(rule, DictPath("values"), "")
                if deep_get(src, DictPath(key), "").rstrip() in values:
                    skip = True
                    break
        if skip:
            break
    if skip:
        entry = None
    else:
        d["ref"] = obj
        d["__deleted"] = deleted
        d["__uid"] = deep_get(obj, DictPath("metadata#uid"))
        entry = type("InfoClass", (), d)

    return entry


def generic_infogetter(**kwargs: Any) -> list[dict]:
    """
    Generic getter for information from an object.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                _vlist ([dict]): A list of already populated entries
                field_dict (dict): The dict containing the description of the field
                field_names ([str]): The names of the fields to populate
                field_index (str): The index for the field list
                filters (dict): The filters to apply
                extra_data (dict): Extra data to add to the obj
                caller_obj (dict): Used for lookups when doing path substitutions
        Returns:
            ([InfoClass]): A list of InfoClass objects
                           with the data for all fields in the field_names list
    """
    info = []

    # Generate an empty entry
    if not (vlist := deep_get(kwargs, DictPath("_vlist"), [])):
        return []

    field_dict = deep_get(kwargs, DictPath("_field_dict"), {})
    field_names = deep_get(kwargs, DictPath("_field_names"), [])
    field_index = deep_get(kwargs, DictPath("_field_index"), "Normal")
    filters = deep_get(kwargs, DictPath("_filters"), {})
    extra_data = deep_get(kwargs, DictPath("extra_data"), {})
    caller_obj = deep_get(kwargs, DictPath("caller_obj"), {})

    if not field_dict or not field_names:
        sys.exit(f"generic_infogetter() received empty field_dict {field_dict} "
                 f"or field_names {field_names}; this is a programming error")

    # If we know the view we can use it to get overrides from cmt.yaml
    view = deep_get(kwargs, DictPath("_view"), "")
    for obj in vlist:
        if extra_data:
            obj["_extra_data"] = extra_data
        deleted = False
        if deep_get(obj, DictPath("metadata#deletionTimestamp")) is not None:
            deleted = True
        tmp = get_obj(obj, field_dict=field_dict, field_names=field_names, field_index=field_index,
                      view=view, filters=filters, deleted=deleted, caller_obj=caller_obj)
        if tmp is None:
            continue

        info.append(tmp)

    return info


# pylint: disable-next=too-many-locals,too-many-branches
def get_journalctl_log(obj: dict, **kwargs: Any) -> \
        tuple[list[datetime], list[str], list[LogLevel], list[list[ThemeRef | ThemeStr] | str]]:
    """
    Extract log entries from journalctl.

        Parameters:
            obj (dict): The object to extract log entries from
            **kwargs (dict[str, Any]): Keyword arguments
                _show_raw (bool): Return unformatted entries?
        Returns:
            (([datetime], [str], [LogLevel], [ThemeRef | ThemeStr])):
                ([datetime]): A list of timestamps
                ([str]): A list of facilities
                ([LogLevel]): A list of severities
                ([[ThemeRef | ThemeStr] | str]): A list of messages
    """
    timestamps: list[datetime] = []
    facilities: list[str] = []
    severities: list[LogLevel] = []
    messages: list[list[ThemeRef | ThemeStr] | str] = []

    show_raw: bool = deep_get(kwargs, DictPath("_show_raw"), False)
    objlist = deep_get(obj, DictPath("obj"))
    parser = deep_get(objlist[0], DictPath("parser"))

    for line in objlist[1:]:
        try:
            d = json.loads(line)
        except DecodeException:
            d = {}

        timestamp = \
            datetime.fromtimestamp(int(deep_get(d, DictPath("__REALTIME_TIMESTAMP")), 0) / 1000000)
        severity = None
        facility = ""
        remnants = None
        msg = ""

        raw_severity = int(deep_get(d, DictPath("PRIORITY"), "6"))
        raw_msg = deep_get(d, DictPath("MESSAGE"), "")

        if show_raw:
            msg = raw_msg
        elif parser == "glog":
            msg, severity, facility, remnants, matched = \
                logparsers.split_glog(raw_msg, severity=raw_severity)

            if not matched:
                severity = raw_severity
                remnants = None
                msg = raw_msg
        elif "=" in raw_msg and parser == "key_value":
            facility, severity, msg, remnants = \
                logparsers.key_value(raw_msg, severity=raw_severity, fold_msg=False)
        else:
            severity = raw_severity
            msg = raw_msg

        timestamps.append(timestamp.astimezone())
        facilities.append(facility)
        if severity is None:
            severity = raw_severity
        severities.append(severity)
        messages.append(msg)

        if remnants is not None:
            if isinstance(remnants, tuple):
                fmt_remnants, remnant_severity = remnants

                for remnant in fmt_remnants:
                    timestamps.append(none_timestamp())
                    facilities.append("")
                    severities.append(remnant_severity)
                    messages.append(remnant)
            else:
                for remnant, remnant_severity in remnants:
                    timestamps.append(none_timestamp())
                    facilities.append("")
                    severities.append(remnant_severity)
                    messages.append(remnant)

    return timestamps, facilities, severities, messages


# pylint: disable-next=unused-argument,too-many-locals
def get_traceflow(obj: dict, **kwargs: Any) -> \
        tuple[list[datetime], list[str], list[LogLevel], list[list[ThemeRef | ThemeStr] | str]]:
    """
    Extract log entries from a traceflow.

        Parameters:
            obj (dict): The object to extract log entries from
            **kwargs (dict[str, Any]): Keyword arguments
        Returns:
            (([datetime], [str], [str], [str])):
                ([str]): A list of timestamps
                ([str]): A list of facilities
                ([str]): A list of severities
                ([ThemeArray] | str): A list of ThemeArrays
    """
    timestamps: list[datetime] = []
    facilities: list[str] = []
    severities: list[LogLevel] = []
    messages: list[list[ThemeRef | ThemeStr] | str] = []

    for result in deep_get(obj, DictPath("status#results"), []):
        node = deep_get(result, DictPath("node"), "<unset>")
        nodestr_len = len(node) + themearray_len([ThemeRef("separators", "facility_prefix"),
                                                  ThemeRef("separators", "facility_suffix"),
                                                  ThemeRef("separators", "facility_padding")])
        tmp_timestamp = deep_get(result, DictPath("timestamp"), -1)
        if tmp_timestamp >= 0:
            saved_timestamp = datetime.fromtimestamp(tmp_timestamp)
        else:
            saved_timestamp = none_timestamp()
        message: list[ThemeRef | ThemeStr] = []
        for observation in deep_get(result, DictPath("observations"), []):
            facility = node
            timestamp = saved_timestamp
            for key, value in sorted(observation.items()):
                facilities.append(facility)
                timestamps.append(timestamp.astimezone())
                message = []
                if not facility and node:
                    message.append(ThemeStr("".ljust(nodestr_len), ThemeAttr("main", "default")))
                message += [
                    ThemeStr(key, ThemeAttr("types", "yaml_key")),
                    ThemeRef("separators", "yaml_key_separator"),
                    ThemeRef("separators", "space"),
                    ThemeStr(value, ThemeAttr("types", "yaml_value")),
                ]
                messages.append(message)
                facility = ""
                timestamp = none_timestamp()

    return timestamps, facilities, severities, messages


# pylint: disable-next=unused-argument
def get_task_log(obj: dict, **kwargs: Any) -> list[list[ThemeRef | ThemeStr]]:
    field: list = []

    skipped = deep_get(obj, DictPath("log#skipped"), False)
    stdout_lines = deep_get(obj, DictPath("log#stdout_lines"), [])
    stderr_lines = deep_get(obj, DictPath("log#stderr_lines"), [])
    msg_lines = deep_get(obj, DictPath("log#msg_lines"), [])

    if skipped:
        field.append([ThemeStr("[skipped]", ThemeAttr("types", "unset"))])
        return field

    if stderr_lines:
        field.append([ThemeStr("stderr:", ThemeAttr("main", "paragraphheader"))])
        for line in stderr_lines:
            field.append([ThemeStr(f"{line}", color_status_group(StatusGroup.NOT_OK))])

    if stdout_lines:
        if field:
            field.append([ThemeStr("", ThemeAttr("main", "default"))])
        field.append([ThemeStr("stdout:", ThemeAttr("main", "paragraphheader"))])
        for line in stdout_lines:
            field.append([ThemeStr(f"{line}", ThemeAttr("main", "default"))])

    if msg_lines:
        if field:
            field.append([ThemeStr("", ThemeAttr("main", "default"))])
            field.append([ThemeStr("", ThemeAttr("main", "default"))])
        field.append([ThemeStr("msg:", ThemeAttr("main", "paragraphheader"))])
        for line in msg_lines:
            field.append([ThemeStr(f"{line}", color_status_group(StatusGroup.OK))])

    return field


def logpad_files(obj: dict, **kwargs: Any) -> list[list[ThemeRef | ThemeStr]]:
    # This is essentially just a wrapper around listgetter_files
    show_raw: bool = deep_get(kwargs, DictPath("_show_raw"), False)
    extra_values_lookup = deep_get(kwargs, DictPath("extra_values_lookup"), {})
    if (formatter := deep_get(obj, DictPath("_extra_data#formatter"))) is None:
        formatter = deep_get(kwargs, DictPath("formatter"), "none")

    for key, path in extra_values_lookup.items():
        if "extra_values" not in kwargs:
            kwargs["extra_values"] = {}
        kwargs["extra_values"][key] = deep_get_with_fallback(obj, path, "")
    if "_pass_obj" in kwargs:
        kwargs["_obj"] = obj

    kwargs.pop("extra_values_lookup", "")

    vlist, status = listgetters.listgetter_files(**kwargs)

    if status != "OK":
        return []

    if (formatter_args := deep_get(obj, DictPath("_extra_data#formatter_args"))) is None:
        formatter_args = deep_get(kwargs, DictPath("formatter_args"), {})

    if not show_raw and formatter == "markdown":
        return formatters.format_markdown(vlist[0], **formatter_args)
    return formatters.format_none(vlist[0], **formatter_args)


def logpad_formatted(obj: dict, **kwargs: Any) -> list[list[ThemeRef | ThemeStr]]:
    """
    Takes an object and dumps it using the specified format (if possible).

        Parameters:
            obj (dict): The dict to dump
            **kwargs (Dict): Additional parameters
        Returns:
            [ThemeArray]: A list of themearrays
    """

    path = deep_get(kwargs, DictPath("path"), "")
    dump_formatter_tmp = deep_get(kwargs, DictPath("formatter"), "format_none")
    dump_formatter = deep_get(formatter_allowlist, DictPath(dump_formatter_tmp))
    if dump_formatter is None:
        raise ValueError(f"{dump_formatter_tmp} is not a valid formatter; "
                         "the view-file is probably incorrect.")

    return dump_formatter(deep_get(obj, path))


# pylint: disable-next=unused-argument,too-many-locals,too-many-branches,too-many-statements
def get_cmt_log(obj: dict, **kwargs: Any) -> \
        tuple[list[datetime], list[str], list[LogLevel], list[list[ThemeRef | ThemeStr] | str]]:
    """
    Extract log entries from CMT log.

        Parameters:
            obj (dict): The object to extract log entries from
            **kwargs (dict[str, Any]): Keyword arguments
        Returns:
            (([str], [str], [str], [str])):
                ([datetime]): A list of timestamps
                ([str]): A list of facilities
                ([LogLevel]): A list of severities
                ([ThemeArray]): A list of ThemeArrays
    """
    filepath = deep_get(obj, DictPath("filepath"), "")
    timestamps: list[datetime] = []
    facilities: list[str] = []
    severities: list[LogLevel] = []
    messages: list[list[ThemeRef | ThemeStr] | str] = []

    d = secure_read_yaml(filepath)

    if not d or not isinstance(d, list):
        return timestamps, facilities, severities, messages

    for message in d:
        timestamp = deep_get(message, DictPath("timestamp"), "")
        severity = deep_get(message, DictPath("severity"), "")
        facility = deep_get(message, DictPath("facility"), "")
        file = deep_get(message, DictPath("file"), "")
        function = deep_get(message, DictPath("function"), "")
        lineno = deep_get(message, DictPath("lineno"), "")

        facilitystr = f"{file}:{lineno} [{function}()]"

        themestrings = True
        msgs = deep_get(message, DictPath("themearray"), [])
        if not msgs:
            themestrings = False
            msgs = deep_get(message, DictPath("strarray"), [])

        first = True

        for msg in msgs:
            if first:
                timestamps.append(timestamp.astimezone())
                if facility:
                    facilities.append((facilitystr, facility))
                else:
                    facilities.append(facilitystr)
                first = False
            else:
                timestamps.append(none_timestamp())
                if facility:
                    facilities.append(("".ljust(len(facilitystr)), "".ljust(len(facility))))
                else:
                    facilities.append("".ljust(len(facilitystr)))
            severities.append(severity)

            reformatted_msg = []
            for substring in msg:
                if themestrings:
                    # These log messages are in ANSIThemeStr format;
                    # hence we need to convert them to ThemeStrs.
                    # Luckily ANSIThemeStr has fewer formats
                    # than ThemeStr. We should probably have
                    # a cross-reference table in themes though.
                    string = deep_get(substring, DictPath("string"))
                    themeref = deep_get(substring, DictPath("themeref"))
                else:
                    string = substring
                    themeref = "default"
                if themeref == "default":
                    fmt = ThemeAttr("main", "default")
                elif themeref == "emphasis":
                    fmt = ThemeAttr("main", "highlight")
                elif themeref == "argument":
                    fmt = ThemeAttr("main", "infoheader")
                elif themeref == "error":
                    fmt = ThemeAttr("logview", "severity_error")
                # Insert more here when necessary
                else:
                    fmt = ThemeAttr("main", "default")
                reformatted_msg.append(ThemeStr(string, fmt))
            messages.append(reformatted_msg)

    return timestamps, facilities, severities, messages


def logpad_yaml(obj: dict, **kwargs: Any) -> list[list[ThemeRef | ThemeStr]]:
    """
    Takes an object and dumps it as formatted YAML.

        Parameters:
            obj (dict): The dict to dump formatted as YAML
            **kwargs (dict[str, Any]): Keyword arguments
        Returns:
            ([themearray]): A list of themearrays
    """
    path = deep_get(kwargs, DictPath("path"), "")
    messages: list = []

    try:
        if path:
            data = deep_get(obj, DictPath(path))
        else:
            data = obj
        if data is not None:
            tmp = yaml.dump(data, width=16384)
            messages = formatters.format_yaml(tmp, **kwargs)
    except yaml.YAMLError:
        pass

    return messages


def logpad_msg_getter(obj: dict, **kwargs: Any) -> list[list[ThemeRef | ThemeStr]]:
    messages: list[list[ThemeRef | ThemeStr]] = []

    path = deep_get(kwargs, DictPath("path"))
    tmp = deep_get(obj, DictPath(path), "")

    for line in split_msg(tmp):
        messages.append([ThemeStr(f"{line}", ThemeAttr("main", "default"))])

    return messages


def get_name_by_kind_from_owner_references(owner_references: list[dict], kind: str) -> str:
    for owr in owner_references:
        if deep_get(owr, DictPath("kind"), "") == kind:
            name = deep_get(owr, DictPath("name"))
            break
    return name


def get_holder_kind_from_owner_references(owner_references: list[dict], holder_name: str) -> str:
    holder_kind: str = ""

    for owr in owner_references:
        if deep_get(owr, DictPath("name")) == holder_name:
            holder_kind = deep_get(owr, DictPath("kind"), "")
            break

    return holder_kind


def get_pod_log_by_name_namespace_container(name: str, namespace: str, container: str,
                                            tail_lines: int = DEFAULT_TAIL_LINES) \
        -> tuple[str, bool]:
    internal_error: bool = False

    rawmsg, status = \
        kh.read_namespaced_pod_log(name, namespace, container=container, tail_lines=tail_lines)
    if status == 200:
        # Everything is successful
        internal_error = False
    elif status == 400:
        # Not successful; error in rawmsg
        rawmsg = f"{datetime.now(timezone.utc):%Y-%m-%d %H:%M:%S} CRITICAL: {rawmsg}"
        internal_error = True
    elif status == 500:
        # Not successful; error in rawmsg
        internal_error = True
    else:
        rawmsg = f"{datetime.now(timezone.utc):%Y-%m-%d %H:%M:%S} CRITICAL: Failed to fetch log " \
                 f"for pod (name: {name}, namespace: {namespace}, container: {container}); " \
                 f"Request Status: {status}"
        internal_error = True

    if rawmsg.startswith("unable to retrieve container logs for"):
        rawmsg = f"{datetime.now(timezone.utc):%Y-%m-%d %H:%M:%S} CRITICAL: {rawmsg}"
        internal_error = True

    return rawmsg, internal_error


# To make the failure case easier, return both the ref and the name of the control plane
def get_control_plane() -> tuple[Optional[dict], str]:
    if not kubernetes_support:
        return None, ""

    vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "", resource_cache=kh_cache)
    control_planes = []

    if vlist is None or not vlist or status != 200:
        return None, ""

    # Find control planes; but for now only return the first match
    for obj in vlist:
        labels = deep_get(obj, DictPath("metadata#labels"), {})
        if "node-role.kubernetes.io/control-plane" in labels \
                or "node-role.kubernetes.io/master" in labels:
            control_planes.append((obj, deep_get(obj, DictPath("metadata#name"))))

    # If we have exactly one node, assume that it is the control plane even if it lacks that label
    if not control_planes and len(vlist) == 1:
        control_planes.append((vlist[0], deep_get(vlist[0], DictPath("metadata#name"))))

    if not control_planes:
        ansithemeprint([ANSIThemeStr("Error", "warning"),
                        ANSIThemeStr(": None of the nodes in the cluster are labelled as "
                                     "control planes. The cluster is most likely "
                                     "misconfigured.", "default")], stderr=True)
        return {}, ""
    if len(control_planes) > 1:
        ansithemeprint([ANSIThemeStr("Warning", "warning"),
                        ANSIThemeStr(": Multiple control planes not supported yet, "
                                     "found multiple; returning first entry:", "default")],
                       stderr=True)
        for control_plane in control_planes:
            ansithemeprint([ANSIThemeStr(f"  {control_plane[1]}", "default")], stderr=True)

    return control_planes[0][0], control_planes[0][1]


# pylint: disable-next=unused-argument
def set_cluster_context(stdscr: curses.window, **kwargs: Any) -> Retval:
    global force_refresh_apis  # pylint: disable=global-statement

    selected = deep_get(kwargs, DictPath("selected"))
    name = getattr(selected, "name")

    retval = kh.set_context(name=name)
    # If we actually changed context we need to force an API reload,
    # since we might have changed between different clusters (or switched
    # to a role that does not have access to a particular API)
    if retval:
        force_refresh_apis = True
    return Retval.RETURNDONE


# pylint: disable-next=too-many-locals
def generate_list_header(uip: UIProps, headerpad: curses.window,
                         field_dict: dict, is_taggable: bool = False) -> None:
    headerarray: list[ThemeRef | ThemeStr] = []
    first = True

    tabstops = []

    tabstop = 0

    # Is the list taggable?
    if is_taggable:
        tabstops.append(tabstop)
        headerarray.append(ThemeRef("separators", "tag"))
        tabstop = themearray_len(headerarray)

    for field in field_dict:
        generator = field_dict[field].get("generator")
        if generator is None:
            continue

        tabstops.append(tabstop)

        theme = get_theme_ref()
        if uip.get_sortcolumn() == field:
            if not uip.reversible:
                sort_direction_char = theme["boxdrawing"]["arrownone"]
            elif uip.sortorder_reverse:
                sort_direction_char = theme["boxdrawing"]["arrowup"]
            else:
                sort_direction_char = theme["boxdrawing"]["arrowdown"]
        else:
            sort_direction_char = theme["boxdrawing"]["arrownone"]

        # We always want this much padding between the headers,
        # except if this is the first header
        #
        # Note that we need to subtract the width of sort direction char
        # from the width of pad; this only works if len(pad) > 0
        if not first:
            separator_len = len(ThemeRef("separators", "pad"))
            direction_char_len = len(sort_direction_char)
            headerarray.append(ThemeStr("".ljust(separator_len - direction_char_len),
                                        ThemeAttr("types", "generic")))

        tabstop = themearray_len(headerarray)

        # This tells the length of the alignment of the header
        fieldlen = deep_get(field_dict, DictPath(f"{field}#fieldlen"))
        header = deep_get(field_dict, DictPath(f"{field}#header"))
        ralign = deep_get(field_dict, DictPath(f"{field}#ralign"), False)

        # We cannot use ljust/rjust on the string,
        # because we want the string and arrow in different colours,
        # so just prepend/append whitespace instead
        if ralign:
            headerarray.append(ThemeStr("".ljust(fieldlen - len(header)),
                                        ThemeAttr("types", "generic")))
        headerarray.append(ThemeStr(header, ThemeAttr("main", "listheader"),
                                    selected=uip.get_sortcolumn() == field))
        headerarray.append(ThemeStr(sort_direction_char,
                                    ThemeAttr("main", "listheader_arrows")))
        if not ralign:
            headerarray.append(ThemeStr("".ljust(fieldlen - len(header)),
                                        ThemeAttr("types", "generic")))
        first = False

    # We've got to account for the last entry
    if field_dict:
        tabstops.append(tabstop)

    # We've processed all fields, time to output the header
    uip.addthemearray(headerpad, headerarray, y=0, x=0)
    uip.tabstops = tabstops


# pylint: disable-next=too-many-arguments,too-many-locals,too-many-positional-arguments
def generate_list_row(uip: UIProps, listpad: curses.window,
                      data, field_list,
                      ypos: int, is_selected: bool, is_taggable: bool = False,
                      is_tagged: bool = False, is_deleted: bool = False) -> None:
    first: bool = True
    i: int = 0

    for field in field_list:
        i += 1

        if is_taggable:
            tagprefixlen = len(ThemeRef("separators", "tag"))

            if is_tagged:
                tagprefix: list[ThemeRef | ThemeStr] = [ThemeRef("separators", "tag")]
            else:
                tagprefix = [ThemeStr("".ljust(tagprefixlen), ThemeAttr("types", "generic"))]
        else:
            tagprefix = ""
            tagprefixlen = 0

        generator = field_list[field].get("generator")
        if generator is None:
            continue
        if isinstance(generator, str):
            generator = \
                deep_get(generator_allowlist, DictPath(generator), generators.generator_basic)

        fieldlen = field_list[field]["fieldlen"]
        if i < len(field_list):
            fpad = len(ThemeRef("separators", "pad"))
        else:
            fpad = 0

        ralign = field_list[field].get("ralign", False)

        formatting = {
            "item_separator":
                field_list[field].get("item_separator", ThemeRef("separators", "list")),
            "field_separators":
                field_list[field].get("field_separators", [ThemeRef("separators", "field")]),
            "field_colors": field_list[field].get("field_colors", [ThemeAttr("types", "field")]),
            "ellipsise": field_list[field].get("ellipsise", -1),
            "ellipsis": field_list[field].get("ellipsis", ThemeRef("separators", "ellipsis")),
            "field_prefixes": field_list[field].get("field_prefixes", []),
            "field_suffixes": field_list[field].get("field_suffixes", []),
            "mapping": field_list[field].get("mapping", {}),
        }

        tmp = generator(data, field, fieldlen, fpad, ralign, is_selected, **formatting)

        pos = field_list[field]["pos"]

        if first and is_taggable:
            uip.addthemearray(listpad, tagprefix, y=ypos, x=pos, deleted=is_deleted)
            first = False

        uip.addthemearray(listpad, tmp, y=ypos, x=pos + tagprefixlen, deleted=is_deleted)


# noqa: E501 pylint: disable-next=too-many-locals,too-many-branches,too-many-statements,too-many-return-statements
def genericlistloop(stdscr: curses.window, view: str) -> Retval:
    """
    Generic main loop for listviews.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            view (str): The view to show
        Returns:
            (Retval): The return value
        Raises:
            ProgrammingError (view is invalid)
    """
    global executor  # pylint: disable=global-statement
    global selected_namespace  # pylint: disable=global-statement
    global initial_name  # pylint: disable=global-statement
    global initial_namespace  # pylint: disable=global-statement

    if not (isinstance(stdscr, curses.window) and isinstance(view, str)):
        msg = [
            [("genericlistloop()", "emphasis"),
             (" called with invalid argument(s):", "error")],
            [("stdscr = ", "default"),
             (f"{stdscr}", "argument"),
             (" (type: ", "default"),
             (f"{type(stdscr)}", "argument"),
             (", expected: ", "default"),
             ("{curses.window}", "argument"),
             (")", "default")],
            [("view = ", "default"),
             (f"{yaml.dump(view)}", "argument"),
             (" (type: ", "default"),
             (f"{type(view)}", "argument"),
             (", expected: ", "default"),
             ("str", "argument"),
             (")", "default")],
        ]

        unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(msg)

        raise ProgrammingError(unformatted_msg,
                               severity=LogLevel.ERR,
                               formatted_msg=formatted_msg)

    denylist = deep_get(views, DictPath(f"{view}#field_denylist"), [])
    field_indexes = deep_get(views, DictPath(f"{view}#field_indexes"), {})

    if not (isinstance(field_indexes, dict) and field_indexes):
        msg = [
            [("genericlistloop()", "emphasis"),
             (" called with invalid argument(s):", "error")],
            [("field_indexes = ", "default")],
            [(f"{yaml.dump(field_indexes)}", "argument"),
             (" (type: ", "default"),
             (f"{type(field_indexes)}", "argument"),
             (", expected: ", "default"),
             (f"{dict}", "argument"),
             (") with at least one element", "default")],
        ]

        unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(msg)

        raise ProgrammingError(unformatted_msg,
                               severity=LogLevel.ERR,
                               formatted_msg=formatted_msg)

    # Just in case there are leftover futures from other views
    executor.shutdown()
    executor = reexecutor.ReExecutor()

    if "Custom" in field_indexes:
        field_index = "Custom"
    elif "Wide" in field_indexes:
        field_index = "Wide"
    else:
        field_index = list(field_indexes.keys())[0]

    fieldgenerator_args = {
        "field_index": field_index,
        "field_indexes": field_indexes,
        "fields": deep_get(views, DictPath(f"{view}#fields")),
        "denylist": denylist,
    }
    field_dict, field_names, sortcolumn, sortorder_reverse = \
        generators.fieldgenerator(view=view, selected_namespace=selected_namespace,
                                  **fieldgenerator_args)

    uip = UIProps(stdscr)

    kind = deep_get(views, DictPath(f"{view}#kind"))

    windowheader = view

    if kind is None or kind[0].startswith("__"):
        is_namespaced = False
    else:
        is_namespaced = kh.is_kind_namespaced(kind)

    helptext = generate_helptext(view, "listview", [], [])
    activatedfun = deep_get(views, DictPath(f"{view}#activatedfun"), genericinfoloop)
    on_activation = deep_get(views, DictPath(f"{view}#on_activation"), {})
    update_delay = deep_get(views, DictPath(f"{view}#update_delay"), -1)

    is_taggable = (deep_get(views, DictPath(f"{view}#is_taggable"), True)
                   and deep_get(views, DictPath(f"{view}#actions")) is not None)
    extra_vars = deep_get(views, DictPath(f"{view}#extra_vars"), {})

    uip.init_window(field_list=field_dict, view=kind, windowheader=windowheader,
                    update_delay=update_delay, sortcolumn=sortcolumn,
                    sortorder_reverse=sortorder_reverse, helptext=helptext,
                    activatedfun=activatedfun, on_activation=on_activation)

    # The statusbar is always located at the bottom of the screen and fills the entire width
    statusbar = uip.init_statusbar()

    # For the list
    headerpad, listpad = uip.init_listpad(listheight=1, width=-1, ypos=1, xpos=1)

    label_selector = ""

    # These values can be toggled, so we need to read them first
    listview_args = copy.deepcopy(deep_get(views, DictPath(f"{view}#listview_args"), {}))

    listgetter = deep_get(views, DictPath(f"{view}#listgetter"))
    listgetter_async = deep_get(views, DictPath(f"{view}#listgetter_async"))
    listgetter_args = deep_get(views, DictPath(f"{view}#listgetter_args"), {})
    listgetter_args["label_selector"] = label_selector

    infogetter = deep_get(views, DictPath(f"{view}#infogetter"), generic_infogetter)
    infogetter_extra_args = deep_get(views, DictPath(f"{view}#extra_vars#infogetter"),
                                     {"_view": view.strip("*")})
    infogetter_extra_args["_field_index"] = field_index.lower()
    infogetter_extra_args["_field_names"] = field_names
    infogetter_extra_args["_field_dict"] = field_dict
    if "filters" in listview_args:
        infogetter_extra_args["_filters"] = deep_get(listview_args, DictPath("filters"))

    uip.last_action = datetime.now()
    uip.idle_timeout = 5
    tagged_items = set()
    serverstatus = "ok"

    first_fetch = True
    new_data = "false"
    uip.force_update()
    uip.listlen = 0

    # pylint: disable-next=too-many-nested-blocks
    while True:
        if listgetter_async is not None:
            # Temporary workaround
            # pylint: disable-next=comparison-with-callable
            if listgetter_async == listgetters_async.get_inventory_list and "hosts" not in executor:
                hosts = list(deep_get(ansible_get_inventory_dict(), DictPath("all#hosts")).keys())
                # The inventory doesn't change all that often,
                # but reading it every 10 seconds should be OK
                executor.trigger("hosts", 10, read_file_async, path=ANSIBLE_INVENTORY,
                                 filetype="yaml", **listgetter_args)
                async_data["hosts"] = copy.deepcopy(hosts)
                infogetter_extra_args["_match_key"] = "name"
                new_data = "pending"
                first_fetch = False
            # pylint: disable-next=comparison-with-callable
            elif listgetter_async == listgetters_async.get_context_list \
                    and (first_fetch or uip.update_forced):
                vlist, hosts = listgetters_async.get_context_list(kubernetes_helper=kh)
                async_data["hosts"] = copy.deepcopy(hosts)
                infogetter_extra_args["_vlist"] = copy.deepcopy(vlist)
                infogetter_extra_args["_match_key"] = "server_address"
                new_data = "pending"
                first_fetch = False
            # pylint: disable-next=comparison-with-callable
            elif listgetter_async == listgetters_async.get_kubernetes_list \
                    and ".".join(kind) not in executor:
                if "kubernetes_helper" not in listgetter_args:
                    listgetter_args["kubernetes_helper"] = kh
                    listgetter_args["kh_cache"] = kh_cache
                if "kind" not in listgetter_args:
                    listgetter_args["kind"] = kind
                if "namespace" not in listgetter_args:
                    listgetter_args["namespace"] = selected_namespace
                executor.trigger(".".join(kind), 5, listgetters_async.get_kubernetes_list,
                                 **listgetter_args)
            if listgetter_async in (listgetters_async.get_inventory_list,
                                    listgetters_async.get_context_list) and "pings" not in executor:
                facts_ping_playbook_path = get_playbook_path(FilePath("facts_ping.yaml"))
                # But the hosts can change status more frequently than that
                executor.trigger("pings", 5, run_ansible_play_async,
                                 playbook=facts_ping_playbook_path, selection=hosts, verbose=False)
        elif listgetter is not None:
            if first_fetch or uip.update_forced:
                if listgetter is not None:
                    if "kubernetes_helper" not in listgetter_args:
                        listgetter_args["kubernetes_helper"] = kh
                        listgetter_args["kh_cache"] = kh_cache
                    if kind[0].startswith("__"):
                        vlist, status = listgetter(**listgetter_args)
                    else:
                        vlist, status = \
                            listgetter(deep_get(view, DictPath(f"{view}#kind")), selected_namespace,
                                       label_selector=label_selector, **listgetter_args)
                    infogetter_extra_args["_vlist"] = vlist
                new_data = "pending"
                uip.update_timestamp(update=new_data)
                first_fetch = False
        else:
            # We only have an infogetter
            new_data = "pending"
            uip.update_timestamp(update=new_data)
            first_fetch = False

        # The asynchronous UI follows these rules:
        # Idle:
        #   No user activity within the last idle_timeout seconds
        # Force refresh:
        #   User pressed [F5], changed sort column,
        #   or opened/closed a dialog ([F1], [F2], [F8], etc)
        # Additional blockers:
        #   Items are tagged, menus are open, etc.
        if executor:
            if (result := executor.get("hosts")) != ([], []):
                data, _host_statuses = result
                hosts = deep_get(data, DictPath("all#hosts"), {}).keys()
                hosts_set = set(hosts)
                async_data["hosts"] = list(hosts)
                if vlist := deep_get(infogetter_extra_args, DictPath("_vlist"), []):
                    vlist_hosts = [deep_get(item, DictPath("name")) for item in vlist]
                    vlist_hosts_set = set(vlist_hosts)
                else:
                    vlist_hosts = []
                    vlist_hosts_set = set()
                # Only add hosts that aren't part of vlist already
                inventory_dict = ansible_get_inventory_dict()
                for host in hosts_set - vlist_hosts_set:
                    vlist.append({
                        "name": host,
                        "ref": host,
                        "ips": [],
                        "ansible_groups": ansible_get_groups_by_host(inventory_dict, host),
                        "status": "UNKNOWN",
                        "__deleted": False,
                    })
                # Tag hosts in vlist that are no longer part of hosts as deleted
                for host in vlist_hosts_set - hosts_set:
                    for i, item in enumerate(vlist):
                        if deep_get(item, DictPath("name"), "") == host:
                            vlist[i]["status"] = "DELETED"
                            vlist[i]["__deleted"] = True
                infogetter_extra_args["_vlist"] = copy.deepcopy(vlist)
                if not uip.listlen:
                    uip.force_update()
                new_data = "pending"
                uip.update_timestamp(update=new_data)
                first_fetch = False
            elif (result := executor.get("pings")) != ([], []):
                ansible_results, _ansible_status = result
                vlist = deep_get(infogetter_extra_args, DictPath("_vlist"), [])
                for i, item in enumerate(vlist):
                    host = deep_get(item, DictPath(infogetter_extra_args["_match_key"]))
                    for result in deep_get(ansible_results, f"{host}", []):
                        if deep_get(result, DictPath("task")) == "Ping":
                            if not deep_get(vlist[i], DictPath("__deleted"), False):
                                status = deep_get(result, DictPath("status"))
                                vlist[i]["status"] = status
                                ips = []
                                if (ip := deep_get(result,
                                                   DictPath("ansible_facts#"
                                                            "ansible_default_ipv4#address"), "")):
                                    ips.append(ip)
                                if (ip := deep_get(result,
                                                   DictPath("ansible_facts#"
                                                            "ansible_default_ipv6#address"), "")):
                                    ips.append(ip)
                                vlist[i]["ips"] = copy.deepcopy(ips)
                _pings_args, pings_kwargs = executor.get_parameters("pings")
                if set(async_data["hosts"]) != set(deep_get(pings_kwargs,
                                                            DictPath("selection"), [])):
                    executor.update("pings", selection=copy.deepcopy(async_data["hosts"]))
                    executor.retrigger("pings")
                infogetter_extra_args["_vlist"] = copy.deepcopy(vlist)
                if not uip.listlen:
                    uip.force_update()
                new_data = "pending"
                uip.update_timestamp(update=new_data)
                first_fetch = False
            elif (result := executor.get(".".join(kind))) != ([], []):
                vlist, status = result
                infogetter_extra_args["_vlist"] = copy.deepcopy(vlist)

                if status == 42503:
                    serverstatus = "Server Unavailable"
                elif status == 42504:
                    serverstatus = "Connection Timeout"
                else:
                    serverstatus = str(status)
                if not uip.listlen:
                    uip.force_update()
                new_data = "pending"
                uip.update_timestamp(update=new_data)
                first_fetch = False

        if uip.is_idle() or uip.is_update_triggered():
            # We need to generate the list info even if the list is empty,
            # otherwise we'll crash elsewhere
            if not uip.listlen and first_fetch \
                    or new_data == "pending" and (uip.update_forced or not tagged_items):
                if "kubernetes_helper" not in infogetter_extra_args:
                    infogetter_extra_args["kubernetes_helper"] = kh
                if "kh_cache" not in infogetter_extra_args:
                    infogetter_extra_args["kh_cache"] = kh_cache
                vinfo = infogetter(**infogetter_extra_args)
                uip.update_info(vinfo)
                uip.force_update()
                new_data = "true"
                tagged_items = set()
                uip.update_forced = False
        if uip.is_update_triggered():
            linelen = update_field_widths(field_dict, field_names, uip.info)
            if is_taggable:
                linelen += len("✓ ")
            uip.resize_listpad(linelen)
            uip.list_needs_regeneration(True)
            uip.update_window(update=new_data)
            if new_data == "true":
                new_data = "false"

        if uip.refresh:
            # The data in some fields might become shorter, so we need to trigger a clear
            uip.statusbar.erase()

            statusarray1: list[ThemeRef | ThemeStr] = []

            if view != "Contexts" and selected_namespace:
                statusarray1 += \
                    [ThemeStr("Namespace: ", ThemeAttr("statusbar", "infoheader")),
                     ThemeStr(f"{selected_namespace if selected_namespace else '<All>'}",
                              ThemeAttr("statusbar", "highlight"))]

            if statusarray1:
                statusarray1 += [ThemeRef("separators", "statusbar")]

            statusarray1 += [
                ThemeStr("Fields: ", ThemeAttr("statusbar", "infoheader")),
                ThemeStr(field_index, ThemeAttr("statusbar", "highlight"))
            ]
            if label_selector:
                if statusarray1:
                    statusarray1 += [ThemeRef("separators", "statusbar")]
                statusarray1 += [
                    ThemeStr("Label selector: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{label_selector}", ThemeAttr("statusbar", "highlight"))
                ]
            statusarray2: list[ThemeRef | ThemeStr] = []
            if read_only_mode:
                statusarray2 += [ThemeStr("Read Only Mode", ThemeAttr("statusbar", "highlight"))]

            if statusarray2:
                statusarray2 += [ThemeRef("separators", "statusbar")]
            statusarray2 += [
                ThemeStr("API Status: ", ThemeAttr("statusbar", "infoheader")),
                # Here we should probably highlight when something is bad
                ThemeStr(f"{serverstatus}", ThemeAttr("statusbar", "default")),
            ]

            for status_data in deep_get(views, DictPath(f"{view}#statusmsg"), []):
                if len(status_data) == 2:
                    key, path = status_data
                    default_status = "<unset>"
                else:
                    key, path, default_status = status_data

                src_obj = listview_args

                # If path is a list the first item tells what source to use and the second
                # what path to fetch the value from
                if isinstance(path, list):
                    if path[0] == "config":
                        src_obj = cmtlib.cmtconfig
                    # elif path[0] == "obj":
                    #     value_path = obj
                    elif path[0] == "var":
                        src_obj = listview_args
                    value_path = DictPath(path[1])
                else:
                    src_obj = listview_args
                    value_path = DictPath(path)

                value = str(deep_get(src_obj, value_path, default_status))
                if statusarray2:
                    statusarray2 += [ThemeRef("separators", "statusbar")]
                statusarray2 += [
                    ThemeStr(key, ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(value, ThemeAttr("statusbar", "default")),
                ]

            uip.addthemearray(statusbar, statusarray1, y=0, x=0)
            uip.addthemearray(statusbar, statusarray2, y=1, x=0)

        uip.update_sorted_list()

        if uip.info:
            unique_match = uip.goto_first_match_by_name_namespace(initial_name, initial_namespace)
            initial_name = None
            initial_namespace = None
            if unique_match is not None:
                selected = uip.get_selected()
                if uip.activatedfun is not None:
                    if (retval := uip.activatedfun(uip.stdscr,
                                                   unique_match, kind)) == Retval.RETURNFULL:
                        return retval
                uip.force_update()
                uip.refresh_all()
                continue

        uip.refresh_selected()
        if not uip.is_list_regenerated():
            generate_list_header(uip, headerpad, field_dict, is_taggable=is_taggable)
            for y in range(uip.yoffset,
                           min(uip.yoffset + uip.mincurypos + uip.maxcurypos + 1, uip.listlen)):
                item = uip.sorted_list[y]
                is_tagged = item in tagged_items
                is_deleted = getattr(item, "__deleted", False)
                generate_list_row(uip, listpad, item, field_dict, y - uip.yoffset,
                                  uip.is_selected(item), is_taggable=is_taggable,
                                  is_tagged=is_tagged, is_deleted=is_deleted)
            uip.list_needs_regeneration(False)

        uip.refresh_window()
        uip.refresh_listpad()
        uip.refresh_statusbar()
        if first_fetch:
            __win = curses_helper.notice(uip.listpad, uip.maxy // 2, uip.maxx // 2,
                                         message="Checking for data")
        curses.doupdate()

        uip.stdscr.timeout(100)
        c = uip.stdscr.getch()

        retval = uip.generic_keycheck(c)

        if retval == Retval.MATCH:
            continue
        if retval == Retval.RETURNONE:
            try:
                # This is to get the necessary stack info
                raise UserWarning
            except UserWarning:
                # Calling function; if we're at the top level view we shouldn't return further,
                # but we should clear selections
                caller = sys.exc_info()[2].tb_frame.f_back.f_code.co_name
                if caller in ("setupui",):
                    if tagged_items:
                        tagged_items = set()
                        uip.list_needs_regeneration(True)
                else:
                    return Retval.RETURNDONE
        if retval == Retval.RETURNFULL:
            return retval

        if c == curses.KEY_F2:
            if (retval := selectwindow(uip)) == Retval.RETURNFULL:
                return retval
            uip.refresh_all()
        elif c == curses.KEY_F3:
            if (retval := selectwindow(uip, refresh_apis=True)) == Retval.RETURNFULL:
                return retval
            uip.refresh_all()
        elif c == ord("B"):
            uip.toggle_borders()
            uip.refresh_all()
            uip.force_update()
            uip.update_window(update=False)
        elif c == ord("W"):
            if not field_indexes:
                continue

            _list = list(field_indexes.keys())
            _index = _list.index(field_index)
            field_index = _list[(_index + 1) % len(field_indexes)]

            fieldgenerator_args = {
                "field_index": field_index,
                "field_indexes": field_indexes,
                "fields": deep_get(views, DictPath(f"{view}#fields")),
                "denylist": denylist,
            }
            field_dict, field_names, sortcolumn, sortorder_reverse = \
                generators.fieldgenerator(view=view,
                                          selected_namespace=selected_namespace,
                                          **fieldgenerator_args)
            infogetter_extra_args["_field_index"] = field_index.lower()
            infogetter_extra_args["_field_names"] = field_names
            infogetter_extra_args["_field_dict"] = field_dict
            vinfo = infogetter(**infogetter_extra_args)
            uip.update_info(vinfo)
            update_field_widths(field_dict, field_names, uip.info)
            uip.reinit_window(field_list=field_dict, sortcolumn=sortcolumn)
            uip.resize_listpad(width=-1)
            uip.refresh_all()
            uip.force_update()
            uip.update_window(update=False)
        # pylint: disable-next=too-many-nested-blocks
        elif c == curses.KEY_F7:
            action_title = "Perform cluster-wide actions"
            action_src_list = listviewactions

            # Populate the list of actions
            actions, actionlist = populate_actionlist(action_list=action_src_list)

            if not actions:
                continue

            tmpselection = \
                curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                           uip.maxy // 2, uip.maxx // 2, actions,
                                           title=action_title)
            selection = None
            if tmpselection is not None and tmpselection != "":
                selection = ""
                for i, element in enumerate(tmpselection):
                    if element:
                        selection += str(element[0])
            uip.refresh_all()
            curses.doupdate()

            if selection is not None and selection != "":
                actionfunc = None

                # Map the description back to key
                action = None
                for action in actionlist:
                    description = deep_get(actionlist, DictPath(f"{action}#description"))
                    tmpdescription = ""
                    if isinstance(description, str):
                        tmpdescription = description
                    else:
                        for i, element in enumerate(description):
                            tmpdescription += element[0]
                    tmpmetadata = deep_get(actionlist, DictPath(f"{action}#metadata"), [])
                    for metadata in tmpmetadata:
                        tmpdescription += metadata[0]
                    if tmpdescription == selection:
                        actionfunc = \
                            deep_get(actionlist, DictPath(f"{action}#actionfunc"), command_hosts)
                        if isinstance(actionfunc, str):
                            actionfunc = deep_get(actionfunc_allowlist, DictPath(actionfunc))
                        # These are only relevant for node and inventory view
                        # allowoncontrolplane = \
                        #     deep_get(actionlist,
                        #              DictPath(f"{action}#allow_on_control_plane"), True)
                        # singleoncontrolplane = \
                        #     deep_get(actionlist,
                        #              DictPath(f"{action}#single_on_control_plane"), False)
                        confirm = deep_get(actionlist, DictPath(f"{action}#confirm"), False)
                        query = deep_get(actionlist, DictPath(f"{action}#query"))
                        queryval = deep_get(actionlist, DictPath(f"{action}#queryval"))
                        queryfunc = deep_get(actionlist, DictPath(f"{action}#queryfunc"))
                        extravars = deep_get(actionlist, DictPath(f"{action}#extravars"), {})
                        break

                if actionfunc is None:
                    continue

                selection_vars = extravars

                # This should be modified; we might want to ask multiple queries.
                # At the very least asking for one input plus confirmation.
                # A multi input box might be useful too.
                if queryfunc is not None and queryval is not None and query is not None:
                    if queryfunc == "string":
                        # Not supported by inputbox widget
                        # querydefault = ""
                        query_title = f"{query}: "
                        if not (string := curses_helper.inputbox(uip.stdscr, title=query_title)):
                            continue
                        selection_vars[queryval] = string
                    elif queryfunc == "confirm":
                        querydefault = False
                        query_title = f"{query}?"
                        if not curses_helper.confirmationbox(uip.stdscr, title=query_title,
                                                             default=querydefault):
                            continue
                    elif queryfunc == "filechooser":
                        # It is a programming error if either of these two are not set,
                        # so it is OK to get an exception
                        listgetter = extravars["listgetter"]
                        basedir = extravars["basedir"]
                        selected_file = None
                        selected_ptype = None

                        while basedir is not None:
                            tmp_file_list = listgetter(basedir)
                            file_list = []
                            for item in tmp_file_list:
                                realpath, filename, ptype = item
                                if ptype in ("File", "Configuration File", "Kustomization"):
                                    fmt = ThemeAttr("windowwidget", "default")
                                elif ptype == "<dir>":
                                    fmt = ThemeAttr("windowwidget", "highlight")
                                else:
                                    raise ValueError(f"Unknown ptype {ptype}")
                                file_list.append({
                                    "lineattrs": WidgetLineAttrs.NORMAL,
                                    "columns": [[ThemeStr(f"{filename}", fmt)],
                                                [ThemeStr(f"{ptype}",
                                                          ThemeAttr("windowwidget",
                                                                    "description"))]],
                                    "retval": filename,
                                })
                            tmpselection = \
                                curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                           uip.maxy // 2, uip.maxx // 2, file_list,
                                                           title=query, cursor=True)
                            if tmpselection is None or tmpselection == "":
                                # This will break out of the loop
                                basedir = None
                                selected_file = None
                                continue
                            selected_entry = tmpselection
                            # Find entry in tmp_file_list
                            for item in tmp_file_list:
                                realpath, filename, ptype = item
                                if filename == selected_entry:
                                    if ptype == "<dir>":
                                        basedir = realpath
                                        uip.refresh_all()
                                    elif ptype in ("File", "Configuration File", "Kustomization"):
                                        selected_file = realpath
                                        selected_ptype = ptype
                                        basedir = None
                                        break

                        if selected_file is None:
                            uip.force_update()
                            continue
                        selection_vars = extra_vars
                        selection_vars["resource_path"] = (selected_file, selected_ptype)

                if confirm:
                    query_title = f"Perform “{description}“?"
                    if not curses_helper.confirmationbox(uip.stdscr, title=query_title,
                                                         default=False):
                        continue

                retval = actionfunc(uip, items=[], action=actionlist[action],
                                    values=selection_vars, kind=kind)
                if retval is not None and retval == Retval.RETURNFULL:
                    return retval

                uip.force_update()
                continue
        elif c == ord("N"):
            if not is_namespaced:
                continue

            all_ns = "<All>"
            if selected_namespace == "":
                preselection = all_ns
            else:
                preselection = selected_namespace
            namespace_list = [{
                "lineattrs": WidgetLineAttrs.NORMAL,
                "columns": [[ThemeStr(f"{all_ns}", ThemeAttr("windowwidget", "default"))]],
                "retval": all_ns,
            }]

            tmp, status = \
                kh.get_list_by_kind_namespace(("Namespace", ""), "", resource_cache=kh_cache)
            if status == 200:
                for ns in (deep_get(item, DictPath("metadata#name")) for item in tmp):
                    namespace_list.append({
                        "lineattrs": WidgetLineAttrs.NORMAL,
                        "columns": [[ThemeStr(f"{ns}", ThemeAttr("windowwidget", "default"))]],
                        "retval": ns,
                    })

            tmpselection = \
                curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                           uip.maxy // 2, uip.maxx // 2, namespace_list,
                                           title="Select Namespace", cursor=True,
                                           preselection=preselection)
            selection = None
            if tmpselection is not None and isinstance(tmpselection, str):
                selection = tmpselection

            if selection is not None and selection:
                if selection == all_ns:
                    selected_namespace = ""
                else:
                    selected_namespace = selection

            fieldgenerator_args = {
                "field_index": field_index,
                "field_indexes": field_indexes,
                "fields": deep_get(views, DictPath(f"{view}#fields")),
                "denylist": denylist,
            }
            field_dict, field_names, sortcolumn, sortorder_reverse = \
                generators.fieldgenerator(view=view,
                                          selected_namespace=selected_namespace,
                                          **fieldgenerator_args)

            update_field_widths(field_dict, field_names, uip.info)
            tagged_items.clear()
            uip.reinit_window(field_list=field_dict, sortcolumn=sortcolumn)
            uip.resize_listpad(width=-1)
            uip.refresh_all()
            uip.update_info([])
            uip.force_update()
            if ".".join(kind) in executor:
                executor.update(".".join(kind), namespace=selected_namespace)
            uip.update_window(update=False)
            uip.list_needs_regeneration(True)
            infogetter_extra_args["_vlist"] = []
        elif c in (ord("t"), ord(" ")) and is_taggable:
            selected = uip.get_selected()

            if selected is not None:
                if selected in tagged_items:
                    tagged_items.discard(selected)
                    uip.list_needs_regeneration(True)
                else:
                    tagged_items.add(selected)
                    uip.list_needs_regeneration(True)
                # After we tag an item we advance the cursor (when possible);
                # this way we can select multiple continuous items in a straight-forward manner
                uip.move_cur_with_offset(1)
        elif c == ord("T") and is_taggable:
            # Tag by pattern
            tag_title = f"Tag “{uip.sortcolumn.rstrip().lower()}“ matching: "
            if not (pattern := curses_helper.inputbox(uip.stdscr, title=tag_title)):
                continue
            compiled_pattern: re.Pattern[str] = re.compile(pattern)

            # XXX: This should search the specified sortcolumn, not always in name
            for item in uip.sorted_list:
                try:
                    tmp = compiled_pattern.match(item.name)

                    if tmp is not None and tmp[0]:
                        if item not in tagged_items:
                            tagged_items.add(item)
                            uip.list_needs_regeneration(True)
                except re.error:
                    continue
        elif c == ord("") and is_taggable:
            if not tagged_items:
                continue

            # Untag by pattern
            untag_title = f"Untag “{(uip.sortcolumn).rstrip().lower()}“ matching: "
            if not (pattern := curses_helper.inputbox(uip.stdscr, title=untag_title)):
                continue
            compiled_pattern = re.compile(pattern)

            # XXX: This should search the specified sortcolumn, not always in name
            for item in uip.sorted_list:
                try:
                    tmp = compiled_pattern.match(item.name)

                    if tmp is not None and tmp[0]:
                        tagged_items.discard(item)
                        uip.list_needs_regeneration(True)
                except re.error:
                    continue
        elif c == ord("l") and is_taggable and vlist is not None and uip.listlen:
            # List the union of all labels of the tagged objects (if the objects support labels)
            if not tagged_items:
                selected = uip.get_selected()
                tagged_items.add(selected)
                uip.list_needs_regeneration(True)
            labellist = []
            labels = []
            if "namespace" in deep_get(vlist[0], DictPath("metadata"), "") \
                    and hasattr(item, "namespace"):
                itemlist = [(item.namespace, item.name) for item in tagged_items]
            else:
                itemlist = [item.name for item in tagged_items]

            if not itemlist:
                continue

            for obj in vlist:
                if isinstance(itemlist[0], tuple):
                    if (deep_get(obj, DictPath("metadata#namespace"), ""),
                            deep_get(obj, DictPath("metadata#name"))) not in itemlist:
                        continue
                else:
                    if deep_get(obj, DictPath("metadata#name")) not in itemlist:
                        continue

                labelpath = deep_get(views, DictPath(f"{view}#labels"), "metadata#labels")
                labelref = deep_get(obj, DictPath(labelpath), {})
                for key in labelref:
                    if (key, labelref[key]) not in labels:
                        labels.append((key, labelref[key]))
            if not labels:
                tagged_items.clear()
                uip.list_needs_regeneration(True)
                continue
            for key, value in cast(list[tuple[str, str]], natsorted(labels)):
                labellist.append({
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr(f"{key}", ThemeAttr("windowwidget", "default"))],
                                [ThemeStr(f"{value}", ThemeAttr("windowwidget", "default"))]],
                })
            label_headers = ["Label:", "Value:"]
            curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                       uip.maxy // 2, uip.maxx // 2,
                                       labellist, headers=label_headers,
                                       title="Labels", cursor=False)
            tagged_items.clear()
            uip.list_needs_regeneration(True)
            uip.refresh_all()
            curses.doupdate()
        elif c == ord("f") and is_taggable and vlist is not None and uip.listlen:
            # List the union of all labels of the tagged objects and create a label selector
            # from the choices made by the user (if the objects support labels)
            if not tagged_items:
                selected = uip.get_selected()
                tagged_items.add(selected)
                uip.list_needs_regeneration(True)

            labellist = []
            labels = []
            if "namespace" in deep_get(vlist[0], DictPath("metadata"), ""):
                itemlist = [(item.namespace, item.name) for item in tagged_items]
            else:
                itemlist = [item.name for item in tagged_items]

            if not itemlist:
                continue

            for obj in vlist:
                if isinstance(itemlist[0], tuple):
                    if (deep_get(obj, DictPath("metadata#namespace"), ""),
                            deep_get(obj, DictPath("metadata#name"))) not in itemlist:
                        continue
                else:
                    if deep_get(obj, DictPath("metadata#name")) not in itemlist:
                        continue

                labelref = deep_get(obj, DictPath("metadata#labels"), {})
                for key in labelref:
                    if (key, labelref[key]) not in labels:
                        labels.append((key, labelref[key]))
            if not labels:
                continue
            for key, value in labels:
                labellist.append({
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr(f"{key}", ThemeAttr("windowwidget", "default"))],
                                [ThemeStr(f"{value}", ThemeAttr("windowwidget", "default"))]],
                })
            label_headers = ["Label:", "Value:"]
            tagged_labels = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                       uip.maxy // 2, uip.maxx // 2, labellist,
                                                       headers=label_headers, title="Labels",
                                                       cursor=True, taggable=True)
            if tagged_labels:
                selectors = {}
                for i, label in enumerate(labels):
                    if i in tagged_labels:
                        selectors[label[0]] = label[1]
                label_selector = make_label_selector(selectors)
                uip.force_update()
            tagged_items.clear()
            uip.update_info([])
            uip.force_update()
            if ".".join(kind) in executor:
                executor.update(".".join(kind), label_selector=label_selector)
            uip.update_window(update=False)
            uip.list_needs_regeneration(True)
            infogetter_extra_args["_vlist"] = []
        elif c == ord("A") and view == "Inventory" and not tagged_items:
            selected = uip.get_selected()
            groups = ansible_get_groups(ANSIBLE_INVENTORY)
            inventory = ansible_get_inventory_dict()

            # These Ansible groups should not be possible to toggle on/off
            for skip in ["all", "controlplane", "controlplanes", "master", "node", "nodes"]:
                try:
                    groups.remove(skip)
                except (KeyError, ValueError):
                    pass
            host_groups = ansible_get_groups_by_host(inventory, selected.name)
            grouplist = []
            preselection = set()
            for i, group in enumerate(groups):
                grouplist.append({
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr(f"{group}",
                                          ThemeAttr("windowwidget", "default"))]],
                })
                if group in host_groups:
                    preselection.add(i)
            group_headers = ["Ansible Groups:"]
            selection = \
                curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                           uip.maxy // 2, uip.maxx // 2, grouplist,
                                           headers=group_headers,
                                           title=f"Toggle Ansible groups for {selected.name}:",
                                           cursor=True, taggable=True, preselection=preselection)
            new_groups = []
            for keep in ["all", "controlplane", "controlplanes", "master", "node", "nodes"]:
                if keep in host_groups:
                    new_groups.append(keep)
            for i in selection:
                new_groups.append(groups[i])

            add_groups = set(new_groups) - set(host_groups)
            remove_groups = set(host_groups) - set(new_groups)

            for group in add_groups:
                retval = ansible_add_hosts(inventory=ANSIBLE_INVENTORY,
                                           hosts=[selected.name], group=group, skip_all=False)
            for group in remove_groups:
                retval = ansible_remove_hosts(inventory=ANSIBLE_INVENTORY,
                                              hosts=[selected.name], group=group)

            if add_groups or remove_groups:
                uip.force_update()
            uip.refresh_all()
            curses.doupdate()
        elif c == ord("F") and is_taggable:
            # Clear the label selector
            if label_selector:
                label_selector = ""
                uip.force_update()
                uip.refresh_all()
                curses.doupdate()
                tagged_items.clear()
                uip.update_info([])
                uip.force_update()
                if ".".join(kind) in executor:
                    executor.update(".".join(kind), label_selector=label_selector)
                uip.update_window(update=False)
                uip.list_needs_regeneration(True)
                infogetter_extra_args["_vlist"] = []
        elif c == ord("L") and is_taggable:
            # List tagged items
            taggeditemlist = []
            if not tagged_items:
                continue
            # XXX: Currently windowwidget cannot handle ThemeRefs
            bullet = str(ThemeRef("separators", "widgetbullet"))
            for item in tagged_items:
                taggeditemlist.append({
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr(f"{bullet}{item.name}",
                                          ThemeAttr("windowwidget", "default"))]],
                })
            curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2,
                                       taggeditemlist, title="Tagged items", cursor=False)
            uip.refresh_all()
            curses.doupdate()
        # pylint: disable-next=too-many-nested-blocks
        elif c == ord(";") and is_taggable and uip.listlen:
            cluster_available = True
            items = []
            autoitem = False
            control_plane_selected = False

            if not tagged_items:
                selected = uip.get_selected()
                tagged_items.add(selected)
                uip.list_needs_regeneration(True)
                autoitem = True

            for item in tagged_items:
                # XXX Once all infogetters have been fixed we do not need to check for <none>
                if not item.name or item.name == "<none>":
                    break

                if hasattr(item, "roles"):
                    if isinstance(item.roles, (list, tuple)):
                        if ("control-plane", "") in item.roles:
                            control_plane_selected = True
                        if ("<unknown>", "") in item.roles:
                            cluster_available = False
                    else:
                        if "control-plane" in item.roles:
                            control_plane_selected = True
                        if "<unknown>" in item.roles:
                            cluster_available = False
                if hasattr(item, "namespace"):
                    items.append((item.namespace, item.name))
                else:
                    items.append(item.name)

            if not items:
                tagged_items.clear()
                uip.list_needs_regeneration(True)
                continue

            action_title = deep_get(views, DictPath(f"{view}#actions#title"),
                                    "Perform action on tagged items")
            tmp_action_src_list = deep_get(views, DictPath(f"{view}#actions#actionlist"), {})

            action_src_list = {
            }

            for action in tmp_action_src_list:
                # Override default actions by passing an empty action by the same name
                if action in action_src_list and tmp_action_src_list[action] == {}:
                    action_src_list.pop(action)
                else:
                    action_src_list[action] = tmp_action_src_list[action]

            # Populate the list of actions
            actions, actionlist = \
                populate_actionlist(action_list=action_src_list,
                                    control_plane_selected=control_plane_selected,
                                    single_item=(len(items) == 1),
                                    cluster_available=cluster_available)

            # If there are playbook actions, add those too
            if deep_get(views, DictPath(f"{view}#actions#playbooklist"), {}):
                playbook_context = \
                    deep_get(views, DictPath(f"{view}#actions#playbooklist#context"), None)
                actions, actionlist = \
                    populate_playbooklist(context=playbook_context,
                                          actions=[],
                                          action_list=actionlist,
                                          control_plane_selected=control_plane_selected,
                                          single_item=(len(items) == 1),
                                          cluster_available=cluster_available)

            if not actions:
                if autoitem:
                    tagged_items.clear()
                    uip.list_needs_regeneration(True)
                continue

            tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                      uip.maxy // 2, uip.maxx // 2, actions,
                                                      title=action_title)
            selection = None
            if tmpselection is not None and tmpselection != "":
                selection = ""
                for i, element in enumerate(tmpselection):
                    if element:
                        selection += str(element[0])
            uip.refresh_all()
            curses.doupdate()

            if selection is not None and selection != "":
                actionfunc = None

                # Map the description back to key
                for action in actionlist:
                    description = deep_get(actionlist, DictPath(f"{action}#description"))
                    tmpdescription = ""
                    if isinstance(description, str):
                        tmpdescription = description
                    else:
                        for i, segment in enumerate(description):
                            tmpdescription += segment[0]
                    tmpmetadata = deep_get(actionlist, DictPath(f"{action}#metadata"), [])
                    for metadata in tmpmetadata:
                        tmpdescription += metadata[0]
                    if tmpdescription == selection:
                        actiontype = deep_get(actionlist, DictPath(f"{action}#action"))
                        if actiontype is not None:
                            if actiontype == "execute":
                                actionfunc = action_execute_command
                        else:
                            actionfunc = deep_get(actionlist, DictPath(f"{action}#actionfunc"),
                                                  command_hosts)
                            if isinstance(actionfunc, str):
                                actionfunc = deep_get(actionfunc_allowlist, DictPath(actionfunc))
                        action_args = deep_get(actionlist, DictPath(f"{action}#action_args"), {})
                        # These are only relevant for node and inventory view
                        # allowoncontrolplane = \
                        #     deep_get(actionlist,
                        #              DictPath(f"{action}#allow-on-control-plane"), True)
                        # singleoncontrolplane = \
                        #     deep_get(actionlist,
                        #              DictPath(f"{action}#single-on-control-plane"), False)
                        confirm = deep_get(actionlist, DictPath(f"{action}#confirm"), False)
                        query = deep_get(actionlist, DictPath(f"{action}#query"))
                        queryval = deep_get(actionlist, DictPath(f"{action}#queryval"))
                        queryfunc = deep_get(actionlist, DictPath(f"{action}#queryfunc"))
                        extravars = deep_get(actionlist, DictPath(f"{action}#extravars"), {})
                        title = deep_get(actionlist, DictPath(f"{action}#title"))
                        break

                if actionfunc is None:
                    continue

                selection_vars = extravars

                # This should be modified; we might want to ask multiple queries.
                # At the very least asking for one input plus confirmation.
                # A multi input box might be useful too.
                if queryfunc is not None and queryval is not None and query is not None:
                    if queryfunc == "string":
                        # Not supported by inputbox widget
                        # querydefault = ""
                        query_title = f"{query}: "
                        if not (string := curses_helper.inputbox(uip.stdscr, title=query_title)):
                            continue
                        selection_vars[queryval] = string
                    elif queryfunc == "confirm":
                        querydefault = False
                        query_title = f"{query}?"
                        if not curses_helper.confirmationbox(uip.stdscr, title=query_title,
                                                             default=querydefault):
                            continue
                    elif queryfunc == "filechooser":
                        # It is a programming error if either of these two are not set,
                        # so it is OK to get an exception
                        listgetter = extravars["listgetter"]
                        basedir = extravars["basedir"]
                        selected_file = None
                        selected_ptype = None

                        while basedir is not None:
                            tmp_file_list = listgetter(basedir)
                            file_list = []
                            for item in tmp_file_list:
                                realpath, filename, ptype = item
                                if ptype in ("File", "Configuration File", "Kustomization"):
                                    fmt = ThemeAttr("windowwidget", "default")
                                elif ptype == "<dir>":
                                    fmt = ThemeAttr("windowwidget", "highlight")
                                else:
                                    raise ValueError(f"Unknown ptype {ptype}")
                                file_list.append({
                                    "lineattrs": WidgetLineAttrs.NORMAL,
                                    "columns": [[ThemeStr(f"{filename}", fmt)],
                                                [ThemeStr(f"{ptype}",
                                                          ThemeAttr("windowwidget",
                                                                    "description"))]],
                                    "retval": filename,
                                })
                            tmpselection = \
                                curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                           uip.maxy // 2, uip.maxx // 2, file_list,
                                                           title=query, cursor=True)
                            if tmpselection is None or tmpselection == "":
                                # This will break out of the loop
                                basedir = None
                                selected_file = None
                                continue
                            selected_entry = selection
                            # Find entry in tmp_file_list
                            for item in tmp_file_list:
                                realpath, filename, ptype = item
                                if filename == selected_entry:
                                    if ptype == "<dir>":
                                        basedir = realpath
                                        uip.refresh_all()
                                    elif ptype in ("File", "Configuration File", "Kustomization"):
                                        selected_file = realpath
                                        selected_ptype = ptype
                                        basedir = None
                                        break

                        if selected_file is None:
                            uip.force_update()
                            continue
                        selection_vars["resource_path"] = (selected_file, selected_ptype)

                if confirm:
                    query_title = f"Are you sure you want to perform “{description}“?"
                    if not curses_helper.confirmationbox(uip.stdscr, title=query_title,
                                                         default=False):
                        continue

                selection_vars["_tagged_items"] = list(tagged_items)
                selection_vars["action_args"] = action_args
                retval = actionfunc(uip, items, actionlist[action], values=selection_vars,
                                    kind=kind, title=title)
                if retval is not None and retval == Retval.RETURNFULL:
                    return retval

                uip.force_update()
                uip.update_forced = True
                tagged_items.clear()
                uip.list_needs_regeneration(True)
                continue
            tagged_items.clear()
            uip.list_needs_regeneration(True)

        shortcuts = deep_get(views, DictPath(f"{view}#shortcuts"), {})

        for key, value in shortcuts.items():
            read_only = deep_get(value, DictPath("read_only"), False)
            if read_only_mode and not read_only:
                continue

            shortcut_keys = deep_get(value, DictPath("shortcut"))
            if shortcut_keys is None:
                continue

            if not isinstance(shortcut_keys, list):
                shortcut_keys = [shortcut_keys]

            if c not in shortcut_keys:
                continue

            query = deep_get(value, DictPath("query"))
            queryval = deep_get(value, DictPath("queryval"))
            queryfunc = deep_get(value, DictPath("queryfunc"))
            # Force update data
            force_update = deep_get(value, DictPath("force_update"), False)
            # Force update UI
            force_refresh = deep_get(value, DictPath("force_refresh"), False)

            selection_vars = None

            # This should be modified; we might want to ask multiple queries.
            # At the very least asking for one input plus confirmation.
            # A multi input box might be useful too.
            if queryfunc is not None and queryval is not None and query is not None:
                if queryfunc == "string":
                    # Not supported by inputbox widget
                    # querydefault = ""
                    query_title = f"{query}: "
                    if not (string := curses_helper.inputbox(uip.stdscr, title=query_title)):
                        continue
                    selection_vars = {queryval: string}
                elif queryfunc == "confirm":
                    querydefault = False
                    query_title = f"{query}?"
                    if not curses_helper.confirmationbox(uip.stdscr, title=query_title,
                                                         default=querydefault):
                        continue
            if deep_get(value, DictPath("confirm")):
                uip.force_update()
                query_title = deep_get(value, DictPath("title"), "")
                if not curses_helper.confirmationbox(uip.stdscr, title=query_title, default=False):
                    continue

            selected = uip.get_selected()

            action = deep_get(value, DictPath("action"), None)
            if action is not None:
                action_args = deep_get(value, DictPath("action_args"), {})
                if "_pass_obj" in action_args and selected is not None:
                    action_args["obj"] = selected.ref
                if "_pass_kind" in action_args:
                    action_args["kind"] = kind
                if "_pass_selected" in action_args and selected is not None:
                    action_args["selected"] = selected
                if "_pass_selection_vars" in action_args:
                    action_args["selection_vars"] = selection_vars
                if "_parent_namespace_path" in action_args and selected is not None:
                    parent_namespace_path = \
                        deep_get(action_args, DictPath("_parent_namespace_path"))
                    action_args["_parent_namespace"] = deep_get(obj, parent_namespace_path, "")
                if "_named_title" in action_args:
                    title = deep_get(action_args, DictPath("title"), "")
                    title_name = ""
                    if "_name_path" in action_args:
                        title_name_path = deep_get(action_args, DictPath("_name_path"), "")
                        title_name = deep_get(selected.ref, DictPath(title_name_path), "")
                    elif "_name_tuple_paths" in action_args:
                        title_name_paths = deep_get(action_args, DictPath("_name_tuple_paths"), [])
                        title_name = deep_get_str_tuple_paths(selected.ref, title_name_paths, "")
                    elif selected is not None:
                        title_name = getattr(selected, "name", "")
                    if title_name != "":
                        title_name = f" ({title_name})"
                    action_args["named_title"] = f"{title}{title_name}"
                action_call = deep_get(value, DictPath("action_call"))
                if action == "toggle_var":
                    var = deep_get(action_args, DictPath("var"))
                    if var is not None:
                        tmp = deep_get(listview_args, DictPath(var))
                        deep_set(listview_args, DictPath(var), not tmp)
                elif action == "call" and action_call is not None:
                    retval = action_call(uip.stdscr, **action_args)
                    if retval is not None and retval == Retval.RETURNFULL:
                        return retval
                elif action == "command" and action_args is not None:
                    do_command(uip.stdscr, **action_args)

            if force_refresh:
                uip.force_refresh()

            if force_update:
                uip.update_forced = True
                uip.force_update()


def __switch_resource_map(**kwargs: Any) -> tuple[Retval, dict]:
    uip = deep_get(kwargs, DictPath("uip"))
    uip.refresh_all()
    return Retval.MATCH, {
        "selected_heatmap": deep_get(kwargs, DictPath("next_resource_map"))
    }


# pylint: disable-next=too-many-branches,too-many-statements
def __resource_map_cursor(**kwargs: Any) -> tuple[Retval, dict]:
    uip = deep_get(kwargs, DictPath("uip"))
    keypress = deep_get(kwargs, DictPath("__keypress"))
    selected = deep_get(kwargs, DictPath("selected"))
    info = deep_get(kwargs, DictPath("info"))
    if info is None:
        return Retval.MATCH, {
            "selected": 0,
            "ypos": 0,
            "xpos": 0,
        }

    status_len = len(info)
    heatmap_width = deep_get(kwargs, DictPath("heatmap_width"))
    stride = deep_get(kwargs, DictPath("stride"), 1)

    maxval = status_len - 1
    oldval = selected

    if keypress == curses.KEY_LEFT:
        selected = clamp(oldval - 1, 0, maxval)
        uip.refresh_all()
    if keypress == curses.KEY_RIGHT:
        selected = clamp(oldval + 1, 0, maxval)
        uip.refresh_all()
    elif keypress == curses.KEY_UP:
        if (oldval - (heatmap_width + 1)) >= 0:
            selected = oldval - (heatmap_width + 1)
    elif keypress == curses.KEY_DOWN:
        if (oldval + heatmap_width + 1) <= maxval:
            selected = oldval + heatmap_width + 1
    elif keypress == curses.KEY_PPAGE:
        if (oldval - ((heatmap_width + 1) * stride)) >= 0:
            selected = oldval - (heatmap_width + 1) * stride
    elif keypress == curses.KEY_NPAGE:
        if (oldval + ((heatmap_width + 1) * stride)) <= maxval:
            selected = oldval + (heatmap_width + 1) * stride
    elif keypress == curses.KEY_HOME:
        selected = max((oldval // (heatmap_width + 1)) * (heatmap_width + 1), 0)
    elif keypress == curses.KEY_END:
        selected = \
            min((oldval // (heatmap_width + 1)) * (heatmap_width + 1) + heatmap_width, maxval)
    elif keypress == curses.KEY_SHOME:
        selected = oldval - (oldval // (heatmap_width + 1)) * (heatmap_width + 1)
    elif keypress == curses.KEY_SEND:
        rowwidth = heatmap_width + 1
        if maxval > rowwidth:
            selected = (rowwidth * (maxval // rowwidth)) + (oldval % rowwidth)
            if selected > maxval:
                selected -= rowwidth
    elif keypress == ord("\t"):
        if oldval < maxval:
            for i in range(selected + 1, len(info)):
                if info[i].status_group != StatusGroup.OK:
                    selected = i
                    uip.force_update()
                    break
    elif keypress == curses.KEY_BTAB:
        if oldval > 0:
            for i in range(1, selected):
                if info[selected - i].status_group != StatusGroup.OK:
                    selected -= i
                    uip.force_update()
                    break

    xpos = selected % (heatmap_width + 1)
    ypos = selected // (heatmap_width + 1)
    return Retval.MATCH, {
        "selected": selected,
        "ypos": ypos,
        "xpos": xpos,
    }


def __open_reference(**kwargs: Any) -> tuple[Retval, dict]:
    uip = deep_get(kwargs, DictPath("uip"))
    keypress = deep_get(kwargs, DictPath("__keypress"))
    pod_name = deep_get(kwargs, DictPath("pod_name"))
    namespace = deep_get(kwargs, DictPath("namespace"))
    node = deep_get(kwargs, DictPath("node"))

    if keypress == ord("d"):
        if node is None:
            return Retval.MATCH, {}
        name = node
        namespace = ""
        kind = ("Node", "")
    elif keypress == ord("N"):
        if namespace is None:
            return Retval.MATCH, {}
        name = namespace
        namespace = ""
        kind = ("Namespace", "")
    else:
        if pod_name is None:
            return Retval.MATCH, {}
        name = pod_name
        kind = ("Pod", "")

    ref = kh.get_ref_by_kind_name_namespace(kind, name, namespace, resource_cache=kh_cache)
    retval = resourceinfodispatch(uip.stdscr, ref, kind)
    if retval is not None and retval == Retval.RETURNFULL:
        return retval, {}
    uip.force_update()
    return Retval.MATCH, {}


def __fetch_package_versions(**kwargs: Any) -> tuple[Retval, dict]:
    uip = deep_get(kwargs, DictPath("uip"))
    hostname = deep_get(kwargs, DictPath("hostname"))

    _win = curses_helper.notice(uip.stdscr, uip.maxy // 2, uip.maxx // 2,
                                message="Fetching package versions...")
    _package_versions = get_package_versions(hostname)
    package_versions = []
    for package, version in _package_versions:
        if version == "N/A":
            fmt = ThemeAttr("windowwidget", "dim")
        else:
            fmt = ThemeAttr("windowwidget", "default")
        package_versions.append({
            "lineattrs": WidgetLineAttrs.NORMAL,
            "columns": [[ThemeStr(f"{package}", ThemeAttr("windowwidget", "default"))],
                        [ThemeStr(f"{version}", fmt)]],
        })
    uip.refresh_window()
    uip.refresh_infopad()
    uip.refresh_listpad()
    uip.refresh_statusbar()
    curses.doupdate()
    if not package_versions:
        return Retval.MATCH, {}
    title = "Package Versions:"
    headers = ["Package:", "Version:"]
    curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2,
                               package_versions, title=title, headers=headers, cursor=False)
    return Retval.MATCH, {}


clusteroverview_shortcuts = {
    "__common_shortcuts": [
        "Toggle mouse on/off",
        "Toggle borders",
        "Show this helptext",
        "Switch main view",
        "Switch main view (recheck available API resources)",
        "Show information about the program",
    ],
    "Open info page for Node": {
        "helptext": ("D", "Open info page for Node"),
        "shortcut": ord("d"),
        "helpgroup": 2,
        "action": "key_callback",
        "action_call": __open_reference,
    },
    "Open info page for Namespace [Pod context only]": {
        "helptext": ("[Shift] + N", "Open info page for Namespace [Pod context only]"),
        "shortcut": ord("N"),
        "helpgroup": 2,
        "action": "key_callback",
        "action_call": __open_reference,
    },
    "Open info page for Pod [Pod context only]": {
        "helptext": ("[Shift] + P", "Open info page for Pod [Pod context only]"),
        "shortcut": ord("P"),
        "helpgroup": 2,
        "action": "key_callback",
        "action_call": __open_reference,
    },
    "Show package versions": {
        "helptext": ("[Shift] + V", "Show package versions"),
        "shortcut": ord("V"),
        "helpgroup": 2,
        "action": "key_callback",
        "action_call": __fetch_package_versions,
    },
    "Move cursor up / down / left / right within resource map": {
        "helptext": ("[Cursor keys]", "Move cursor up / down / left / right within resource map"),
        "shortcut": [curses.KEY_LEFT, curses.KEY_RIGHT, curses.KEY_UP, curses.KEY_DOWN],
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
    "Move cursor 10 rows up / down within resource map": {
        "helptext": ("[Page Up]", "Move cursor 10 rows up / down within resource map"),
        "shortcut": [curses.KEY_PPAGE, curses.KEY_NPAGE],
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
        "action_args": {
            "stride": 10,
        }
    },
    "Switch to previous resource map": {
        "shortcut": curses.KEY_SLEFT,
        "helptext": ("[Shift] + [Left]", "Switch to previous resource map"),
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __switch_resource_map,
        "action_args": {
            "next_resource_map": "Node",
        }
    },
    "Switch to next resource map": {
        "helptext": ("[Shift] + [Right]", "Switch to next resource map"),
        "shortcut": curses.KEY_SRIGHT,
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __switch_resource_map,
        "action_args": {
            "next_resource_map": "Pod",
        }
    },
    "Jump to first column of resource map": {
        "helptext": ("[Home]", "Jump to first column of resource map"),
        "shortcut": curses.KEY_HOME,
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
    "Jump to last column of resource map": {
        "helptext": ("[End]", "Jump to last column of resource map"),
        "shortcut": curses.KEY_END,
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
    "Jump to next elevated severity in resource map": {
        "helptext": ("[Tab]", "Jump to next elevated severity in resource map"),
        "shortcut": ord("\t"),
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
    "Jump to first row of resource map": {
        "helptext": ("[Shift] + [Home]", "Jump to first row of resource map"),
        "shortcut": curses.KEY_SHOME,
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
    "Jump to last row of resource map": {
        "helptext": ("[Shift] + [End]", "Jump to last row of resource map"),
        "shortcut": curses.KEY_SEND,
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
    "Jump to previous elevated severity in resource map": {
        "helptext": ("[Shift] + [Tab]", "Jump to previous elevated severity in resource map"),
        "shortcut": curses.KEY_BTAB,
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
}


# pylint: disable-next=unused-argument
def read_file_async(*args: Any, **kwargs: Any) -> tuple[list[Any], list[StatusGroup]]:
    file_not_found_status: str = deep_get(kwargs,
                                          DictPath("file_not_found_status"), "File not found")
    path: str = deep_get(kwargs, DictPath("path"))
    filetype: str = deep_get(kwargs, DictPath("filetype"), "string")

    status = StatusGroup.OK
    result: list[Any] = []

    try:
        if filetype == "string":
            result = secure_read_string(path, directory_is_symlink=True)
        elif filetype == "yaml":
            result = secure_read_yaml(path, directory_is_symlink=True)
    except FilePathAuditError as e:
        if "SecurityStatus.PARENT_DOES_NOT_EXIST" in str(e) \
                or "SecurityStatus.DOES_NOT_EXIST" in str(e):
            status = file_not_found_status
        else:
            raise

    return result, status


# pylint: disable-next=unused-argument
def run_ansible_play_async(*args: Any, **kwargs: Any) -> tuple[list[Any], list[StatusGroup]]:
    playbook = deep_get(kwargs, DictPath("playbook"))
    selection = deep_get(kwargs, DictPath("selection"))
    verbose = deep_get(kwargs, DictPath("verbose"), False)
    status, result = ansible_run_playbook_on_selection(playbook=playbook,
                                                       selection=selection, verbose=verbose)
    return result, status


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def clusteroverviewloop(stdscr: curses.window, view: str) -> Retval:
    """
    Main loop for the Cluster Overview.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            view (str): The view to show
        Returns:
            (Retval): The return value
        Raises:
            ProgrammingError (view is invalid)
    """
    global executor  # pylint: disable=global-statement

    # Just in case there are leftover futures from other views
    executor.shutdown()
    executor = reexecutor.ReExecutor()

    field_list, sortcolumn = (None, None)
    uip = UIProps(stdscr)

    windowheader = view
    activatedfun = views[view]["activatedfun"]
    on_activation = deep_get(views[view], DictPath("on_activation"), {})
    update_delay = views[view].get("update_delay", -1)

    sortorder_reverse = views[view].get("sortorder_reverse", False)

    uip.init_window(field_list=field_list, windowheader=windowheader, update_delay=update_delay,
                    sortcolumn=sortcolumn, sortorder_reverse=sortorder_reverse,
                    activatedfun=activatedfun, on_activation=on_activation)

    infopadheight = 11
    eventpadheight = 7

    # For generic information
    infopad = uip.init_infopad(height=infopadheight, width=-1, ypos=1, xpos=1)

    # For the status panes
    _headerpad, listpad = \
        uip.init_listpad(listheight=1, width=-1,
                         ypos=infopadheight + eventpadheight + 2, xpos=1, header=False)

    # For the status bar; position is always at the bottom of the screen
    # and the entire width of the screen
    _statusbar = uip.init_statusbar()

    selected_heatmap = "Node"
    selected_node = 0
    selected_pod = 0

    # Get control plane node
    control_plane_node, control_plane_name = get_control_plane()
    control_plane_addresses = deep_get(control_plane_node, DictPath("status#addresses"), [])
    name, iips, eips = infogetters.get_node_addresses(control_plane_addresses)

    hostname = socket.gethostname()
    islocal = hostname == name

    stat_regex: re.Pattern[str] = re.compile(r"^[A-Za-z]+ +(\d+) +(\d+) +(\d+) +(\d+) "
                                             r"(\d+) +(\d+) +(\d+) +(\d+) +(\d+) (\d+)$")

    loadavg_raw = []
    meminfo_raw = []
    stat_raw = []

    podinfo = []
    nodeinfo = []

    pod_curypos = 0
    node_curypos = 0

    cputimeuser = 0
    cputimeusernice = 0
    cputimetotalsystem = 0
    cputimetotalguest = 0
    cputimetotal = 1
    cputimetotalused = 0
    memused = 0
    memcached = 0
    buffers = 0
    memtotal = 1
    swapused = 0
    running = 0
    tasks = 0
    loadavg_raw = []
    meminfo_raw = []
    stat_raw = []

    swaptotal = 0

    node_statuses = []
    node_heatmap = []
    nodeinfo = []
    pod_statuses = []
    podinfo = []
    pod_heatmap = []
    events = []

    if not islocal:
        ping_playbook_path = get_playbook_path(FilePath("load_ping.yaml"))
        executor.trigger("sysinfo", 5, run_ansible_play_async,
                         playbook=ping_playbook_path, selection=[control_plane_name])
    executor.trigger("node", 5, listgetters_async.get_kubernetes_list, kind=("Node", ""),
                     namespace="", fetch_args={"sort_key": "metadata#name", "postprocess": "node"},
                     kubernetes_helper=kh, kh_cache=kh_cache)
    executor.trigger("pod", 5, listgetters_async.get_kubernetes_list, kind=("Pod", ""),
                     namespace="", fetch_args={"postprocess": "pod"},
                     kubernetes_helper=kh, kh_cache=kh_cache)
    executor.trigger("event", 5, listgetters_async.get_kubernetes_list, kind=("Event", ""),
                     namespace="",
                     fetch_args={"sort_key": "lastTimestamp", "sort_reverse": True, "limit": 5},
                     kubernetes_helper=kh, kh_cache=kh_cache)

    # pylint: disable-next=too-many-nested-blocks
    while True:
        if (result := executor.get("sysinfo")) != ([], []):
            ansible_results, ansible_status = result
            if ansible_status == 0:
                for ansible_result in deep_get(ansible_results, DictPath(control_plane_name), []):
                    task = deep_get(ansible_result, DictPath("task"), "")
                    if task == "Fetching /proc/loadavg":
                        loadavg_raw = deep_get(ansible_result, DictPath("stdout_lines"), [])
                    elif task == "Fetching /proc/meminfo":
                        meminfo_raw = deep_get(ansible_result, DictPath("stdout_lines"), [])
                    elif task == "Fetching /proc/stat":
                        stat_raw = deep_get(ansible_result, DictPath("stdout_lines"), [])
                    uip.force_update()
        if (result := executor.get("node")) != ([], []):
            nodeinfo, node_statuses = result
        if (result := executor.get("pod")) != ([], []):
            podinfo, pod_statuses = result
        if (result := executor.get("event")) != ([], []):
            events, _status = result

        if uip.is_update_triggered():
            # The data in some fields might become shorter, so we need to trigger a clear
            uip.infopad.erase()
            uip.statusbar.erase()

            uip.update_window()

            if islocal:
                tmp: str = secure_read_string(FilePath("/proc/loadavg"))
                loadavg_raw = tmp.splitlines()
                tmp = secure_read_string(FilePath("/proc/meminfo"))
                meminfo_raw = tmp.splitlines()
                tmp = secure_read_string(FilePath("/proc/stat"))
                stat_raw = tmp.splitlines()

            if loadavg_raw:
                try:
                    _avg1min, _avg5min, _avg15min, tasks_running, _latest_pid = \
                        loadavg_raw[0].split()
                    running, tasks = tasks_running.split("/")
                except ValueError:
                    loadavg_raw = []

            if meminfo_raw:
                memtotal = 0
                memfree = 0
                memcached = 0
                sreclaimable = 0
                memshared = 0
                swaptotal = 0
                swapfree = 0
                try:
                    for tmp in meminfo_raw:
                        values = tmp.split()
                        if values[0] == "MemTotal:":
                            memtotal = int(values[1])
                        elif values[0] == "MemFree:":
                            memfree = int(values[1])
                        elif values[0] == "MemShared:":
                            memshared = int(values[1])
                        elif values[0] == "Buffers:":
                            buffers = int(values[1])
                        elif values[0] == "Cached:":
                            memcached = int(values[1])
                        elif values[0] == "SwapTotal:":
                            swaptotal = int(values[1])
                        elif values[0] == "SwapFree:":
                            swapfree = int(values[1])
                        elif values[0] == "Shmem:":
                            memshared = int(values[1])
                        elif values[0] == "SReclaimable:":
                            sreclaimable = int(values[1])
                except (IndexError, ValueError):
                    meminfo_raw = []

                # Total used mem; includes buffers and cache
                memused = memtotal - memfree
                memcached = memcached + sreclaimable - memshared
                swapused = swaptotal - swapfree
                # FIXME
                # threads = 42

            # cpu  30175835 25947 13018006 435764225 200633 0   3229829 0     0     0
            # ...  normal   niced system   idle      iowait irq softirq steal guest guest_nice
            #      1        2     3        4         5      6   7       8     9     10
            if stat_raw:
                tmp = stat_regex.match(stat_raw[0])
                if tmp is not None:
                    cputimeuser = int(tmp[1])
                    cputimeusernice = int(tmp[2])
                    cputimesystem = int(tmp[3])
                    cputimeidle = int(tmp[4])
                    cputimeiowait = int(tmp[5])
                    cputimeirq = int(tmp[6])
                    cputimesoftirq = int(tmp[7])
                    cputimesteal = int(tmp[8])
                    cputimeguest = int(tmp[9])
                    cputimeguestnice = int(tmp[10])
                    cputimeuser = cputimeuser - cputimeguest
                    cputimeusernice = cputimeusernice - cputimeguestnice
                    cputimetotalidle = cputimeidle + cputimeiowait
                    cputimetotalsystem = cputimesystem + cputimeirq + cputimesoftirq
                    cputimetotalguest = cputimeguest + cputimeguestnice
                    cputimetotal = cputimeuser + cputimeusernice + cputimetotalsystem \
                        + cputimetotalidle + cputimesteal + cputimetotalguest
                    cputimetotalused = cputimeuser + cputimeusernice + cputimetotalsystem \
                        + cputimesteal + cputimetotalguest
                else:
                    stat_raw = []

            # We most likely have far more nodes than pods, so give the nodes 20% of the width and
            # the pods 80% of the width; even this is probably too much for the nodes,
            # but we can adjust that later
            node_heatmap_width = ((uip.maxx - uip.minx - 1) // 5) - 2
            pod_heatmap_width = ((uip.maxx - uip.minx - 1) * 4 // 5) - 1

        k8s_distro, _status = identify_k8s_distro(kubernetes_helper=kh)

        if k8s_distro is not None:
            k8s_distro_string = ThemeStr(f"{k8s_distro}", ThemeAttr("types", "generic"))
        else:
            k8s_distro_string = ThemeStr("<unknown>", ThemeAttr("types", "unset"))

        internal_ips_array = generators.format_list(iips, 0, 0)
        external_ips_array = generators.format_list(eips, 0, 0)

        infoarrays: list[list[ThemeRef | ThemeStr]] = [
            [
                ThemeStr("Control Plane: ", ThemeAttr("main", "infoheader")),
                ThemeStr(f"{name}", ThemeAttr("types", "generic"))
            ], [
                ThemeStr("Cluster Name: ", ThemeAttr("main", "infoheader")),
                ThemeStr(f"{kh.cluster_name}", ThemeAttr("types", "generic"))
            ], [
                ThemeStr("Cluster Context: ", ThemeAttr("main", "infoheader")),
                ThemeStr(f"{kh.context_name}", ThemeAttr("types", "generic"))
            ], [
                ThemeStr("Kubernetes Distro: ", ThemeAttr("main", "infoheader")),
                k8s_distro_string,
            ], [
                ThemeStr("Internal IP-address(es): ", ThemeAttr("main", "infoheader")),
            ] + internal_ips_array, [
                ThemeStr("External IP-address(es): ", ThemeAttr("main", "infoheader")),
            ] + external_ips_array, [
                # Kubernetes port
                # KubeDNS
                # control plane load, disk, mem, uptime (requires ansible or local)
                # ], [
            ]
        ]

        y = 0
        for i, row in enumerate(infoarrays):
            uip.addthemearray(infopad, row, y=y + i, x=0)
        y += i

        # cpu usage:
        # low-priority (bold blue) / normal (green) / kernel (red) / virtualized (cyan)
        # This is aggregate over all CPUs
        percentagebar_cpu: list[ThemeRef | ThemeStr] = \
            curses_helper.percentagebar(7, uip.infopadwidth - 10, cputimetotal, [
                (cputimeusernice, ThemeRef("strings", "cputime_user_nice")),
                (cputimeuser, ThemeRef("strings", "cputime_user")),
                (cputimetotalsystem, ThemeRef("strings", "cputime_total_system")),
                (cputimetotalguest, ThemeRef("strings", "cputime_total_guest"))
            ])

        # memory usage:
        # used (green) / buffers (bold blue) / cache (yellow)
        percentagebar_mem: list[ThemeRef | ThemeStr] = \
            curses_helper.percentagebar(7, uip.infopadwidth - 10, memtotal, [
                (memused - memcached - buffers, ThemeRef("strings", "mem")),
                (buffers, ThemeRef("strings", "buffers")),
                (memcached, ThemeRef("strings", "cached"))
            ])

        # swap usage:
        # used (red)
        if swaptotal:
            percentagebar_or_string_swap: list[ThemeRef | ThemeStr] = \
                curses_helper.percentagebar(6, uip.infopadwidth - 10, swaptotal, [
                    (swapused, ThemeRef("strings", "swap_used"))])
            percentagebar_or_string_swap += [
                ThemeStr(f"{100 * swapused // swaptotal}", ThemeAttr("main", "dim")),
                ThemeRef("separators", "percentage"),
            ]
        else:
            percentagebar_or_string_swap = [ThemeStr("Disabled", ThemeAttr("types", "none"))]

        tasksarrays: list[list[ThemeRef | ThemeStr]] = [
            [
                ThemeStr("Tasks: ", ThemeAttr("main", "infoheader")),
                ThemeStr(f"{running}", ThemeAttr("types", "numerical")),
                ThemeRef("separators", "fraction"),
                ThemeStr(f"{tasks} ", ThemeAttr("types", "numerical")),
                ThemeStr("running", ThemeAttr("types", "generic")),
            ], [
                ThemeStr("  CPU: ", ThemeAttr("main", "infoheader")),
                ThemeStr("[", ThemeAttr("types", "generic"))
            ] + percentagebar_cpu + [
                ThemeStr("]", ThemeAttr("types", "generic")),
                ThemeStr(f"{str(100 * cputimetotalused // cputimetotal).rjust(3)}",
                         ThemeAttr("types", "numerical")),
                ThemeRef("separators", "percentage"),
            ], [
                ThemeStr("  Mem: ", ThemeAttr("main", "infoheader")),
                ThemeStr("[", ThemeAttr("types", "generic"))
            ] + percentagebar_mem + [
                ThemeStr("]", ThemeAttr("types", "generic")),
                ThemeStr(str(100 * memused // memtotal).rjust(3),
                         ThemeAttr("types", "numerical")),
                ThemeRef("separators", "percentage"),
            ], [
                ThemeStr(" Swap: ", ThemeAttr("main", "infoheader")),
            ] + percentagebar_or_string_swap,
        ]

        if loadavg_raw and meminfo_raw and stat_raw:
            for i, row in enumerate(tasksarrays):
                uip.addthemearray(infopad, row, y=y + i, x=0)
            y += i + 1
        else:
            y += len(tasksarrays)

        # Namespace, Name, Last Seen, Type, Reason, Message
        evheaders = [
            "Namespace:",
            "Name:",
            "Last Seen:",
            "Type:",
            "Reason:",
            "Message:",
        ]

        # path(s), type
        evfields = [
            ([DictPath("metadata#namespace")], "namespace"),
            ([DictPath("metadata#name")], "str"),
            ([DictPath("series#lastObservedTime"),
              DictPath("deprecatedLastTimestamp"),
              DictPath("lastTimestamp"),
              DictPath("eventTime"),
              DictPath("deprecatedFirstTimestamp"),
              DictPath("firstTimestamp")],
             "timestamp"),
            ([DictPath("type")], "event_type"),
            ([DictPath("reason")], "str"),
            ([DictPath("message"), DictPath("note")], "str"),
        ]

        evlens = [len(header) for header in evheaders]

        for event in events:
            for i, evfield in enumerate(evfields):
                paths, ptype = evfield
                val = deep_get_with_fallback(event, paths, "")
                if ptype == "timestamp":
                    timestamp = timestamp_to_datetime(cast(str, val))
                    formatted_timestamp = format_timestamp(timestamp)
                    evlens[i] = max(evlens[i], themearray_len(formatted_timestamp))
                else:
                    evlens[i] = max(evlens[i], len(val))

        # Draw the events over the bottom of the visible area of the listpad
        eventarrays: list[ThemeRef | ThemeStr] = [
            [ThemeStr("Events:", ThemeAttr("main", "listheader_compact"))],
        ]

        tmp2: list[ThemeStr] = []
        for i, header in enumerate(evheaders):
            tmp2.append(ThemeStr(header.ljust(evlens[i]), ThemeAttr("main", "listheader")))
            if i < len(evheaders):
                tmp2.append(ThemeStr("  ", ThemeAttr("main", "listheader")))
        eventarrays.append(tmp2)

        for evindex in range(0, 5):
            tmp2 = []

            if evindex < len(events):
                event = events[evindex]
                for i, evfield in enumerate(evfields):
                    paths, ptype = evfield
                    val = deep_get_with_fallback(event, paths, "")
                    if ptype == "timestamp":
                        timestamp = timestamp_to_datetime(cast(str, val))
                        formatted_timestamp = format_timestamp(timestamp)
                        tmp2 += formatted_timestamp
                        ft_len = evlens[i] - themearray_len(formatted_timestamp)
                        if ft_len:
                            tmp2.append(ThemeStr("".ljust(ft_len), ThemeAttr("main", "default")))
                    elif ptype == "namespace":
                        tmp2.append(ThemeStr(val.ljust(evlens[i]),
                                             ThemeAttr("types", "namespace")))
                    elif ptype == "event_type":
                        if val == "Error":
                            event_type = "status_not_ok"
                        elif val == "Warning":
                            event_type = "status_admin"
                        else:
                            event_type = "status_ok"
                        tmp2.append(ThemeStr(val.ljust(evlens[i]), ThemeAttr("main", event_type)))
                    else:
                        tmp2.append(ThemeStr(val.ljust(evlens[i]), ThemeAttr("main", "default")))

                    if i < len(evheaders):
                        tmp2.append(ThemeStr("  ", ThemeAttr("main", "default")))
            else:
                tmp2.append(ThemeStr("<none>", ThemeAttr("types", "none")))
            eventarrays.append(tmp2)

        y += 1
        curses_helper.window_tee_hline(uip.stdscr, y=y, start=0, end=uip.maxx)

        for i, row in enumerate(eventarrays):
            uip.addthemearray(uip.stdscr, row, y=y + i, x=1)
        y += i + 1
        curses_helper.window_tee_hline(uip.stdscr, y=y, start=0, end=uip.maxx)

        selected_pod = min(selected_pod, len(podinfo))
        selected_node = min(selected_node, len(nodeinfo))

        if nodeinfo and podinfo:
            node_heatmap_xpos = 0
            pod_heatmap_xpos = uip.maxx - pod_heatmap_width - 2

            selectednodetaints = \
                generators.format_list(nodeinfo[selected_node].taints, node_heatmap_width, 0,
                                       field_colors=[ThemeAttr("types", "key"),
                                                     ThemeAttr("types", "value")],
                                       field_separators=[ThemeRef("separators", "keyvalue_taint")])

            nodearrays: list[list[ThemeRef | ThemeStr]] = [
                [
                    ThemeStr(f"Node ({selected_node + 1}/{len(nodeinfo)}):",
                             ThemeAttr("main", "listheader"),
                             selected=selected_heatmap == "Node"),
                    ThemeStr("".ljust(node_heatmap_width),
                             ThemeAttr("types", "generic")),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("No", ThemeAttr("main", "listheader")),
                    ThemeStr("d", ThemeAttr("main", "listheader"),
                             selected=selected_heatmap == "Node"),
                    ThemeStr("e: ", ThemeAttr("main", "listheader")),
                    ThemeStr(f"{nodeinfo[selected_node].name}".ljust(node_heatmap_width),
                             ThemeAttr("main", "highlight")),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("Status: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{nodeinfo[selected_node].status}".ljust(node_heatmap_width),
                             color_status_group(nodeinfo[selected_node].status_group)),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("Taints: ", ThemeAttr("main", "infoheader")),
                ] + selectednodetaints, [
                    # Empty line
                ], [
                    # Empty line
                ],
            ]

            node_heatmap = \
                curses_helper.generate_heatmap(node_heatmap_width, node_statuses, selected_node)
            nodearrays += node_heatmap

            podarrays: list[list[ThemeRef | ThemeStr]] = [
                [
                    ThemeStr(f"Pod ({selected_pod + 1}/{len(podinfo)}):",
                             ThemeAttr("main", "listheader"),
                             selected=selected_heatmap == "Pod"),
                    ThemeStr("".ljust(pod_heatmap_width), ThemeAttr("types", "generic")),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("P", ThemeAttr("main", "listheader"),
                             selected=selected_heatmap == "Pod"),
                    ThemeStr("od: ", ThemeAttr("main", "listheader")),
                    ThemeStr(f"{podinfo[selected_pod].name}".ljust(pod_heatmap_width),
                             ThemeAttr("main", "highlight")),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("N", ThemeAttr("main", "listheader"),
                             selected=selected_heatmap == "Pod"),
                    ThemeStr("amespace: ", ThemeAttr("main", "listheader")),
                    ThemeStr(f"{podinfo[selected_pod].namespace}".ljust(pod_heatmap_width),
                             ThemeAttr("main", "highlight")),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("No", ThemeAttr("main", "infoheader")),
                    ThemeStr("d", ThemeAttr("main", "listheader"),
                             selected=selected_heatmap == "Pod"),
                    ThemeStr("e: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{podinfo[selected_pod].node}".ljust(pod_heatmap_width),
                             ThemeAttr("main", "highlight")),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("Status: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{podinfo[selected_pod].status}".ljust(pod_heatmap_width),
                             color_status_group(podinfo[selected_pod].status_group)),
                ], [
                    # Empty line
                ]
            ]

            pod_heatmap = \
                curses_helper.generate_heatmap(pod_heatmap_width, pod_statuses, selected_pod)
            podarrays += pod_heatmap

            # Resize the list pad
            uip.resize_listpad(max(len(node_heatmap), len(pod_heatmap)))

            for y, row in enumerate(nodearrays):
                uip.addthemearray(listpad, row, y=y, x=node_heatmap_xpos)

            for y, row in enumerate(podarrays):
                uip.addthemearray(listpad, row, y=y, x=pod_heatmap_xpos)

        if selected_heatmap == "Pod":
            uip.maxcurypos = len(pod_heatmap) - 1
            uip.curypos = pod_curypos
            uip.maxyoffset = 0
            uip.yoffset = 0
        elif selected_heatmap == "Node":
            uip.maxcurypos = len(node_heatmap) - 1
            uip.curypos = node_curypos
            uip.maxyoffset = 0
            uip.yoffset = 0

        uip.refresh_window()
        uip.refresh_infopad()
        uip.refresh_listpad()
        uip.refresh_statusbar()
        curses.doupdate()

        if podinfo and selected_heatmap == "Pod":
            __node_name = podinfo[selected_pod].node
            __pod_name = podinfo[selected_pod].name
            __namespace = podinfo[selected_pod].namespace
            __info = podinfo
            __selected = selected_pod
            heatmap_width = pod_heatmap_width
        elif nodeinfo:
            __node_name = nodeinfo[selected_node].name
            __namespace = None
            __pod_name = None
            __info = copy.deepcopy(nodeinfo)
            __selected = selected_node
            heatmap_width = node_heatmap_width
        else:
            __node_name = None
            __namespace = None
            __pod_name = None
            __info = None
            __selected = None
            heatmap_width = 0

        # These are arguments that *might* be needed by the callbacks
        input_args = {
            "uip": uip,
            "selectwindow": selectwindow,
            "read_only": read_only_mode,
            "hostname": control_plane_name,
            "node": __node_name,
            "pod_name": __pod_name,
            "namespace": __namespace,
            "selected_heatmap": selected_heatmap,
            "info": __info,
            "selected": __selected,
            "heatmap_width": heatmap_width,
        }

        retval, return_args = uip.generic_inputhandler(clusteroverview_shortcuts, **input_args)

        if "selected" in return_args:
            if selected_heatmap == "Pod":
                selected_pod = deep_get(return_args, DictPath("selected"))
                pod_curypos = deep_get(return_args, DictPath("ypos"), pod_curypos)
            else:
                selected_node = deep_get(return_args, DictPath("selected"))
                node_curypos = deep_get(return_args, DictPath("ypos"), node_curypos)
        if "selected_heatmap" in return_args:
            selected_heatmap = deep_get(return_args, DictPath("selected_heatmap"))

        if retval == Retval.MATCH:
            continue
        if retval == Retval.RETURNONE:
            return Retval.RETURNDONE
        if retval == Retval.RETURNFULL:
            return retval


# pylint: disable-next=too-many-locals,too-many-branches
def check_cni_updates(cni: str, current_version: str) -> str:
    """
    Check whether there are newer versions of the CNI available.

        Parameters:
            cni (str): The CNI
            current_version (str): The current version
        Returns:
            (str): The newest available version
    """
    candidate_version = None

    security_policy = SecurityPolicy.ALLOWLIST_RELAXED
    fallback_allowlist = ["/bin", "/sbin", "/usr/bin", "/usr/sbin",
                          "/usr/local/bin", "/usr/local/sbin", f"{HOMEDIR}/bin"]

    if cni == "weave":
        # GET /report -H 'Accept: application/json'
        # This should be the IP address of the control plane
        # XXX: We probably need to do this locally on the control plane (via ansible)
        # rather than remotely connecting to the control plane
        weaveaddr = "127.0.0.1"

        conn = http.client.HTTPConnection(weaveaddr, 6784)
        headers = {
            "Accept": "application/json"
        }

        try:
            conn.request("GET", "/report", headers=headers)
            r1 = conn.getresponse()
        except ConnectionRefusedError:
            return "<Version check failed>"

        if r1.status == 200:
            try:
                weavestatus = json.loads(r1.read())
                if deep_get(weavestatus, DictPath("VersionCheck#Enabled"), False) \
                        and deep_get(weavestatus, DictPath("VersionCheck#Success"), False):
                    candidate_version = deep_get(weavestatus,
                                                 DictPath("VersionCheck#NewVersion"), None)
            except DecodeException:
                # We got a response, but the data is malformed
                pass
        conn.close()
    elif cni == "cilium":
        try:
            cpath = secure_which(FilePath(os.path.join(BINDIR, "cilium")),
                                 fallback_allowlist=fallback_allowlist,
                                 security_policy=security_policy)
        except FileNotFoundError:
            cpath = None

        if cpath is not None:
            args = [cpath, "version"]
            result = subprocess.run(args, stdout=PIPE, stderr=PIPE,
                                    universal_newlines=True, check=False)
            if result is not None:
                versionoutput = result.stdout.splitlines()
                version_regex: re.Pattern[str] = re.compile(r"^cilium image \(default\): (.*)")
                for line in versionoutput:
                    tmp = version_regex.match(line)
                    if tmp is not None:
                        candidate_version = tmp[1]
                        break
    else:
        candidate_version = "<Update check not implemented>"

    if candidate_version is not None:
        if versiontuple(current_version) < versiontuple(candidate_version):
            candidate_version = ""
        else:
            candidate_version = "No newer version found"

    return candidate_version


# pylint: disable-next=unused-argument
def update_cni(stdscr: curses.window, cni: str, current_version: str, candidate_version: str,
               dry_run: bool = False) -> bool:
    """
    Update the CNI.

        Parameters:
            stdscr (opaque): A curses stdscr reference
            cni (str): The CNI
            current_version (str): The current version
            candidate_version (str): The candidate version
            dry_run (bool): If True just verify that the update method is valid
        Returns:
            (bool): True on success, False on failure
    """
    security_policy = SecurityPolicy.ALLOWLIST_RELAXED
    fallback_allowlist = ["/bin", "/sbin", "/usr/bin", "/usr/sbin",
                          "/usr/local/bin", "/usr/local/sbin", f"{HOMEDIR}/bin"]

    retval = True

    if cni == "Unknown":
        retval = False
    elif cni == "weave":
        # XXX: Currently we do not have any reliable update method for weave
        retval = False
    elif cni == "cilium":
        try:
            cpath = secure_which(FilePath(os.path.join(BINDIR, "cilium")),
                                 fallback_allowlist=fallback_allowlist,
                                 security_policy=security_policy)
        except FileNotFoundError:
            cpath = None

        if dry_run or cpath is None:
            return cpath is not None

        args = [cpath, "upgrade"]
        curses.endwin()
        _retval = clear_screen()

        ansithemeprint([ANSIThemeStr("Updating Cilium:", "phase")])
        print()
        retval = execute_command(args)
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])

    return retval


def __update_cni(uip: UIProps, **kwargs: Any) -> Retval:
    cni = deep_get(kwargs, DictPath("cni"))
    cni_version = deep_get(kwargs, DictPath("cni_version"))
    candidate_version = deep_get(kwargs, DictPath("candidate_version"))

    # If we do not recognise the CNI or we do not support updates we cannot update it
    if not update_cni(uip.stdscr, cni, cni_version, candidate_version, dry_run=True):
        return Retval.MATCH

    # Try to download and install an update
    query_title = f"Update {cni} to version {candidate_version}:"
    if curses_helper.confirmationbox(uip.stdscr, title=query_title, default=False):
        update_cni(uip.stdscr, cni, cni_version, candidate_version)
    uip.refresh_all()

    return Retval.MATCH


cniloop_shortcuts = {
    "__common_shortcuts": [
        "Toggle mouse on/off",
        "Toggle borders",
        "Show this helptext",
        "Switch main view",
        "Switch main view (recheck available API resources)",
        "Refresh information",
        "Show information about the program",
    ],
    "Update Cluster Network Interface": {
        "shortcut": ord("U"),
        "helptext": ("[Shift] + U",
                     "Update Cluster Network Interface (if a newer candidate is available)"),
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __update_cni,
    },
}


# pylint: disable-next=too-many-locals,too-many-statements
def cniloop(stdscr: curses.window, view: str) -> Retval:
    """
    Main loop for the Container Network Interface view.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            view (str): The view to show
        Returns:
            (Retval): The return value
        Raises:
            ProgrammingError (view is invalid)
    """
    global executor  # pylint: disable=global-statement

    # Just in case there are leftover futures from other views
    executor.shutdown()
    executor = reexecutor.ReExecutor()

    uip = UIProps(stdscr)

    windowheader = view
    activatedfun = views[view]["activatedfun"]
    on_activation = deep_get(views[view], DictPath("on_activation"), {})
    update_delay = views[view].get("update_delay", -1)

    uip.init_window(windowheader=windowheader, update_delay=update_delay,
                    sortcolumn=None, activatedfun=activatedfun, on_activation=on_activation)

    # For generic information
    infopad = uip.init_infopad(height=9, width=-1, ypos=1, xpos=1)

    # The statusbar is always located at the bottom of the screen and fills the entire width
    _statusbar = uip.init_statusbar()

    candidate_version = ""

    cni = None

    while True:
        if uip.is_update_triggered():
            # The data in some fields might become shorter, so we need to trigger a clear
            uip.infopad.erase()
            uip.statusbar.erase()

            uip.update_window()

            # Try to figure out which CNI we are using, if any
            _cnis = kh.identify_cni()

            if not _cnis:
                cni = "<unknown>"
                cnistr: list[ThemeRef | ThemeStr] = [
                    ThemeStr(f"{cni}", color_status_group(StatusGroup.UNKNOWN))
                ]
                cni_version = "N/A"
                cni_version_str = [
                    ThemeStr(f"{cni_version}", color_status_group(StatusGroup.UNKNOWN))
                ]
                cni_status = ("N/A", StatusGroup.UNKNOWN)
            elif len(_cnis) == 1:
                cni = _cnis[0][0]
                cnistr = [
                    ThemeStr(f"{cni}", ThemeAttr("types", "generic"))
                ]
                cni_version = _cnis[0][1]
                cni_version_str = [
                    ThemeStr(f"{cni_version}", ThemeAttr("types", "version"))
                ]
                cni_status = _cnis[0][2]
            else:
                cni = "<unknown>"
                cnistr = [
                    ThemeStr("Could not uniquely identify CNI ",
                             ThemeAttr("main", "status_not_ok")),
                    ThemeStr("(", ThemeAttr("types", "generic")),
                    ThemeStr("Candidates: ", ThemeAttr("main", "infoheader"))]
                for i, _cni in enumerate(_cnis):
                    cnistr += [
                        ThemeStr(f"{_cni[0]}", ThemeAttr("types", "generic")),
                        ThemeRef("separators", "version"),
                        ThemeStr(f"{_cni[1]}", ThemeAttr("types", "version"))]
                    if i < len(_cnis) - 1:
                        cnistr.append(ThemeRef("separators", "list"))
                cnistr.append(ThemeStr(")", ThemeAttr("types", "generic")))
                cni_version = "N/A"
                cni_version_str = [
                    ThemeStr(f"{cni_version[0]}", color_status_group(StatusGroup.UNKNOWN))
                ]
                cni_status = ("N/A", StatusGroup.UNKNOWN)

            cni_status_str = [
                ThemeStr(f"{cni_status[0]}", color_status_group(cni_status[1]))
            ]

            versionarray: list[ThemeRef | ThemeStr] = [
                ThemeStr("Version: ", ThemeAttr("main", "infoheader")),
            ]
            versionarray += cni_version_str
            candidateversionarray: list[ThemeRef | ThemeStr] = [
                ThemeStr("Candidate version: ", ThemeAttr("main", "infoheader")),
            ]

            candidate_version = check_cni_updates(cni, cni_version)
            candidateversionarray.append(ThemeStr(f"{candidate_version}",
                                                  ThemeAttr("types", "version")))

            namearray: list[ThemeRef | ThemeStr] = [
                ThemeStr("Container Network Interface: ", ThemeAttr("main", "infoheader")),
            ]
            namearray += cnistr
            statusarray: list[ThemeRef | ThemeStr] = [
                ThemeStr("Status: ", ThemeAttr("main", "infoheader")),
            ]
            statusarray += cni_status_str

            uip.addthemearray(infopad, namearray, y=0, x=0)
            uip.addthemearray(infopad, versionarray, y=1, x=0)
            uip.addthemearray(infopad, candidateversionarray, y=2, x=0)
            uip.addthemearray(infopad, statusarray, y=3, x=0)

        uip.refresh_window()
        uip.refresh_infopad()
        uip.refresh_statusbar()
        curses.doupdate()

        # These are arguments that *might* be needed by the callbacks
        input_args = {
            "uip": uip,
            "selectwindow": selectwindow,
            "read_only": read_only_mode,
            "cni": cni,
            "cni_version": cni_version,
            "candidate_version": candidate_version,
        }

        retval, _return_args = uip.generic_inputhandler(cniloop_shortcuts, **input_args)

        if retval == Retval.MATCH:
            continue
        if retval == Retval.RETURNONE:
            return Retval.RETURNDONE
        if retval == Retval.RETURNFULL:
            return retval


def decode_and_view_data(stdscr: curses.window, **kwargs: Any) -> Retval:
    if "selected" in kwargs:
        bvalue = kwargs["selected"].value
        title = kwargs["selected"].key
        bvtype = kwargs["selected"].vtype
        vtype, value = decode_value(bvalue)
        if bvalue == value:
            vtype = bvtype
    elif "path" in kwargs:
        obj = deep_get(kwargs, DictPath("obj"), {})
        path = deep_get(kwargs, DictPath("path"), "")
        bvalue = deep_get(obj, DictPath(path), "")
        title = deep_get(kwargs, DictPath("title"), "")
        vtype, value = decode_value(bvalue)
    else:
        return Retval.RETURNDONE

    if vtype == "empty" or vtype.startswith(("base64-binary", "gzip")):
        return Retval.RETURNDONE

    if vtype.startswith("string"):
        obj = value
    elif vtype.startswith("base64-utf-8"):
        obj = base64.b64decode(value).decode("utf-8")
    else:
        raise TypeError(f"Trying to export unknown vtype: {vtype}")
    if title.endswith((".crt", "tls.key", ".pem", "CAKey")) \
            or isinstance(obj, str) and obj.startswith(("-----BEGIN", "-----END")):
        formatter = formatters.format_crt
    elif title == ".dockercfg" or title.endswith(".json"):
        formatter = formatters.reformat_json
    elif title.endswith(".yaml"):
        formatter = formatters.format_yaml
    else:
        formatter = formatters.format_none
    return resourceinfodispatch(stdscr, obj, ("__ResourceView", ""),
                                title=title, formatter=formatter)


def decode_and_view_file_templates(stdscr: curses.window, **kwargs: Any) -> Retval:
    selection = deep_get(kwargs, DictPath("selection"), {})
    if not selection:
        return Retval.RETURNDONE
    obj = deep_get(kwargs, DictPath("obj"), {})
    if not obj:
        return Retval.RETURNDONE
    name_path = deep_get(kwargs, DictPath("name_path"))
    name = selection[1][name_path][0]
    file_path = deep_get(kwargs, DictPath("file_path"))
    files = deep_get(obj, DictPath(file_path))
    for file in files:
        if deep_get(file, DictPath("path"), "") == name:
            break
    else:
        return Retval.RETURNDONE
    encoding = deep_get(file, DictPath("encoding"), "")
    content = deep_get(file, DictPath("content"))
    title = name
    if encoding == "":
        formatter = formatters.map_dataformat(title)
        return resourceinfodispatch(stdscr, content, ("__ResourceView", ""),
                                    title=title, formatter=formatter)

    vtype, value = decode_value(content)
    if vtype.startswith("string"):
        obj = value
    elif vtype.startswith("base64-utf-8"):
        obj = base64.b64decode(value).decode("utf-8")
    elif vtype.startswith(("base64-binary", "gzip")):
        return Retval.RETURNDONE
    formatter = formatters.map_dataformat(title)
    return resourceinfodispatch(stdscr, obj, ("__ResourceView", ""),
                                title=title, formatter=formatter)


# pylint: disable-next=unused-argument
def export_data(stdscr: curses.window, **kwargs: Any) -> Retval:
    selected = deep_get(kwargs, DictPath("selected"))
    obj = deep_get(kwargs, DictPath("obj"))

    if selected is None and obj is None:
        return Retval.RETURNDONE

    extra_args = deep_get(kwargs, DictPath("_extra_args"), {})
    base_path = deep_get(extra_args, DictPath("base_path"))
    name_attr = deep_get(extra_args, DictPath("name_attr"), "value")
    raw_export = deep_get(extra_args, DictPath("raw_export"), False)

    value = None
    if selected is not None:
        value = getattr(selected, name_attr)
    if obj is not None:
        if value is not None:
            value = deep_get(obj, DictPath(f"{base_path}#{value}"))
        else:
            value = deep_get(obj, DictPath(f"{base_path}"))

    raw_filename = deep_get(kwargs, DictPath("result"))
    if "/" not in raw_filename:
        filename = FilePath(Path.cwd()).joinpath(raw_filename)
    else:
        filename = FilePath(raw_filename)

    vtype, value = decode_value(value)

    if vtype.startswith("string") or raw_export:
        secure_write_string(filename, value)
    elif vtype.startswith("base64-utf-8"):
        tmp = base64.b64decode(value).decode("utf-8")
        secure_write_string(filename, tmp)
    elif vtype.startswith(("base64-binary", "gzip")):
        tmp = base64.b64decode(value)
        secure_write_string(filename, tmp, write_mode="wb")
    else:
        raise TypeError(f"Trying to export unknown vtype: {vtype}")
    return Retval.RETURNDONE


# pylint: disable-next=too-many-branches,too-many-statements
def generate_helptext(view: str, viewtype: str,
                      additional_helptexts: list[tuple[str, str]],
                      shortcuts: dict[str, dict[str, Any]]) -> list[dict]:
    helptext: list[tuple[str, str]] = []

    if viewtype == "infoview":
        helptext += helptexts.infoviewheader_part1

        if view not in infoviews:
            helptext += helptexts.infoviewheader_part2
            helptext += helptexts.spacer
            helptext += additional_helptexts
            return format_helptext(helptext)

        viewref = infoviews[view]

        if "listpad" in viewref:
            helptext += helptexts.togglewidth
            helptext += helptexts.infoviewheader_part2
            if deep_get(viewref, DictPath("activatedfun")) is not None:
                helptext.append(("[Enter]", "Open info page for selected resource"))

        if additional_helptexts:
            helptext += helptexts.spacer
            helptext += additional_helptexts

        if shortcuts:
            for shortcut in shortcuts:
                tmp = deep_get(shortcuts[shortcut], DictPath("helptext"))
                if tmp is not None:
                    helptext.append(tmp)

        if "listpad" in viewref:
            helptext += helptexts.spacer

            if not deep_get(viewref, DictPath("reversible"), True):
                helptext += helptexts.irreversiblelistmovement
            else:
                helptext += helptexts.listmovement
        elif "logpad" in viewref:
            helptext += helptexts.linewrap
            helptext += helptexts.toggleformatter
            helptext += helptexts.spacer
            helptext += helptexts.logmovement
    elif viewtype == "listview":
        helptext += helptexts.listviewheader

        viewref = views[view]

        if viewref["kind"] in infoviews:
            helptext += helptexts.openresource

        if "shortcuts" in viewref:
            for shortcut in deep_get(viewref, DictPath("shortcuts")):
                read_only = deep_get(viewref, DictPath(f"shortcuts#{shortcut}#read_only"), False)
                if read_only_mode and not read_only:
                    continue
                tmp = deep_get(viewref, DictPath(f"shortcuts#{shortcut}#helptext"))
                if tmp is not None:
                    helptext.append(tmp)
            helptext += helptexts.spacer

        if deep_get(viewref, DictPath("is_taggable"), True):
            helptext += helptexts.tagactions
            helptext += helptexts.spacer
            if deep_get(viewref, DictPath("labels")):
                helptext += helptexts.selectoractions
                helptext += helptexts.spacer

        helptext += helptexts.listmovement

    return format_helptext(helptext)


# noqa: E501 pylint: disable-next=too-many-locals,too-many-branches,too-many-statements,too-many-return-statements
def genericinfoloop(stdscr: curses.window, obj: dict, view: str, **kwargs: Any) -> Retval:
    global initial_container  # pylint: disable=global-statement
    global executor  # pylint: disable=global-statement

    # Just in case there are leftover futures from other views
    executor.shutdown()
    executor = reexecutor.ReExecutor()

    # If obj is a tuple we got the object as obj[0]
    # params as obj[1]
    if isinstance(obj, tuple):
        obj = obj[0]

    # If we are using the logpad this can be used to format the data
    formatter_path = deep_get(kwargs, DictPath("formatter_path"))
    # formatter_path has precedence over formatter, to allow ConfigMaps to work properly
    formatter = deep_get(kwargs, DictPath("formatter"))
    if formatter_path is not None:
        formatter = deep_get(obj, DictPath(formatter_path))
    elif formatter is not None:
        if isinstance(formatter, str):
            formatter = check_allowlist(formatter_allowlist, "formatter_allowlist", formatter)
    obj_path = deep_get(kwargs, DictPath("obj_path"))
    title = None
    if obj_path is not None:
        title_path = deep_get(kwargs, DictPath("title_path"))
        if title_path is not None:
            title = deep_get(obj, DictPath(title_path))
        if obj_path != "":
            obj = deep_get(obj, DictPath(obj_path))
        else:
            obj = [obj]

    uip = UIProps(stdscr)

    if view not in infoviews:
        return Retval.NOMATCH

    viewref = infoviews[view]

    objgetter = deep_get(viewref, DictPath("objgetter"))
    if objgetter is not None:
        obj = objgetter(obj)
        if obj is None or not obj:
            return Retval.NOMATCH

    # XXX: For now we do not support custom fields for the lists on the info pages
    field_indexes = deep_get(viewref, DictPath("field_indexes"), {})
    field_index = "Normal"

    field_denylist = deep_get(viewref, DictPath("field_denylist"), [])
    fieldgenerator_args = {
        "field_index": field_index,
        "field_indexes": field_indexes,
        "fields": deep_get(viewref, DictPath("fields")),
        "denylist": field_denylist,
    }
    field_dict, field_names, sortcolumn, sortorder_reverse = \
        generators.fieldgenerator(view=view,
                                  selected_namespace=selected_namespace,
                                  **fieldgenerator_args)

    windowheader = deep_get(viewref, DictPath("windowheader"), f"{view[0]} Info")

    # These values can be toggled, so we need to read them first
    infoview_args = copy.deepcopy(viewref.get("infoview_args", {}))

    # These are used for anything that uses ResourceViewer
    if title is not None:
        windowheader = title
    elif "title" in kwargs:
        windowheader = deep_get(kwargs, DictPath("title"))
    elif "title_path" in kwargs:
        windowheader = deep_get(obj, DictPath(title_path), windowheader)
    else:
        kind = deep_get(viewref, DictPath("kind"))
        if kind is not None and kind[1]:
            windowheader = f"{windowheader} ({kind[1]})"

    sortorder_reverse = deep_get(viewref, DictPath("sortorder_reverse"), False)
    reversible = deep_get(viewref, DictPath("reversible"), True)
    activatedfun = deep_get(viewref, DictPath("activatedfun"))
    on_activation = deep_get(viewref, DictPath("listpad#on_activation"), {})
    labels = deep_get(viewref, DictPath("labels"))
    annotations = deep_get(viewref, DictPath("annotations"))
    extraref = deep_get(viewref, DictPath("extraref"))
    data = deep_get(viewref, DictPath("data"), None)
    if data is not None:
        data = obj
    viewoverride = deep_get(viewref, DictPath("viewoverride"), view)
    infopadheight = 0
    if "infopad" in viewref:
        if "name_path" in viewref:
            name_path = deep_get(viewref, DictPath("name_path"))
        else:
            name_path = "metadata#name"
        if "namespace_path" in viewref:
            namespace_path = deep_get(viewref, DictPath("namespace_path"))
        else:
            namespace_path = "metadata#namespace"
        if "creation_timestamp_path" in viewref:
            creation_timestamp_path = deep_get(viewref, DictPath("creation_timestamp_path"))
        else:
            creation_timestamp_path = "metadata#creationTimestamp"

        # Number of fields added conditionally
        if name_path is not None and name_path and deep_get(obj, DictPath(name_path)) is not None:
            infopadheight += 1
        if namespace_path is not None and namespace_path \
                and deep_get(obj, DictPath(namespace_path)) is not None:
            infopadheight += 1
        if creation_timestamp_path is not None and creation_timestamp_path \
                and deep_get(obj, DictPath(creation_timestamp_path)) is not None:
            infopadheight += 1
        # Number of custom fields
        infopadheight += len(deep_get(viewref, DictPath("infopad"), {}))
        # If we *only* have an infopad, then it should cover at least the entire screen;
        # if not it should be as big as needed; it does not really matter if we allocate an
        # infopad larger than the screen, but this should be correct.
        if "listpad" not in viewref and "logpad" not in viewref:
            maxyx = stdscr.getmaxyx()
            infopadheight = max(infopadheight, maxyx[0] - 3)

    shortcuts = copy.deepcopy(deep_get(viewref, DictPath("shortcuts"), {}))

    # Shortcuts
    # Always include the shortcut for namespaces, unless overriden
    # or the namespace_path returns None
    #
    # An override is necessary if metadata#namespace is not the correct path
    # or some other changes are necessary
    if deep_get(shortcuts, DictPath("Namespace")) is None \
            and deep_get(obj, DictPath(namespace_path)) is not None:
        shortcuts["Namespace"] = {
            "shortcut": ord("N"),
            "read_only": True,
            "helptext": ("[Shift] + N", "Open info page for Namespace"),
            "call": resourceinfodispatch,
            "kind": ("Namespace", ""),
            "name_path": "metadata#namespace",
        }

    # Always include the shortcut for security contexts,
    # unless the path returns None
    if "securityContext" in deep_get(obj, DictPath("spec"), {}) \
            or "securityContext" in deep_get(obj, DictPath("spec#template#spec"), {}):
        shortcuts["Show Security Context"] = {
            "shortcut": ord("x"),
            "read_only": True,
            "helptext": ("X", "Show security context information"),
            "widget": "windowwidget",
            "title": "Security Context Policies:",
            "headers": ["Policy:", "Value:"],
            "itemgetter": itemgetters.get_security_context,
            "formatting": [ThemeAttr("windowwidget", "default"),
                           ThemeAttr("windowwidget", "highlight")],
        }

    # Always include the shortcut for conditions,
    # unless the path returns None
    if "conditions" in deep_get(obj, DictPath("status"), {}):
        shortcuts["Show Resource Conditions"] = {
            "shortcut": ord("c"),
            "read_only": True,
            "helptext": ("C", "Show resource conditions"),
            "widget": "windowwidget",
            "title": "Conditions:",
            "headers": ["Type:", "Status:", "Last Probe:", "Last Transition:", "Message:"],
            "itemgetter": itemgetters.get_conditions,
        }

    if deep_get(cmtlib.cmtconfig, DictPath("Internal#sanity_check_views"), False):
        _shortcuts = {}
        for shortcut in shortcuts:
            _shortcut = shortcuts[shortcut].get("shortcut")
            if _shortcut is None:
                continue
            if not isinstance(_shortcut, list):
                _shortcut = [_shortcut]
            for _sc in _shortcut:
                if _sc in _shortcuts:
                    sys.exit(f"infoview {view}: The same keypress ({_sc}) is used for both "
                             f"“{shortcut}“ and “{_shortcuts[_sc]}“; aborting.")
                else:
                    _shortcuts[_sc] = shortcut

    # Conditional helptexts
    additional_helptexts = []
    if deep_get(obj, DictPath(labels)) is not None:
        additional_helptexts += helptexts.labels
    if deep_get(obj, DictPath(annotations)) is not None:
        additional_helptexts += helptexts.annotations

    helptext = generate_helptext(view, "infoview", additional_helptexts, shortcuts=shortcuts)

    uip.init_window(field_list=field_dict, windowheader=windowheader, helptext=helptext,
                    view=viewoverride, sortcolumn=sortcolumn, sortorder_reverse=sortorder_reverse,
                    reversible=reversible, activatedfun=activatedfun, on_activation=on_activation,
                    extraref=extraref, data=obj)

    # For generic information
    if infopadheight:
        infopad = uip.init_infopad(height=infopadheight, width=-1, ypos=1, xpos=1,
                                   labels=deep_get(obj, DictPath(labels)),
                                   annotations=deep_get(obj, DictPath(annotations)))
    else:
        infopad = None

    # The statusbar is always located at the bottom of the screen and fills the entire width
    statusbar = uip.init_statusbar()

    # For lists
    headerpad = None
    listpad = None
    if deep_get(viewref, DictPath("listpad"), {}):
        if infopadheight == 0:
            headerpad, listpad = \
                uip.init_listpad(listheight=1, width=-1, ypos=1, xpos=1)
        else:
            headerpad, listpad = \
                uip.init_listpad(listheight=1, width=-1, ypos=infopadheight + 2, xpos=1)

    # For log pads; we cannot have both a logpad and a listpad simultaneously;
    # at least not with the current implementation
    logpad = deep_get(viewref, DictPath("logpad"))
    if logpad is not None:
        if listpad is not None:
            raise ValueError("We cannot have listpad and logpad simultaneously")

        show_timestamps = deep_get_with_fallback(viewref, [DictPath("logpad#timestamps"),
                                                           DictPath("timestamps")], True)
        uip.toggle_timestamps(show_timestamps)
        if infopadheight == 0:
            tspad, logpad = \
                uip.init_logpad(width=-1, ypos=1, xpos=1,
                                timestamps=show_timestamps)
        else:
            tspad, logpad = \
                uip.init_logpad(width=-1, ypos=infopadheight + 2, xpos=1,
                                timestamps=show_timestamps)

    wrap_lines = False
    raw_output = False

    first_fetch = True

    # pylint: disable-next=too-many-nested-blocks
    while True:
        # Populate useful variables that can be used in the statusbar
        if formatter:
            deep_set(infoview_args, DictPath("formatter"), formatter.__name__)

        # Output listpad if we have one
        if uip.is_update_triggered():
            # The data in some fields might become shorter, so we need to trigger a clear
            if infopad is not None:
                uip.infopad.erase()
            uip.statusbar.erase()

            statusarray1: list[ThemeRef | ThemeStr] = [
                ThemeStr("Fields: ", ThemeAttr("statusbar", "infoheader")),
                ThemeStr(field_index, ThemeAttr("statusbar", "highlight"))
            ]
            statusarray2: list[ThemeRef | ThemeStr] = []

            for status_data in deep_get(viewref, DictPath("statusmsg"), []):
                if len(status_data) == 2:
                    key, path = status_data
                    default_status = "<unset>"
                else:
                    key, path, default_status = status_data

                # If path is a list the first item tells what source to use and the second
                # what path to fetch the value from
                if isinstance(path, list):
                    if path[0] == "config":
                        src_obj = cmtlib.cmtconfig
                    # elif path[0] == "obj":
                    #     value_path = obj
                    elif path[0] == "var":
                        src_obj = infoview_args
                    value_path = DictPath(path[1])
                else:
                    src_obj = infoview_args
                    value_path = DictPath(path)

                value = str(deep_get(src_obj, value_path, default_status))
                if statusarray2:
                    statusarray2 += [ThemeRef("separators", "statusbar")]
                statusarray2 += [
                    ThemeStr(key, ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(value, ThemeAttr("statusbar", "default")),
                ]

            uip.addthemearray(statusbar, statusarray1, y=0, x=0)
            uip.addthemearray(statusbar, statusarray2, y=1, x=0)

            # Refresh obj whenever we reload,
            # unless this is a special view or "no_reload_on_refresh" is true
            if not view[0].startswith("__") \
                    and not deep_get(viewref, DictPath("no_reload_on_refresh"), False):
                obj_name = deep_get(obj, DictPath("metadata#name"))
                obj_namespace = deep_get(obj, DictPath("metadata#namespace"))
                obj = kh.get_ref_by_kind_name_namespace(view, obj_name, obj_namespace,
                                                        resource_cache=kh_cache)

                if obj is None:
                    title = "Error!"
                    errormsg = [{
                        "lineattrs": 0,
                        "columns": [[ThemeStr("Resource not available; "
                                              "it may have been deleted",
                                              ThemeAttr("types", "generic"))]],
                    }]
                    curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                               uip.maxy // 2, uip.maxx // 2, errormsg,
                                               title=title, cursor=False)
                    return Retval.RETURNDONE

            uip.update_window()

            if infopad is not None:
                y = 0
                if name_path is not None and name_path:
                    fieldarray: list[ThemeRef | ThemeStr] = [
                        ThemeStr("Name:", ThemeAttr("main", "infoheader")),
                        ThemeStr(f" {deep_get(obj, DictPath(name_path))}",
                                 ThemeAttr("types", "generic"))
                    ]
                    uip.addthemearray(infopad, fieldarray, y=y, x=0)
                    y += 1

                if namespace_path is not None and namespace_path \
                        and deep_get(obj, DictPath(namespace_path)) is not None:
                    fieldarray = [
                        ThemeStr("N", ThemeAttr("main", "infoheader_shortcut")),
                        ThemeStr("amespace:", ThemeAttr("main", "infoheader")),
                        ThemeStr(f" {deep_get(obj, DictPath(namespace_path))}",
                                 ThemeAttr("types", "namespace"))
                    ]
                    uip.addthemearray(infopad, fieldarray, y=y, x=0)
                    y += 1

                for key, value in deep_get(viewref, DictPath("infopad"), {}).items():
                    # If there is a header field, this is from a view file;
                    # otherwise it is an old-style field
                    fieldarray = []
                    header = deep_get(value, DictPath("header"))

                    if header is not None:
                        fieldarray += header
                        # Only add stuff if there's a path
                        if "path" in value or "paths" in value:
                            # Use generic_infogetter for this
                            data = get_obj(obj, field_dict={key: value}, field_names=[key],
                                           field_index="Normal", view="", filters={})
                            _formatter = {key: generators.get_formatter(value)}
                            _generator = deep_get(_formatter, DictPath(f"{key}#generator"))
                            if _generator is not None:
                                ralign = deep_get(_formatter, DictPath(f"{key}#ralign"))
                                formatting = deep_get(_formatter, DictPath(f"{key}#formatting"))
                                fieldarray += [ThemeStr(" ", ThemeAttr("types", "generic"))]
                                fieldarray += _generator(data, key, fieldlen=0, pad=0,
                                                         ralign=ralign,
                                                         selected=False, **formatting)
                        uip.addthemearray(infopad, fieldarray, y=y, x=0)

                        y += 1
                        continue

                if creation_timestamp_path is not None \
                        and creation_timestamp_path \
                        and deep_get(obj, DictPath(creation_timestamp_path)) is not None:
                    timestamp = deep_get(obj, DictPath(creation_timestamp_path))

                    if timestamp is None:
                        field = [ThemeRef("strings", "unset")]
                    elif isinstance(timestamp, datetime):
                        field = format_timestamp(timestamp)
                    else:
                        timestamp = timestamp_to_datetime(timestamp)
                        field = format_timestamp(timestamp, localtimezone=True)
                    fieldarray = [
                        ThemeStr("Created: ", ThemeAttr("main", "infoheader")),
                    ]
                    fieldarray += field
                    uip.addthemearray(infopad, fieldarray, y=y, x=0)
            uip.refresh_window()
            uip.refresh_infopad()
            curses.doupdate()

            if listpad is not None:
                listgetter = deep_get(viewref, DictPath("listpad#listgetter"))
                listgetter_args = deep_get(viewref, DictPath("listpad#listgetter_args"), {})
                _kind = deep_get(listgetter_args, DictPath("_kind"))
                _kind_path = deep_get(listgetter_args, DictPath("_kind_path"))
                _api_family = deep_get(listgetter_args, DictPath("_api_family"))
                _api_family_path = deep_get(listgetter_args, DictPath("_api_family_path"))
                _label_selector_path = deep_get(listgetter_args, DictPath("_label_selector_path"))
                _label_selector_key_values = \
                    deep_get(listgetter_args, DictPath("_label_selector_key_values"))
                if _label_selector_path is not None:
                    if isinstance(_label_selector_path, str):
                        _label_selector_path = [DictPath(_label_selector_path)]
                    _label_selector_data = deep_get_with_fallback(obj, _label_selector_path)
                    if isinstance(_label_selector_data, str):
                        listgetter_args["label_selector"] = _label_selector_data
                    else:
                        listgetter_args["label_selector"] = \
                            make_label_selector(_label_selector_data)
                elif _label_selector_key_values is not None:
                    label_selectors = {}
                    for label_key, label_value in _label_selector_key_values:
                        if isinstance(label_value, str):
                            label_selectors[label_key] = label_value
                        elif isinstance(label_value, list):
                            label_selectors[label_key] = deep_get_with_fallback(obj, label_value)
                    listgetter_args["label_selector"] = make_label_selector(label_selectors)
                if not deep_get(listgetter_args, DictPath("label_selector"), "") \
                        and deep_get(listgetter_args, DictPath("_none_on_empty_selector"), False):
                    listgetter = listgetters.listgetter_noop
                _field_selector = deep_get(listgetter_args, DictPath("_field_selector"), {})
                if _field_selector:
                    field_selectors = {}
                    for field_key, field_value in _field_selector.items():
                        if isinstance(field_value, list):
                            field_selectors[field_key] = deep_get_with_fallback(obj, field_value)
                        else:
                            field_selectors[field_key] = field_value
                    listgetter_args["field_selector"] = make_label_selector(field_selectors)
                if _kind is None:
                    _kind = deep_get(obj, DictPath(_kind_path))
                if _api_family is None:
                    _api_family = deep_get(obj, DictPath(_api_family_path), "")
                if _kind is not None:
                    _kind = guess_kind((_kind, _api_family))
                _namespace = deep_get(listgetter_args, DictPath("namespace"))
                _namespace_path = deep_get(listgetter_args, DictPath("_namespace_path"), "")
                if _namespace is None:
                    _namespace = deep_get(obj, DictPath(_namespace_path), "")
                listgetter_args["kind"] = _kind
                listgetter_args["namespace"] = _namespace
                if "_pass_obj" in listgetter_args:
                    listgetter_args["_obj"] = obj

                uip.refresh_window()
                uip.refresh_statusbar()
                if first_fetch or uip.update_forced:
                    fetch_message = deep_get(listgetter_args, DictPath("message"), "Fetching data")
                    _win = curses_helper.notice(uip.listpad, uip.maxy // 2, uip.maxx // 2,
                                                message=fetch_message)
                    curses.doupdate()
                    if "kubernetes_helper" not in listgetter_args:
                        listgetter_args["kubernetes_helper"] = kh
                        listgetter_args["kh_cache"] = kh_cache
                    # pylint: disable-next=comparison-with-callable
                    if listgetter == listgetters.generic_listgetter:
                        vlist, _status = listgetter(**listgetter_args)
                    else:
                        vlist, _status = listgetter(obj, **listgetter_args)
                    first_fetch = False
                    uip.update_forced = False

                infogetter = deep_get(viewref, DictPath("listpad#infogetter"))
                infogetter_filters = deep_get(viewref, DictPath("listpad#infogetter_filters"), None)
                infogetter_args = deep_get(viewref, DictPath("listpad#infogetter_args"), {})

                filters = None
                if infogetter_filters is not None:
                    filters = []
                    if infogetter_filters is not None:
                        for key, value in infogetter_filters:
                            filters.append((ast.literal_eval(key), ast.literal_eval(value)))

                infogetter_args.pop("_vlist", None)
                infogetter_args["_vlist"] = vlist

                infogetter_args.pop("_field_index", None)
                infogetter_args["_field_index"] = field_index

                infogetter_args.pop("_field_names", None)
                infogetter_args["_field_names"] = field_names

                infogetter_args.pop("_field_dict", None)
                infogetter_args["_field_dict"] = field_dict

                infogetter_args.pop("_filters", None)
                infogetter_args["_filters"] = filters

                infogetter_args.pop("_obj", None)
                infogetter_args["_obj"] = obj

                if deep_get(infogetter_args, DictPath("_pass_caller_obj")):
                    infogetter_args["caller_obj"] = copy.deepcopy(obj)
                else:
                    infogetter_args["caller_obj"] = {}

                extra_data = {}
                for key, value in deep_get(infogetter_args, DictPath("_extra_data"), {}).items():
                    if isinstance(value, list):
                        tmp = deep_get_with_fallback(obj, value)
                        extra_data[key] = tmp
                    else:
                        extra_data[key] = value
                infogetter_args["extra_data"] = extra_data
                infogetter_args["kubernetes_helper"] = kh
                infogetter_args["kh_cache"] = kh_cache
                info = infogetter(**infogetter_args)

                _listlen = uip.update_info(info)
                linelen = update_field_widths(field_dict, field_names, uip.info)
                uip.resize_listpad(linelen)
            elif logpad is not None:
                if deep_get(infoview_args, DictPath("decoder#override_decoder")):
                    decoder = deep_get(infoview_args, DictPath("decoder#decoder"))
                    if decoder is not None:
                        try:
                            decoded_obj = copy.deepcopy(base64.b64decode(obj).decode("utf-8"))
                        except (binascii.Error, TypeError, UnicodeDecodeError):
                            decoded_obj = obj
                else:
                    decoded_obj = obj

                if formatter is not None:
                    formatter_args = deep_get(infoview_args, DictPath("formatter_args"), {})
                    formatted_obj = formatter(decoded_obj, raw=raw_output, **formatter_args)
                else:
                    formatted_obj = decoded_obj

                infogetter = deep_get(viewref, DictPath("logpad#infogetter"))
                infogetter_args = deep_get(viewref, DictPath("logpad#infogetter_args"), {})
                infogetter_args["_show_raw"] = raw_output

                if infogetter is not None:
                    tmp = infogetter(formatted_obj, **infogetter_args)
                    if isinstance(tmp, tuple):
                        timestamps, facilities, severities, messages = tmp
                    else:
                        timestamps = []
                        facilities = None
                        severities = None
                        messages = tmp
                    uip.update_log_info(timestamps, facilities, severities, messages)
                    uip.loglen = len(messages)

        # Output listpad if we have one
        remember_uid = uip.remember_uid
        uip.remember_uid = False
        if listpad is not None:
            uip.update_sorted_list()
            if not uip.is_list_regenerated():
                generate_list_header(uip, headerpad, field_dict)
                # Output the visible part of the list
                uip.selected = None
                for y in range(uip.yoffset,
                               min(uip.yoffset + uip.mincurypos + uip.maxcurypos + 1, uip.listlen)):
                    item = uip.sorted_list[y]
                    uip.select_if_y(y, item)
                    generate_list_row(uip, listpad, item, field_dict, y - uip.yoffset,
                                      uip.is_selected(item))
                uip.list_needs_regeneration(False)
        uip.remember_uid = remember_uid

        # Output logpad if we have one
        if logpad is not None and uip.refresh:
            uip.logpad.erase()
            # This is needed in case we get a resize event or toggle borders
            uip.resize_logpad(uip.maxy - uip.logpadypos - 2, 0)
            maxx = 0
            yadd = 0

            tscount = 0
            for y in range(0, min(uip.logpadheight, len(messages))):
                facility = None
                if facilities is not None and uip.yoffset + y < len(facilities):
                    fac = facilities[uip.yoffset + y]

                    if fac:
                        if isinstance(fac, tuple):
                            fac0 = fac[0]
                            fac1 = fac[1]
                        else:
                            fac0 = fac
                            fac1 = ""

                        facility = []
                        facility_prefix_len = len(ThemeRef("separators", "facility_prefix"))
                        facility_ext_prefix_len = \
                            len(ThemeRef("separators", "facility_extended_prefix"))
                        facility_suffix_len = len(ThemeRef("separators", "facility_suffix"))
                        facility_ext_suffix_len = \
                            len(ThemeRef("separators", "facility_extended_suffix"))
                        if not fac0.strip():

                            facility += [ThemeStr("".ljust(facility_prefix_len),
                                                  ThemeAttr("logview", "facility")),
                                         ThemeStr(fac0, ThemeAttr("logview", "facility")),
                                         ThemeStr("".ljust(facility_suffix_len),
                                                  ThemeAttr("logview", "facility"))]
                        else:
                            facility += [ThemeRef("separators", "facility_prefix"),
                                         ThemeStr(fac0, ThemeAttr("logview", "facility")),
                                         ThemeRef("separators", "facility_suffix")]
                        if fac1:
                            if not fac1.strip():
                                facility += \
                                    [ThemeStr("".ljust(facility_ext_prefix_len),
                                              ThemeAttr("logview", "facility")),
                                     ThemeStr(fac1, ThemeAttr("types", "facility_extended")),
                                     ThemeStr("".ljust(facility_ext_suffix_len),
                                              ThemeAttr("logview", "facility"))]
                            else:
                                facility += \
                                    [ThemeRef("separators", "facility_extended_prefix"),
                                     ThemeStr(fac1, ThemeAttr("types", "facility_extended")),
                                     ThemeRef("separators", "facility_extended_suffix")]
                        facility += [ThemeRef("separators", "facility_padding")]

                if timestamps is None or uip.yoffset + y >= len(timestamps) \
                        or timestamps[uip.yoffset + y] == none_timestamp():
                    timestamp: str = "".ljust(uip.tspadwidth)
                else:
                    timestamp = str(timestamps[uip.yoffset + y]).ljust(uip.tspadwidth)
                    tscount += 1
                tsthemearray: list[ThemeRef | ThemeStr] = \
                    [ThemeStr(timestamp, ThemeAttr("logview", "timestamp"))]

                if severities is None or uip.yoffset + y >= len(severities):
                    severity = LogLevel.INFO
                else:
                    severity = severities[uip.yoffset + y]

                message = messages[uip.yoffset + y]
                if uip.search_matches:
                    line_match = uip.yoffset + y in uip.search_matches
                    match_prefix: list[ThemeRef | ThemeStr] = \
                        [ThemeRef("separators", "matchbullet")]
                    if not line_match:
                        match_prefix = \
                            [ThemeStr("".ljust(len(themearray_to_string(match_prefix))),
                                      ThemeAttr("types", "generic"))]
                    message = match_prefix + message
                if wrap_lines:
                    sideadjust = 0
                    if not uip.borders:
                        sideadjust = 2
                    maxwidth = uip.logpadminwidth + sideadjust
                else:
                    maxwidth = -1
                if isinstance(message, str):
                    message = [ThemeStr(message, color_log_severity(severity))]
                if facility is not None:
                    message = facility + message
                untruncated_len = themearray_len(message)
                max_untruncated_len = 16384
                if wrap_lines or untruncated_len < max_untruncated_len:
                    _lines = themearray_wrap_line(message, maxwidth,
                                                  wrap_marker=(uip.borders or get_mousemask() != 0))
                else:
                    _lines = [themearray_truncate(message, max_untruncated_len - 1)]
                    severity_name = f"severity_{loglevel_to_name(LogLevel.ERR).lower()}"
                    _lines.append([ThemeStr(f"Line too long ({untruncated_len} bytes); "
                                            f"truncated to {max_untruncated_len} bytes "
                                            "(Use line wrapping to see the entire message)",
                                            ThemeAttr("logview", severity_name))])

                for i, _line in enumerate(_lines):
                    if y + yadd + i >= uip.logpadheight:
                        break
                    if i == 0 and timestamps is not None and tscount:
                        uip.addthemearray(cast(curses.window, tspad), tsthemearray, y=y + yadd, x=0)
                    _ypos, xpos = uip.addthemearray(logpad, _line, y=y + yadd + i, x=0)
                    maxx = max(maxx, xpos)
                yadd += i
            uip.resize_logpad(-1, maxx)
            uip.update_window()

        uip.refresh_window()
        uip.refresh_infopad()
        uip.refresh_listpad()
        uip.refresh_logpad()
        uip.refresh_statusbar()
        curses.doupdate()
        uip.refresh = False

        # XXX: Handle initial containers and configmaps
        #      This should be done by the same code path as a regular activation;
        #      this solution is too ugly for words
        if initial_container is not None:
            match = None

            if uip.info:
                match_count = 0

                obj_path = deep_get(viewref, DictPath("listpad#on_activation#obj_path"))
                for item in uip.info:
                    # If we are dealing with a config map we are interested in non-binary types
                    # If we are dealing with a pod we are interested in containers
                    if hasattr(item, "type") and item.type in ("[container]", "[init_container]"):
                        name = item.ref["name"]
                        ikind = item.type
                    elif view == ("ConfigMap", "") \
                            and item.type in (rtype[4] for rtype in formatters.cmdata_format):
                        name = item.data
                        ikind = deep_get(viewref, DictPath("listpad#on_activation#kind"), "")
                        if isinstance(ikind, str):
                            iapi_family = \
                                deep_get(viewref, DictPath("listpad#on_activation#api_family"), "")
                            ikind = guess_kind((ikind, iapi_family))
                    else:
                        continue

                    # If name is not set we skip
                    if name is None:
                        continue

                    # If we have an exact match we do not care about partial matches
                    if name == initial_container:
                        if view == ("ConfigMap", ""):
                            match = item.data
                        else:
                            match = item.ref
                        match_count = 1
                        break

                    if name.startswith(initial_container):
                        # Since the exact match might occur later than the partial we cannot abort
                        # on partial matches; instead just save the match and continue searching.
                        # If we get more than one partial match we ignore the partial matches.
                        if match_count == 0:
                            if view == ("ConfigMap", ""):
                                match = item.data
                            else:
                                match = item.ref
                        match_count += 1

                initial_container = None

                if match is not None and match_count == 1:
                    on_activation_args = {}
                    formatter_path = deep_get(viewref,
                                              DictPath("listpad#on_activation#formatter_path"))
                    if deep_get(viewref,
                                DictPath("listpad#on_activation#formatter"), "") == "identify":
                        formatter = formatters.identify_formatter(None, kind=view,
                                                                  obj=obj, path=match)
                        on_activation_args["formatter"] = formatter
                    else:
                        formatter = deep_get(viewref, DictPath("listpad#on_activation#formatter"))
                        formatter_path = deep_get(viewref,
                                                  DictPath("listpad#on_activation#formatter_path"))
                        on_activation_args["formatter"] = formatter
                        on_activation_args["formatter_path"] = formatter_path
                    if view == ("ConfigMap", "") and callable(uip.activatedfun):
                        retval = uip.activatedfun(uip.stdscr,
                                                  deep_get(obj, DictPath(f"data#{match}"), ""),
                                                  ikind, info=None, title=name,
                                                  **on_activation_args)
                    elif callable(uip.activatedfun):
                        retval = uip.activatedfun(uip.stdscr, match, ikind, info=obj,
                                                  **on_activation_args)
                    if retval == Retval.RETURNFULL:
                        return retval
                    uip.force_update()
                    uip.refresh_all()
                    continue

        uip.stdscr.timeout(100)
        c = uip.stdscr.getch()
        retval = uip.generic_keycheck(c)

        if retval == Retval.MATCH:
            continue
        if retval == Retval.RETURNONE:
            return Retval.RETURNDONE
        if retval == Retval.RETURNFULL:
            return retval

        if c == curses.KEY_F2:
            if (retval := selectwindow(uip)) == Retval.RETURNFULL:
                return retval
            uip.refresh_all()
        elif c == curses.KEY_F3:
            if (retval := selectwindow(uip, refresh_apis=True)) == Retval.RETURNFULL:
                return retval
            uip.refresh_all()
        elif c == ord("B"):
            uip.toggle_borders()
            uip.refresh_all()
            uip.force_update()
        elif c == ord("W") and listpad is not None:
            if not field_indexes:
                continue

            _list = list(field_indexes.keys())
            _index = _list.index(field_index)
            field_index = _list[(_index + 1) % len(field_indexes)]

            fieldgenerator_args = {
                "field_index": field_index,
                "field_indexes": field_indexes,
                "fields": deep_get(viewref, DictPath("fields")),
                "denylist": [],
            }
            field_dict, field_names, sortcolumn, sortorder_reverse = \
                generators.fieldgenerator(view=view,
                                          selected_namespace=selected_namespace,
                                          **fieldgenerator_args)

            uip.reinit_window(field_list=field_dict, sortcolumn=sortcolumn)
            uip.resize_listpad(width=-1)
            uip.refresh_all()
            uip.force_update()
        elif c == ord("R") and logpad is not None:
            raw_output = not raw_output
            uip.refresh_all()
            uip.force_update()
        elif c == ord("W") and logpad is not None:
            wrap_lines = not wrap_lines
            uip.refresh_all()
            uip.force_update()
        elif c == ord("T"):
            uip.toggle_timestamps()
            uip.refresh_all()
            uip.force_update()

        for _key, sc_value in shortcuts.items():
            if (shortcut_keys := deep_get(sc_value, DictPath("shortcut"))) is None:
                continue

            if not isinstance(shortcut_keys, list):
                shortcut_keys = [shortcut_keys]

            if c not in shortcut_keys:
                continue

            widget = deep_get(sc_value, DictPath("widget"))
            force_update = deep_get(sc_value, DictPath("force_update"), True)
            tmpselection = None
            if widget is not None:
                if widget == "windowwidget":
                    w_title = deep_get(sc_value, DictPath("title"), "")
                    w_headers = deep_get(sc_value, DictPath("headers"))
                    if (w_itemgetter := deep_get(sc_value, DictPath("itemgetter"))) is None:
                        continue
                    w_itemgetter_args = deep_get(sc_value, DictPath("itemgetter_args"), {})
                    w_itemgetter_args["kubernetes_helper"] = kh
                    w_itemgetter_args["kh_cache"] = kh_cache
                    w_itemgetter_src = deep_get(w_itemgetter_args, DictPath("source"), "object")
                    w_selectable = deep_get(sc_value, DictPath("selectable"), False)
                    # w_kind = deep_get(sc_value, DictPath("kind"), view)
                    if "_slow_task_msg" in w_itemgetter_args:
                        _w_win = curses_helper.notice(uip.stdscr, uip.maxy // 2, uip.maxx // 2,
                                                      message=deep_get(w_itemgetter_args,
                                                                       DictPath("_slow_task_msg")))

                    if w_itemgetter_src == "selected":
                        selected = uip.get_selected()
                        if selected is not None:
                            w_ref = getattr(selected, "ref", None)
                            if w_ref is not None:
                                w_items = w_itemgetter(w_ref["ref"], **w_itemgetter_args)
                    else:
                        w_items = w_itemgetter(obj, **w_itemgetter_args)

                    # If the first element is an integer we assume that we've been provided
                    # a pre-formatted list. Otherwise we apply formatting if available.
                    # If not available we try to provide some sensible defaults.
                    if w_items is not None and w_items \
                            and (isinstance(w_items[0], dict)
                                 or (isinstance(w_items[0], (list, tuple))
                                     # pylint: disable-next=unidiomatic-typecheck
                                     and type(w_items[0][0]) != int)):  # noqa: E721
                        tmp_items = []
                        w_formatting = deep_get(sc_value, DictPath("formatting"),
                                                [ThemeAttr("windowwidget", "default")])
                        lineattrs = WidgetLineAttrs.NORMAL
                        # w_item is a line
                        for w_item in w_items:
                            ref = None
                            if isinstance(w_item, dict):
                                ref = deep_get(w_item, DictPath("ref"))
                                w_item = deep_get(w_item, DictPath("fields"))
                            # w_item[i] is a column
                            tmp = []
                            for i, column in enumerate(w_item):
                                tmp_formatting = w_formatting[min(i, len(w_formatting) - 1)]
                                if isinstance(tmp_formatting, list):
                                    formatting = ThemeAttr(tmp_formatting[0], tmp_formatting[1])
                                else:
                                    formatting = tmp_formatting
                                tmp.append([ThemeStr(column, formatting)])

                            tmp_items.append({
                                "lineattrs": lineattrs,
                                "columns": tmp,
                                "retval": ref,
                            })
                        w_items = tmp_items

                    if w_items is not None and w_items:
                        w_sortcolumn = deep_get(sc_value, DictPath("sortcolumn"))
                        tmpselection = \
                            curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                       uip.maxy // 2, uip.maxx // 2,
                                                       items=w_items, headers=w_headers,
                                                       title=w_title, cursor=w_selectable,
                                                       sortcolumn=w_sortcolumn)
                        if not tmpselection:
                            continue
                elif widget == "inputbox":
                    selected = uip.get_selected()
                    w_title = deep_get(sc_value, DictPath("inputtitle"), "")
                    if not (w_result := curses_helper.inputbox(uip.stdscr, title=w_title)):
                        continue
                    # This is necessary because we never go through
                    # the normal update cycle for the listpad and infopad
                    uip.refresh_infopad()
                    uip.refresh_listpad()
                    uip.refresh_logpad()
                    uip.refresh_statusbar()
                    curses.doupdate()
                    # Check this condition before confirming
                    w_confirm = deep_get(sc_value, DictPath("confirm"), False)
                    if isinstance(w_confirm, str):
                        if w_confirm == "path_exists":
                            w_confirm = os.path.exists(w_result)
                        else:
                            sys.exit("Unknown value for w_confirm; "
                                     "must be either boolean or path_exists")
                    if w_confirm:
                        curses.doupdate()
                        w_confirmtitle = deep_get(sc_value, DictPath("confirmtitle"))
                        if not curses_helper.confirmationbox(uip.stdscr,
                                                             title=w_confirmtitle, default=False):
                            continue
                elif widget == "command":
                    w_args = deep_get(sc_value, DictPath("widget_args"), {})
                    if "_pass_obj" in w_args:
                        w_args["obj"] = obj
                    elif "_pass_selected_obj" in w_args:
                        selected = uip.get_selected()
                        if selected is not None:
                            w_args["obj"] = getattr(selected, "ref")
                    do_command(uip.stdscr, **w_args)
                elif widget == "executecommand":
                    selected = uip.get_selected()
                    if (w_kinds := deep_get_with_fallback(sc_value,
                                                          [DictPath("widget_args#kinds"),
                                                           DictPath("kinds")])) is None:
                        continue
                    w_ref = None
                    if selected is not None:
                        w_ref = getattr(selected, "ref", None)
                    if w_kinds != ["<native>"] \
                            and [deep_get(w_ref, DictPath("kind"), ""),
                                 deep_get(w_ref, DictPath("api_group"), "")] not in w_kinds \
                            and w_kinds != [("", "")]:
                        continue

                    w_inputtitle = deep_get_with_fallback(sc_value,
                                                          [DictPath("widget_args#inputtitle"),
                                                           DictPath("inputtitle")])
                    if w_inputtitle is not None:
                        if not (w_input := curses_helper.inputbox(uip.stdscr, title=w_inputtitle)):
                            continue
                        w_command = w_input.split()
                    else:
                        w_command = deep_get_with_fallback(sc_value,
                                                           [DictPath("widget_args#command"),
                                                            DictPath("command")], [])
                    if not w_command:
                        continue

                    w_waitforkeypress = deep_get(sc_value,
                                                 DictPath("widget_args#wait_for_keypress"), False)
                    if not (w_kinds == ["<native>"] and w_command == ["<dnsutils>"]):
                        containername = deep_get(w_ref, DictPath("name"), "")
                    if w_command == ["<ephemeral>"]:
                        ephemeral_image = \
                            deep_get(cmtlib.cmtconfig, DictPath("Debug#ephemeral_image"), "busybox")
                        msg = [ANSIThemeStr("Creating ephemeral ", "action"),
                               ANSIThemeStr(ephemeral_image, "programname"),
                               ANSIThemeStr(" container sharing process namespace with ",
                                            "action"),
                               ANSIThemeStr(f"{containername}", "path")]
                    elif w_command == ["<dnsutils>"]:
                        node_name = deep_get(obj, DictPath("metadata#name"))
                        containername = None
                        msg = [ANSIThemeStr("Opening dnsutils container on ", "action"),
                               ANSIThemeStr(node_name, "hostname")]
                    else:
                        msg = [ANSIThemeStr("Executing ", "action"),
                               ANSIThemeStr(w_command[0], "programname"),
                               ANSIThemeStr(" inside ", "action"),
                               ANSIThemeStr(containername, "path")]
                    executecommand(uip.stdscr, obj, containername, msg,
                                   command=w_command, waitforkeypress=w_waitforkeypress)
            if "action" in sc_value:
                selected = uip.get_selected()
                action = deep_get(sc_value, DictPath("action"), "")
                if action == "from_ref":
                    ref = tmpselection
                    action = deep_get(ref, DictPath("action"))
                    action_call = deep_get(ref, DictPath("action_call"))
                    _action_call = deep_get(action_call_allowlist, DictPath(action_call))
                    if _action_call is None:
                        sys.exit(f"{action_call} is not in the action_call allow list")
                    action_call = _action_call
                    action_args = deep_get(ref, DictPath("action_args"), {})
                else:
                    action_call = deep_get(sc_value, DictPath("action_call"))
                    action_args = deep_get(sc_value, DictPath("action_args"), {})
                if "_pass_obj" in action_args:
                    action_args["obj"] = obj
                if "_pass_result" in action_args:
                    action_args["result"] = w_result
                if "_pass_selected" in action_args and selected is not None:
                    action_args["selected"] = selected
                if "_pass_selected_obj" in action_args and selected is not None:
                    action_args["selected_obj"] = getattr(selected, "ref", None)
                if "_parent_namespace_path" in action_args:
                    parent_namespace_path = \
                        deep_get(action_args, DictPath("_parent_namespace_path"))
                    action_args["_parent_namespace"] = \
                        deep_get(obj, DictPath(parent_namespace_path), "")
                if "_named_title" in action_args:
                    title = deep_get(action_args, DictPath("title"), "")
                    title_name = ""
                    if selected is not None:
                        ref = getattr(selected, "ref", None)
                    elif tmpselection is not None:
                        ref = tmpselection
                    if "_name_path" in action_args and ref is not None:
                        title_name_path = deep_get(action_args, DictPath("_name_path"), "")
                        title_name = deep_get(ref, DictPath(title_name_path), "")
                    elif "_name_tuple_paths" in action_args:
                        title_name_paths = deep_get(action_args, DictPath("_name_tuple_paths"), [])
                        title_name = deep_get_str_tuple_paths(cast(dict, ref), title_name_paths, "")
                    elif selected is not None:
                        title_name = getattr(selected, "name", "")
                    if title_name != "":
                        title_name = f" ({title_name})"
                    action_args["named_title"] = f"{title}{title_name}"

                if tmpselection is not None:
                    action_args["selection"] = tmpselection
                if action == "call" and action_call is not None:
                    retval = action_call(uip.stdscr, **action_args)
                    if retval is not None and retval == Retval.RETURNFULL:
                        return retval
                elif action == "toggle_var":
                    var = deep_get(action_args, DictPath("var"))
                    if var is not None:
                        tmp = deep_get(infoview_args, DictPath(var))
                        deep_set(infoview_args, DictPath(var), not tmp)
                elif action == "execute":
                    _command = deep_get(action_args, DictPath("command"), [])
                    # replace paths with data
                    if _command:
                        command = []
                        for _cmd in _command:
                            if isinstance(_cmd, list):
                                command.append(deep_get_with_fallback(obj, _cmd))
                            else:
                                command.append(_cmd)
                    # Check this condition before confirming
                    w_confirm = deep_get(sc_value, DictPath("confirm"), False)
                    if isinstance(w_confirm, str):
                        if w_confirm == "path_exists":
                            w_confirm = os.path.exists(w_result)
                        else:
                            sys.exit("Unknown value for w_confirm; "
                                     "must be either boolean or path_exists")
                    if w_confirm:
                        curses.doupdate()
                        w_confirmtitle = deep_get(sc_value, DictPath("confirmtitle"))
                        if not curses_helper.confirmationbox(uip.stdscr,
                                                             title=w_confirmtitle, default=False):
                            continue
                    _values = {}
                    _values = {
                        "action_args": {
                            "command": command,
                            "iterate": True,
                        }
                    }
                    items = [(deep_get(obj, DictPath("metadata#namespace"), ""),
                              deep_get(obj, DictPath("metadata#name")))]
                    action_execute_command(uip, items=items, action={},
                                           values=_values, kind=None, title="")
            else:
                call = deep_get(sc_value, DictPath("call"))
                call_name = None
                owner_references_path = deep_get(sc_value, DictPath("owner_references_path"))
                owner_references_kind = deep_get(sc_value, DictPath("owner_references_kind"))
                holder_identity_path = deep_get(sc_value, DictPath("holder_identity_path"))
                if owner_references_path is not None:
                    owner_reference = deep_get(obj, DictPath(owner_references_path), [])
                    if holder_identity_path is not None:
                        if not owner_reference:
                            continue
                        call_name = deep_get(obj, DictPath(holder_identity_path))
                        kind = get_holder_kind_from_owner_references(owner_reference, call_name)
                    elif owner_references_kind is not None:
                        call_name = get_name_by_kind_from_owner_references(owner_reference,
                                                                           owner_references_kind)
                        kind = owner_references_kind
                    else:
                        kind, call_name = get_controller_from_owner_references(owner_reference)
                    if kind == ("", "") or not call_name:
                        continue
                else:
                    call_name_path = deep_get(sc_value, DictPath("name_path"))
                    if (kind := deep_get(sc_value, DictPath("kind"))) is None:
                        kind_path = deep_get(value, DictPath("kind_path"), "")
                        if isinstance(kind_path, tuple):
                            kind = (deep_get(obj, DictPath(kind_path[0])),
                                    deep_get(obj, DictPath(kind_path[1])))
                        else:
                            kind = deep_get(obj, DictPath(kind_path))
                    if call_name_path is not None:
                        call_name = deep_get(obj, DictPath(call_name_path))

                call_namespace = ""
                call_namespace_path = deep_get(sc_value, DictPath("namespace_path"))
                if call_namespace_path is not None:
                    call_namespace = deep_get(obj, DictPath(call_namespace_path))

                if call is not None and call_name is not None:
                    if kind is None or kind == ("", ""):
                        retval = call(uip.stdscr, **{"selected": call_name})
                        if retval is not None and retval == Retval.RETURNFULL:
                            return retval
                    elif kind:
                        if isinstance(kind, str):
                            kind = guess_kind(kind)
                        ref = kh.get_ref_by_kind_name_namespace(kind, call_name, call_namespace,
                                                                resource_cache=kh_cache)
                        retval = call(uip.stdscr, ref, kind)
                        if retval is not None and retval == Retval.RETURNFULL:
                            return retval
            if force_update:
                uip.force_update()


def eventdispatch(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Dispatch from an event to the infoview of an involved object;
    this could probably be achieved using the regular dispatcher.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict): The object to get information from
                kind_path (DictPath): The path to get the kind from
                api_version_path (DictPath): The path to get the API-version from
                name_path (DictPath): The path to get name from
                namespace_path (DictPath): The path to get namespace from
        Returns:
            (Retval): Retval.RETURNDONE if no match was found, otherwise
                      Retval from the involved object whenever that returns.
    """
    obj = deep_get(kwargs, DictPath("obj"))
    if obj is None:
        return Retval.RETURNDONE

    kind_path = deep_get(kwargs, DictPath("kind_path"))
    kind = deep_get_with_fallback(obj, kind_path)
    # In some cases we don't get a kind from involvedObject/regarding;
    # just return, otherwise we'll crash in guess_kind().
    if kind is None:
        return Retval.RETURNDONE
    api_version_path = deep_get(kwargs, DictPath("api_version_path"))
    api_version = deep_get_with_fallback(obj, api_version_path, "")
    # Is this a core API?
    if "/" not in api_version:
        api_family = ""
    else:
        api_family = api_version.split("/")[0]
    kind = (kind, api_family)

    name_path = deep_get(kwargs, DictPath("name_path"))
    name = deep_get_with_fallback(obj, name_path)
    namespace_path = deep_get(kwargs, DictPath("namespace_path"))
    namespace = deep_get_with_fallback(obj, namespace_path + ["metadata#namespace"], "")
    ref = kh.get_ref_by_kind_name_namespace(kind, name, namespace, resource_cache=kh_cache)
    return resourceinfodispatch(stdscr, ref, kind)


# pylint: disable-next=too-many-arguments,too-many-positional-arguments
def log_add_line(timestamps: list[datetime], facilities: list[str],
                 severities: list[LogLevel], messages: list[list[ThemeRef | ThemeStr] | str],
                 timestamp: Optional[datetime], facility: str,
                 severity: LogLevel, message: list[ThemeRef | ThemeStr],
                 facility_extended: list[ThemeRef | ThemeStr]) \
        -> tuple[list[datetime], list[str], list[LogLevel], list[list[ThemeRef | ThemeStr] | str]]:
    """
    Add a new line to the log.

        Parameters:
            timestamps ([datetime]): The list of timestamps
            facilities ([str]): The list of facilities
            severities ([LogLevel]): The list of severities
            messages ([[ThemeRef | ThemeStr] | str]): The list of log messages
            timestamp (Optional[datetime]): The timestamp of the message to add
            facility ([str]): The facility of the message to add
            severity ([LogLevel]): The severity of the message to add
            message ([ThemeRef | ThemeStr] | str): The message to add
            facility_extended ([ThemeRef | ThemeStr): A formatted facility;
                                                      used in podlog-viewer
        Returns:
            (([datetime], [str], [LogLevel], [ThemeRef | ThemeStr])):
                ([datetime]): The updated list of timestamps
                ([str]): The updated list of facilities
                ([LogLevel]): The updated list of severities
                ([[ThemeRef | ThemeStr] | str]): The updated list of log messages
    """
    if timestamp is not None and timestamp != none_timestamp():
        timestamps.append(timestamp.astimezone())
    else:
        timestamps.append(none_timestamp())
    if facility_extended is None:
        facilities.append(facility)
    else:
        facilities.append((facility_extended, facility))
    severities.append(severity)
    messages.append(message)

    return timestamps, facilities, severities, messages


# noqa: E501 pylint: disable-next=too-many-locals,too-many-branches,too-many-statements,too-many-return-statements
def containerinfoloop(stdscr: curses.window, container, kind, obj, **kwargs: Any) -> Retval:
    global executor  # pylint: disable=global-statement
    global override_tail_lines  # pylint: disable=global-statement

    # Just in case there are leftover futures from other views
    executor.shutdown()
    executor = reexecutor.ReExecutor()

    multilog_containers_full = deep_get(kwargs, DictPath("multilog_containers_full"), [])
    multilog_containers = deep_get(kwargs, DictPath("multilog_containers"), [])
    all_same_namespace = deep_get(kwargs, DictPath("all_same_namespace"), False)
    multilog_prefix = ["namespace", "podname", "container"]
    facility_extended = None

    uip = UIProps(stdscr)

    helptext = format_helptext(helptexts.containerinfo)
    uip.init_window(windowheader="Container Info", helptext=helptext)

    # For generic information
    infopad = uip.init_infopad(height=7, width=-1, ypos=1, xpos=1)

    # For the pod log
    tspad, logpad = uip.init_logpad(width=-1, ypos=9, xpos=1)

    # For the status bar; position is always at the bottom of the screen
    # and the entire width of the screen
    statusbar = uip.init_statusbar()

    # Number of lines of log to show by default
    if override_tail_lines is None:
        override_tail_lines = deep_get(cmtlib.cmtconfig,
                                       DictPath("Pod#logsize"), DEFAULT_TAIL_LINES)

    tail_lines = override_tail_lines

    uip.continuous_log = False
    merge_repeats = deep_get(cmtlib.cmtconfig, DictPath("Pod#merge_repeated_messages"), False)
    saved_merge_repeats = merge_repeats
    raw_logs = False
    tmp_log_level = deep_get(cmtlib.cmtconfig, DictPath("Pod#loglevel"), "Info")
    log_level = name_to_loglevel(tmp_log_level)
    show_borders = deep_get(cmtlib.cmtconfig, DictPath("Pod#show_borders"), True)
    uip.toggle_borders(show_borders)
    show_timestamps = deep_get(cmtlib.cmtconfig, DictPath("Pod#show_timestamps"), True)
    uip.toggle_timestamps(show_timestamps)
    wrap_lines = False
    # Show severity as text
    severity_prefix = deep_get(cmtlib.cmtconfig, DictPath("Pod#severity_prefix"), [])
    # Backwards compatibility
    # pylint: disable-next=unidiomatic-typecheck
    if type(severity_prefix) == bool:  # noqa: E721
        if not severity_prefix:
            severity_prefix = []
        else:
            severity_prefix = ["[", "4LETTER", "] "]

    # This decides whether or not compound log messages,
    # such as Python dicts and JSON, should be expanded
    fold_msg = deep_get(cmtlib.cmtconfig, DictPath("Pod#fold_msg"), True)
    saved_fold_msg = fold_msg

    # This decides whether or not to show the facility,
    # and if so how it is to be displayed
    show_facility = deep_get(cmtlib.cmtconfig, DictPath("Pod#show_facility"), "Full")
    override_parser = None
    _parser = None

    uip.update_window()
    uip.force_update()
    uip.refresh_window()
    uip.refresh_statusbar()
    curses.doupdate()

    facility_regex: re.Pattern[str] = re.compile(r"^.*/(.*)")

    # pylint: disable-next=too-many-nested-blocks
    while True:
        if uip.is_update_triggered():
            # When following the log we update the log continuously, but tail lines is limited to
            # the number of lines that fits on the screen, and cursor movements are disabled; as
            # soon as the user presses a key the log will stop scrolling and the whole log
            # (default number of tail lines) will be loaded
            if uip.continuous_log:
                tail_lines = uip.logpadheight

            if not multilog_containers:
                pod_info = infogetters.get_pod_info(**{"vlist": [obj]}, kubernetes_helper=kh,
                                                    kh_cache=kh_cache)[0]
                podname = pod_info.name
                namespace = pod_info.namespace
                containername = deep_get(container, DictPath("name"))

                if kind == ("InitContainer", ""):
                    src_statuses = \
                        deep_get(pod_info.ref, DictPath("status#initContainerStatuses"), [])
                    container_type = "init_container"
                else:
                    src_statuses = \
                        deep_get(pod_info.ref, DictPath("status#containerStatuses"), [])
                    container_type = "container"
                container_status = None
                for container_status in src_statuses:
                    if deep_get(container_status, DictPath("name")) == containername:
                        break
                if container_status is not None:
                    image_id = deep_get(container_status, DictPath("imageID"), "")
                    image = deep_get(container_status, DictPath("image"), "")
                    if image.startswith("sha256:"):
                        image = image_id
                else:
                    image = "<unavailable>"

            # We do not want the "Fetching Log" notification every few seconds;
            # we are just loading a few lines...
            if not uip.continuous_log:
                notice = curses_helper.notice(None, y=uip.maxy // 2, x=uip.maxx // 2,
                                              message="Fetching log")
            if not multilog_containers:
                rawmsg, internal_error = \
                    get_pod_log_by_name_namespace_container(podname, namespace, containername,
                                                            tail_lines=tail_lines)
                splitmsg = split_msg(rawmsg)
            else:
                container_type = "container"
                splitmsg = []
                image_id = None
                for namespace, podname, containername, image_id in multilog_containers_full:
                    if len(multilog_containers) == 1:
                        facility_extended = None
                    elif multilog_prefix == ["container"]:
                        facility_extended = [
                            ThemeRef("separators", "facility_extended_prefix"),
                            ThemeStr(f"{containername}",
                                     ThemeAttr("types", "facility_extended")),
                            ThemeRef("separators", "facility_extended_suffix"),
                        ]
                    elif multilog_prefix == ["podname", "container"] \
                            or multilog_prefix == ["namespace", "podname", "container"] \
                            and all_same_namespace:
                        facility_extended = [
                            ThemeRef("separators", "facility_extended_prefix"),
                            ThemeStr(f"{podname}", ThemeAttr("types", "facility_extended")),
                            ThemeRef("separators", "container"),
                            ThemeStr(f"{containername}",
                                     ThemeAttr("types", "facility_extended")),
                            ThemeRef("separators", "facility_extended_suffix"),
                        ]
                    elif multilog_prefix == ["namespace", "podname", "container"]:
                        facility_extended = [
                            ThemeRef("separators", "facility_extended_prefix"),
                            ThemeStr(f"{namespace}", ThemeAttr("types", "facility_extended")),
                            ThemeRef("separators", "namespace"),
                            ThemeStr(f"{podname}", ThemeAttr("types", "facility_extended")),
                            ThemeRef("separators", "container"),
                            ThemeStr(f"{containername}",
                                     ThemeAttr("types", "facility_extended")),
                            ThemeRef("separators", "facility_extended_suffix"),
                        ]
                    rawmsg, internal_error = \
                        get_pod_log_by_name_namespace_container(podname, namespace, containername,
                                                                tail_lines=tail_lines)
                    if internal_error:
                        splitmsg = split_msg(rawmsg)
                        break
                    # Now we have one per line; now we need to add
                    # (podname, containername, image, facility_extended) to each line,
                    # to allow the logparser to function without guessing
                    for line in split_msg(rawmsg):
                        splitmsg.append((line, podname, containername, image_id, facility_extended))
                splitmsg = natsorted(splitmsg, key=itemgetter(0))

            if not uip.continuous_log:
                del notice
            uip.refresh_window()
            uip.refresh_infopad()
            uip.refresh_logpad()
            uip.refresh_statusbar()
            curses.doupdate()

            timestamps: list[datetime] = []
            facilities: list[str] = []
            severities: list[LogLevel] = []
            messages: list[list[ThemeRef | ThemeStr] | str] = []
            parser = None
            prev_timestamp = None
            prev_facility = ""
            prev_severity = LogLevel.INFO
            prev_message = [ThemeStr("", ThemeAttr("types", "generic"))]
            prev_remnants = None
            repeat_count = 0

            total_msgs = 0
            hidden_msgs = 0
            merged_lines = 0

            linecount = len(splitmsg)
            linepercent = int(linecount * 0.1)

            progressbar = None
            if linecount > 1000:
                progressbar = curses_helper.progressbar(None, y=uip.maxy // 2, minx=(uip.minx + 8),
                                                        maxx=(uip.maxx - 8), progress=0,
                                                        title="Parsing log")

            i = 0
            while i < len(splitmsg):
                _line = splitmsg[i]

                # We probably need a progress bar once we reach this many lines
                if linecount > 1000 and (i % linepercent) == 0:
                    curses_helper.progressbar(progressbar, y=uip.maxy // 2, minx=(uip.minx + 8),
                                              maxx=(uip.maxx - 8),
                                              progress=100 - 100 * ((linecount - i) // linecount))
                    progressbar.timeout(10)
                    c = progressbar.getch()
                    if c == 27:  # ESCAPE
                        return Retval.RETURNDONE

                if isinstance(_line, tuple):
                    line, podname, containername, image, facility_extended = _line
                    # We need to identify parser again and again and again for every line
                    _parser = None
                else:
                    line = _line
                if internal_error:
                    timestamp_, facility, severity, message, remnants, parser, _parser = \
                        logparser("internal_error", "", "", message=line,
                                  container_type=container_type, line=i)
                elif raw_logs:
                    timestamp_, facility, severity, message, remnants, parser, _parser = \
                        logparser("raw", "", "", message=line,
                                  container_type=container_type, line=i)
                elif override_parser is not None or _parser is None or parser is None:
                    timestamp_, facility, severity, message, remnants, parser, _parser = \
                        logparser(podname, containername, image, message=line, fold_msg=fold_msg,
                                  override_parser=override_parser,
                                  container_type=container_type, line=i)
                else:
                    timestamp_, facility, severity, message, remnants = \
                        logparser_initialised(parser=_parser, message=line,
                                              fold_msg=fold_msg, line=i)

                i += 1

                # In some cases rather than expanding a single line into multiple lines,
                # we want to parse multiple lines as a single block;
                # we signal this by returning message == ["start_block", processor],
                # then continue parsing until we either get ["end_block", *],
                # ["break", *], or reach the end of the file
                if isinstance(message, tuple) and message[0] == "start_block" and not raw_logs:
                    _logentries = [(timestamp_, facility, severity, remnants)]
                    processor = message
                    options = processor[2]
                    _block_state = "none"
                    for j in range(i, len(splitmsg)):
                        if not callable(processor[1]):
                            raise ProgrammingError(f"processor: {processor} does not "
                                                   "contain a valid processor")
                        processor, _logentry = \
                            processor[1](splitmsg[j], fold_msg=fold_msg, options=options)
                        _block_state = processor[0]
                        if _block_state != "end_block_not_processed":
                            _logentries.append(_logentry)

                        if _block_state in ("end_block", "end_block_not_processed"):
                            # OK, we've got a block; start by appending the first line
                            if _logentries:
                                timestamps, facilities, severities, messages = \
                                    log_add_line(timestamps, facilities, severities, messages,
                                                 timestamp_, facility, severity,
                                                 _logentries[0][3], facility_extended)
                            if len(_logentries) > 1:
                                for _timestamp, _facility, _severity, _message in _logentries[1:]:
                                    timestamps, facilities, severities, messages = \
                                        log_add_line(timestamps, facilities, severities, messages,
                                                     _timestamp, "".ljust(len(facility)), severity,
                                                     _message, facility_extended)
                                break
                        elif _block_state == "break":
                            # We got something indicating that this is not a valid block; abort
                            break
                    else:
                        if _logentries \
                                and deep_get(options, DictPath("eof"), "break") == "end_block":
                            for _timestamp, _facility, _severity, _message in _logentries:
                                timestamps, facilities, severities, messages = \
                                    log_add_line(timestamps, facilities, severities, messages,
                                                 _timestamp, "".ljust(len(facility)), severity,
                                                 _message, facility_extended)
                            _block_state = "end_block"
                        else:
                            _block_state = "break"

                    if _block_state == "end_block":
                        # We got a block and it has been appended, so go on
                        i = j + 1
                        continue

                    if _block_state == "end_block_not_processed":
                        # We got a block and it has been appended,
                        # but the last line needs processing again
                        i = j
                        continue

                    message = remnants
                    remnants = None

                total_msgs += 1

                if severity > log_level:
                    hidden_msgs += 1
                    continue

                # pylint: disable-next=too-many-boolean-expressions
                if prev_message == message \
                        and prev_facility == facility \
                        and prev_severity == severity \
                        and (themearray_len(prev_message) or prev_remnants is not None) \
                        and prev_remnants == remnants:
                    repeat_count += 1
                    prev_timestamp = timestamp_
                    if merge_repeats:
                        merged_lines += 1
                        continue
                else:
                    if repeat_count and merge_repeats:
                        timestamps, facilities, severities, messages = \
                            log_add_line(timestamps, facilities, severities, messages,
                                         prev_timestamp, prev_facility, prev_severity,
                                         [ThemeStr("[previous message repeated ",
                                                   color_log_severity(prev_severity)),
                                          ThemeStr(f"{repeat_count}",
                                                   ThemeAttr("logview", "repeat_count")),
                                          ThemeStr(" times]",
                                                   color_log_severity(prev_severity))],
                                         facility_extended)
                    repeat_count = 0
                    prev_timestamp = timestamp_
                    prev_facility = facility
                    prev_severity = severity
                    prev_message = message
                    prev_remnants = remnants

                timestamps, facilities, severities, messages = \
                    log_add_line(timestamps, facilities, severities, messages, timestamp_,
                                 facility, severity, message, facility_extended)

                if remnants is not None and remnants:
                    # Remnants are used for unfolding multi-line messages that have been
                    # folded into one, such as YAML/JSON, etc.
                    #
                    # Remnants can, for the time being, be either:
                    # (list of string, severity)
                    # (string(newline separated strings), severity)
                    # or
                    # [(string, severity), ...]
                    if isinstance(remnants, tuple):
                        tmpmessages, severity = remnants
                        if isinstance(tmpmessages, list):
                            tmpmsg = tmpmessages
                        else:
                            tmpmsg = tmpmessages.split("\n")

                        for message in tmpmsg:
                            timestamps, facilities, severities, messages = \
                                log_add_line(timestamps, facilities, severities, messages, None,
                                             "".ljust(len(facility)), severity, message,
                                             facility_extended)
                    else:
                        for message, severity in remnants:
                            timestamps, facilities, severities, messages = \
                                log_add_line(timestamps, facilities, severities, messages, None,
                                             "".ljust(len(facility)), severity, message,
                                             facility_extended)

            # The data in some fields might become shorter, so we need to trigger a clear
            uip.infopad.erase()
            uip.statusbar.erase()

            del progressbar

            # If the last message in the log is a repeat we need to add the repeat signature
            if repeat_count and merge_repeats:
                timestamps, facilities, severities, messages = \
                    log_add_line(timestamps, facilities, severities, messages, prev_timestamp,
                                 prev_facility, prev_severity,
                                 [ThemeStr("[previous message repeated ",
                                           color_log_severity(prev_severity)),
                                  ThemeStr(f"{repeat_count}",
                                           ThemeAttr("logview", "repeat_count")),
                                  ThemeStr(" times]", color_log_severity(prev_severity))],
                                 facility_extended)

            uip.update_log_info(timestamps, facilities, severities, messages)
            uip.loglen = len(messages)
            uip.update_window()

            if not multilog_containers:
                containertypearray = f" [Type: {kind[0]}]"
                if kind == ("InitContainer", ""):
                    src_statuses = deep_get(pod_info.ref, DictPath("status#initContainerStatuses"))
                else:
                    src_statuses = deep_get(pod_info.ref, DictPath("status#containerStatuses"))

                if src_statuses is None or not src_statuses:
                    break

                for container_status in src_statuses:
                    if deep_get(container_status, DictPath("name")) == containername:
                        break

                status, status_group, restarts, message, _age = \
                    datagetters.get_container_status(src_statuses, containername)
                containerarray: list[ThemeRef | ThemeStr] = [
                    ThemeStr("Container: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{containername}{containertypearray}", ThemeAttr("types", "generic"))
                ]
                statusarray: list[ThemeRef | ThemeStr] = [
                    ThemeStr("Status: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{status}", color_status_group(status_group))
                ]
                if message != "":
                    statusarray.append(ThemeStr(f" ({message})", ThemeAttr("types", "generic")))
                restartsarray: list[ThemeRef | ThemeStr] = [
                    ThemeStr("Restarts: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{restarts}", ThemeAttr("types", "numerical"))
                ]
                podarray: list[ThemeRef | ThemeStr] = [
                    ThemeStr("Pod: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{pod_info.name}", ThemeAttr("types", "generic")),
                ]
                containeridarray: list[ThemeRef | ThemeStr] = [
                    ThemeStr("Container ID: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{deep_get(container_status, DictPath('containerID'))}",
                             ThemeAttr("types", "generic")),
                ]
                image_name, image_version = \
                    get_image_tuple(deep_get(container_status, DictPath("image")))
                imagearray: list[ThemeRef | ThemeStr] = [
                    ThemeStr("Image: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{image_name}", ThemeAttr("types", "generic")),
                    ThemeRef("separators", "version"),
                    ThemeStr(f"{image_version}", ThemeAttr("types", "version")),
                ]
                image_id = deep_get(container_status, DictPath("imageID"))
                imageidarray: list[ThemeRef | ThemeStr] = [
                    ThemeStr("I", ThemeAttr("main", "infoheader_shortcut")),
                    ThemeStr("mage ID: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{image_id}", ThemeAttr("types", "generic")),
                ]
                uip.addthemearray(infopad, containerarray, y=0, x=0)
                uip.addthemearray(infopad, statusarray, y=1, x=0)
                uip.addthemearray(infopad, restartsarray, y=2, x=0)
                uip.addthemearray(infopad, podarray, y=3, x=0)
                uip.addthemearray(infopad, containeridarray, y=4, x=0)
                uip.addthemearray(infopad, imagearray, y=5, x=0)
                uip.addthemearray(infopad, imageidarray, y=6, x=0)
            else:
                if len(multilog_containers) == 1:
                    containerarray = [
                        ThemeStr("Container: ", ThemeAttr("main", "infoheader")),
                        ThemeStr(f"{containername}", ThemeAttr("types", "generic")),
                    ]
                    podarray = [
                        ThemeStr("Pod: ", ThemeAttr("main", "infoheader")),
                        ThemeStr(f"{podname}", ThemeAttr("types", "generic")),
                    ]
                    namespacearray: list[ThemeRef | ThemeStr] = [
                        ThemeStr("Namespace: ", ThemeAttr("main", "infoheader")),
                        ThemeStr(f"{namespace}", ThemeAttr("types", "namespace")),
                    ]
                    containeridarray = [
                        ThemeStr("I", ThemeAttr("main", "infoheader_shortcut")),
                        ThemeStr("mage ID: ", ThemeAttr("main", "infoheader")),
                        ThemeStr(f"{image_id}", ThemeAttr("types", "generic")),
                    ]
                    uip.addthemearray(infopad, podarray, y=1, x=0)
                    uip.addthemearray(infopad, namespacearray, y=2, x=0)
                    uip.addthemearray(infopad, containeridarray, y=3, x=0)
                else:
                    containerarray = [
                        ThemeStr("Containers: ", ThemeAttr("main", "infoheader")),
                    ]
                    containerarray += \
                        generators.format_list(multilog_containers, 0, 0,
                                               field_colors=[
                                                   ThemeAttr("types", "namespace"),
                                                   ThemeAttr("types", "generic"),
                                                   ThemeAttr("types", "generic")
                                               ],
                                               field_separators=[
                                                   ThemeRef("separators", "namespace"),
                                                   ThemeRef("separators", "container")
                                               ],
                                               ellipsise=3)
                    if all_same_namespace:
                        namespacearray = [
                            ThemeStr("Namespace: ", ThemeAttr("main", "infoheader")),
                            ThemeStr(f"{namespace}", ThemeAttr("types", "namespace")),
                        ]
                        uip.addthemearray(infopad, namespacearray, y=1, x=0)
                uip.addthemearray(infopad, containerarray, y=0, x=0)

            uip.refresh = True

        if uip.refresh:
            # FIXME: the status stuff should be done by curses_helper
            uip.statusbar.erase()

            if uip.continuous_log:
                interval = "Follow"
            else:
                interval = "Manual"

            if tail_lines == sys.maxsize:
                loglimit = "Unlimited"
            else:
                loglimit = f"{tail_lines}"

            loglevel_str = loglevel_to_name(log_level)

            # We have two different widths of the statusbar
            if uip.maxx - uip.minx > 108:
                # Wide version
                statusarray1: list[ThemeRef | ThemeStr] = [
                    ThemeStr("Updates: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{interval}", ThemeAttr("statusbar", "highlight")),
                    ThemeRef("separators", "statusbar"),
                    ThemeStr("Loglvl: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{loglevel_str}", ThemeAttr("statusbar", "highlight")),
                    ThemeRef("separators", "statusbar"),
                    ThemeStr("Log length: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{uip.loglen} ", ThemeAttr("statusbar", "highlight")),
                    ThemeStr("lines (", ThemeAttr("statusbar", "default")),
                ]
                if hidden_msgs:
                    statusarray1 += [
                        ThemeStr(f"{hidden_msgs}", ThemeAttr("statusbar", "highlight")),
                        ThemeStr(" messages hidden)", ThemeAttr("statusbar", "dim")),
                        ThemeStr("; ", ThemeAttr("statusbar", "default")),
                    ]
                statusarray1 += [
                    ThemeStr("limit: ", ThemeAttr("statusbar", "default")),
                    ThemeStr(f"{loglimit}", ThemeAttr("statusbar", "highlight")),
                    ThemeStr(")", ThemeAttr("statusbar", "default")),
                ]
                statusarray2: list[ThemeRef | ThemeStr] = []
                if not fold_msg:
                    statusarray2 += [
                        ThemeStr("Unfolding messages", ThemeAttr("statusbar", "highlight")),
                        ThemeRef("separators", "statusbar"),
                    ]
                if merge_repeats:
                    statusarray2 += [
                        ThemeStr("Repeats merged", ThemeAttr("statusbar", "highlight")),
                        ThemeRef("separators", "statusbar"),
                    ]

                statusarray2 += [
                    ThemeStr("Facility: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{show_facility}", ThemeAttr("statusbar", "highlight")),
                    ThemeRef("separators", "statusbar"),
                    ThemeStr("Format: ", ThemeAttr("statusbar", "infoheader")),
                ]
            else:
                # Compact version
                statusarray1 = [
                    ThemeStr("Updates: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{interval}", ThemeAttr("statusbar", "highlight")),
                    ThemeRef("separators", "statusbar_compact"),
                    ThemeStr("Loglvl: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{loglevel_str}", ThemeAttr("statusbar", "highlight")),
                    ThemeRef("separators", "statusbar_compact"),
                    ThemeStr(f"{uip.loglen} ", ThemeAttr("statusbar", "highlight")),
                    ThemeStr("lines (", ThemeAttr("statusbar", "default")),
                ]
                if hidden_msgs:
                    statusarray1 += [
                        ThemeStr(f"{hidden_msgs}", ThemeAttr("statusbar", "highlight")),
                        ThemeStr(" hidden", ThemeAttr("statusbar", "dim")),
                        ThemeStr("; ", ThemeAttr("statusbar", "default")),
                    ]
                statusarray1 += [
                    ThemeStr("max: ", ThemeAttr("statusbar", "default")),
                    ThemeStr(f"{loglimit}", ThemeAttr("statusbar", "highlight")),
                    ThemeStr(")", ThemeAttr("statusbar", "default")),
                ]
                statusarray2 = [
                ]
                if not fold_msg:
                    statusarray2 += [
                        ThemeStr("Unfolding", ThemeAttr("statusbar", "highlight")),
                        ThemeRef("separators", "statusbar_compact"),
                    ]
                if merge_repeats:
                    statusarray2 += [
                        ThemeStr("Repeats merged", ThemeAttr("statusbar", "highlight")),
                        ThemeRef("separators", "statusbar_compact"),
                    ]

                statusarray2 += [
                    ThemeStr("Facility: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{show_facility}", ThemeAttr("statusbar", "highlight")),
                    ThemeRef("separators", "statusbar_compact"),
                    ThemeStr("Format: ", ThemeAttr("statusbar", "infoheader")),
                ]

            if not rawmsg:
                statusarray2 += [
                    ThemeStr("Empty", ThemeAttr("main", "format_empty")),
                ]
            elif parser is None or parser[0] == "unknown":
                statusarray2 += [
                    ThemeStr("Unknown", ThemeAttr("main", "format_unknown")),
                ]
            elif raw_logs:
                statusarray2 += [
                    ThemeStr("Raw", ThemeAttr("main", "format_raw")),
                ]
            else:
                if uip.maxx - uip.minx > 118:
                    statusarray2 += [
                        ThemeStr(f"{parser[0]}:{parser[1]}", ThemeAttr("statusbar", "highlight")),
                    ]
                else:
                    statusarray2 += [
                        ThemeStr(f"{parser[0]}", ThemeAttr("statusbar", "highlight")),
                    ]
                if uip.maxx - uip.minx > 128 and LogparserConfiguration.using_bundles:
                    statusarray2 += [
                        ThemeStr(" (Bundle)", ThemeAttr("statusbar", "dim")),
                    ]

            uip.addthemearray(statusbar, statusarray1, y=0, x=0)
            uip.addthemearray(statusbar, statusarray2, y=1, x=0)

            maxlen = 0
            latest_facility_len = -1

            uip.tspad.erase()
            uip.logpad.erase()
            # This is needed in case we get a resize event or toggle borders
            uip.resize_logpad(uip.maxy - uip.logpadypos - 2, 0)
            yadd = 0
            timestamp: str = ""
            tscount = 0
            for y in range(0, min(uip.logpadheight, uip.loglen)):
                if timestamps is None or uip.yoffset + y >= len(timestamps) \
                        or timestamps[uip.yoffset + y] == none_timestamp():
                    timestamp = "".ljust(uip.tspadwidth)
                else:
                    timestamp = str(timestamps[uip.yoffset + y]).ljust(uip.tspadwidth)
                    tscount += 1

                if y + yadd > uip.logpadheight:
                    continue

                tsthemearray: list[ThemeRef | ThemeStr] = \
                    [ThemeStr(timestamp, ThemeAttr("logview", "timestamp"))]

                if show_facility == "None" or uip.yoffset + y >= len(facilities):
                    facility_extended = ""
                    facility = ""
                elif show_facility == "Short":
                    _facility = facilities[uip.yoffset + y]
                    if isinstance(_facility, tuple):
                        facility_extended, _facility = _facility
                    if _facility is None:
                        _facility = ""
                    tmp = facility_regex.match(_facility)
                    if tmp is not None:
                        facility = tmp[1]
                        latest_facility_len = len(facility)
                    elif len(_facility.strip()) != len(_facility) and not _facility.strip():
                        if latest_facility_len == -1:
                            facility = _facility
                        else:
                            facility = _facility[0:latest_facility_len]
                    else:
                        facility = _facility
                else:
                    facility = facilities[uip.yoffset + y]
                    if isinstance(facility, tuple):
                        facility_extended, facility = facility
                    if facility is None:
                        facility = ""

                if uip.yoffset + y >= len(severities):
                    severity = LogLevel.INFO
                else:
                    severity = severities[uip.yoffset + y]

                msgstrarray: list[ThemeRef | ThemeStr] = []

                if severity_prefix:
                    _prefix, _severity_type, _suffix = severity_prefix
                    if _severity_type.lower() == "letter":
                        _severity_str = lvl_to_letter_severity(severity)
                    elif _severity_type.lower() == "4letter":
                        _severity_str = lvl_to_4letter_severity(severity)
                    elif _severity_type.lower() == "full":
                        _severity_str = lvl_to_word_severity(severity)

                    if _severity_type.startswith(("LE", "4LE", "FU")):
                        _severity_str = f"{_prefix}{_severity_str.upper()}{_suffix}"
                    elif _severity_type.startswith(("Le", "4Le", "Fu")):
                        _severity_str = f"{_prefix}{_severity_str.capitalize()}{_suffix}"
                    else:
                        _severity_str = f"{_prefix}{_severity_str.lower()}{_suffix}"

                    if timestamp.strip() or y >= len(timestamps):
                        msgstrarray.append(ThemeStr(f"{_severity_str}",
                                                    color_log_severity(severity)))
                    else:
                        msgstrarray.append(ThemeStr("".ljust(len(f"{_severity_str}")),
                                                    color_log_severity(severity)))

                if facility_extended is not None and facility_extended:
                    msgstrarray += facility_extended

                if facility != "":
                    facilitystr: list[ThemeRef | ThemeStr] = [
                        ThemeRef("separators", "facility_prefix"),
                        ThemeStr(facility, ThemeAttr("logview", "facility")),
                        ThemeRef("separators", "facility_suffix"),
                        ThemeRef("separators", "facility_padding"),
                    ]
                    # We do not actually want any prefix,
                    # but we want empty padding of the same length
                    if facility.rstrip() == "":
                        facilitystr = [ThemeStr("".ljust(themearray_len(facilitystr)),
                                                ThemeAttr("logview", "severity_debug"))]
                    msgstrarray += facilitystr

                msg = messages[uip.yoffset + y]
                if not isinstance(msg, list):
                    msgstrarray.append(ThemeStr(msg, color_log_severity(severity)))
                else:
                    msgstrarray += msg
                if wrap_lines:
                    sideadjust = 0
                    if not uip.borders:
                        sideadjust = 2
                    maxwidth = uip.maxx - uip.logpadxpos + sideadjust
                else:
                    maxwidth = -1
                msgstrarrays = \
                    themearray_wrap_line(msgstrarray, maxwidth,
                                         wrap_marker=(uip.borders or get_mousemask() != 0))
                for i, msgstrarray in enumerate(msgstrarrays):
                    if y + yadd + i >= uip.logpadheight:
                        break
                    if i == 0 and tspad is not None and tscount:
                        uip.addthemearray(tspad, tsthemearray, y=y + yadd, x=0)
                    _cury, _curx = uip.addthemearray(logpad, msgstrarray, y=y + yadd + i, x=0)
                    maxlen = max(maxlen, themearray_len(msgstrarray))
                yadd += i
            uip.resize_logpad(-1, maxlen)

            uip.refresh_window()
            uip.refresh_infopad()
            uip.refresh_logpad()
            uip.refresh_statusbar()
            curses.doupdate()
            uip.refresh = False

        uip.stdscr.timeout(100)
        c = uip.stdscr.getch()
        retval = uip.generic_keycheck(c)

        if retval == Retval.MATCH:
            continue
        if retval == Retval.RETURNONE:
            return Retval.RETURNDONE
        if retval == Retval.RETURNFULL:
            return retval

        if c == curses.KEY_F2:
            if (retval := selectwindow(uip)) == Retval.RETURNFULL:
                return retval
            uip.refresh_all()
        elif c == curses.KEY_F3:
            if (retval := selectwindow(uip, refresh_apis=True)) == Retval.RETURNFULL:
                return retval
            uip.refresh_all()
        elif c == ord("B"):
            uip.toggle_borders()
            uip.refresh_all()
            uip.force_update()
        elif c == curses.KEY_F4:
            if uip.continuous_log:
                # Disable log tailing
                uip.continuous_log = False
                tail_lines = override_tail_lines
                uip.set_update_delay(-1)
                # When we disable tailing we would ideally want to be at the end,
                # but we do not know where the end is, so, stay on top...
            else:
                # Enable log tailing
                uip.continuous_log = True
                tail_lines = uip.logpadheight
                uip.set_update_delay(10)
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == curses.KEY_F8:
            if uip.continuous_log:
                continue

            # Toggle full logs; this might be VERY slow
            uip.continuous_log = False

            if tail_lines == override_tail_lines:
                query_title = "Show full log (Potentially very slow):"
                if curses_helper.confirmationbox(uip.stdscr, title=query_title, default=False):
                    tail_lines = sys.maxsize
            else:
                tail_lines = override_tail_lines

            uip.refresh_infopad()
            uip.refresh_logpad()
            uip.refresh_statusbar()
            curses.doupdate()
            uip.force_update()
        elif c == ord("I"):
            # XXX: This is very inefficient
            _vlist = get_container_info()
            retval = None
            for _obj in _vlist:
                if _obj.name == containername and _obj.image_id == image_id:
                    retval = resourceinfodispatch(stdscr, _obj.ref, ("__Container", ""))
                    uip.force_update()
                    break
            if retval is not None and retval == Retval.RETURNFULL:
                return retval
        elif c == ord("O"):
            option_list = [
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Pop timestamps", ThemeAttr("windowwidget", "default"))]],
                    "retval": "pop_ts",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Pop severity", ThemeAttr("windowwidget", "default"))]],
                    "retval": "pop_severity",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Pop facility", ThemeAttr("windowwidget", "default"))]],
                    "retval": "pop_facility",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Extract message",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "msg_extract",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Message first", ThemeAttr("windowwidget", "default"))]],
                    "retval": "msg_first",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Override severity",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "override_severity",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Replace bullets",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "msg_realbullets",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Collector bullets",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "bullet_collectors",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Merge starting version",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "merge_starting_version",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Expand newlines (WIP)",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "expand_newlines",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Expand tabs (WIP)",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "expand_tabs",
                },
            ]
            preselection = set()

            for i, option in enumerate(option_list):
                retval = False
                option_path = deep_get(option, DictPath("retval"))
                if option_path is not None:
                    retval = getattr(LogparserConfiguration, option_path, False)
                if retval:
                    preselection.add(i)

            tmpselection = \
                curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2,
                                           uip.maxx // 2, option_list, title="Parser options",
                                           cursor=True, preselection=preselection, taggable=True)
            selection = None
            if tmpselection is not None and tmpselection != "":
                selection = tmpselection
            uip.refresh_all()

            # Some option changed, so we need to re-render the log
            if selection is not None and preselection != selection:
                # Perform the changes
                modified_options = preselection.symmetric_difference(selection)
                for i in modified_options:
                    option_path = deep_get(option_list[i], DictPath("retval"))
                    value = not getattr(LogparserConfiguration, option_path, False)
                    setattr(LogparserConfiguration, option_path, value)

                uip.yoffset = 0
                uip.xoffset = 0
                uip.force_update()
        elif c == ord("R"):
            if uip.continuous_log:
                continue

            if not raw_logs:
                saved_fold_msg = fold_msg
                saved_merge_repeats = merge_repeats
                fold_msg = True
                merge_repeats = False
            else:
                fold_msg = saved_fold_msg
                merge_repeats = saved_merge_repeats
            raw_logs = not raw_logs
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("P"):
            parserlist = [{
                "lineattrs": WidgetLineAttrs.NORMAL,
                "columns": [[ThemeStr("<autodetect>", ThemeAttr("windowwidget", "default"))]],
                "retval": "<autodetect>",
            }]
            for parser in natsorted(get_parser_list()):
                parserlist.append({
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr(f"{parser}", ThemeAttr("windowwidget", "default"))]],
                    "retval": parser,
                })

            if override_parser is None:
                preselection = "<autodetect>"
            else:
                preselection = override_parser
            tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                      uip.maxy // 2, uip.maxx // 2, parserlist,
                                                      title="Override Logparser", cursor=True,
                                                      preselection=preselection)
            selection = None
            if tmpselection is not None and tmpselection != "":
                selection = tmpselection
            uip.refresh_all()
            if selection is not None and selection:
                if selection == "<autodetect>":
                    override_parser = None
                else:
                    override_parser = selection
                _parser = None
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("L"):
            loglevellist = []
            for lvl in get_loglevel_names():
                if lvl.startswith("Diff"):
                    continue
                loglevellist.append({
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr(f"{lvl}", ThemeAttr("windowwidget", "default"))]],
                    "retval": lvl,
                })

            tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                      uip.maxy // 2, uip.maxx // 2, loglevellist,
                                                      title="Select Loglevel", cursor=True,
                                                      preselection=loglevel_to_name(log_level))
            selection = None
            if tmpselection is not None and tmpselection != "":
                selection = tmpselection
            uip.refresh_all()
            if selection is not None and selection:
                log_level = name_to_loglevel(selection)
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("W"):
            wrap_lines = not wrap_lines
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("F"):
            if uip.continuous_log or raw_logs:
                continue

            fold_msg = not fold_msg
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("D"):
            if uip.continuous_log or raw_logs:
                continue

            merge_repeats = not merge_repeats
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("T"):
            uip.toggle_timestamps()
            uip.refresh_all()
            uip.force_update()
        elif c == ord("V"):
            facilitylist = [
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Full", ThemeAttr("windowwidget", "default"))]],
                    "retval": "Full",
                }, {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Short", ThemeAttr("windowwidget", "default"))]],
                    "retval": "Short",
                }, {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("None", ThemeAttr("windowwidget", "default"))]],
                    "retval": "None",
                }
            ]

            tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                      uip.maxy // 2, uip.maxx // 2, facilitylist,
                                                      title="Select Facility Level", cursor=True,
                                                      preselection=show_facility)
            selection = None
            if tmpselection is not None and tmpselection != "":
                selection = tmpselection
            uip.refresh_all()
            if selection is not None and selection:
                show_facility = selection
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("E"):
            if uip.continuous_log:
                continue

            uip.refresh = True
            if raw_logs:
                rawprefix = "Raw "
            else:
                rawprefix = ""
            export_title = f"Export {rawprefix}log to file: "
            if not (filename := curses_helper.inputbox(uip.stdscr, title=export_title)):
                continue

            # This is necessary because we never go through the normal update cycle
            # for the logpad and infopad
            uip.refresh_infopad()
            uip.refresh_logpad()
            curses.doupdate()

            if os.path.exists(filename):
                curses.doupdate()
                query_title = f"File “{filename}“ already exists; overwrite?:"
                if not curses_helper.confirmationbox(uip.stdscr, title=query_title, default=False):
                    continue

            data = ""

            for y in range(0, uip.loglen):
                # Even when the log is raw we want the first timestamp
                if y >= len(timestamps) or isinstance(timestamps[y], str) \
                        or timestamps[uip.yoffset + y] == none_timestamp():
                    timestamp = "".ljust(uip.tspadwidth)
                else:
                    timestamp = str(timestamps[y])[0:uip.tspadwidth]

                if y >= len(facilities) or facilities[y] == "":
                    facility = ""
                else:
                    if facilities[y].strip() == "":
                        facility = f" {facilities[y]}  "
                    else:
                        facility = f"<{facilities[y]}> "

                if uip.yoffset + y >= len(severities):
                    severity_str = f"{lvl_to_4letter_severity(LogLevel.INFO)}: "
                else:
                    severity_str = f"{lvl_to_4letter_severity(severities[y])}: "

                message = themearray_to_string(messages[y])

                if raw_logs:
                    data += f"{timestamp}  {message}\n"
                else:
                    data += f"{timestamp}  {severity_str}{facility}{message}\n"

            secure_write_string(FilePath(filename), data, allow_relative_path=True)

    # Should be unreachable
    return Retval.RETURNFULL


# pylint: disable-next=too-many-locals,too-many-branches
def do_command(stdscr: curses.window, **kwargs: Any) -> None:
    """
    Execute a command on localhost.
    XXX: This should be renamed.

        Parameters:
            stdscr (opaque): A curses stdscr reference
            **kwargs (dict): Additional parameters
    """
    security_policy = SecurityPolicy.ALLOWLIST_RELAXED
    fallback_allowlist = ["/bin", "/sbin", "/usr/bin", "/usr/sbin",
                          "/usr/local/bin", "/usr/local/sbin", f"{HOMEDIR}/bin"]

    _args = deep_get(kwargs, DictPath("command"))
    input_path = deep_get(kwargs, DictPath("input_path"))

    if not _args:
        return

    obj = deep_get(kwargs, DictPath("obj"), {})

    if input_path is not None:
        if input_path:
            command_input = deep_get(obj, DictPath(input_path))
        else:
            command_input = obj
        if not isinstance(command_input, str):
            command_input = None
        else:
            command_input = command_input.encode("utf-8")
    else:
        command_input = None

    args = []
    for arg in _args:
        if isinstance(arg, str):
            args.append(arg)
        elif isinstance(arg, list):
            for path in arg:
                tmp = deep_get(obj, DictPath(path))
                if isinstance(tmp, str):
                    args.append(tmp)
                elif isinstance(tmp, list):
                    args += tmp
                else:
                    sys.exit("widget_args: command requested incorrect data type; "
                             "only str and list are valid")

    waitforkeypress = deep_get(kwargs, DictPath("wait_for_keypress"), False)

    msg = deep_get(kwargs, DictPath("msg"), "")

    curses.endwin()
    _retval = clear_screen()
    if msg:
        ansithemeprint(msg)
        print()

    try:
        _cpath = secure_which(FilePath(args[0]),
                              fallback_allowlist=fallback_allowlist,
                              security_policy=security_policy)
    except FileNotFoundError:
        ansithemeprint([ANSIThemeStr("Error", "error"),
                        ANSIThemeStr(": “", "default"),
                        ANSIThemeStr(f"{args[0]}", "programname"),
                        ANSIThemeStr("“ does not exist.\n", "default")], stderr=True)
        waitforkeypress = True
    else:
        _retval = subprocess.run(args, check=False, input=command_input).returncode

    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    stdscr.refresh()


# noqa: E501 pylint: disable-next=too-many-arguments,too-many-locals,too-many-branches,too-many-positional-arguments
def executecommand(stdscr: curses.window,
                   obj: dict, container, msg, command, waitforkeypress: bool) -> None:
    """
    Executes a command in a container.
    XXX: This should be renamed.
    """
    try:
        kubectl_path = secure_which(FilePath("/usr/bin/kubectl"),
                                    fallback_allowlist=["/etc/alternatives"],
                                    security_policy=SecurityPolicy.ALLOWLIST_RELAXED)
    except FileNotFoundError:
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("kubectl", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    # This should probably be done using connect_get_namespaced_pod_exec()
    curses.endwin()
    _retval = clear_screen()
    ansithemeprint(msg)
    print()
    if obj is not None:
        obj_name = deep_get(obj, DictPath("metadata#name"))
        obj_namespace = deep_get(obj, DictPath("metadata#namespace"))
        # This is a request to create a new ephemeral container
        if command == ["<ephemeral>"]:
            ephemeral_image = \
                deep_get(cmtlib.cmtconfig, DictPath("Debug#ephemeral_image"), "busybox")
            args = [kubectl_path, "debug", obj_name, "--target", container, "-n", obj_namespace,
                    "-i", "-t", "--image", ephemeral_image]
            _result = subprocess.run(args, check=False)
        elif command == ["<dnsutils>"]:
            dnsutils_image = deep_get(cmtlib.cmtconfig, DictPath("Debug#network_image"),
                                      "registry.k8s.io/e2e-test-images/jessie-dnsutils:1.7")
            args = [kubectl_path, "debug", f"node/{obj_name}", "-n", "default", "-i", "-t",
                    "--image", dnsutils_image, "--attach=false"]
            result = subprocess.run(args, stdout=PIPE, stderr=STDOUT, check=False)
            if result.returncode != 0:
                ansithemeprint([ANSIThemeStr("Error", "error"),
                                ANSIThemeStr(": Failed to create debug image", "default")],
                               stderr=True)
            else:
                output = result.stdout.decode("utf-8", errors="replace")
                tmp = re.match(r"^Creating debugging pod (\S+) with container (\S+) .*", output)
                if tmp is not None:
                    pod_name = tmp[1]
                    container_name = tmp[2]
                else:
                    sys.exit(f"executecommand failed to parse output; {output}; aborting.")

                # Wait for the pod to be ready
                ansithemeprint([ANSIThemeStr("Waiting for debug pod to be ready "
                                             "(timeout: 60s).", "default")])
                args = [kubectl_path, "wait", "--for=condition=ready",
                        "--timeout=60s", "-n", "default", "pod", pod_name]
                result = subprocess.run(args, stdout=PIPE, stderr=STDOUT, check=False)
                if result.returncode != 0:
                    ansithemeprint([ANSIThemeStr("Error", "error"),
                                    ANSIThemeStr(": The pod failed to become ready before "
                                                 "timeout.", "default")], stderr=True)
                else:
                    # Attach to the debug container
                    args = [kubectl_path, "attach", "-n", "default", pod_name,
                            "-c", container_name,
                            "-i", "-t", "--pod-running-timeout=1m0s"]
                    _result = subprocess.run(args, check=False)

                # Delete the pod
                ansithemeprint([ANSIThemeStr("Forcibly deleting pod.", "default")])
                _message, _status = \
                    kh.delete_obj_by_kind_name_namespace(("Pod", ""), pod_name,
                                                         "default", force=True)
        else:
            args = [kubectl_path, "exec", obj_name, "-n", obj_namespace,
                    "-i", "-t", "--container", container, "--"] + command
            _result = subprocess.run(args, check=False).returncode
    else:
        sys.exit("Called executecommand() with obj == None")

    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    stdscr.refresh()


# pylint: disable-next=too-many-branches
def listviewdispatch(stdscr: curses.window, **kwargs: Any) -> Retval:
    obj = deep_get(kwargs, DictPath("obj"))
    selection = deep_get(kwargs, DictPath("selection"))
    if obj is None and selection is None:
        return Retval.RETURNDONE

    kind = deep_get(kwargs, DictPath("kind"))
    kind_path = deep_get(kwargs, DictPath("kind_path"))
    if kind_path is not None:
        if isinstance(kind_path, str):
            kind_path = [kind_path]
            kind = deep_get_with_fallback(obj, kind_path)
        elif isinstance(kind_path, int) and selection is not None and selection:
            tmp = selection[kind_path]
            if tmp is not None:
                kind = themearray_to_string(tmp)
    api_family = deep_get_with_fallback(kwargs, [DictPath("api_family"), DictPath("api_group")])
    api_group_path = \
        deep_get_with_fallback(kwargs, [DictPath("api_family_path"), DictPath("api_group_path")])
    if api_group_path is not None:
        if isinstance(api_group_path, str):
            api_group_path = [api_group_path]
            api_family = deep_get_with_fallback(obj, api_group_path)
        else:
            tmp = selection[api_group_path]
            if tmp is not None:
                api_family = themearray_to_string(tmp)

    if kind is None:
        return Retval.RETURNDONE
    if api_family is None:
        api_family = ""
    if "/" in api_family:
        api_family, _api_version = api_family.split("/")
    else:
        # Is the api_family only a version#? Then it's a core API
        tmp = re.match(r"^v\d+(alpha\d+|beta\d+|)", api_family)
        if tmp is not None:
            api_family = ""

    view = checkforview((kind, api_family))

    if view is not None:
        if "viewfunc" in views[view]:
            viewfunc = views[view]["viewfunc"]
        else:
            viewfunc = genericlistloop
        return viewfunc(stdscr, view)

    return Retval.RETURNDONE


# pylint: disable-next=unused-argument
def patch_object(stdscr: curses.window, **kwargs: Any) -> Retval:
    kind = deep_get(kwargs, DictPath("kind"))
    name = deep_get(kwargs, DictPath("name"))
    namespace = deep_get(kwargs, DictPath("namespace"))
    patch = deep_get(kwargs, DictPath("args#patch"))
    subresource = deep_get(kwargs, DictPath("args#subresource"), "")
    strategic_merge = deep_get(kwargs, DictPath("args#strategic_merge"), False)

    _message, _status = kh.patch_obj_by_kind_name_namespace(kind, name, namespace, patch,
                                                            subresource=subresource,
                                                            strategic_merge=strategic_merge)
    return Retval.RETURNDONE


# This dispatches to info views; as soon as one is added this function will
# dispatch to that view.
def resourceinfodispatch(stdscr: curses.window, obj: dict,
                         kind: str | tuple[str, str], **kwargs: Any) -> Retval:
    """
    Dispatch from an object to the infoview of another object.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict): The object to get information from
                kind_path (DictPath): The path to get the kind from
                api_version_path (DictPath): The path to get the API-version from
                name_path (DictPath): The path to get name from
                namespace_path (DictPath): The path to get namespace from
        Returns:
            (Retval): Retval.RETURNDONE if no match was found, otherwise
                      Retval from the involved object whenever that returns.
    """
    info = deep_get(kwargs, DictPath("info"))

    if obj is None:
        return Retval.RETURNDONE

    if kind == ("", ""):
        kind = deep_get(obj, DictPath("kind"), "")
        if isinstance(kind, str):
            api_version = deep_get(obj, DictPath("apiVersion"), "")
            # Is this a core API?
            if "/" not in api_version:
                api_family = ""
            else:
                api_family = api_version.split("/")[0]
            kind = (kind, api_family)

    if kind in infoviews:
        return genericinfoloop(stdscr, obj, kind, **kwargs)

    # Exceptions
    if kind in (("Container", ""), ("InitContainer", ""), ("EphemeralContainer", "")):
        # Do not try to open pending containers
        containername = deep_get(obj, DictPath("name"), "")
        src_statuses = {}
        if kind == ("InitContainer", ""):
            src_statuses = deep_get(info, DictPath("status#initContainerStatuses"))
        else:
            src_statuses = deep_get(info, DictPath("status#containerStatuses"))
        # Get the status of the container
        status, _status_group, _restarts, _message, _age = \
            datagetters.get_container_status(src_statuses, containername)
        if status in ("ContainerCreating", "CreateContainerError", "ErrImagePull",
                      "ImagePullBackOff", "Pending", "PodInitializing", "UNKNOWN"):
            return Retval.RETURNDONE
        return containerinfoloop(stdscr, obj, kind, info)

    return Retval.RETURNDONE


def resourceinfodispatch_from_pod_resource_list(stdscr: curses.window, obj=None,
                                                kind=None, info=None, **kwargs: Any) -> Retval:
    kind = deep_get(obj, DictPath("kind"))
    api_family = deep_get(obj, DictPath("api_group"), "")
    obj = deep_get(obj, DictPath("ref"))
    return resourceinfodispatch(stdscr, obj, (kind, api_family), info=info, **kwargs)


def resourceinfodispatch_from_selection(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Dispatch from a selection to the infoview of another object.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict): The object to get information from
                kind (str): The kind of the object to dispatch to
                api_version (str): The API-version of the object to dispatch to
        Returns:
            (Retval): Retval.RETURNDONE if no match was found, otherwise
                      Retval from the involved object whenever that returns.
    """
    # Do not pass both direct and _path versions at the same time
    obj = deep_get(kwargs, DictPath("selection"))
    kind = deep_get(kwargs, DictPath("kind"))
    api_family = deep_get(kwargs, DictPath("api_family"), "")
    kwargs.pop("kind", None)
    kwargs.pop("api_family", None)
    return resourceinfodispatch(stdscr, obj, (kind, api_family), **kwargs)


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def resourceinfodispatch_with_lookup(stdscr: curses.window, **kwargs: Any) -> Retval:
    # Do not pass both direct and _path versions at the same time
    obj = deep_get(kwargs, DictPath("obj"))
    # pylint: disable-next=too-many-nested-blocks
    if obj is None:
        if "selected_obj" in kwargs:
            obj = deep_get(kwargs, DictPath("selected_obj"))
        elif "selected" in kwargs:
            selected = deep_get(kwargs, DictPath("selected"))
            if "_selected_objs" in kwargs:
                obj = {}
                for key, attribute in deep_get(kwargs, DictPath("_selected_objs"), []).items():
                    if isinstance(attribute, list):
                        tmp = getattr(selected, attribute[0])
                        if tmp is not None:
                            obj[key] = tmp[attribute[1]]
                        else:
                            obj[key] = None
                    else:
                        obj[key] = getattr(selected, attribute)
            else:
                obj = selected

    selection = deep_get(kwargs, DictPath("selection"))

    name = deep_get(kwargs, DictPath("name"))
    namespace = deep_get(kwargs, DictPath("namespace"))
    namespaced_name = deep_get(obj, DictPath("namespacedName"))
    namespaced_name_separator = deep_get(kwargs, DictPath("namespaced_name_separator"), "/")
    namespaced_name_enabled_path = deep_get(kwargs, DictPath("namespaced_name_enabled_path"))
    namespaced_name_enabled = True
    namespaced_name_path = None

    name_path = deep_get(kwargs, DictPath("name_path"))
    if name_path is not None and isinstance(name_path, str):
        name_path = [name_path]
    namespace_path = deep_get(kwargs, DictPath("namespace_path"), "")
    if namespace_path is not None and isinstance(namespace_path, str):
        namespace_path = [namespace_path]
    namespaced_name_path = deep_get(kwargs, DictPath("namespaced_name_path"), "")
    if namespaced_name_path is not None and isinstance(namespaced_name_path, str):
        namespaced_name_path = [namespaced_name_path]
        if namespaced_name_enabled_path is not None:
            namespaced_name_enabled = deep_get(obj, DictPath(namespaced_name_enabled_path), True)
    else:
        namespaced_name_enabled = False

    kind = deep_get(kwargs, DictPath("kind"))
    api_family = ""

    # If kind is a dict it contains further rules (and provides both kind and api_family)
    if isinstance(kind, dict):
        substitutions = deep_get(kind, DictPath("substitutions"), {})
        kind_path = deep_get(kind, DictPath("path"), "")
        kind = deep_get(obj, DictPath(kind_path))
        api_family = deep_get(substitutions, DictPath(f"{kind}#api_family"), "")
        kind = deep_get(substitutions, DictPath(f"{kind}#kind"), kind)

    kind_path = deep_get(kwargs, DictPath("kind_path"))
    if kind_path is not None:
        if isinstance(kind_path, str):
            kind_path = [kind_path]
        elif isinstance(kind_path, int) and selection is not None and selection:
            tmp = selection[kind_path]
            if tmp is not None:
                kind = themearray_to_string(tmp)

    api_group = deep_get_with_fallback(kwargs, [DictPath("api_family"),
                                                DictPath("api_group")], api_family)
    api_group_path = deep_get_with_fallback(kwargs, [DictPath("api_family_path"),
                                                     DictPath("api_group_path")])
    if api_group_path is not None:
        if isinstance(api_group_path, str):
            api_group_path = [api_group_path]
        elif isinstance(api_group_path, int) and selection is not None and selection:
            tmp = selection[api_group_path]
            if tmp is not None:
                api_group = themearray_to_string(tmp)

    api_version_path = deep_get(kwargs, DictPath("api_version_path"))
    if api_version_path is not None:
        if isinstance(api_version_path, str):
            api_version_path = [api_version_path]
        elif isinstance(api_version_path, int) and selection is not None and selection:
            tmp = selection[api_version_path]
            if tmp is not None:
                api_version = themearray_to_string(tmp)
                if api_version is not None:
                    if "/" in api_version:
                        api_group = api_version.split('/', maxsplit=1)[0]
                    else:
                        api_group = ""

    owner_reference_path = deep_get(kwargs, DictPath("owner_reference_path"))
    holder_identity_path = deep_get(kwargs, DictPath("holder_identity_path"))

    # When a path is an integer it references a field in selected
    if isinstance(name_path, int) and selection is not None and selection:
        tmp = selection[name_path]
        if tmp is not None:
            name = themearray_to_string(tmp)
    if isinstance(namespace_path, int) and selection is not None and selection:
        tmp = selection[namespace_path]
        if tmp is not None:
            namespace = themearray_to_string(tmp)

        # If an integer namespace is empty, the namespace is (most likely)
        # the same namespace as the parent. This should not interfere with non-namespaced
        # APIs, since they ignore the namespace
        if namespace is None or not namespace:
            namespace = deep_get(kwargs, DictPath("_parent_namespace"), "")

    if obj is not None:
        kind = deep_get_with_fallback(obj, kind_path, kind)
        if kind is not None and kind and isinstance(api_version_path, list):
            api_version = deep_get_with_fallback(obj, api_version_path)
            if api_version is not None:
                if "/" in api_version:
                    api_group = api_version.split("/")[0]
                else:
                    api_group = ""
            api_group = deep_get_with_fallback(obj, api_group_path, api_group)

    if not isinstance(kind, tuple):
        if api_group is None:
            api_group = ""
        kind = (kind, api_group)

    controller = None
    non_controller = None

    holder_identity = None
    if holder_identity_path is not None:
        holder_identity = deep_get(obj, DictPath(holder_identity_path))

    if owner_reference_path is not None and obj is not None:
        # Search for a controller, or the first reference that matches the kind if specified
        owner_references = deep_get(obj, DictPath(owner_reference_path), [])
        for ref in owner_references:
            ref_name = deep_get(ref, DictPath("name"))

            # We only want to dispatch if there's an owner reference
            # that matches the holder identity
            if holder_identity is not None and ref_name != holder_identity:
                continue

            ref_kind = deep_get(ref, DictPath("kind"))
            ref_api_version = deep_get(ref, DictPath("apiVersion"))
            if "/" in ref_api_version:
                ref_api_family = ref_api_version.split("/")[0]
            else:
                ref_api_family = ""
            ref_kind = (ref_kind, ref_api_family)
            accept_only_owner = deep_get(kwargs, DictPath("accept_only_owner"), False)
            if deep_get(ref, DictPath("controller"), False):
                controller = (ref_kind, ref_name)
            elif kind is not None and kind == ref_kind \
                    or holder_identity is not None \
                    or accept_only_owner and len(owner_references) == 1:
                if non_controller is None:
                    non_controller = (ref_kind, ref_name)

    if controller is not None:
        kind, name = controller
    elif non_controller is not None:
        kind, name = non_controller
    else:
        if name is None and obj is not None:
            name = deep_get_with_fallback(obj, name_path)
            # This is needed since CiliumID, for instance, is an integer
            if name is not None:
                name = str(name)

    if kind is None or isinstance(kind, tuple) and kind[0] is None:
        return Retval.RETURNDONE

    if namespaced_name_path is not None:
        namespaced_name = deep_get_with_fallback(obj, DictPath(namespaced_name_path))
    if namespaced_name is not None and namespaced_name_enabled:
        tmp = namespaced_name.split(namespaced_name_separator)
        if len(tmp) == 2:
            namespace, name = tmp

    if name is None or not name:
        return Retval.RETURNDONE

    if namespace is None and obj is not None:
        namespace = deep_get_with_fallback(obj, namespace_path)

    parent_namespace = deep_get(kwargs, DictPath("_parent_namespace"), "")
    if namespace is None and parent_namespace is not None:
        namespace = parent_namespace

    # If the kind is unknown we will get NameError;
    # in this case we probably do not want to crash
    try:
        kind = guess_kind(kind)
    except NameError:
        obj = None

    # If the kind is unknown we will get NameError;
    # in this case we probably do not want to crash
    try:
        obj = kh.get_ref_by_kind_name_namespace(kind, name, namespace, resource_cache=kh_cache)
    except NameError:
        obj = None

    return resourceinfodispatch(stdscr, obj, kind)


def resourceinfodispatch_with_lookup_on_activation(stdscr: curses.window,
                                                   obj, kind, **kwargs) -> Optional[Retval]:
    if "obj" not in kwargs:
        kwargs["obj"] = obj
    if kind not in kwargs:
        kwargs["kind"] = kind
    return resourceinfodispatch_with_lookup(stdscr, **kwargs)


# Iterate over the list of items and execute command on all of them
def executecommand_multiple(stdscr: curses.window, msg, command, items, waitforkeypress) -> None:
    item = None

    curses.endwin()
    _retval = clear_screen()
    print(msg + "\n")

    for item in items:
        args = command + [item]
        retval = subprocess.run(args, check=False).returncode
        if retval != 0:
            break

    if waitforkeypress or retval > 0:
        if retval > 0:
            ansithemeprint([ANSIThemeStr("Error", "error"),
                            ANSIThemeStr(": ", "default")]
                           + format_commandline(args)
                           + [ANSIThemeStr(" returned ", "default"),
                              ANSIThemeStr(f"{retval}", "errorvalue")], stderr=True)
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    stdscr.refresh()


def __run_playbook(playbookpath: FilePath, hosts: list[str], **kwargs: Any) -> int:
    extra_values: dict = deep_get(kwargs, DictPath("extra_values"), {})
    quiet: bool = deep_get(kwargs, DictPath("quiet"), False)
    verbose: bool = deep_get(kwargs, DictPath("verbose"), False)

    # Set necessary Ansible keys before running playbooks
    http_proxy: str = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), "")
    https_proxy: str = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), "")
    no_proxy: str = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), "")

    use_proxy = "no"
    if http_proxy or https_proxy:
        use_proxy = "yes"

    values = {
        "http_proxy": http_proxy,
        "https_proxy": https_proxy,
        "no_proxy": no_proxy,
        "use_proxy": use_proxy,
    }
    merged_values = {**values, **extra_values}

    retval, ansible_results = \
        ansible_run_playbook_on_selection(playbookpath, selection=hosts, values=merged_values,
                                          verbose=verbose, quiet=quiet)
    if verbose:
        ansithemeprint([ANSIThemeStr("", "default")])

    if not quiet:
        ansible_print_play_results(retval, ansible_results, verbose=verbose)

    return retval


def run_playbook(playbook: dict, nodes: list[str],
                 values: Optional[dict] = None) -> tuple[int, dict]:
    verbose: bool = deep_get(cmtlib.cmtconfig, DictPath("Ansible#verbose"), False)
    return __run_playbook(FilePath(cast(str, playbook.get("playbook"))), nodes,
                          extra_values=values, verbose=verbose)


def view_obj(stdscr: curses.window, **kwargs: Any) -> Retval:
    selection = deep_get(kwargs, DictPath("selection"))
    if selection is not None:
        obj = selection
    else:
        obj = deep_get(kwargs, DictPath("obj"))
    if obj is None:
        return Retval.RETURNDONE
    title = deep_get_with_fallback(kwargs, [DictPath("named_title"), DictPath("title")])
    title_path = deep_get(kwargs, DictPath("title_path"))
    if title_path is not None:
        title = deep_get(obj, DictPath(title_path))
    path = deep_get(kwargs, DictPath("path"))
    formatter = deep_get(kwargs, DictPath("formatter"), formatters.format_yaml)
    if path is not None:
        if deep_get(kwargs, DictPath("include_root"), False):
            obj = [{f"{path.rsplit('#')[-1]}": deep_get(obj, DictPath(path))}]
        # pylint: disable-next=comparison-with-callable
        elif formatter == formatters.format_yaml:
            obj = [deep_get(obj, DictPath(path))]
        else:
            obj = deep_get(obj, DictPath(path))
    else:
        obj = [obj]
    if isinstance(formatter, str):
        _formatter = deep_get(formatter_allowlist, DictPath(formatter))
        if _formatter is None:
            raise ValueError(f"{formatter} is not in formatter_allowlist")
        formatter = _formatter
    return resourceinfodispatch(stdscr, obj, ("__ResourceView", ""),
                                title=title, formatter=formatter)


def view_yaml(stdscr: curses.window, **kwargs: Any) -> Retval:
    selection = deep_get(kwargs, DictPath("selection"))
    if selection is not None:
        obj = selection
    else:
        obj = deep_get(kwargs, DictPath("obj"))

    if obj is None:
        return Retval.RETURNDONE
    path = deep_get(kwargs, DictPath("path"))
    if path is not None:
        if deep_get(kwargs, DictPath("include_root"), False):
            _obj = {f"{path.rsplit('#')[-1]}": deep_get(obj, DictPath(path))}
        else:
            _obj = deep_get(obj, DictPath(path))
        if _obj is None:
            return Retval.RETURNDONE
        obj = [_obj]
    else:
        obj = [obj]
    title = deep_get_with_fallback(kwargs, [DictPath("named_title"), DictPath("title")])
    formatter = formatters.format_yaml
    return resourceinfodispatch(stdscr, obj, ("__ResourceView", ""),
                                title=title, formatter=formatter)


def view_json(stdscr: curses.window, **kwargs: Any) -> Retval:
    selection = deep_get(kwargs, DictPath("selection"))
    if selection is not None:
        obj = selection
    else:
        obj = deep_get(kwargs, DictPath("obj"))

    if obj is None:
        return Retval.RETURNDONE
    path = deep_get(kwargs, DictPath("path"))
    if path is not None:
        if deep_get(kwargs, DictPath("include_root"), False):
            _obj = {f"{path.rsplit('#')[-1]}": deep_get(obj, DictPath(path))}
        else:
            _obj = deep_get(obj, DictPath(path))
        if _obj is None:
            return Retval.RETURNDONE
        obj = [_obj]
    else:
        obj = [obj]
    title = deep_get_with_fallback(kwargs, [DictPath("named_title"), DictPath("title")])
    formatter = formatters.reformat_json
    return resourceinfodispatch(stdscr, obj, ("__ResourceView", ""),
                                title=title, formatter=formatter)


def view_pod_logs(stdscr: curses.window, **kwargs: Any) -> Retval:
    containers = []
    containers_full = []
    items = deep_get(kwargs, DictPath("_tagged_items"), [])
    selected = deep_get(kwargs, DictPath("selected"))
    if selected is not None:
        items = [selected]
    namespaces = set()
    for obj in items:
        namespace = getattr(obj, "namespace")
        namespaces.add(namespace)
        name = getattr(obj, "name")
        container_name = getattr(obj, "container")
        image_id = getattr(obj, "image_id")
        containers.append((namespace, name, container_name))
        containers_full.append((namespace, name, container_name, image_id))

    multilog_args = {
        "multilog_containers": containers,
        "multilog_containers_full": containers_full,
        "all_same_namespace": len(namespaces) == 1
    }

    return containerinfoloop(stdscr, container=None, kind=None, obj=None, **multilog_args)


# pylint: disable-next=unused-argument
def action_view_pod_logs(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    return view_pod_logs(uip.stdscr, **values)


def view_last_applied_configuration(stdscr: curses.window, **kwargs: Any) -> Retval:
    obj = deep_get(kwargs, DictPath("obj"))

    last_applied_configuration_path = \
        DictPath("metadata#annotations#kubectl.kubernetes.io/last-applied-configuration")
    last_applied_configuration = \
        deep_get(obj, last_applied_configuration_path, {})
    if last_applied_configuration is None or not last_applied_configuration:
        return Retval.RETURNDONE

    try:
        data = json.loads(last_applied_configuration)
    except DecodeException:
        return Retval.RETURNDONE

    title = deep_get(kwargs, DictPath("title"))
    # themearrays = formatters.format_yaml([data])
    formatter = formatters.format_yaml
    return resourceinfodispatch(stdscr, [data], ("__ResourceView", ""),
                                title=title, formatter=formatter)


# pylint: disable-next=unused-argument,too-many-locals
def delete_resource(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    success = True
    force = deep_get(values, DictPath("__force"), False)

    for item in items:
        if isinstance(item, tuple):
            namespace, name = item
        else:
            namespace = None
            name = item
        message, status = kh.delete_obj_by_kind_name_namespace(kind, name, namespace, force=force)
        if status != 200:
            # Status messages can be very verbose; delete everything from URL and on
            tmp = re.match(r"^(.+?), URL:.*", message)
            if tmp is not None:
                message = tmp[1]
            win = curses_helper.alert(uip.stdscr, uip.maxy // 2, uip.maxx // 2, message=message)
            success = False
            break

    # We successfully deleted everything
    if success:
        win = curses_helper.notice(uip.stdscr, uip.maxy // 2, uip.maxx // 2,
                                   message="Successfully deleted all specified resources")

    # Wait for a keypress
    while True:
        uip.stdscr.timeout(100)
        c = uip.stdscr.getch()
        if c != -1:
            del win
            break

    return Retval.RETURNDONE


# pylint: disable-next=unused-argument
def force_delete_resource(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    values["__force"] = True
    return delete_resource(uip, items=items, action=action, values=values, kind=kind)


def create_namespace(stdscr: curses.window, **kwargs: Any) -> Retval:
    selection_vars = deep_get(kwargs, DictPath("selection_vars"))
    name = deep_get(selection_vars, DictPath("namespace"))

    curses.endwin()
    _retval = clear_screen()

    # Verify that the name of the new namespace is valid
    if not validate_name("dns-label", name):
        msg = [ANSIThemeStr("Error: ", "error"),
               ANSIThemeStr("“", "default"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“ is not a valid name", "default")]
        ansithemeprint(msg, stderr=True)
    elif kh.get_ref_by_kind_name_namespace(("Namespace", ""), name, "",
                                           resource_cache=kh_cache) is not None:
        msg = [ANSIThemeStr("Error: ", "error"),
               ANSIThemeStr("namespace “", "default"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“ already exists", "default")]
        ansithemeprint(msg, stderr=True)
    else:
        msg = [ANSIThemeStr("Creating namespace “", "default"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“", "default")]
        ansithemeprint(msg)
        _msg, _status = kh.create_namespace(name)

    print("\n")

    waitforkeypress = True
    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    stdscr.refresh()

    return Retval.RETURNDONE


# Valid kinds:
# ("DaemonSet", "apps")
# ("Deployment", "apps")
# ("StatefulSet", apps")
def __restart_resource(kind, namespace, name) -> int:
    try:
        kubectl_path = secure_which(FilePath("/usr/bin/kubectl"),
                                    fallback_allowlist=["/etc/alternatives"],
                                    security_policy=SecurityPolicy.ALLOWLIST_RELAXED)
    except FileNotFoundError:
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("kubectl", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    args = [kubectl_path, "rollout", "restart",
            f"{kind[0]}.{kind[1]}/{name}", f"--namespace={namespace}"]
    result = subprocess.run(args, stdout=PIPE, stderr=PIPE, universal_newlines=True, check=False)
    return result.returncode


def __get_resource_scale(kind, namespace, name):
    obj = kh.get_ref_by_kind_name_namespace(kind, name, namespace, resource_cache=kh_cache)
    return deep_get(obj, DictPath("status#replicas"))


# Valid kinds:
# ("Deployment", "apps")
# ("ReplicaSet", "apps")
# ("ReplicationController", "")
# ("StatefulSet", apps")
def __scale_replicas(kind, namespace, name, scale):
    try:
        kubectl_path = secure_which(FilePath("/usr/bin/kubectl"),
                                    fallback_allowlist=["/etc/alternatives"],
                                    security_policy=SecurityPolicy.ALLOWLIST_RELAXED)
    except FileNotFoundError:
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("kubectl", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    args = [kubectl_path, "scale", f"{kind[0]}.{kind[1]}/{name}",
            f"--namespace={namespace}", f"--replicas={scale}"]
    result = subprocess.run(args, stdout=PIPE, stderr=PIPE, universal_newlines=True, check=False)
    return result.returncode


def __edit_resource(kind, namespace, name) -> tuple[int, list[str]]:
    try:
        kubectl_path = secure_which(FilePath("/usr/bin/kubectl"),
                                    fallback_allowlist=["/etc/alternatives"],
                                    security_policy=SecurityPolicy.ALLOWLIST_RELAXED)
    except FileNotFoundError:
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("kubectl", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    if namespace is None:
        args = [kubectl_path, "edit", f"{kind[0]}.{kind[1]}/{name}"]
    else:
        args = [kubectl_path, "edit", f"{kind[0]}.{kind[1]}/{name}", f"--namespace={namespace}"]
    result = subprocess.run(args, universal_newlines=True, check=False)
    return result.returncode, args


# pylint: disable-next=unused-argument,too-many-locals,too-many-branches
def perform_action_on_configuration(uip: UIProps, items, action,
                                    values, **kwargs: Any) -> None:
    try:
        kubectl_path = secure_which(FilePath("/usr/bin/kubectl"),
                                    fallback_allowlist=["/etc/alternatives"],
                                    security_policy=SecurityPolicy.ALLOWLIST_RELAXED)
    except FileNotFoundError:
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("kubectl", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    if (resource_url := deep_get(values, DictPath("resource_url"))) is not None:
        if not resource_url.startswith(("http://", "https://")):
            return Retval.MATCH
        resource_path = resource_url
        rtype = deep_get(action, DictPath("extravars#rtype"))
    else:
        resource_path, rtype = values["resource_path"]

    configuration_action = deep_get(action, DictPath("extravars#action"))
    if configuration_action is None:
        raise ProgrammingError("perform_action_on_configuration() called without action'")
    if configuration_action not in ("delete", "create", "apply"):
        raise ProgrammingError(f"perform_action_on_configuration() does not support "
                               f"the action '{configuration_action}'")

    curses.endwin()
    _retval = clear_screen()

    kubectl_major_version, kubectl_minor_version, _kubectl_git_version, \
        _server_major_version, _server_minor_version, _server_git_version = kubectl_get_version()
    if kubectl_major_version is None or kubectl_minor_version is None:
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not extract ", "default"),
                        ANSIThemeStr("kubectl", "programname"),
                        ANSIThemeStr(" version; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)
    args = [kubectl_path]
    extra_options = []

    if configuration_action == "apply":
        if kubectl_major_version <= 1 and kubectl_minor_version < 22:
            configuration_action = "create"
        else:
            extra_options = ["--server-side"]

    args.append(configuration_action)
    args += extra_options

    if rtype == "Configuration File":
        args.append("-f")
    elif rtype == "Kustomization":
        args.append("-k")
    else:
        raise TypeError(f"Unknown resource type {rtype}; this is a programming error.")

    args.append(resource_path)
    result = subprocess.run(args, universal_newlines=True, check=False)

    # waitforkeypress = deep_get(kwargs, DictPath("wait_for_keypress"), False)
    waitforkeypress = True

    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()

    return result.returncode, args


def __summarise_resources(path):
    resources = []
    dicts = secure_read_yaml_all(path)
    for d in dicts:
        kind, api_group = \
            kh.kind_api_version_to_kind(deep_get(d, DictPath("kind")),
                                        deep_get(d, DictPath("apiVersion")))
        if api_group == "":
            merged_kind = kind
        else:
            merged_kind = f"{kind}.{api_group}"
        name = deep_get(d, DictPath("metadata#name"))
        namespace = deep_get(d, DictPath("metadata#namespace"), "")
        resources.append((merged_kind, namespace, name))

    return resources


# pylint: disable-next=unused-argument,too-many-locals,too-many-branches
def diff_resource_configuration(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    if (resource_url := deep_get(values, DictPath("resource_url"))) is not None:
        if not resource_url.startswith(("http://", "https://")):
            return Retval.MATCH
        resource_path = resource_url
        rtype = deep_get(action, DictPath("extravars#rtype"))
    else:
        resource_path, rtype = values["resource_path"]

    try:
        kubectl_path = secure_which(FilePath("/usr/bin/kubectl"),
                                    fallback_allowlist=["/etc/alternatives"],
                                    security_policy=SecurityPolicy.ALLOWLIST_RELAXED)
    except FileNotFoundError:
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("kubectl", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    if rtype == "Configuration File":
        args = [kubectl_path, "diff", "-f", resource_path]
    elif rtype == "Kustomization":
        args = [kubectl_path, "diff", "-k", resource_path]
    else:
        raise TypeError(f"Unknown resource type {rtype}; this is a programming error.")

    result = subprocess.run(args, stdout=PIPE, stderr=PIPE, universal_newlines=True, check=False)
    indent = deep_get(cmtlib.cmtconfig, DictPath("Global#indent"), 2)
    diff = []

    if not result.stdout:
        return Retval.MATCH

    diff_regex: re.Pattern[str] = re.compile(r"^(\s*)(.*)")

    for line in result.stdout.splitlines():
        if line.startswith("+"):
            fmt = ThemeAttr("windowwidget", "diffplus")
        elif line.startswith("-"):
            fmt = ThemeAttr("windowwidget", "diffminus")
        elif line.startswith("@@"):
            fmt = ThemeAttr("windowwidget", "diffatat")
        elif line.startswith("diff "):
            fmt = ThemeAttr("windowwidget", "diffheader")
        else:
            fmt = ThemeAttr("windowwidget", "diffsame")

        # kubectl shows the diff with a 2-space indent;
        # if a different indent is configured we have to modify this
        if indent != 2:
            prefix = line[0]
            tmp = diff_regex.match(line[1:])
            if tmp is not None and len(tmp[1]) % 2 == 0:
                line = prefix + "".ljust(int(len(tmp[1]) / 2) * indent) + tmp[2]

        diff.append({
            "lineattrs": WidgetLineAttrs.NORMAL,
            "columns": [[ThemeStr(line, fmt)]],
        })

    _tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                               uip.maxy // 2, uip.maxx // 2, diff,
                                               title="Difference if applying new configuration:",
                                               cursor=False)
    return Retval.MATCH


def format_commandline(args: list[str], implicit_command: bool = True) -> list[ANSIThemeStr]:
    """
    Given a command line as an array of strings, format it as an array of ANSIThemeStr.

        Parameters:
            args ([str]): The commandline
            implicit_command (bool): Is the first non-option command the command?
        Returns:
            ([ANSIThemeStr]): A list of ANSIThemeStr
    """
    themearray = []

    command = implicit_command

    for i, arg in enumerate(args):
        # The first argument is the program name
        if i == 0:
            themearray += [ANSIThemeStr(f"{arg}", "programname")]
        # This is an option
        elif arg.startswith(("-")):
            themearray += [ANSIThemeStr(f" {arg}", "option")]
        # The first non-option argument is the command
        elif not command:
            themearray += [ANSIThemeStr(f" {arg}", "command")]
            command = True
        else:
            themearray += [ANSIThemeStr(f" {arg}", "argument")]
    return themearray


def edit_resource(stdscr: curses.window, **kwargs) -> None:
    obj = deep_get(kwargs, DictPath("obj"))
    kind = deep_get(kwargs, DictPath("kind"))
    name = deep_get(obj, DictPath("metadata#name"))
    namespace: str = deep_get(obj, DictPath("metadata#namespace"), "")
    if name is None:
        return

    curses.endwin()
    _retval = clear_screen()
    retval, args = __edit_resource(kind, namespace, name)

    waitforkeypress = False
    if waitforkeypress or retval > 0:
        if retval > 0:
            ansithemeprint([ANSIThemeStr("\nError", "error"),
                            ANSIThemeStr(": ", "default")]
                           + format_commandline(args, implicit_command=False)
                           + [ANSIThemeStr(" returned ", "default"),
                              ANSIThemeStr(f"{retval}", "errorvalue")], stderr=True)
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    stdscr.refresh()


# pylint: disable-next=unused-argument
def patch_resource(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    curses.endwin()
    _retval = clear_screen()
    action_str = deep_get(values, DictPath("action_str"))
    args = deep_get(values, DictPath("args"), {})

    for item in items:
        namespace, name = item

        if action_str is not None:
            msg = [ANSIThemeStr(f"{action_str} {kind[0]}.{kind[1]} “", "default"),
                   ANSIThemeStr(namespace, "argument"),
                   ANSIThemeStr("::", "separator"),
                   ANSIThemeStr(name, "argument"),
                   ANSIThemeStr("“", "default")]
            ansithemeprint(msg)

        patch_object(uip.stdscr, **{"kind": kind,
                                    "name": name,
                                    "namespace": namespace,
                                    "args": args})

    print("\n")

    waitforkeypress = True
    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()

    return Retval.RETURNDONE


# pylint: disable-next=unused-argument
def restart_resource_rescale(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    curses.endwin()
    _retval = clear_screen()

    for item in items:
        namespace, name = item
        old_scale = __get_resource_scale(kind, namespace, name)
        __scale_replicas(kind, namespace, name, scale=0)
        __scale_replicas(kind, namespace, name, scale=old_scale)
        msg = [ANSIThemeStr(f"Restarting {kind[0]}.{kind[1]} “", "default"),
               ANSIThemeStr(namespace, "argument"),
               ANSIThemeStr("::", "separator"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“ scale: ", "default"),
               ANSIThemeStr(f"{old_scale}", "emphasis")]
        ansithemeprint(msg)

    print("\n")

    waitforkeypress = True
    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()

    return Retval.RETURNDONE


# pylint: disable-next=unused-argument
def restart_resource_rollout(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    curses.endwin()
    _retval = clear_screen()

    for item in items:
        namespace, name = item
        __restart_resource(kind, namespace, name)
        msg = [ANSIThemeStr(f"Restarting {kind[0]}.{kind[1]} “", "default"),
               ANSIThemeStr(namespace, "argument"),
               ANSIThemeStr("::", "separator"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“", "default")]
        ansithemeprint(msg)

    print("\n")

    waitforkeypress = True
    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()

    return Retval.RETURNDONE


# pylint: disable-next=unused-argument
def rescale_resource(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    curses.endwin()
    _retval = clear_screen()

    for item in items:
        namespace, name = item
        scale = values["scale"]
        old_scale = __get_resource_scale(kind, namespace, name)
        __scale_replicas(kind, namespace, name, scale)
        msg = [ANSIThemeStr(f"Rescaling {kind[0]}.{kind[1]} “", "default"),
               ANSIThemeStr(namespace, "argument"),
               ANSIThemeStr("::", "separator"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“ scale: ", "default"),
               ANSIThemeStr(f"{old_scale}", "emphasis"),
               ANSIThemeStr(" => ", "default"),
               ANSIThemeStr(f"{scale}", "emphasis")]
        ansithemeprint(msg)

    print("\n")

    waitforkeypress = True
    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()

    return Retval.RETURNDONE


# Valid kinds:
# ("Deployment", "apps")
# pylint: disable-next=unused-argument
def stop_resource_rescale(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    curses.endwin()
    _retval = clear_screen()

    for item in items:
        namespace, name = item
        old_scale = __get_resource_scale(kind, namespace, name)
        __scale_replicas(kind, namespace, name, 0)
        msg = [ANSIThemeStr(f"Stopping {kind[0]}.{kind[1]} “", "default"),
               ANSIThemeStr(namespace, "argument"),
               ANSIThemeStr("::", "separator"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“ scale: ", "default"),
               ANSIThemeStr(f"{old_scale}", "emphasis"),
               ANSIThemeStr(" => ", "default"),
               ANSIThemeStr("0", "emphasis")]
        ansithemeprint(msg)

    print("\n")

    waitforkeypress = True
    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()

    return Retval.RETURNDONE


# pylint: disable-next=unused-argument
def delete_logs(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    for item in items:
        ansible_delete_log(item)

    return Retval.RETURNDONE


# pylint: disable-next=unused-argument,too-many-locals,too-many-branches
def action_execute_command(uip: UIProps, items, action, values, kind, **kwargs: Any) -> None:
    tmpargs = deep_get(values, DictPath("action_args#command"), [])
    iterate = deep_get(values, DictPath("action_args#iterate"), False)
    if not tmpargs:
        return

    args = []

    for arg in tmpargs:
        if arg == "<<<items>>>":
            args += items
        elif arg.startswith("<<<items:"):
            separator = arg.removeprefix("<<<items:").removesuffix(">>>")
            args.append(separator.join(items))
        else:
            args.append(arg)

    description = action.get("description")
    if description is None:
        description = " ".join(args)
    msg = [ANSIThemeStr("Executing “", "action"),
           ANSIThemeStr(description, "argument"),
           ANSIThemeStr("“\n", "action")]

    curses.endwin()
    _retval = clear_screen()

    ansithemeprint(msg)

    if iterate:
        iterations = items
    else:
        iterations = [items]

    for item in iterations:
        substitutions = {}
        if isinstance(item, tuple):
            for i, subitem in enumerate(item):
                substitutions[f"<<<item.{i}>>>"] = subitem
        else:
            substitutions["<<<item>>>"] = item
        iterargs = substitute_list(args, substitutions)

        try:
            result = subprocess.run(iterargs, check=False)
            retval = result.returncode
        except FileNotFoundError:
            ansithemeprint([ANSIThemeStr("Error", "error"),
                            ANSIThemeStr(": Command “", "default"),
                            ANSIThemeStr(f"{args[0]}", "programname"),
                            ANSIThemeStr("“ not found", "default")])
            retval = 2

    waitforkeypress = True
    if waitforkeypress or retval > 0:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()


# pylint: disable-next=unused-argument,too-many-locals,too-many-branches
def command_hosts(uip: UIProps, items, action, values, kind, **kwargs: Any) -> None:
    verbose: bool = deep_get(cmtlib.cmtconfig, DictPath("Ansible#verbose"), False)
    verbose = deep_get(kwargs, DictPath("verbose"), verbose)

    values.pop("_tagged_items", None)
    msg = \
        [ANSIThemeStr("Executing playbook “", "action"),
         ANSIThemeStr(action.get("description"), "argument"),
         ANSIThemeStr("“ on the following hosts: ", "action")] \
        + ansithemestr_join_list(items, formatting="hostname",
                                 separator=ANSIThemeStr(", ", "separator")) \
        + [ANSIThemeStr("\n", "action")]

    curses.endwin()
    _retval = clear_screen()

    if action.get("requires_cluster_info") and kubernetes_support:
        ansithemeprint([ANSIThemeStr("[Gathering cluster information]\n", "phase")])
        gather_cluster_info(kubernetes_helper=kh, kh_cache=kh_cache)

    ansithemeprint(msg)

    # If run_before is set we have one or several playbooks that need to be run before this one
    runbefore = action.get("run_before", [])

    retval = 0

    for preplaybook in runbefore:
        preplaybookpath = get_playbook_path(FilePath(f"{preplaybook}.yaml"))
        if (tmpretval := __run_playbook(preplaybookpath, items,
                                        extra_values=values, verbose=verbose)):
            if retval == 0:
                retval = tmpretval
            break

    # If all pre-requisites completed successfully we perform the main task
    if not retval:
        retval = run_playbook(action, items, values=values)

    # If everything was successful it is time for the run_after playbooks
    if not retval:
        runafter = action.get("run_after", [])

        for postplaybook in runafter:
            postplaybookpath = get_playbook_path(FilePath(f"{postplaybook}.yaml"))
            if (tmpretval := __run_playbook(postplaybookpath, items,
                                            extra_values=values, verbose=verbose)):
                if retval == 0:
                    retval = tmpretval
                break

    # If everything was successful we execute the add_to_groups/remove_from_groups actions
    if not retval:
        for group in action.get("add_to_groups", []):
            ansible_add_hosts(ANSIBLE_INVENTORY, items, group=group, skip_all=True)

        for group in action.get("remove_from_groups", []):
            ansible_remove_hosts(ANSIBLE_INVENTORY, items, group=group)

    waitforkeypress = True
    if waitforkeypress or retval:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()


# pylint: disable-next=unused-argument
def cordon_node(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    for node in items:
        kh.cordon_node(node)
    return Retval.RETURNDONE


# pylint: disable-next=unused-argument
def drain_node(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    force = deep_get(kwargs, DictPath("force"), False)
    for node in items:
        kh.drain_node(node, force=force)
    return Retval.RETURNDONE


# pylint: disable-next=unused-argument
def force_drain_node(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    return drain_node(uip, items, action, values, kind, **{"force": True})


# pylint: disable-next=unused-argument
def uncordon_node(uip: UIProps, items, action, values, kind, **kwargs: Any) -> Retval:
    for node in items:
        kh.uncordon_node(node)
    return Retval.RETURNDONE


nodeplaybooks = {}  # type: ignore


# pylint: disable-next=too-many-locals
def ssh_to_host(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    SSH to a host

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict[str, Any]): The object to fetch information from
                name_path (str): The path to the member of the object
                                 to fetch the name from (optional)
                name (str): The name of the host (optional)
        Returns:
            (Retval): Retval.RETURNDONE
    """
    host = None

    if "selected" in kwargs:
        selected = deep_get(kwargs, DictPath("selected"))
        if isinstance(selected, tuple):
            host = selected[0]
        elif isinstance(selected, str):
            host = selected
        else:
            ref = getattr(selected, "ref")
            _kind = deep_get(ref, DictPath("kind"), "")
            _api_group = deep_get(ref, DictPath("api_group"), "")
            try:
                kind = guess_kind((_kind, _api_group))
            except NameError:
                # If we cannot guess the kind we return
                return Retval.RETURNDONE

            if kind != ("Node", ""):
                # If this is not a Node object, return
                return Retval.RETURNDONE
            host = deep_get(ref, DictPath("name"), "")
    elif "obj" in kwargs:
        obj = deep_get(kwargs, DictPath("obj"), {})
        name_path = deep_get(kwargs, DictPath("name_path"), "")
        host = deep_get(obj, DictPath(name_path))
    host = deep_get(kwargs, DictPath("name"), host)

    if host is None or not host:
        return Retval.RETURNDONE

    msg = [ANSIThemeStr("SSH:ing to ", "action"),
           ANSIThemeStr(host, "hostname"),
           ANSIThemeStr(":\n", "action")]

    inventory = ansible_get_inventory_dict()

    # ansible_user in the inventory overrides that defined in cmt.yaml
    # thus we get these in ascending over of priority
    # if no user is specified we assume that we are to use the user we are running as
    sshuser = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_user"))
    sshuser = deep_get(inventory, DictPath("all#vars#ansible_user"), sshuser)
    sshuser = deep_get(inventory, DictPath(f"all#hosts#{host}#ansible_user"), sshuser)

    curses.endwin()
    _retval = clear_screen()
    ansithemeprint(msg)

    try:
        ssh_path = secure_which(SSH_BIN_PATH, fallback_allowlist=[])
    except FileNotFoundError:
        # Once we have support for logging we should probably just log an error
        # and return here instead
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("ssh", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    if sshuser is not None:
        host = f"{sshuser}@{host}"

    relaxed_ssh_hosts = deep_get(cmtlib.cmtconfig, DictPath("Network#relaxed_ssh_hosts"), [])
    if relaxed_ssh_hosts == ["ALL"] or host in relaxed_ssh_hosts:
        ssh_args = SSH_ARGS_RELAXED
    else:
        ssh_args = SSH_ARGS_STRICT
    args = [ssh_path] + ssh_args + [host]

    subprocess.run(args, check=False)

    stdscr.refresh()
    return Retval.RETURNDONE


def list_configuration_files(basedir: FilePath):
    """
    Scan a directory and a list of all {.yml,.yaml} files
    and directories with a kustomization.yaml file in it.

        Parameters:
            basedir (FilePath): The directory to scan
        Returns:
            ([(str, str, str]): A list of directory entries
                (str): The path to the file
                (str): The filename
                (str): The file type (Configuration File/Kustomization/<dir>)
    """
    plist: list[tuple[str, str, str]] = []
    files: list[tuple[str, str, str]] = []

    if os.path.isdir(basedir):
        for filename in os.listdir(basedir):
            if filename.startswith(("~", ".")):
                continue

            # real path, display name, type
            if filename.endswith((".yaml", ".yml")):
                files.append((f"{basedir}/{filename}", filename, "Configuration File"))
            elif os.path.isdir(f"{basedir}/{filename}"):
                if os.path.isfile(f"{basedir}/{filename}/kustomization.yaml"):
                    files.append((f"{basedir}/{filename}", filename, "Kustomization"))
                else:
                    files.append((f"{basedir}/{filename}", filename, "<dir>"))
            else:
                continue

    # Always provide a means to navigate up in the directory tree
    plist = [(f"{os.path.dirname(basedir)}", "..", "<dir>")]
    plist += cast(list[tuple[str, str, str]], natsorted(files))

    return plist


# pylint: disable-next=too-many-locals
def populate_actionlist(**kwargs: Any) -> tuple[list[dict[str, Any]], dict[str, Any]]:
    """
    Populate the list of actions based on context and policy.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                context (str): The context to populate actions for
                action_list ([dict]): The list of actions
                control_plane_selected (bool): Is the control plane part of the selection?
                single_item (bool): Has only a single item been selected?
        Returns:
            (([dict[str, Any]], dict[str, Any])):
                ([dict[str, Any]]): The formatted list of actions (for use with WindowWidget)
                (dict[str, Any]): The action list dict
    """
    action_list: dict[str, Any] = deep_get(kwargs, DictPath("action_list"), {})
    control_plane_selected: bool = deep_get(kwargs, DictPath("control_plane_selected"), False)
    single_item: bool = deep_get(kwargs, DictPath("single_item"), False)

    actions: list[dict[str, Any]] = []
    order: list[tuple[str, str, str]] = []

    for item in action_list:
        description: str = deep_get(action_list, DictPath(f"{item}#description"),
                                    "<description missing>")
        category: str = deep_get(action_list, DictPath(f"{item}#category"), "")
        name: str = item
        order.append((description, category, name))

    currentcategory = ""
    for item in natsorted(order, key=itemgetter(1, 0)):
        action = item[0]
        category = item[1]
        allowoncontrolplane = \
            deep_get(action_list, DictPath(f"{item[2]}#allow_on_control_plane"), True)
        singleoncontrolplane = \
            deep_get(action_list, DictPath(f"{item[2]}#single_on_control_plane"), False)
        singleonly = deep_get(action_list, DictPath(f"{item[2]}#single_only"), False)
        readonly = deep_get(action_list, DictPath(f"{item[2]}#read_only"), False)
        metadata = deep_get(action_list, DictPath(f"{item[2]}#metadata"), [])
        tmp = []
        for md in metadata:
            if isinstance(md, ThemeStr):
                tmp.append(md)
            elif isinstance(md[1], list):
                tmp.append(ThemeStr(md[0], ThemeAttr(md[1][0], md[1][1])))
            else:
                raise ValueError(f"Unknown type for metadata {type(md)} for metadata {md}; "
                                 "expected ThemeStr(str, ThemeAttr) or [str, [str, str]]")
        metadata = tmp
        if singleonly and not single_item:
            continue
        if singleoncontrolplane and control_plane_selected and not single_item:
            continue
        if not allowoncontrolplane and control_plane_selected:
            continue
        if not readonly and read_only_mode:
            continue

        if currentcategory != category:
            actions.append({
                "lineattrs": WidgetLineAttrs.SEPARATOR,
                "columns": [[ThemeStr(f" {category} ", ThemeAttr("windowwidget", "default"))],
                            [ThemeStr("", ThemeAttr("windowwidget", "default"))]],
            })
            currentcategory = category
        actions.append({
            "lineattrs": WidgetLineAttrs.NORMAL,
            "columns": [[ThemeStr(f"{action}", ThemeAttr("windowwidget", "default"))], metadata],
        })

    return actions, action_list


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def __populate_playbooklist(path: FilePath, action_list: Optional[dict]) -> Optional[dict]:
    if not os.path.isdir(path):
        return action_list

    if action_list is None:
        action_list = {}

    yaml_regex: re.Pattern[str] = re.compile(r"^(.*)\.ya?ml$")

    for playbookpath in Path(path).iterdir():
        if playbookpath.name.startswith(("~", ".")):
            continue

        tmp = yaml_regex.match(playbookpath.name)
        if tmp is None:
            continue

        playbookname = str(tmp[1])

        # Check if the playbook already exists in the action list,
        if playbookname in action_list:
            continue

        description = None

        try:
            d = secure_read_yaml(FilePath(playbookpath), directory_is_symlink=True)
        except yaml.YAMLError:
            # This entry could not be parsed; add a dummy entry
            action_list[playbookname] = {
                "description": playbookpath,
                "playbook": FilePath(playbookpath),
                "category": "__INVALID__",
                "comments": "Failed to parse (Not valid YAML)",
            }
            continue

        # Empty files are used to disable playbooks completely
        if d is None or not d:
            action_list[playbookname] = {
                "description": playbookpath,
                "playbook": FilePath(playbookpath),
                "category": "__DISABLED__",
            }
            continue

        if not isinstance(d, list):
            # This entry could not be parsed; add a dummy entry
            action_list[playbookname] = {
                "description": playbookpath,
                "playbook": FilePath(playbookpath),
                "category": "__INVALID__",
                "comments": "Failed to parse (Not a list of plays)",
            }
            continue

        description = deep_get(d[0], DictPath("vars#metadata#description"))

        # Ignore all playbooks that lack a description;
        # typically they are internal playbooks
        if description is None:
            continue

        query = deep_get(d[0], DictPath("vars#metadata#query#string"))
        queryval = deep_get(d[0], DictPath("vars#metadata#query#variable"))
        queryfunc = deep_get(d[0], DictPath("vars#metadata#query#function"))

        # Sanity check
        if queryfunc is not None:
            if queryfunc not in ("string", "yesno", "filechooser"):
                raise ValueError(f"unknown queryfunc “{queryfunc}“ provided")

        confirm = deep_get(d[0], DictPath("vars#metadata#confirm"), False)
        tmpallowoncontrolplane = deep_get(d[0], DictPath("vars#metadata#allow_on_control_plane"))
        if tmpallowoncontrolplane is None or tmpallowoncontrolplane == "always":
            allowoncontrolplane = True
            singleoncontrolplane = False
        elif tmpallowoncontrolplane.lower() == "single":
            allowoncontrolplane = True
            singleoncontrolplane = True
        elif tmpallowoncontrolplane.lower() == "never":
            allowoncontrolplane = False
            singleoncontrolplane = False
        else:
            raise ValueError(f"{playbookpath}: Invalid values for allow-on-control-plane")

        requiresclusterinfo = deep_get(d[0], DictPath("vars#metadata#requires_cluster_info"), False)
        runbefore = deep_get(d[0], DictPath("vars#metadata#run_before"), [])
        runafter = deep_get(d[0], DictPath("vars#metadata#run_after"), [])
        addtogroups = deep_get(d[0], DictPath("vars#metadata#add_to_groups"), [])
        removefromgroups = deep_get(d[0], DictPath("vars#metadata#remove_from_groups"), [])
        category = deep_get(d[0], DictPath("vars#metadata#category"), "Uncategorized")
        playbooktypes = deep_get(d[0], DictPath("vars#metadata#playbook_types"), [])
        comments = deep_get(d[0], DictPath("vars#metadata#comments"), "")
        readonly = deep_get(d[0], DictPath("vars#metadata#read_only"), False)
        extravars = {
            "quiet": deep_get(d[0], DictPath("vars#metadata#quiet"), False),
        }

        action_list[playbookname] = {
            "description": description,
            "playbook": FilePath(playbookpath),
            "query": query,
            "queryval": queryval,
            "queryfunc": queryfunc,
            "confirm": confirm,
            "allow_on_control_plane": allowoncontrolplane,
            "single_on_control_plane": singleoncontrolplane,
            "requires_cluster_info": requiresclusterinfo,
            "run_before": runbefore,
            "run_after": runafter,
            "add_to_groups": addtogroups,
            "remove_from_groups": removefromgroups,
            "category": category,
            "playbook_types": playbooktypes,
            "comments": comments,
            "read_only": readonly,
            "extravars": extravars,
        }

    return action_list


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def populate_playbooklist(**kwargs: Any) -> tuple[list[dict], dict]:
    """
    Populate the list of playbooks based on context and policy.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                context (str): The context to populate playbooks for
                actions ([dict]): The actions to pass through
                action_list (dict): A dict of actions to append the playbook actions to
                control_plane_selected (bool): Is the control plane part of the selection?
                single_item (bool): Has only a single item been selected?
                cluster_available (bool): Is the cluster available?
    """
    context: Optional[dict] = deep_get(kwargs, DictPath("context"))
    actions: list[dict] = deep_get(kwargs, DictPath("actions"))
    action_list: dict = deep_get(kwargs, DictPath("action_list"), {})
    control_plane_selected: bool = deep_get(kwargs, DictPath("control_plane_selected"), False)
    single_item: bool = deep_get(kwargs, DictPath("single_item"), False)
    cluster_available: bool = deep_get(kwargs, DictPath("cluster_available"), True)

    local_playbooks = deep_get(cmtlib.cmtconfig, DictPath("Ansible#local_playbooks"), [])
    for playbook_path in local_playbooks:
        # Substitute {HOME}/ for {HOMEDIR}
        if playbook_path.startswith(("{HOME}/", "{HOME}\\")):
            playbook_path = HOMEDIR.joinpath(playbook_path[len('{HOME}/'):])
        # Skip non-existing playbook paths
        if not os.path.isdir(playbook_path):
            continue
        action_list = __populate_playbooklist(playbook_path, action_list=action_list)
    action_list = __populate_playbooklist(ANSIBLE_PLAYBOOK_DIR, action_list=action_list)
    action_list = __populate_playbooklist(SYSTEM_ANSIBLE_PLAYBOOK_DIR, action_list=action_list)

    order = []
    for item in action_list:
        playbooktypes: list[str] = action_list[item].get("playbook_types", [])
        if context is not None and playbooktypes != [] and context not in playbooktypes:
            continue

        description = action_list[item].get("description")
        category = action_list[item].get("category", "")
        name = item
        order.append((description, category, name))

    currentcategory = ""
    for item in natsorted(order, key=itemgetter(1, 0)):
        action = item[0]
        category = item[1]
        allowoncontrolplane = action_list[item[2]].get("allow_on_control_plane", True)
        singleoncontrolplane = action_list[item[2]].get("single_on_control_plane", True)
        readonly = action_list[item[2]].get("read_only", False)
        comments = action_list[item[2]].get("comments", "")
        lineattrs = WidgetLineAttrs.NORMAL
        if read_only_mode and not readonly:
            continue
        if singleoncontrolplane and control_plane_selected and not single_item:
            continue
        if not allowoncontrolplane and control_plane_selected:
            continue

        if action_list[item[2]].get("requires_cluster_info", False) and not cluster_available:
            metadata = []
            if comments:
                metadata.append(ThemeStr(f"{comments},", ThemeAttr("windowwidget", "highlight")))
            metadata.append(ThemeStr("<cluster not available>",
                                     ThemeAttr("windowwidget", "alert")))
            lineattrs = WidgetLineAttrs.UNSELECTABLE
        elif category == "__INVALID__":
            lineattrs = WidgetLineAttrs.UNSELECTABLE & WidgetLineAttrs.INVALID
            metadata = [ThemeStr(comments, ThemeAttr("windowwidget", "alert"))]
        elif category == "__DISABLED__":
            continue
        else:
            metadata = [ThemeStr(comments, ThemeAttr("windowwidget", "highlight"))]

        if currentcategory != category:
            if category == "__INVALID__":
                actions.append({
                    "lineattrs": WidgetLineAttrs.SEPARATOR,
                    "columns": [[ThemeStr(" INVALID ", ThemeAttr("windowwidget", "bright"))],
                                [ThemeStr("", ThemeAttr("windowwidget", "default"))]],
                })
                currentcategory = category
            else:
                actions.append({
                    "lineattrs": WidgetLineAttrs.SEPARATOR,
                    "columns": [[ThemeStr(f" {category} ",
                                          ThemeAttr("windowwidget", "default"))],
                                [ThemeStr("", ThemeAttr("windowwidget", "default"))]],
                })
                currentcategory = category
        if currentcategory == "__INVALID__":
            actions.append({
                "lineattrs": lineattrs,
                "columns": [[ThemeStr(f"{action}",
                                      ThemeAttr("windowwidget", "alert"))], metadata],
            })
        else:
            actions.append({
                "lineattrs": lineattrs,
                "columns": [[ThemeStr(f"{action}",
                                      ThemeAttr("windowwidget", "default"))], metadata],
            })

    return actions, action_list


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def format_selection_list(uip: UIProps, refresh_apis: bool = False) -> list[dict[str, Any]]:
    global force_refresh_apis  # pylint: disable=global-statement

    if force_refresh_apis:
        force_refresh_apis = False
        refresh_apis = True

    hide_unavailable = deep_get(cmtlib.cmtconfig,
                                DictPath("__Selector#hide_unavailable_apis"), True)
    categorise = deep_get(cmtlib.cmtconfig, DictPath("__Selector#categorise"), True)
    sortcolumn = deep_get(cmtlib.cmtconfig, DictPath("__Selector#sortcolumn"), "family")

    if sortcolumn == "family":
        if categorise:
            sortkey1 = 1
            sortkey2 = 2
        else:
            sortkey1 = 2
            sortkey2 = 0
    elif sortcolumn == "name":
        if categorise:
            sortkey1 = 1
            sortkey2 = 0
        else:
            sortkey1 = 0
            sortkey2 = 2
    else:
        sys.exit(f"Invalid sortcolumn {sortcolumn} for Selector; aborting.")

    if refresh_apis:
        _notice = curses_helper.notice(None, y=uip.maxy // 2, x=uip.maxx // 2,
                                       message="Refreshing list of available APIs")
        # Repopulate the list of views, on the offhand chance that a view file has been added
        populate_views(force_refresh=refresh_apis)
        curses.doupdate()

    if kubernetes_support:
        available_api_families, _status, _modified = kh.get_available_kinds()
    else:
        available_api_families = {}

    items = []
    order = []

    # Find the correct sort order
    for viewkey, viewref in views.items():
        kind = None
        if deep_get(viewref, DictPath("skip"), False):
            continue
        if hide_unavailable:
            kind = deep_get(viewref, DictPath("kind"), ("", ""))
            if kind is not None and kind != ("", ""):
                if not kind[0].startswith("__") \
                        and (kind not in available_api_families
                             or not deep_get(available_api_families[kind],
                                             DictPath("available"), False)):
                    continue
            check_availability = deep_get(viewref, DictPath("check_availability"), None)
            if check_availability is not None:
                if not check_availability():
                    continue
        group = deep_get(viewref, DictPath("group"))
        # XXX: Do override in a nicer manner; perhaps we want all "built-in" groups first?
        if group == "Administration":
            group = "0"
        elif group == "Core":
            group = "1"
        elif group == "Workloads":
            group = "2"
        elif "(Deprecated)" in group:
            # This should ensure that all deprecated groups end up last, but still sorted
            group = "ZZZZZ" + group

        view_name = deep_get(viewref, DictPath("windowheader"))

        if kind is not None:
            api_group = kind[1]
        else:
            api_group = ""

        if group is None:
            raise ValueError(f"group should not be None unless skip=True; view: {view_name}")

        order.append((view_name, group, api_group))

    currentgroup = ""
    for item in natsorted(order, key=itemgetter(sortkey1, sortkey2)):
        view = item[0]
        viewkey = view
        api_group = item[2]
        if api_group:
            viewkey = f"{view} ({api_group})"
        viewref = views[viewkey]

        # This allows us to override the sort order
        group = deep_get(viewref, DictPath("group"), "")
        kind = deep_get(viewref, DictPath("kind"), ("", ""))
        if kind is not None:
            api_group = kind[1]
        else:
            api_group = ""

        if currentgroup != group and categorise:
            items.append({
                "lineattrs": WidgetLineAttrs.SEPARATOR,
                "columns": [[ThemeStr(f" {group} ", ThemeAttr("windowwidget", "highlight"))],
                            [ThemeStr("", ThemeAttr("windowwidget", "default"))]],
            })
            currentgroup = group
        lineattrs = WidgetLineAttrs.NORMAL
        if kind is not None and kind != ("", "") and not kind[0].startswith("__") \
                and (kind not in available_api_families
                     or not deep_get(available_api_families[kind], DictPath("available"), False)):
            lineattrs = WidgetLineAttrs.UNSELECTABLE
        if api_group == "":
            items.append({
                "lineattrs": lineattrs,
                "columns": [[ThemeStr(f"{view}", ThemeAttr("windowwidget", "default"))],
                            [ThemeStr("", ThemeAttr("windowwidget", "dim"))]],
                "retval": viewkey,
            })
        else:
            items.append({
                "lineattrs": lineattrs,
                "columns": [[ThemeStr(f"{view}", ThemeAttr("windowwidget", "default"))],
                            [ThemeStr(f"<{api_group}>", ThemeAttr("windowwidget", "dim"))]],
                "retval": viewkey,
            })

    return items


def selectwindow(uip: UIProps, refresh_apis: bool = False) -> Retval:
    # Ideally we want to return to the same selection
    global defaultview  # pylint: disable=global-statement

    uip.refresh_all()
    items = format_selection_list(uip, refresh_apis)
    title = "Choose view"

    selection = None

    categorise = deep_get(cmtlib.cmtconfig, DictPath("__Selector#categorise"), True)

    while selection is None:
        extra_args = {"KEY_F6": True}
        tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2,
                                                  uip.maxx // 2, items, title=title,
                                                  preselection=defaultview, **extra_args)
        if tmpselection is not None:
            # pylint: disable-next=unidiomatic-typecheck
            if type(tmpselection) == int and tmpselection < 0:  # noqa: E721
                if tmpselection == -curses.KEY_F6:
                    categorise = not categorise
                    deep_set(cmtlib.cmtconfig, DictPath("__Selector#categorise"),
                             categorise, create_path=True)
                    items = format_selection_list(uip, refresh_apis)
                    uip.refresh_all()
                    continue
            selection = tmpselection

    if selection != "":
        defaultview = selection
        return Retval.RETURNFULL

    return Retval.NOMATCH


def selectorloop(stdscr: curses.window, view: str) -> Retval:
    """
    Main loop for the Selector.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            view (str): The view to show
        Returns:
            (Retval): The return value
        Raises:
            ProgrammingError (view is invalid)
    """
    field_list, sortcolumn = (None, None)
    uip = UIProps(stdscr)

    windowheader = deep_get(views, DictPath(f"{view}#windowheader"), view)

    uip.init_window(field_list=field_list, windowheader=windowheader, sortcolumn=sortcolumn)

    while True:
        retval = selectwindow(uip)
        if retval == Retval.RETURNFULL:
            return retval


listviewactions = {
    "Apply configuration (local)": {
        "description": "Apply configurations from file/Kustomization (autodetected)",
        "confirm": True,
        "actionfunc": perform_action_on_configuration,
        "query": "Choose file or Kustomization to apply:",
        "queryval": "resource_path",
        "queryfunc": "filechooser",
        "extravars": {
            "action": "apply",
            "listgetter": list_configuration_files,
            "basedir": DEPLOYMENT_DIR,
        },
        # "confirmfunc":
        # "confirmstring": "The following changes will be performed:",
    },
    "Create resources (local)": {
        "description": "Create resources from file/Kustomization (autodetected)",
        "actionfunc": perform_action_on_configuration,
        "query": "Choose file or Kustomization to create:",
        "queryval": "resource_path",
        "queryfunc": "filechooser",
        "extravars": {
            "action": "create",
            "listgetter": list_configuration_files,
            "basedir": DEPLOYMENT_DIR,
        },
    },
    "Apply configuration (URL to file)": {
        "description": "Apply configurations from URL (file)",
        "confirm": True,
        "actionfunc": perform_action_on_configuration,
        "query": "URL to apply",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "action": "apply",
            "rtype": "Configuration File",
        },
        # "confirmfunc":
        # "confirmstring": "The following changes will be performed:",
    },
    "Apply configuration (URL to Kustomization)": {
        "description": "Apply configurations from URL (Kustomization)",
        "confirm": True,
        "actionfunc": perform_action_on_configuration,
        "query": "URL to apply",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "action": "apply",
            "rtype": "Kustomization",
        },
        # "confirmfunc":
        # "confirmstring": "The following changes will be performed:",
    },
    "Create resources (URL to file)": {
        "description": "Create resources from URL (file)",
        "actionfunc": perform_action_on_configuration,
        "query": "URL to create resource from",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "action": "create",
            "rtype": "Configuration File",
        },
    },
    "Create resources (URL to Kustomization)": {
        "description": "Create resources from URL (Kustomization)",
        "actionfunc": perform_action_on_configuration,
        "query": "URL to create resource from",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "action": "create",
            "rtype": "Kustomization",
        },
    },
    "Delete resources (file)": {
        "description":
            "Delete resource by reverting configuration file/Kustomization (autodetected)",
        "actionfunc": perform_action_on_configuration,
        "query": "Choose file or Kustomization to delete:",
        "queryval": "resource_path",
        "queryfunc": "filechooser",
        "extravars": {
            "action": "delete",
            "listgetter": list_configuration_files,
            "basedir": DEPLOYMENT_DIR,
        },
    },
    "Delete resources (URL to file)": {
        "description": "Delete resource by reverting configuration URL (file)",
        "actionfunc": perform_action_on_configuration,
        "query": "URL to configuration file to revert",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "action": "delete",
            "rtype": "Configuration File",
        },
    },
    "Delete resources (URL to Kustomization)": {
        "description": "Delete resource by reverting configuration URL (Kustomization)",
        "actionfunc": perform_action_on_configuration,
        "query": "URL to configuration Kustomization to revert",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "action": "delete",
            "rtype": "Kustomization",
        },
    },
    "Diff resource creation (local)": {
        "description": "Show what changes applying file or Kustomization would make (autodetected)",
        "actionfunc": diff_resource_configuration,
        "query": "Choose file or Kustomization to show difference against:",
        "queryval": "resource_path",
        "queryfunc": "filechooser",
        "extravars": {
            "listgetter": list_configuration_files,
            "basedir": DEPLOYMENT_DIR,
        },
    },
    "Diff resource creation (URL to file)": {
        "description": "Show what changes applying URL would make (file)",
        "actionfunc": diff_resource_configuration,
        "query": "URL to file to show difference against",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "rtype": "Configuration File",
        },
    },
    "Diff resource creation (URL to Kustomization)": {
        "description": "Show what changes applying URL would make (Kustomization)",
        "actionfunc": diff_resource_configuration,
        "query": "URL to Kustomization to show difference against",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "rtype": "Kustomization",
        },
    },
}


infoviews = {}  # type: ignore


# These functions are used to check whether an API is available
def is_kubernetes_supported() -> bool:
    return kubernetes_support


def is_cluster_reachable() -> bool:
    reachable = False

    if kubernetes_support and kh is not None:
        reachable = kh.is_cluster_reachable()
    return reachable


availability_checker_allowlist: dict[str, Callable] = {
    "is_cluster_reachable": is_cluster_reachable,
    "is_kubernetes_supported": is_kubernetes_supported,
}


# action calls acceptable for direct use in view files
action_call_allowlist: dict[str, Callable] = {
    "create_namespace": create_namespace,
    "decode_and_view_data": decode_and_view_data,
    "decode_and_view_file_templates": decode_and_view_file_templates,
    "edit_resource": edit_resource,
    "eventdispatch": eventdispatch,
    "export_data": export_data,
    "listviewdispatch": listviewdispatch,
    "patch_object": patch_object,
    "resourceinfodispatch_from_pod_resource_list": resourceinfodispatch_from_pod_resource_list,
    "resourceinfodispatch_with_lookup": resourceinfodispatch_with_lookup,
    "resourceinfodispatch_from_selection": resourceinfodispatch_from_selection,
    "set_cluster_context": set_cluster_context,
    "ssh_to_host": ssh_to_host,
    "view_last_applied_configuration": view_last_applied_configuration,
    "view_obj": view_obj,
    "view_pod_logs": view_pod_logs,
    "view_json": view_json,
    "view_yaml": view_yaml,
}


# Actionfuncs acceptable for direct use in view files
actionfunc_allowlist: dict[str, Callable] = {
    "action_view_pod_logs": action_view_pod_logs,
    "cordon_node": cordon_node,
    "delete_logs": delete_logs,
    "delete_resource": delete_resource,
    "drain_node": drain_node,
    "force_delete_resource": force_delete_resource,
    "force_drain_node": force_drain_node,
    "patch_resource": patch_resource,
    "rescale_resource": rescale_resource,
    "restart_resource_rescale": restart_resource_rescale,
    "restart_resource_rollout": restart_resource_rollout,
    "stop_resource_rescale": stop_resource_rescale,
    "uncordon_node": uncordon_node,
}


# Activatedfuns acceptable for direct use in view files
activatedfun_allowlist: dict[str, Callable] = {
    "resourceinfodispatch": resourceinfodispatch,
    "resourceinfodispatch_from_pod_resource_list": resourceinfodispatch_from_pod_resource_list,
    "resourceinfodispatch_with_lookup_on_activation":
        resourceinfodispatch_with_lookup_on_activation,
}


# Infogetters acceptable for direct use in view files
infogetter_allowlist: dict[str, Callable] = {
    # Used by listview, infopad, and listpad
    "generic_infogetter": generic_infogetter,
    # Used by listview
    "get_container_info": get_container_info,
    "get_log_info": get_log_info,
    # Used by listpad
    "get_auth_rule_info": infogetters.get_auth_rule_info,
    "get_eps_subsets_info": infogetters.get_eps_subsets_info,
    "get_key_value_info": infogetters.get_key_value_info,
    "get_limit_info": infogetters.get_limit_info,
    "get_promrules_info": infogetters.get_promrules_info,
    "get_rq_item_info": infogetters.get_rq_item_info,
    "get_sas_info": infogetters.get_sas_info,
    "get_strategy_info": infogetters.get_strategy_info,
    "get_subsets_info": infogetters.get_subsets_info,
    # Used by logpad
    "logpad_formatted": logpad_formatted,
    # XXX: We should aim to replace this with logpad_formatted
    "logpad_msg_getter": logpad_msg_getter,
    # XXX: We should aim to replace this with logpad_formatted
    "logpad_yaml": logpad_yaml,
    "logpad_files": logpad_files,
    "get_journalctl_log": get_journalctl_log,
    "get_task_log": get_task_log,
    "get_cmt_log": get_cmt_log,
    "get_themearrays": infogetters.get_themearrays,
    "get_traceflow": get_traceflow,
}


# These views are always defined internally and cannot be disabled
views_special = {
    "Selector": {
        "windowheader": "Selector",
        "kind": ("__Selector", ""),
        "commandline": ["selector"],
        "viewfunc": selectorloop,
        "fields": None,
        "skip": True,
        "is_taggable": False,
    },
    "Cluster Overview": {
        "windowheader": "Cluster Overview",
        "kind": ("__ClusterOverview", ""),
        "commandline": ["clusteroverview", "clusterinfo", "overview", "co", "ci"],
        "group": "Administration",
        "viewfunc": clusteroverviewloop,
        "fields": None,
        "update_delay": 5,
        "sortcolumn": None,
        "activatedfun": None,
        "listgetter": None,
        "infogetter": None,
        "is_taggable": False,
        "check_availability": is_cluster_reachable,
    },
    "Container Network Interface Info": {
        "windowheader": "Container Network Interface Info",
        "kind": ("__ContainerNetworkInterface", ""),
        "commandline": ["cni"],
        "group": "Administration",
        "viewfunc": cniloop,
        "fields": None,
        "sortcolumn": None,
        "activatedfun": None,
        "listgetter": None,
        "infogetter": None,
        "check_availability": is_cluster_reachable,
    },
}


views = {**views_special}


key_mappings = {
    "f1": curses.KEY_F1,
    "f2": curses.KEY_F2,
    "f3": curses.KEY_F3,
    "f4": curses.KEY_F4,
    "f5": curses.KEY_F5,
    "f6": curses.KEY_F6,
    "f7": curses.KEY_F7,
    "f8": curses.KEY_F8,
    "f9": curses.KEY_F9,
    "f10": curses.KEY_F10,
    "f11": curses.KEY_F11,
    "f12": curses.KEY_F12,
    "f13": curses.KEY_F13,
    "f14": curses.KEY_F14,
    "f15": curses.KEY_F15,
    "f16": curses.KEY_F16,
    "f17": curses.KEY_F17,
    "f18": curses.KEY_F18,
    "f19": curses.KEY_F19,
    "f20": curses.KEY_F20,
    "f21": curses.KEY_F21,
    "f22": curses.KEY_F22,
    "f23": curses.KEY_F23,
    "f24": curses.KEY_F24,
}


def map_key(view_file: str, shortcut: str, activatedfun,
            key: str, modifier: str) -> tuple[int | list[int], str]:
    if modifier and modifier not in ("ctrl", "shift"):
        sys.exit(f"View-file {view_file} is invalid: "
                 f"unknown modifier {modifier}; valid modifiers are shift, ctrl; aborting")

    if key in ("f1", "f2", "f3", "f4", "f5", "f6",
               "f7", "f8", "f9", "f10", "f11", "f12") and not modifier:
        shortcut_key = deep_get(key_mappings, DictPath(key))
        help_key = f"[{key.upper()}]"
    elif key in ("f1", "f2", "f3", "f4", "f5", "f6",
                 "f7", "f8", "f9", "f10", "f11", "f12") and modifier == "shift":
        _key = key[0] + str(int(key[1:]) + 12)
        num = int(key[1:]) + 12
        shortcut_key = deep_get(key_mappings, DictPath(_key))
        help_key = f"[Shift] + [{key.upper()}] / [{key[0].upper()}{num}]"
    elif key in ("f13", "f14", "f15", "f16", "f17", "f18",
                 "f19", "f20", "f21", "f22", "f23", "f24") and not modifier:
        num = int(key[1:]) - 12
        _key = key[0] + str(num)
        shortcut_key = deep_get(key_mappings, DictPath(key))
        help_key = f"[Shift] + [{key[0].upper()}{num}] / [{key.upper()}]"
    elif key in ("enter", "return"):
        if modifier:
            help_key = "[Enter]"
            shortcut_key = [curses.KEY_ENTER, 10, 13]
        if modifier or activatedfun is None:
            help_key = "[Enter]"
            shortcut_key = [curses.KEY_ENTER, 10, 13]
        else:
            sys.exit(f"View-file “{view_file}“ is invalid: the listview shortcut “{shortcut}“"
                     " uses “enter“ as key; this conflicts with "
                     "built-in shortcut for “on_activation“.")
    elif modifier:
        if modifier == "shift":
            help_key = f"[Shift] + {key.upper()}"
            shortcut_key = ord(key.upper())
        elif modifier == "ctrl":
            help_key = f"[Ctrl] + {key.upper()}"
            shortcut_key = ord(key) - 96
    else:
        help_key = f"{key.upper()}"
        shortcut_key = ord(key)

    return shortcut_key, help_key


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def populate_views(force_refresh: bool = False) -> None:
    """
    Populate the list- and info-view data from view-files.

        Parameters:
            force_refresh (bool): Force fresh of the list of available APIs
    """
    global views  # pylint: disable=global-statement

    if kubernetes_support:
        tmp_available_api_families, _status, _modified = \
            kh.get_available_kinds(force_refresh=force_refresh)
    else:
        tmp_available_api_families = {}

    available_api_families = set()
    for kind, kind_data in tmp_available_api_families.items():
        if deep_get(kind_data, DictPath("available"), False):
            available_api_families.add(kind)

    # Get a full list of views from all view directories
    # Start by adding files from the views directory
    view_dirs = []
    view_dirs += deep_get(cmtlib.cmtconfig, DictPath("General#local_views"), [])

    views = {**views_special}

    view_dirs.append(cmtpaths.VIEW_DIR)
    view_dirs.append(cmtpaths.SYSTEM_VIEWS_DIR)

    view_files = []

    yaml_regex: re.Pattern[str] = re.compile(r"^(.*)\.ya?ml$")

    for view_dir in view_dirs:
        if view_dir.startswith("{HOME}"):
            view_dir = view_dir.replace("{HOME}", HOMEDIR, 1)

        if not os.path.isdir(view_dir):
            continue

        for filename in natsorted(os.listdir(view_dir)):
            filename = cast(str, filename)
            if filename.startswith(("~", ".")):
                continue
            if not filename.endswith((".yaml", ".yml")):
                continue

            match_tmp: re.Match[str] = yaml_regex.match(filename)
            tmp = match_tmp[1]
            if "." in tmp:
                kind, api_family = tmp.split(".", 1)
            else:
                kind = tmp
                api_family = ""
            if (kind, api_family) in available_api_families or kind.startswith("__"):
                view_files.append(os.path.join(view_dir, filename))

    # pylint: disable-next=too-many-nested-blocks
    for view_file in view_files:
        has_listview = False
        has_infoview = False

        try:
            d = secure_read_yaml(FilePath(view_file), directory_is_symlink=True)
        except yaml.parser.ParserError:
            sys.exit(f"View-file {view_file} is invalid; aborting.")

        kind = deep_get(d, DictPath("kind"), "<missing>")
        default_command = deep_get(d, DictPath("default_command"), "<missing>")
        if kind is None or default_command is None or "<missing>" in (kind, default_command):
            sys.exit(f"View-file {view_file} is invalid: "
                     "the following fields cannot be missing or None:\n"
                     f"kind: {kind}\n"
                     f"default_command: {default_command}\n"
                     "Aborting.")

        api_family = deep_get(d, DictPath("api_family"), "")
        # Use a set to avoid duplicates
        _command = set()
        if not kind.startswith("__"):
            # If there's a "." in the command it means the plural or singular
            # is not unique without api_family;
            # do not add the lowercase form of kind automagically
            if "." not in default_command:
                _command.add(kind.lower())
        if deep_get(d, DictPath("command"), []):
            _command = set.union(_command, set(deep_get(d, DictPath("command"), [])))
        # OK, we've got all commands we wanted; now we want the preferred form first
        _command.discard(default_command)
        _command = [default_command] + list(_command)
        # Finally, now that we have a list, add variants with api_family suffixed
        command = list(_command)
        if api_family:
            for item in _command:
                command.append(f"{item}.{api_family}")

        listview_entry = None

        if "listview" not in d and "infoview" not in d:
            sys.exit(f"View-file {view_file} lacks both listview and infoview; "
                     "there might be typo somewhere")

        if "listview" in d:
            # Do we need to override kind?
            if deep_get(d, DictPath("listview#kind")) is not None:
                kind = deep_get(d, DictPath("listview#kind"))
                api_family = deep_get(d, DictPath("listview#api_family"), "")
            name = deep_get(d, DictPath("listview#name"), "<missing>")
            group = deep_get(d, DictPath("listview#group"))

            check_availability = \
                check_allowlist(availability_checker_allowlist,
                                "availability_checker_allowlist",
                                deep_get(d, DictPath("listview#check_availability")),
                                allow_none=True)

            sortcolumn = deep_get(d, DictPath("listview#sortcolumn"))
            reversible = deep_get(d, DictPath("listview#reversible"), True)
            sortorder_reverse = deep_get(d, DictPath("listview#sortorder_reverse"), False)
            fields = deep_get(d, DictPath("listview#fields"), {})

            field_indexes = {}
            _indexes = deep_get(d, DictPath("listview#field_indexes"), {})
            confkind = kind
            viewname = name
            if api_family:
                confkind = f"{confkind}.{api_family}"
                viewname = f"{viewname} ({api_family})"

            custom_index = deep_get(cmtlib.cmtconfig,
                                    DictPath(f"Views#{confkind}#listview#field_indexes#Custom"), [])
            if custom_index:
                _indexes["Custom"] = custom_index

            if not _indexes:
                sys.exit(f"View-file {view_file} is invalid: "
                         "field_indexes is either missing or empty for the list view. Aborting.")

            field_indexes = copy.deepcopy(_indexes)

            # Allow for overriding the default sortcolumn and sortorder_reverse
            for field_index, data in field_indexes.items():
                if field_index in deep_get(cmtlib.cmtconfig,
                                           DictPath(f"Views#{confkind}#listview#field_indexes"),
                                           {}):
                    default_field_index_sortcolumn = \
                        deep_get(data, DictPath("sortcolumn"), sortcolumn)
                    default_field_index_sortorder_reverse = \
                        deep_get(data, DictPath("sortorder_reverse"), sortorder_reverse)
                    field_index_sortcolumn = \
                        deep_get(cmtlib.cmtconfig,
                                 DictPath(f"Views#{confkind}#listview#field_indexes#"
                                          f"{field_index}#sortcolumn"),
                                 default_field_index_sortcolumn)
                    field_index_sortorder_reverse = \
                        deep_get(cmtlib.cmtconfig,
                                 DictPath(f"Views#{confkind}#listview#field_indexes#"
                                          f"{field_index}#sortorder_reverse"),
                                 default_field_index_sortorder_reverse)
                    field_indexes[field_index]["sortcolumn"] = field_index_sortcolumn
                    field_indexes[field_index]["sortorder_reverse"] = field_index_sortorder_reverse

            if name is None or group is None or "<missing>" in (name, group):
                sys.exit(f"View-file {view_file} is invalid: "
                         "the following fields cannot be missing, empty or None:\n"
                         "listview:\n"
                         f"  name: {name}\n"
                         f"  group: {group}\n"
                         "Aborting.")

            if viewname in views:
                conflicting_kind = deep_get(views[viewname], DictPath("kind"))
                sys.exit(f"Error when processing view-file {view_file} for kind: "
                         f"{(kind, api_family)}; a view named {viewname} already exists "
                         f"(for the kind: {conflicting_kind})")

            # This complexity is required because if the key is missing we want to use the default,
            # but if the key is explicitly None we do not want any fallback
            if "infogetter" in deep_get(d, DictPath("listview")):
                infogetter = check_allowlist(infogetter_allowlist, "infogetter_allowlist",
                                             deep_get(d, DictPath("listview#infogetter")),
                                             allow_none=True)
            else:
                infogetter = generic_infogetter

            listgetter_async = check_allowlist(listgetter_async_allowlist,
                                               "listgetter_async_allowlist",
                                               deep_get(d, DictPath("listview#listgetter_async")),
                                               allow_none=True)

            listgetter = check_allowlist(listgetter_allowlist, "listgetter_allowlist",
                                         deep_get(d, DictPath("listview#listgetter")),
                                         allow_none=True)

            # If both are unset we use the default asynchronous listgetter
            if "listgetter" not in deep_get(d, DictPath("listview")) and \
               "listgetter_async" not in deep_get(d, DictPath("listview")):
                listgetter_async = listgetters_async.get_kubernetes_list

            listgetter_args = deep_get(d, DictPath("listview#listgetter_args"), {})

            on_activation = deep_get(d, DictPath("listview#on_activation"))
            if on_activation is None or "call" not in on_activation:
                activatedfun = genericinfoloop
            else:
                activatedfun = check_allowlist(activatedfun_allowlist, "activatedfun_allowlist",
                                               deep_get(on_activation, DictPath("call")),
                                               allow_none=True)

            if "labels" in deep_get(d, DictPath("listview"), {}):
                labels = deep_get(d, DictPath("listview#labels"))
            else:
                labels = "metadata#labels"

            listview_entry = {
                "kind": (kind, api_family),
                "commandline": command,
                "windowheader": name,
                "group": group,
                "check_availability": check_availability,
                "field_indexes": field_indexes,
                "fields": fields,
                "activatedfun": activatedfun,
                "listview_args": deep_get(d, DictPath("listview#listview_args"), {}),
                "statusmsg": deep_get(d, DictPath("listview#statusmsg"), {}),
                "is_taggable": deep_get(d, DictPath("listview#is_taggable"), True),
                "labels": labels,
                "listgetter": listgetter,
                "listgetter_async": listgetter_async,
                "listgetter_args": listgetter_args,
                "reversible": reversible,
                "infogetter": infogetter,
                "infogetter_args": deep_get(d, DictPath("listview#infogetter_args"), {}),
                "actions": deep_get(d, DictPath("listview#actions"), {}),
            }

            shortcuts = {}

            _shortcuts = deep_get(d, DictPath("listview#shortcuts"), {})

            # Always include the shortcuts for YAML dump and JSON dump, unless overridden
            if "View YAML dump" not in _shortcuts:
                _shortcuts["View JSON dump of resource"] = {
                    "key": "j",
                    "read_only": True,
                    "helptext": "View JSON dump of resource",
                    "action": "call",
                    "action_call": "view_json",
                    "action_args": {
                        "title": "JSON dump",
                        "_named_title": True,
                        "_pass_obj": True,
                    },
                    "force_update": False,
                    "force_refresh": True,
                }
                _shortcuts["View YAML dump of resource"] = {
                    "key": "y",
                    "read_only": True,
                    "helptext": "View YAML dump of resource",
                    "action": "call",
                    "action_call": "view_yaml",
                    "action_args": {
                        "title": "YAML dump",
                        "_named_title": True,
                        "_pass_obj": True,
                    },
                    "force_update": False,
                    "force_refresh": True,
                }

            # Always include the shortcut for edit resource, unless overridden
            if "Edit resource" not in _shortcuts:
                _shortcuts["Edit resource"] = {
                    "key": "e",
                    "read_only": False,
                    "helptext": "Edit resource",
                    "action": "call",
                    "action_call": "edit_resource",
                    "action_args": {
                        "_pass_obj": True,
                        "_pass_kind": True,
                    },
                    "force_update": False,
                    "force_refresh": True,
                }

            for shortcut in _shortcuts:
                # If the shortcut is empty we are disabling a default shortcut
                if _shortcuts[shortcut] is None or not _shortcuts[shortcut]:
                    shortcuts[shortcut] = {}
                    continue

                key = deep_get(_shortcuts[shortcut], DictPath("key"), "<missing>")
                modifier = deep_get(_shortcuts[shortcut], DictPath("modifier"), "")
                helptext = deep_get(_shortcuts[shortcut], DictPath("helptext"), "<missing>")
                action = deep_get(_shortcuts[shortcut], DictPath("action"), "<missing>")
                action_args = deep_get(_shortcuts[shortcut], DictPath("action_args"), {})
                queryfunc = deep_get(_shortcuts[shortcut], DictPath("queryfunc"))
                queryval = deep_get(_shortcuts[shortcut], DictPath("queryval"))
                query = deep_get(_shortcuts[shortcut], DictPath("query"))
                read_only = deep_get(_shortcuts[shortcut], DictPath("read_only"), False)
                force_update = deep_get(_shortcuts[shortcut], DictPath("force_update"), True)
                force_refresh = deep_get(_shortcuts[shortcut], DictPath("force_refresh"), True)

                if key is None or helptext is None \
                        or action is None or "<missing>" in (key, helptext, action):
                    sys.exit(f"View-file {view_file} is invalid: "
                             "the following fields cannot be missing or None for a shortcut:\n"
                             f"key: {key}\n"
                             f"helptext: {helptext}\n"
                             f"action: {action}\n"
                             "Aborting.")

                key = key.lower()
                modifier = modifier.lower()

                shortcut_key, help_key = map_key(view_file, shortcut, activatedfun, key, modifier)

                shortcuts[shortcut] = {
                    "shortcut": shortcut_key,
                    "helptext": (help_key, helptext),
                    "action": action,
                    "action_args": action_args,
                    "action_call": action_args,
                    "queryfunc": queryfunc,
                    "queryval": queryval,
                    "query": query,
                    "read_only": read_only,
                    "force_update": force_update,
                    "force_refresh": force_refresh,
                }
                if action == "call":
                    shortcuts[shortcut]["action_call"] = \
                        check_allowlist(action_call_allowlist, "action_call_allowlist",
                                        deep_get(_shortcuts[shortcut], DictPath("action_call")),
                                        allow_none=True)

            if shortcuts:
                listview_entry["shortcuts"] = shortcuts

            # Replace existing listviews with the same name
            views.pop(name, None)

            # Add the new view
            has_listview = True
            views[viewname] = listview_entry

        infoview_entry = None

        if "infoview" in d:
            # Default kind and api_family unless overriden
            kind = deep_get(d, DictPath("kind"), "<missing>")
            api_family = deep_get(d, DictPath("api_family"), "")

            # Do we need to override kind?
            if deep_get(d, DictPath("infoview#kind")) is not None:
                kind = deep_get(d, DictPath("infoview#kind"))
                api_family = deep_get(d, DictPath("infoview#api_family"), "")
            name = deep_get(d, DictPath("infoview#name"), "<missing>")
            infopad = deep_get(d, DictPath("infoview#infopad"), {})

            row_indexes = {}
            row_fields = {}

            _indexes = deep_get(infopad, DictPath("row_indexes"))

            if _indexes is not None:
                if not _indexes:
                    sys.exit(f"View-file {view_file} is invalid: "
                             "row_indexes is empty for the info view. Aborting.")

                # We are not using row_indexes in the same way field_indexes are used;
                # we do not support multiple profiles; since dicts are ordered by insertion
                # we get the rows in the right order if we order by row_indexes,
                # and we do not support resorting, so we do not need to include the row_indexes
                row_indexes = copy.deepcopy(deep_get(_indexes, DictPath("Normal#fields"), []))

                # Rows need to be reformatted
                infopad_rows = deep_get(infopad, DictPath("rows"), {})

                for row in row_indexes:
                    if row not in infopad_rows:
                        sys.exit(f"View {name}: row “{row}“ cannot be found in infoview\n"
                                 f"Infoview rows: {infopad_rows}\nrow names: {row_indexes}")
                    row_fields[row] = copy.deepcopy(deep_get(infopad_rows, DictPath(row), {}))
                    # We need to reformat the header
                    _header = deep_get(infopad_rows,
                                       DictPath(f"{row}#header"),
                                       [["<unset>", ["types", "unset"]]])
                    header: list[ThemeRef | ThemeStr] = []
                    try:
                        for string, formatting in _header:
                            header.append(ThemeStr(string,
                                                   ThemeAttr(formatting[0], formatting[1])))
                    except ValueError as e:
                        if str(e) == "not enough values to unpack (expected 2, got 1)":
                            sys.exit(f"Invalid header for info-header row \"{row}\" in file "
                                     f"\"{view_file}\"; this header doesn't "
                                     "seem to be a valid ThemeArray")
                    row_fields[row]["header"] = header

            listpad = deep_get(d, DictPath("infoview#listpad"), {})

            on_activation = deep_get(listpad, DictPath("on_activation"))
            activatedfun = check_allowlist(activatedfun_allowlist, "activatedfun_allowlist",
                                           deep_get(on_activation, DictPath("call")),
                                           allow_none=True)
            override_kind = deep_get(on_activation, DictPath("kind"))
            override_api_family = deep_get(on_activation, DictPath("api_family"), "")
            on_activation_extraref = deep_get(on_activation, DictPath("extraref"))
            on_activation_data = deep_get(on_activation, DictPath("data"))
            if override_kind is None:
                viewoverride = (kind, api_family)
            else:
                viewoverride = (override_kind, override_api_family)
                on_activation["kind"] = viewoverride
                on_activation.pop("api_family", "")

            if "labels" in deep_get(d, DictPath("listview"), {}):
                labels = deep_get(d, DictPath("listview#labels"))
            else:
                labels = "metadata#labels"
            if "annotations" in deep_get(d, DictPath("listview"), {}):
                annotations = deep_get(d, DictPath("infoview#annotations"))
            else:
                annotations = "metadata#annotations"

            sortcolumn = deep_get(listpad, DictPath("sortcolumn"))
            reversible = deep_get(listpad, DictPath("reversible"), True)
            sortorder_reverse = deep_get(listpad, DictPath("sortorder_reverse"), False)

            listpad_fields = deep_get(listpad, DictPath("fields"), {})

            listpad_field_indexes = {}
            _indexes = deep_get(listpad, DictPath("field_indexes"), {})
            confkind = kind
            if api_family:
                confkind = f"{confkind}.{api_family}"
            custom_index = \
                deep_get(cmtlib.cmtconfig,
                         DictPath(f"Views#{confkind}#infoview#listpad#field_indexes#Custom"), [])
            if custom_index:
                _indexes["Custom"] = custom_index

            for key in _indexes:
                if isinstance(_indexes[key], list):
                    listpad_field_indexes[key] = {}
                    listpad_field_indexes[key]["fields"] = copy.deepcopy(_indexes[key])
                    listpad_field_indexes[key]["sortcolumn"] = sortcolumn
                    listpad_field_indexes[key]["sortorder_reverse"] = sortorder_reverse
                else:
                    listpad_field_indexes = copy.deepcopy(_indexes)

            infoview_entry = {
                "kind": (kind, api_family),
                "windowheader": name,
                "field_indexes": listpad_field_indexes,
                "fields": listpad_fields,
                "activatedfun": activatedfun,
                "infoview_args": deep_get(d, DictPath("infoview#infoview_args"), {}),
                "statusmsg": deep_get(d, DictPath("infoview#statusmsg"), {}),
                "viewoverride": viewoverride,
                "extraref": on_activation_extraref,
                "data": on_activation_data,
                "infopad": row_fields,
                "listpad": {},
                "reversible": reversible,
                "labels": labels,
                "annotations": annotations,
                "shortcuts": {},
                "no_reload_on_refresh": deep_get(d, DictPath("infoview#no_reload_on_refresh"),
                                                 False),
            }
            infoview_entry["objgetter"] = \
                check_allowlist(objgetter_allowlist, "objgetter_allowlist",
                                deep_get(infopad, DictPath("objgetter")),
                                allow_none=True)

            if listpad:
                infoview_entry["listpad"]["on_activation"] = on_activation

            if infopad is not None:
                if "name_path" in infopad:
                    infoview_entry["name_path"] = deep_get(infopad, DictPath("name_path"))
                if "namespace_path" in infopad:
                    infoview_entry["namespace_path"] = deep_get(infopad, DictPath("namespace_path"))
                if "creation_timestamp_path" in infopad:
                    infoview_entry["creation_timestamp_path"] = \
                        deep_get(infopad, DictPath("creation_timestamp_path"))

            list_listgetter = deep_get(listpad, DictPath("listgetter"))
            list_listgetter_args = deep_get(listpad, DictPath("listgetter_args"), {})
            list_infogetter = deep_get(listpad, DictPath("infogetter"))
            list_infogetter_args = deep_get(listpad, DictPath("infogetter_args"))
            if list_infogetter is None:
                if listpad:
                    raise ValueError(f"View-file {view_file} is invalid: "
                                     "listpad specified, but no infogetter is provided")
            else:
                infoview_entry["listpad"]["infogetter"] = \
                    check_allowlist(infogetter_allowlist, "infogetter_allowlist",
                                    list_infogetter)
                infoview_entry["listpad"]["infogetter_args"] = list_infogetter_args
            if list_listgetter is None:
                if listpad:
                    raise ValueError(f"View-file {view_file} is invalid: "
                                     "listpad specified, but no listgetter is provided")
            else:
                infoview_entry["listpad"]["listgetter"] = \
                    check_allowlist(listgetter_allowlist, "listgetter_allowlist",
                                    list_listgetter)
                infoview_entry["listpad"]["listgetter_args"] = list_listgetter_args

            shortcuts = {}

            _shortcuts = deep_get(d, DictPath("infoview#shortcuts"), {})

            # Always include the shortcuts for YAML dump and JSON dump, unless overridden
            if "YAML" not in _shortcuts:
                _shortcuts["View JSON dump of resource"] = {
                    "key": "j",
                    "read_only": True,
                    "helptext": "View JSON dump of resource",
                    "action": "call",
                    "action_call": "view_json",
                    "action_args": {
                        "title": "JSON dump",
                        "_named_title": True,
                        "_pass_obj": True,
                    },
                }
                _shortcuts["View YAML dump of resource"] = {
                    "key": "y",
                    "read_only": True,
                    "helptext": "View YAML dump of resource",
                    "action": "call",
                    "action_call": "view_yaml",
                    "action_args": {
                        "title": "YAML dump",
                        "_named_title": True,
                        "_pass_obj": True,
                    },
                }

            # Always include the shortcut for last applied configuration, unless overridden
            if "Last Applied Configuration" not in _shortcuts:
                _shortcuts["Last Applied Configuration"] = {
                    "key": "l",
                    "modifier": "shift",
                    "read_only": True,
                    "helptext": "Show last applied configuration",
                    "action": "call",
                    "action_call": "view_last_applied_configuration",
                    "action_args": {
                        "_pass_obj": True,
                        "title": "Last applied configuration",
                    }
                }

            # Always include the shortcut for events unless overriden
            if "Show Events" not in _shortcuts:
                _shortcuts["Show Events"] = {
                    "key": "e",
                    "read_only": True,
                    "helptext": "Show events",
                    "widget": "windowwidget",
                    "selectable": True,
                    "action": "call",
                    "action_call": "resourceinfodispatch_with_lookup",
                    "action_args": {
                        "kind": "Event",
                        "namespace_path": 0,
                        "name_path": 1,
                    },
                    "title": "Events:",
                    "headers": ["Namespace:", "Name:", "Last Seen:", "Status:",
                                "Reason:", "Source:", "First Seen:", "Count:", "Message:"],
                    "itemgetter": "get_events",
                }

            for shortcut in _shortcuts:
                # If the shortcut is empty we are disabling a default shortcut
                if _shortcuts[shortcut] is None or not _shortcuts[shortcut]:
                    shortcuts[shortcut] = {}
                    continue

                key = deep_get(_shortcuts[shortcut], DictPath("key"), "<missing>")
                modifier = deep_get(_shortcuts[shortcut], DictPath("modifier"), "")
                helptext = deep_get(_shortcuts[shortcut], DictPath("helptext"), "<missing>")
                action = deep_get(_shortcuts[shortcut], DictPath("action"), "<missing>")
                action_args = deep_get(_shortcuts[shortcut], DictPath("action_args"), {})
                queryfunc = deep_get(_shortcuts[shortcut], DictPath("queryfunc"))
                queryval = deep_get(_shortcuts[shortcut], DictPath("queryval"))
                query = deep_get(_shortcuts[shortcut], DictPath("query"))
                widget = deep_get(_shortcuts[shortcut], DictPath("widget"))
                widget_args = deep_get(_shortcuts[shortcut], DictPath("widget_args"))
                inputtitle = deep_get(_shortcuts[shortcut], DictPath("inputtitle"))
                confirm = deep_get(_shortcuts[shortcut], DictPath("confirm"))
                confirmtitle = deep_get(_shortcuts[shortcut], DictPath("confirmtitle"))
                w_title = deep_get(_shortcuts[shortcut], DictPath("title"))
                w_headers = deep_get(_shortcuts[shortcut], DictPath("headers"))
                w_selectable = deep_get(_shortcuts[shortcut], DictPath("selectable"))
                w_itemgetter = check_allowlist(itemgetter_allowlist, "itemgetter_allowlist",
                                               deep_get(_shortcuts[shortcut],
                                                        DictPath("itemgetter")),
                                               allow_none=True)
                w_itemgetter_args = deep_get(_shortcuts[shortcut], DictPath("itemgetter_args"), {})
                _w_formatting = deep_get(_shortcuts[shortcut], DictPath("formatting"))
                w_formatting = None
                if _w_formatting is not None:
                    w_formatting = []
                    for fmt in _w_formatting:
                        w_formatting.append(fmt)
                w_sortcolumn = deep_get(_shortcuts[shortcut], DictPath("sortcolumn"), {})

                if key is None or helptext is None \
                        or action is None or "<missing>" in (key, helptext):
                    sys.exit(f"View-file {view_file} is invalid: "
                             "the following fields cannot be missing or None for a shortcut:\n"
                             f"key: {key}\n"
                             f"helptext: {helptext}\n"
                             "Aborting.")

                if widget is None and "<missing>" == action:
                    sys.exit(f"View-file {view_file} is invalid: "
                             "at least one of [widget, action] needs to be specified.\n"
                             "Aborting.")

                key = key.lower()
                modifier = modifier.lower()

                shortcut_key, help_key = map_key(view_file, shortcut, activatedfun, key, modifier)

                shortcuts[shortcut] = {
                    "shortcut": shortcut_key,
                    "helptext": (help_key, helptext),
                    "action": action,
                    "action_args": action_args,
                    "action_call": None,
                    "queryfunc": queryfunc,
                    "queryval": queryval,
                    "query": query,
                    "widget": widget,
                    "widget_args": widget_args,
                    "inputtitle": inputtitle,
                    "confirm": confirm,
                    "confirmtitle": confirmtitle,
                    "title": w_title,
                    "headers": w_headers,
                    "itemgetter": w_itemgetter,
                    "itemgetter_args": w_itemgetter_args,
                    "selectable": w_selectable,
                    "formatting": w_formatting,
                    "sortcolumn": w_sortcolumn,
                }
                if action == "call":
                    shortcuts[shortcut]["action_call"] = \
                        check_allowlist(action_call_allowlist, "action_call_allowlist",
                                        deep_get(_shortcuts[shortcut], DictPath("action_call")),
                                        allow_none=True)

            logpad = deep_get(d, DictPath("infoview#logpad"), {})

            if logpad:
                if deep_get(infoview_entry, DictPath("listpad"), {}):
                    sys.exit(f"View-file “{view_file}“ is invalid: "
                             "listpad and logpad cannot be used concurrently.")

                log_infogetter = deep_get(logpad, DictPath("infogetter"))
                if log_infogetter is None:
                    if logpad:
                        raise ValueError("View-file {view_file} is invalid: "
                                         "logpad specified, but no infogetter is provided")
                logpad["infogetter"] = deep_get(infogetter_allowlist, DictPath(log_infogetter))
                infoview_entry["logpad"] = copy.deepcopy(logpad)

            if not infoview_entry["listpad"]:
                infoview_entry.pop("listpad")

            if shortcuts:
                infoview_entry["shortcuts"] = shortcuts

            # Replace existing listviews with the same name
            infoviews.pop((kind, api_family), None)

            # Add the new view
            infoviews[(kind, api_family)] = infoview_entry
            has_infoview = True

        if kubernetes_support:
            kh_update_api_status((kind, api_family), listview=has_listview, infoview=has_infoview)


def setupui(stdscr: curses.window) -> None:
    # Hide the cursor; seems some implementations of curses (or terminals?)
    # might not support toggling the cursor; they will throw an exception instead.
    # Catch this an pretend that everything is fine.
    try:
        curses.curs_set(False)
    except curses.error:
        pass
    # Disable CTRL+C, CTRL+Z, etc.
    curses.raw()
    # Enable mouse support
    enable_mouse = deep_get(cmtlib.cmtconfig, DictPath("Mouse#enable"), True)
    if enable_mouse:
        curses_helper.set_mousemask(-1)
    else:
        curses_helper.set_mousemask(0)
    curses_helper.init_curses()

    while True:
        if deep_get(views, DictPath(defaultview)) is not None:
            viewfunc = deep_get(views, DictPath(f"{defaultview}#viewfunc"))
            if viewfunc is None:
                viewfunc = genericlistloop
            check_availability = deep_get(views, DictPath(f"{defaultview}#check_availability"))
            if check_availability is not None and not check_availability():
                curses.endwin()
                ansithemeprint([ANSIThemeStr("Error", "error"),
                                ANSIThemeStr(": The requested view “", "default"),
                                ANSIThemeStr(defaultview, "argument"),
                                ANSIThemeStr("“ is not available; ", "default"),
                                ANSIThemeStr("the cluster may be offline or the API disabled.",
                                             "default")])
                sys.exit(errno.ENOTSUP)
            viewfunc(stdscr, defaultview)
        else:
            curses.endwin()
            ansithemeprint([ANSIThemeStr("Error", "error"),
                            ANSIThemeStr(": Unknown view “", "default"),
                            ANSIThemeStr(defaultview, "argument"),
                            ANSIThemeStr("“; check “", "default"),
                            ANSIThemeStr(CMT_CONFIG_FILE, "path"),
                            ANSIThemeStr("“ and all files in “", "default"),
                            ANSIThemeStr(CMT_CONFIG_FILE_DIR, "path"),
                            ANSIThemeStr("“ for typos.", "default")], stderr=True)
            sys.exit(errno.ENOENT)


# pylint: disable-next=unused-argument
def list_namespaces(options: list[tuple[str, str]], args: list[str]) -> None:
    """
    List all available namespaces.

        Parameters:
            options ([(str, str)]): List of opt, optarg
            args ([str]): Unused
    """
    color = "auto"

    # Valid formats:
    # default = Normal output format (default)
    # csv = Comma-separated values
    # ssv = Space-separated values
    # tsv = Tab-separated values
    output_format = "default"

    for opt, optarg in options:
        if opt == "--color":
            color = optarg
        elif opt == "--format":
            output_format = optarg

    init_kubernetes_client()

    tmp, status = kh.get_list_by_kind_namespace(("Namespace", ""), "", resource_cache=kh_cache)
    if status in (42503, 42504):
        ansithemeprint([ANSIThemeStr("Error", "error"),
                        ANSIThemeStr(": API-server unavailable", "default")], stderr=True)
        sys.exit(errno.ENOENT)
    elif status != 200:
        ansithemeprint([ANSIThemeStr("Error", "error"),
                        ANSIThemeStr(": API-server returned ", "default"),
                        ANSIThemeStr(f"{status}", "errorvalue")], stderr=True)
        sys.exit(errno.EINVAL)

    namespaces = [deep_get(item, DictPath("metadata#name")) for item in tmp]

    if output_format == "default":
        ansithemeprint([ANSIThemeStr("Valid namespaces: ", "default")]
                       + ansithemestr_join_list(namespaces, formatting="namespace",
                                                separator=ANSIThemeStr(", ", "separator"))
                       + [ANSIThemeStr(".", "separator")], color=color)
    else:
        if output_format == "csv":
            separator = ","
        elif output_format == "ssv":
            separator = " "
        elif output_format == "tsv":
            separator = "\t"

        ansithemeprint(ansithemestr_join_list(namespaces, formatting="namespace",
                       separator=ANSIThemeStr(separator, "separator")), color=color)


# pylint: disable-next=unused-argument,disable-next=too-many-branches,too-many-statements
def list_views(options: list[tuple[str, str]], args: list[str]) -> None:
    """
    List available views and their supported fields and default sort column.

        Parameters:
            options ([(str, str)]): List of opt, optarg
            args ([str]): Unused
    """
    viewfields = []
    maxviewlen = 0
    maxkindlen = 0

    # Customises the list views
    ansithemeprint([ANSIThemeStr("Stand by, updating list of supported views...\n", "default")])

    init_kubernetes_client()
    populate_views()
    customise_listviews()

    for view in natsorted(views):
        viewref = views[view]
        if "skip" in viewref:
            continue
        if "kind" not in viewref or viewref["kind"] is None:
            continue
        if "fields" not in viewref:
            continue

        fields = []
        fieldset = set()
        sortcolumn = ""
        # This is necessary because of built-in fields
        for values in deep_get(viewref, DictPath("field_indexes"), {}).values():
            fieldset.update(deep_get(values, DictPath("fields"), []))
            if not sortcolumn:
                sortcolumn = deep_get(values, DictPath("sortcolumn"), "")
        fieldset.union(set(deep_get(viewref, DictPath("fields"), {}).keys()))

        for fieldname in fieldset:
            if sortcolumn == "" and fieldname == "name":
                fields.append(ANSIThemeStr(f"[{fieldname}]", "note"))
            elif fieldname == sortcolumn:
                fields.append(ANSIThemeStr(f"<{fieldname}>", "emphasis"))
            else:
                fields.append(ANSIThemeStr(fieldname, "default"))
        kind = viewref["kind"][0]
        api_group = viewref["kind"][1]
        if api_group == "":
            viewfields.append((view, f"{kind}", fields))
            maxkindlen = max(maxkindlen, len(f"{kind}"))
        else:
            viewfields.append((view, f"{kind}.{api_group}", fields))
            maxkindlen = max(maxkindlen, len(f"{kind}.{api_group}"))
        maxviewlen = max(maxviewlen, len(view))

    ansithemeprint([ANSIThemeStr("View:", "header"),
                    ANSIThemeStr(f"{''.ljust(maxviewlen + 2 - len('View:'))}", "default"),
                    ANSIThemeStr("Kind:", "header"),
                    ANSIThemeStr(f"{''.ljust(maxkindlen + 2 - len('Kind:'))}", "default"),
                    ANSIThemeStr("Supported fields:", "header")])
    for view, kind, fields in viewfields:
        joined_fields = ansithemestr_join_list(fields, separator=ANSIThemeStr(", ", "separator"))
        ansithemeprint([ANSIThemeStr(f"{view.ljust(maxviewlen + 2)}"
                                     f"{kind.ljust(maxkindlen + 2)}",
                                     "default")] + joined_fields)

    ansithemeprint([ANSIThemeStr("\nList views can be customised to only show select fields "
                                 "by editing “", "default"),
                    ANSIThemeStr(CMT_CONFIG_FILE, "path"),
                    ANSIThemeStr("“.\n", "default")])
    ansithemeprint([ANSIThemeStr("Simply add “", "default"),
                    ANSIThemeStr("field:", "emphasis"),
                    ANSIThemeStr("“ followed by a list of the fields you want the list to a "
                                 "section named like", "default")])
    ansithemeprint([ANSIThemeStr("the list view you want to customise.\n", "default")])

    ansithemeprint([ANSIThemeStr("Note that the fields “", "default"),
                    ANSIThemeStr("name", "emphasis"),
                    ANSIThemeStr("“ and, if applicable “", "default"),
                    ANSIThemeStr("namespace", "emphasis"),
                    ANSIThemeStr("“, will unconditionally", "default")])
    ansithemeprint([ANSIThemeStr("be included even if the list of fields does not include "
                                 "them; including them", "default")])
    ansithemeprint([ANSIThemeStr("in the list will only allow reordering the "
                                 "fields.\n", "default")])

    ansithemeprint([ANSIThemeStr("The fields in this list are those supported by ", "default"),
                    ANSIThemeStr(f"{about.UI_PROGRAM_NAME}", "programname"),
                    ANSIThemeStr("; it is NOT an exhaustive list", "default")])
    ansithemeprint([ANSIThemeStr("of fields available in the resource.\n", "default")])

    ansithemeprint([ANSIThemeStr("If a field is marked ", "default"),
                    ANSIThemeStr("<field>", "emphasis"),
                    ANSIThemeStr(" it is the explicit sortcolumn.", "default")])
    ansithemeprint([ANSIThemeStr("If the field is marked ", "default"),
                    ANSIThemeStr("[field]", "note"),
                    ANSIThemeStr(" it is the implicit sortcolumn.", "default")])
    ansithemeprint([ANSIThemeStr("Note: the brackets (“<“, “>“, “[“, and “]“) are not part "
                                 "of the field names.", "default")])


def checkforview(arg: str | tuple[str, str]) -> Optional[str]:
    """
    Check whether a view exists.

        Parameters:
            arg (str|(str, str)): Either the name of a view or a (kind, api_family) tuple
        Returns:
            (str): The key for the matching view, or None if no such view was found
    """
    for view, viewref in views.items():
        if isinstance(arg, str):
            if arg in deep_get(viewref, DictPath("commandline"), []):
                return view
        else:
            if arg == deep_get(viewref, DictPath("kind"), ("", "")):
                return view
    return None


def customise_listviews() -> None:
    """
    Apply user-provided customisation to the list views.
    """
    for view, viewref in views.items():
        if "skip" in viewref:
            continue
        if "kind" not in viewref or viewref["kind"] is None:
            continue
        if "fields" not in viewref:
            continue

        # OK, we've now (hopefully) skipped all views that do not have a list view
        fields: list[str] = deep_get(cmtlib.cmtconfig, DictPath(f"Views#{view}#fields"), [])
        if not fields:
            continue

        custom_fields: dict = {}

        viewref_fields = deep_get(viewref, DictPath("fields"), [])

        if "namespace" in viewref_fields and "namespace" not in fields:
            custom_fields["namespace"] = None
        if "name" not in fields:
            custom_fields["name"] = None

        for field in fields:
            if field not in fields:
                ansithemeprint([ANSIThemeStr("Error", "error"),
                                ANSIThemeStr(": “", "default"),
                                ANSIThemeStr(field, "option"),
                                ANSIThemeStr("“ is not a valid field for the view “", "default"),
                                ANSIThemeStr(view, "argument"),
                                ANSIThemeStr("“; aborting.", "default")], stderr=True)
                sys.exit(errno.EINVAL)
            elif field in custom_fields:
                ansithemeprint([ANSIThemeStr("Warning", "warning"),
                                ANSIThemeStr(": “", "default"),
                                ANSIThemeStr(field, "option"),
                                ANSIThemeStr("“ is specified twice (or more) for the view “",
                                             "default"),
                                ANSIThemeStr(view, "argument"),
                                ANSIThemeStr("“; ignoring.", "default")], stderr=True)
                continue
            custom_fields[field] = None
        viewref["fields_custom"] = list(custom_fields)

        # Next up it is time for the field denylist
        if "denylist" in deep_get(cmtlib.cmtconfig, DictPath(f"Views#{view}"), {}):
            denylist = deep_get(cmtlib.cmtconfig, DictPath(f"Views#{view}#fields"), [])
            viewref["field_denylist"] = denylist

    # As a special case, the configuration option "Inventory#ping_hosts"
    # modifies the denylist, but *only* if the field denylist is unset
    ping_hosts = deep_get(cmtlib.cmtconfig, DictPath("__Inventory#ping_hosts"), "Lazy")
    if "Inventory" in views and ping_hosts == "Never" \
            and "field_denylist" not in views["Inventory"]:
        views["Inventory"]["field_denylist"] = ["status"]


# pylint: disable-next=too-many-branches,too-many-statements
def open_view(options: list[tuple[str, str]], args: list[str]) -> None:
    """
    Open the specified view.

        Parameters:
            options ([(str, str)]): List of opt, optarg
            args ([str]): The view to open,
                          followed by specifiers for object, namespace,
                          and--if applicable--container/configmap
    """
    global initial_name  # pylint: disable=global-statement
    global initial_namespace  # pylint: disable=global-statement
    global initial_container  # pylint: disable=global-statement
    global read_only_mode  # pylint: disable=global-statement
    global selected_namespace  # pylint: disable=global-statement
    global defaultview  # pylint: disable=global-statement
    global kubernetes_support  # pylint: disable=global-statement

    tmpdefaultview = deep_get(cmtlib.cmtconfig, DictPath("Global#defaultview"), "")

    for opt, optarg in options:
        if opt == "--namespace":
            selected_namespace = optarg
        elif opt == "--read-only":
            read_only_mode = True
        elif opt == "--disable-kubernetes":
            kubernetes_support = False

    init_kubernetes_client()

    # Customises the list views
    ansithemeprint([ANSIThemeStr("Populating list of supported views...\n", "default")])

    populate_views()
    customise_listviews()

    if args:
        tmpview = checkforview(args[0].lower())
        if tmpview is None:
            ansithemeprint([ANSIThemeStr("Unsupported or unavailable view “", "default"),
                            ANSIThemeStr(f"{args[0].lower()}", "command"),
                            ANSIThemeStr("“;", "default")], stderr=True)
            ansithemeprint([ANSIThemeStr("Use “", "default"),
                            ANSIThemeStr(f"{about.UI_PROGRAM_NAME} ", "programname"),
                            ANSIThemeStr("list-views", "command"),
                            ANSIThemeStr("“ to list available views.", "default")], stderr=True)
            sys.exit(errno.EINVAL)
        defaultview = tmpview
    else:
        if tmpdefaultview is not None and tmpdefaultview != "":
            defaultview = tmpdefaultview
        else:
            defaultview = "Selector"

    if len(args) > 1:
        # The argument is either OBJECT, NAMESPACE/OBJECT, OBJECT:MEMBER, or NAMESPACE/OBJECT:MEMBER
        initial_name = args[1]
        if "/" in initial_name:
            initial_namespace, initial_name = initial_name.split("/")
        if ":" in initial_name:
            initial_name, initial_container = initial_name.split(":")

        if initial_container is not None and \
                initial_container and defaultview not in ("Pods", "Config Maps"):
            ansithemeprint([ANSIThemeStr(f"{about.UI_PROGRAM_NAME}", "programname"),
                            ANSIThemeStr(": invalid syntax;", "default")], stderr=True)
            ansithemeprint([ANSIThemeStr("Specifying a member", "description"),
                            ANSIThemeStr(" is only supported for ", "default"),
                            ANSIThemeStr("pod", "command"),
                            ANSIThemeStr(" and ", "description"),
                            ANSIThemeStr("configmap", "command"),
                            ANSIThemeStr(" view.", "default")], stderr=True)
            ansithemeprint([ANSIThemeStr("Try “", "default"),
                            ANSIThemeStr(f"{about.UI_PROGRAM_NAME} ", "programname"),
                            ANSIThemeStr("help", "command"),
                            ANSIThemeStr("“ for more information.", "default")], stderr=True)
            sys.exit(errno.EINVAL)

    # We do not need escape sequences, so cut down on the delay to 25ms
    os.environ.setdefault('ESCDELAY', '25')

    init_kubernetes_client()
    ansithemeprint([ANSIThemeStr("Checking available Kubernetes APIs\n", "default")])
    if kubernetes_support:
        _available_api_families, _status, _modified = kh.get_available_kinds()

    # Customises the list views if necessary
    if not infoviews:
        ansithemeprint([ANSIThemeStr("Populating list of supported views...\n", "default")])
        populate_views()
        customise_listviews()

    try:
        wrapper(setupui)
    except curses.error as e:
        # We don't really know *why* if failed to close the window,
        # but we don't really care, since we're about to close down anyway
        if str(e) == "endwin() returned ERR":
            pass
        elif str(e) == "setupterm: could not find terminal":
            term = os.getenv("TERM", "<unknown>")
            sys.exit(f"Error: Could not initialise curses; your terminal environment TERM={term}\n"
                     "might invalid or lack required features.")
        else:
            raise


COMMANDLINE: dict[str, Any] = {
    # This is purely for the benefit of the helptext generator
    "View": {
        "command": ["VIEW"],
        "description": [ANSIThemeStr("start in ", "description"),
                        ANSIThemeStr("VIEW", "command")],
    },
    "View [NAMESPACE/]OBJECT[:MEMBER]": {
        "command": ["VIEW"],
        "values": [ANSIThemeStr("[", "separator"),
                   ANSIThemeStr("NAMESPACE/", "argument"),
                   ANSIThemeStr("]", "separator"),
                   ANSIThemeStr("OBJECT", "argument"),
                   ANSIThemeStr("[", "separator"),
                   ANSIThemeStr(":", "argument"),
                   ANSIThemeStr("[", "separator"),
                   ANSIThemeStr("MEMBER", "argument"),
                   ANSIThemeStr("]]", "separator")],
        "description": [ANSIThemeStr("start in ", "description"),
                        ANSIThemeStr("VIEW", "command"),
                        ANSIThemeStr(" for ", "description"),
                        ANSIThemeStr("OBJECT", "argument")],
        "extended_description": [
            [ANSIThemeStr("Sometimes ", "description"),
             ANSIThemeStr("OBJECT", "argument"),
             ANSIThemeStr(" may need to be qualified by using", "description")],
            [ANSIThemeStr("NAMESPACE", "argument"),
             ANSIThemeStr(", but if there's only one unique match", "description")],
            [ANSIThemeStr(about.UI_PROGRAM_NAME, "programname"),
             ANSIThemeStr(" will open that match. If an object has members", "description")],
            [ANSIThemeStr("(containers or configmaps), these can be opened", "description")],
            [ANSIThemeStr("using the ", "description"),
             ANSIThemeStr(":MEMBER", "argument"),
             ANSIThemeStr(" syntax. If there's only one", "description")],
            [ANSIThemeStr("member specifying ", "description"),
             ANSIThemeStr(":", "argument"),
             ANSIThemeStr(" is sufficient", "description")],
        ],
    },
    "spacer1": {
        "command": [""],
        "description": [ANSIThemeStr("", "description")],
    },
    "List Namespaces": {
        "command": ["list-namespaces"],
        "description": [ANSIThemeStr("List valid namespaces and exit", "description")],
        "callback": list_namespaces,
        "options": {
            "--color": {
                "values": [ANSIThemeStr("WHEN", "argument")],
                "description":
                    [ANSIThemeStr("WHEN should the output use ANSI-colors", "description")],
                "extended_description": [
                    [ANSIThemeStr("Valid arguments are:", "description")],
                    [ANSIThemeStr("always", "argument"),
                     ANSIThemeStr(" (always color the output)", "description")],
                    [ANSIThemeStr("auto", "argument"),
                     ANSIThemeStr(" (color the output when outputting", "description")],
                    [ANSIThemeStr("to a terminal)", "description")],
                    [ANSIThemeStr("never", "argument"),
                     ANSIThemeStr(" (never color the output)", "description")],
                ],
                "requires_arg": True,
                "validation": {
                    "validator": "allowlist",
                    "allowlist": [
                        "always",
                        "auto",
                        "never",
                    ],
                },
            },
            "--format": {
                "values": [ANSIThemeStr("FORMAT", "argument")],
                "description": [ANSIThemeStr("Format the output as ", "description"),
                                ANSIThemeStr("FORMAT", "description")],
                "extended_description": [
                    [ANSIThemeStr("Valid formats are:", "description")],
                    [ANSIThemeStr("default", "argument"),
                     ANSIThemeStr(" (default format)", "description")],
                    [ANSIThemeStr("csv", "argument"),
                     ANSIThemeStr(" (comma-separated values)", "description")],
                    [ANSIThemeStr("ssv", "argument"),
                     ANSIThemeStr(" (space-separated values)", "description")],
                    [ANSIThemeStr("tsv", "argument"),
                     ANSIThemeStr(" (tab-separated values)", "description")],
                ],
                "requires_arg": True,
                "validation": {
                    "validator": "allowlist",
                    "allowlist": [
                        "default",
                        "csv",
                        "ssv",
                        "tsv",
                    ],
                },
            },
        },
    },
    "List Views": {
        "command": ["list-views"],
        "description": [ANSIThemeStr("List view information and exit", "description")],
        "callback": list_views,
    },
    "__*": {
        "command": ["*"],
        "command_alias": "VIEW",
        "values": [ANSIThemeStr("[", "separator"),
                   ANSIThemeStr("NAMESPACE/", "argument"),
                   ANSIThemeStr("]", "separator"),
                   ANSIThemeStr("OBJECT", "argument"),
                   ANSIThemeStr("[", "separator"),
                   ANSIThemeStr(":", "argument"),
                   ANSIThemeStr("[", "separator"),
                   ANSIThemeStr("MEMBER", "argument"),
                   ANSIThemeStr("]]", "separator")],
        "description": [ANSIThemeStr("start in ", "description"),
                        ANSIThemeStr("VIEW", "command"),
                        ANSIThemeStr(" for ", "description"),
                        ANSIThemeStr("OBJECT", "argument")],
        "extended_description": [
            [ANSIThemeStr("Sometimes ", "description"),
             ANSIThemeStr("OBJECT", "argument"),
             ANSIThemeStr(" may need to be qualified by using", "description")],
            [ANSIThemeStr("NAMESPACE", "argument"),
             ANSIThemeStr(", but if there's only one unique match", "description")],
            [ANSIThemeStr(about.UI_PROGRAM_NAME, "programname"),
             ANSIThemeStr(" will open that match. If an object has members", "description")],
            [ANSIThemeStr("(containers or configmaps), these can be opened", "description")],
            [ANSIThemeStr("using the ", "description"),
             ANSIThemeStr(":MEMBER", "argument"),
             ANSIThemeStr(" syntax. If there's only one", "description")],
            [ANSIThemeStr("member specifying ", "description"),
             ANSIThemeStr(":", "argument"),
             ANSIThemeStr(" is sufficient", "description")],
        ],
        "optional_args": [
            {
                "name": "view",
                "string": [ANSIThemeStr("VIEW", "command")],
                "validation": {
                    "validator": "regex",
                    "regex": r"^[a-zA-Z][a-zA-Z0-9.-]*?[a-zA-Z0-9]$"
                },
            },
            {
                "name": "object_namespace_member",
                "string": [ANSIThemeStr("NAME", "argument")],
                "validation": {
                    "validator": "regex",
                    # In order:
                    # object (RFC-1123 dns-subdomain)
                    # object (RFC-1123 dns-subdomain):container (RFC-1123 dns-label)
                    # namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain)
                    # namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain):container
                    # (RFC-1123 dns-label)
                    "regex":
                        r"^("
                        r"[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?|"
                        r"[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?:|"
                        r"[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?:[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]?|"
                        r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]/[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?|"
                        r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]/[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?:|"
                        r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]/[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?:"
                        r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]?"
                        r")$",
                },
            },
            {
                "name": "namespace",
                "string": [ANSIThemeStr("NAMESPACE", "command")],
                "validation": {
                    "validator": "regex",
                    # namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain)
                    "regex": r"^("
                             r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]|"
                             r")$",
                },
            },
            {
                "name": "member",
                "string": [ANSIThemeStr("CONTAINER", "command"),
                           ANSIThemeStr("/", "separator"),
                           ANSIThemeStr("CONFIGMAP", "command")],
                "validation": {
                    "validator": "regex",
                    # namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain)
                    "regex": r"^("
                             r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]?|"
                             r")$",
                },
            },
        ],
        "callback": open_view,
    },
    "extended_description": [
        [ANSIThemeStr("If ", "description"),
         ANSIThemeStr("VIEW", "argument"),
         ANSIThemeStr(" is not specified ", "description"),
         ANSIThemeStr(about.UI_PROGRAM_NAME, "programname"),
         ANSIThemeStr(" will show a list with all available views", "description")],
        [ANSIThemeStr("", "separator")],
        [ANSIThemeStr("Note", "note"),
         ANSIThemeStr(": ", "description"),
         ANSIThemeStr(CMT_CONFIG_FILENAME, "path"),
         ANSIThemeStr(" or a file in ", "description"),
         ANSIThemeStr(CMT_CONFIG_FILE_DIRNAME, "path"),
         ANSIThemeStr(" can be used to set a ", "description"),
         ANSIThemeStr("VIEW", "argument"),
         ANSIThemeStr(" to use", "description")],
        [ANSIThemeStr("if no view is specified.", "description"),
         ANSIThemeStr(" To override this and open the selector instead,", "description")],
        [ANSIThemeStr("simply use “", "description"),
         ANSIThemeStr(about.UI_PROGRAM_NAME, "programname"),
         ANSIThemeStr(" selector", "argument"),
         ANSIThemeStr("“.", "description")],
    ],
    "spacer2": {
        "command": [""],
        "description": [ANSIThemeStr("", "description")],
    },
    "__global_options": {
        "command": ["__global_options"],
        "description": [ANSIThemeStr("", "")],
        "options": {
            "--read-only": {
                "description":
                    [ANSIThemeStr("disable all commands that modify state", "description")],
            },
            "--disable-kubernetes": {
                "description": [ANSIThemeStr("disable Kubernetes support", "description")],
                "extended_description": [
                    [ANSIThemeStr("This option disables Kubernetes support;", "description")],
                    [ANSIThemeStr("this is typically only useful if you use", "description")],
                    [ANSIThemeStr(about.UI_PROGRAM_NAME, "programname"),
                     ANSIThemeStr(" to manage an Ansible inventory", "description")],
                ],
            },
            "--kube-config": {
                "values": [ANSIThemeStr("PATH", "argument")],
                "description": [ANSIThemeStr("PATH", "argument"),
                                ANSIThemeStr(" to kubeconfig file to use", "description")],
                "extended_description": [
                    [ANSIThemeStr("Use ", "description"),
                     ANSIThemeStr("PATH", "argument"),
                     ANSIThemeStr(" as kubeconfig; by default", "description")],
                    [ANSIThemeStr(KUBE_CONFIG_FILE, "path"),
                     ANSIThemeStr(" is used", "description")],
                ],
                "requires_arg": True,
                "validation": {
                    "validator": "path",
                },
            },
            "--namespace": {
                "values": [ANSIThemeStr("NAMESPACE", "argument")],
                "description": [ANSIThemeStr("only show objects in namespace ", "description"),
                                ANSIThemeStr("NAMESPACE", "argument")],
                "requires_arg": True,
                "validation": {
                    "validator": "regex",
                    # namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain)
                    "regex": r"^("
                             r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]|"
                             r")$",
                },
            },
            "--theme": {
                "values": [ANSIThemeStr("THEME", "argument")],
                "description": [ANSIThemeStr("THEME", "argument"),
                                ANSIThemeStr(" to use", "description")],
                "requires_arg": True,
            },
        },
    },
    "spacer3": {
        "command": [""],
        "description": [ANSIThemeStr("", "description")],
    },
}


# pylint: disable-next=too-many-branches,too-many-statements,too-many-locals
def main() -> None:
    """
    Main function for the program.
    """
    # global auditlog
    # global debuglog
    global read_only_mode  # pylint: disable=global-statement

    # Before doing anything else, make sure that the user is not running as root
    if os.geteuid() == 0:
        sys.exit("CRITICAL: This program should not be run as the root user; aborting.")

    # Now check if all necessary paths exist
    if (violations := cmtlib.setup_paths()) != [SecurityStatus.OK]:
        violations_joined = cmtio.join_securitystatus_set(",", set(violations))
        sys.exit(f"Failed to create necessary directories; violated rules: {violations_joined}")

    # Now initialise the audit log and the debug log
    # auditlog = CMTLog(CMTLogType.AUDIT)
    # debuglog = CMTLog(CMTLogType.DEBUG)

    # Then initialise the configuration file
    read_cmtconfig()

    defaultthemefile = DEFAULT_THEME_FILE

    themeindex = None
    try:
        themeindex = sys.argv.index("--theme")
        if themeindex + 1 < len(sys.argv):
            tmpthemefile = sys.argv[themeindex + 1]
        sys.argv.pop(themeindex)
        sys.argv.pop(themeindex)
    except ValueError:
        pass

    if themeindex is None:
        tmpthemefile = deep_get(cmtlib.cmtconfig, DictPath("Global#theme"))
    themefile, theme_path_found = \
        expand_path(path=tmpthemefile,
                    search_paths=[os.getcwd(), THEME_DIR, cmtpaths.SYSTEM_THEMES_DIR],
                    suffixes=[".yaml"], fallback=defaultthemefile)

    try:
        read_theme(themefile, defaultthemefile)
    except ProgrammingError as e:
        if e.subexception == FileNotFoundError:
            print("Error: could not find a valid theme file; aborting.", file=sys.stderr)
            sys.exit(errno.ENOENT)
        raise

    CursesConfiguration.abouttext = helptexts.about
    CursesConfiguration.mousescroll_enable = \
        deep_get(cmtlib.cmtconfig, DictPath("Mouse#enablescroll"), False)
    # These values are ignored when scrolling is disabled, so the defaults do not matter
    CursesConfiguration.mousescroll_up = \
        deep_get(cmtlib.cmtconfig, DictPath("Mouse#scrollup"), 0)
    CursesConfiguration.mousescroll_down = \
        deep_get(cmtlib.cmtconfig, DictPath("Mouse#scrolldown"), 0)
    # Used by the ansible module
    ansible_configuration["ansible_forks"] = \
        deep_get(cmtlib.cmtconfig, DictPath("Ansible#forks"), 10)
    ansible_user = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_user"))
    if ansible_user is None or not ansible_user:
        ansible_user = getuser()
    ansible_configuration["ansible_user"] = ansible_user
    ansible_configuration["ansible_password"] = \
        deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_password"))
    ansible_configuration["disable_strict_host_key_checking"] = \
        deep_get(cmtlib.cmtconfig, DictPath("Node#disablestricthostkeychecking"), False)
    ansible_configuration["save_logs"] = \
        deep_get(cmtlib.cmtconfig, DictPath("Ansible#save_logs"), True)

    if "--developer-mode" in sys.argv:
        deep_set(cmtlib.cmtconfig, DictPath("Debug#developer_mode"), True, create_path=True)
        sys.argv.remove("--developer-mode")
        read_only_mode = True
    if "--use-testdata" in sys.argv:
        if deep_get(cmtlib.cmtconfig, DictPath("Debug#developer_mode")):
            # To be able to add support for APIs that we do not have setup in clusters
            # this allows injecting data; this is currently only supported by
            # get_list_by_kind_namespace() and get_ref_by_kind_name_namespace(),
            # with several limitations (no filtering possible, etc).
            deep_set(cmtlib.cmtconfig, DictPath("Debug#use_testdata"), True, create_path=True)
        else:
            print("Warning: --use-testdata is only supported in developer mode")
        sys.argv.remove("--use-testdata")

    command, options, args = \
        parse_commandline(about.UI_PROGRAM_NAME, about.UI_PROGRAM_VERSION,
                          PROGRAMDESCRIPTION, PROGRAMAUTHORS, sys.argv,
                          COMMANDLINE, default_command="*", theme=themefile)

    for key, value in options:
        if key == "__commandname" and value in ("help", "version"):
            break
    else:
        checks.check_netrc_permissions(verbose=False, exit_on_error=True, quiet_on_ok=True)

    for opt, optarg in options:
        # Currently we only support --kube-config, but in case
        # we add option aliases (which we probably should) this
        # is a good thing to have
        if opt in ("--kubeconfig", "--kube-config"):
            global kube_config_file  # pylint: disable=global-statement
            kube_config_file = optarg

    if themeindex and not theme_path_found:
        ansithemeprint([ANSIThemeStr("Warning", "warning"),
                        ANSIThemeStr(": could not find theme “", "default"),
                        ANSIThemeStr(f"{tmpthemefile}", "path"),
                        ANSIThemeStr("“; using “", "default"),
                        ANSIThemeStr(f"{defaultthemefile}", "path"),
                        ANSIThemeStr("“ instead.\n", "default")])

    return command(options, args)


if __name__ == "__main__":
    main()
