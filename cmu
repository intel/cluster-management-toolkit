#! /bin/sh
# vim: ts=4 filetype=python expandtab shiftwidth=4 softtabstop=4 syntax=python
''''eval version=$( ls /usr/bin/python3.* | \
    grep '.*[0-9]$' | sort -nr -k2 -t. | head -n1 ) && \
    version=${version##/usr/bin/python3.} && [ ${version} ] && \
    [ ${version} -ge 9 ] && exec /usr/bin/python3.${version} "$0" "$@" || \
    exec /usr/bin/env python3 "$0" "$@"' #'''
# The above hack is to handle distros where /usr/bin/python3
# doesn't point to the latest version of python3 they provide

# Requires: ansible
# Requires: python3 (>= 3.9)
# Requires: python3-natsort
# Requires: python3-openssl
# Recommends: python3-ujson
#
# Copyright the Cluster Management Toolkit for Kubernetes contributors.
# SPDX-License-Identifier: MIT

# pylint: disable=too-many-lines

import ast
import base64
import binascii
import copy
import curses
from curses import wrapper
from datetime import datetime, timezone
import errno
from getpass import getuser
import http.client
# ujson is much faster than json,
# but it might not be available
try:  # pragma: no cover
    import ujson as json
# The exception raised by ujson when parsing fails is different
# from what json raises
    DecodeException = ValueError
except ModuleNotFoundError:  # pragma: no cover
    import json  # type: ignore
    DecodeException = json.decoder.JSONDecodeError  # type: ignore
from operator import itemgetter
import os
from pathlib import Path
import re
import socket
import subprocess  # nosec
from subprocess import PIPE, STDOUT  # nosec
import sys
from typing import Any, cast, Optional, Type, Union
from collections.abc import Callable
try:
    import yaml
except ModuleNotFoundError:  # pragma: no cover
    sys.exit("ModuleNotFoundError: Could not import yaml; "
             "you may need to (re-)run `cmt-install` or `pip3 install PyYAML`; aborting.")
try:
    import ruyaml
    ryaml = ruyaml.YAML()
    sryaml = ruyaml.YAML(typ="safe")
except ModuleNotFoundError:  # pragma: no cover
    try:
        import ruamel.yaml as ruyaml  # type: ignore
        ryaml = ruyaml.YAML()
        sryaml = ruyaml.YAML(typ="safe")
    except ModuleNotFoundError:  # pragma: no cover
        sys.exit("ModuleNotFoundError: Could not import ruyaml/ruamel.yaml; "
                 "you may need to (re-)run `cmt-install` or `pip3 install ruyaml/ruamel.yaml`; "
                 "aborting.")

try:
    from natsort import natsorted
except ModuleNotFoundError:  # pragma: no cover
    sys.exit("ModuleNotFoundError: Could not import natsort; "
             "you may need to (re-)run `cmt-install` or `pip3 install natsort`; aborting.")

from clustermanagementtoolkit.cmttypes import deep_get, deep_get_with_fallback
from clustermanagementtoolkit.cmttypes import deep_get_str_tuple_paths, deep_set, DictPath
from clustermanagementtoolkit.cmttypes import FilePath, Retval
from clustermanagementtoolkit.cmttypes import SecurityPolicy, SecurityStatus, StatusGroup
from clustermanagementtoolkit.cmttypes import ProgrammingError, FilePathAuditError
from clustermanagementtoolkit.cmttypes import name_to_loglevel, loglevel_to_name
from clustermanagementtoolkit.cmttypes import get_loglevel_names

from clustermanagementtoolkit import cmtpaths
from clustermanagementtoolkit.cmtpaths import BINDIR, KUBE_CONFIG_FILE, HOMEDIR, DEPLOYMENT_DIR
from clustermanagementtoolkit.cmtpaths import CMT_CONFIG_FILE_DIR, THEME_DIR
from clustermanagementtoolkit.cmtpaths import DEFAULT_THEME_FILE
from clustermanagementtoolkit.cmtpaths import ANSIBLE_PLAYBOOK_DIR, SYSTEM_ANSIBLE_PLAYBOOK_DIR
from clustermanagementtoolkit.cmtpaths import CMT_CONFIG_FILE_DIRNAME, CMT_CONFIG_FILE
from clustermanagementtoolkit.cmtpaths import CMT_CONFIG_FILENAME
from clustermanagementtoolkit.cmtpaths import SSH_ARGS_RELAXED, SSH_ARGS_STRICT, SSH_BIN_PATH

from clustermanagementtoolkit import cmtio
from clustermanagementtoolkit.cmtio import execute_command
from clustermanagementtoolkit.cmtio import expand_path
from clustermanagementtoolkit.cmtio import secure_read_string, secure_which, secure_write_string
from clustermanagementtoolkit.cmtio_yaml import secure_read_yaml

from clustermanagementtoolkit import cmtlog

from clustermanagementtoolkit.cmtvalidators import validate_name

from clustermanagementtoolkit.commandparser import parse_commandline, CommandType

from clustermanagementtoolkit.logparser import logparser, logparser_initialised
from clustermanagementtoolkit.logparser import LogLevel, LogparserConfiguration
from clustermanagementtoolkit.logparser import lvl_to_letter_severity, lvl_to_4letter_severity
from clustermanagementtoolkit.logparser import lvl_to_word_severity
from clustermanagementtoolkit.logparser import get_parser_list

from clustermanagementtoolkit import curses_helper

from clustermanagementtoolkit import cmtlib
from clustermanagementtoolkit.cmtlib import decode_value, clamp, get_package_versions
from clustermanagementtoolkit.cmtlib import make_label_selector
from clustermanagementtoolkit.cmtlib import none_timestamp, timestamp_to_datetime
from clustermanagementtoolkit.cmtlib import split_msg, versiontuple, read_cmtconfig, substitute_list
from clustermanagementtoolkit.cmtlib import check_allowlist

from clustermanagementtoolkit.curses_helper import CursesConfiguration, color_log_severity
from clustermanagementtoolkit.curses_helper import format_helptext, get_mousemask
from clustermanagementtoolkit.curses_helper import color_status_group
from clustermanagementtoolkit.curses_helper import UIProps, WidgetLineAttrs
from clustermanagementtoolkit.curses_helper import get_theme_ref, read_theme
from clustermanagementtoolkit.curses_helper import themearray_wrap_line, themearray_to_string
from clustermanagementtoolkit.curses_helper import themearray_len
from clustermanagementtoolkit.curses_helper import themearray_truncate
from clustermanagementtoolkit.curses_helper import ThemeAttr, ThemeRef, ThemeStr

from clustermanagementtoolkit import listgetters
from clustermanagementtoolkit.listgetters import listgetter_allowlist

from clustermanagementtoolkit import listgetters_async
from clustermanagementtoolkit.listgetters_async import listgetter_async_allowlist

from clustermanagementtoolkit import datagetters

from clustermanagementtoolkit import generators
from clustermanagementtoolkit.generators import generator_allowlist, default_processor
from clustermanagementtoolkit.generators import FormattingType

from clustermanagementtoolkit import infogetters
from clustermanagementtoolkit.infogetters import infogetter_allowlist

from clustermanagementtoolkit import itemgetters
from clustermanagementtoolkit.itemgetters import itemgetter_allowlist

from clustermanagementtoolkit.objgetters import objgetter_allowlist

from clustermanagementtoolkit import formatters
from clustermanagementtoolkit.formatters import formatter_allowlist

from clustermanagementtoolkit.ansible_helper import ansible_configuration
from clustermanagementtoolkit.ansible_helper import ansible_get_inventory_dict
from clustermanagementtoolkit.ansible_helper import ansible_get_groups, ansible_get_groups_by_host
from clustermanagementtoolkit.ansible_helper import ansible_add_hosts, ansible_remove_hosts
from clustermanagementtoolkit.ansible_helper import ansible_set_vars
from clustermanagementtoolkit.ansible_helper import ansible_run_playbook_on_selection
from clustermanagementtoolkit.ansible_helper import ansible_delete_log
from clustermanagementtoolkit.ansible_helper import ansible_print_play_results, get_playbook_path
from clustermanagementtoolkit.ansible_helper import ANSIBLE_INVENTORY

from clustermanagementtoolkit import helptexts

from clustermanagementtoolkit.kubernetes_helper import KubernetesHelper, KubernetesResourceCache
from clustermanagementtoolkit.kubernetes_helper import get_controller_from_owner_references
from clustermanagementtoolkit.kubernetes_helper import kubectl_get_version
from clustermanagementtoolkit.kubernetes_helper import update_api_status as kh_update_api_status
from clustermanagementtoolkit.kubernetes_helper import guess_kind

from clustermanagementtoolkit import checks

from clustermanagementtoolkit.ansithemeprint import ANSIThemeStr, ansithemestr_join_list
from clustermanagementtoolkit.ansithemeprint import clear_screen, ansithemeinput, ansithemeprint

from clustermanagementtoolkit import reexecutor

from clustermanagementtoolkit import about

try:
    import prctl
    # Pylint complains that prctl does not have a member called set_name();
    # prctl disagrees...
    # pylint: disable-next=no-member
    prctl.set_name(os.path.basename(sys.argv[0]))
    prctl.set_proctitle(" ".join(sys.argv))
except ModuleNotFoundError:  # pragma: no cover
    pass

PROGRAMDESCRIPTION = "UI for managing Kubernetes clusters."
PROGRAMAUTHORS = "Written by David Weinehall."

# If the user passes an object (and optionally namespace for that object)
# on the command line, they are stored here
# For pods a container can be appended too
initial_name = None  # pylint: disable=invalid-name
initial_namespace = None  # pylint: disable=invalid-name
initial_container = None  # pylint: disable=invalid-name

# Is cmu running in read only-mode?
read_only_mode = False  # pylint: disable=invalid-name

# Is Kubernetes support enabled
kubernetes_support = True  # pylint: disable=invalid-name
kube_config_file = None  # pylint: disable=invalid-name

# Namespace
selected_namespace = ""  # pylint: disable=invalid-name

# defaults
defaultview = ""  # pylint: disable=invalid-name

kh: KubernetesHelper = None  # type: ignore
kh_cache: KubernetesResourceCache = None  # type: ignore

executor = reexecutor.ReExecutor()
async_data: dict = {}

override_tail_lines = None  # pylint: disable=invalid-name
DEFAULT_TAIL_LINES = 4000

force_refresh_apis = False  # pylint: disable=invalid-name

views: dict[str, dict[str, Any]] = {}
infoviews: dict[tuple[str, str], Any] = {}


def init_kubernetes_client() -> None:
    """
    Initialise the Kubernetes client.
    """
    global kh  # pylint: disable=global-statement
    global kh_cache  # pylint: disable=global-statement

    if kubernetes_support:
        kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION,
                              config_path=kube_config_file)
        kh_cache = KubernetesResourceCache()


# pylint: disable-next=too-many-locals
def gather_cluster_info(**kwargs: Any) -> None:
    """
    Gather information about the cluster necessary for running playbooks.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                kubernetes_helper (KubernetesHelper): A reference to a KubernetesHelper object
    """
    if (kh_ := deep_get(kwargs, DictPath("kubernetes_helper"))) is None:
        errmsg = [
            [("Function called with invalid argument(s):", "default")],
            [("kubernetes_helper", "argument"),
             (" is missing or None.", "default")],
        ]
        unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
        cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
        raise ProgrammingError(unformatted_msg,
                               severity=LogLevel.ERR,
                               formatted_msg=formatted_msg)

    # Set global variables that need to be available when executing playbooks
    join_token = kh_.get_join_token()
    ca_cert_hash = kh_.get_ca_cert_hash()
    control_plane_ip, control_plane_port, control_plane_path = kh_.get_control_plane_address()
    _control_plane_node, control_plane_name = get_control_plane()

    # This is tricky: we get this from the distro packages;
    # since we cannot assume that we are running cmu on the [main] control plane
    # we have to ask the [main] control plane, via ansible, what version of kubeadm it is running
    package_versions = get_package_versions(control_plane_name)
    control_plane_k8s_version = ""
    for package, version in package_versions:
        if package == "kubeadm":
            control_plane_k8s_version = version
    if not control_plane_k8s_version:
        sys.exit(f"Failed to get kubeadm version from control plane “{control_plane_name}“; "
                 "aborting.")

    http_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), None)
    https_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), None)
    no_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), None)
    insecure_registries = deep_get(cmtlib.cmtconfig, DictPath("Docker#insecure_registries"), [])
    registry_mirrors = deep_get(cmtlib.cmtconfig, DictPath("Containerd#registry_mirrors"), [])
    packages = deep_get(cmtlib.cmtconfig, DictPath("Packages"), {})

    values = {
        "control_plane_ip": control_plane_ip,
        "control_plane_port": control_plane_port,
        "control_plane_path": control_plane_path,
        "join_token": join_token,
        "ca_cert_hash": ca_cert_hash,
        "control_plane_k8s_version": control_plane_k8s_version,
        "ntp_server": control_plane_ip,
        "http_proxy": http_proxy,
        "https_proxy": https_proxy,
        "no_proxy": no_proxy,
        "insecure_registries": insecure_registries,
        "registry_mirrors": registry_mirrors,
        "packages": packages,
    }

    ansible_set_vars(ANSIBLE_INVENTORY, "all", values)


def format_timestamp(timestamp: datetime,
                     localtimezone: bool = False) -> list[Union[ThemeRef, ThemeStr]]:
    """
    Takes datetime and formats it as a YYYY-MM-DD HH:MM:SS themearray.

        Parameters:
            timestamp (datetime): The timestamp
            localtimezone (bool): Is the timestamp in local time?
        Returns:
            ([ThemeRef|ThemeStr]): A formatted timestamp
    """
    array = []

    if timestamp is None:
        array = [ThemeRef("strings", "none")]
    else:
        if localtimezone:
            ftimestamp = f"{timestamp.astimezone():%Y-%m-%d %H:%M:%S}"
        else:
            ftimestamp = f"{timestamp:%Y-%m-%d %H:%M:%S}"
        array = generators.format_numerical_with_units(ftimestamp, "timestamp", False)

    return array


# pylint: disable-next=too-many-locals
def update_field_widths(field_dict: dict, field_names: list[str], objects: list[Type]) -> int:
    """
    Process the fields for a line; calcute how wide each field should be,
    then return the total line length.

        Parameters:
            field_dict (dict): The dict containing the description of the field
            field_names ([str]): The names of the fields to populate
            objects ([InfoClass]): An InfoClass object with the data
                                   for all fields in the field_names list
        Returns:
            (int): The total length of all the fields of a line
    """
    linelen: int = 0
    pos: int = 0

    for field_name in field_names:
        field_dict[field_name]["pos"] = pos
        field_dict[field_name]["fieldlen"] = 0

        # These are necessary to calculate width of list items
        item_separator = \
            field_dict[field_name].get("item_separator", ThemeRef("separators", "list"))
        field_separators = \
            field_dict[field_name].get("field_separators", [ThemeRef("separators", "field")])
        ellipsise = field_dict[field_name].get("ellipsise", -1)
        ellipsis = field_dict[field_name].get("ellipsis", ThemeRef("separators", "ellipsis"))
        field_prefixes = field_dict[field_name].get("field_prefixes", [])
        field_suffixes = field_dict[field_name].get("field_suffixes", [])
        field_formatters = field_dict[field_name].get("field_formatters", [])
        formatting: FormattingType = deep_get(field_dict, DictPath(f"{field_name}#formatting"), {})

        tmplen = 0

        for obj in objects:
            generator = field_dict[field_name].get("generator")
            processor = field_dict[field_name].get("processor")

            if processor is None:
                processor = default_processor.get(generator)

            if processor is not None:
                if processor in (generators.processor_list, generators.processor_list_with_status):
                    tmp = processor(obj, field_name,
                                    item_separator=item_separator,
                                    field_separators=field_separators,
                                    ellipsise=ellipsise, ellipsis=ellipsis,
                                    field_prefixes=field_prefixes,
                                    field_suffixes=field_suffixes,
                                    field_formatters=field_formatters)
                # pylint: disable-next=comparison-with-callable
                elif processor == generators.processor_timestamp_with_age:
                    tmp = processor(obj, field_name, formatting)
                else:
                    tmp = processor(obj, field_name)
            else:
                tmp = getattr(obj, field_name)

            tmplen = max(len(str(tmp)), field_dict[field_name].get("fieldlen", 0))

            field_dict[field_name]["fieldlen"] = tmplen

        field_dict[field_name]["fieldlen"] = max(tmplen, len(field_dict[field_name]["header"]))

        linelen += field_dict[field_name].get("fieldlen") + len(ThemeRef("separators", "pad"))
        pos = linelen

    # The last element should not be padded
    if linelen:
        linelen -= len(ThemeRef("separators", "pad"))

    return linelen


def get_image_tuple(image: str) -> tuple[str, str]:
    """
    Given the name of a container, return the name and the version field.

        Paramters:
            image (str): The full container name
        Returns:
            (str, str):
                (str): The container name
                (str): The container version
    """
    tmp: Optional[re.Match[str]] = re.match(r"^(.*):(.*)", image)
    if tmp is not None:
        image_name = f"{tmp[1]}"
        image_version = f"{tmp[2]}"
    else:
        image_name = f"{image}"
        image_version = "<undefined>"
    return image_name, image_version


def get_name_by_kind_from_owner_references(owner_references: list[dict], kind: str) -> str:
    """
    Given a kind, and a list of owner-reference dicts, return the name of the referenced object.
    FIXME: This should probably be modified to match kind as a tuple rather than only str,
           or possibly removed completely.

        Parameters:
            owner_references ([dict[str, Any]]): A list of OWR dicts.
            kind (str): The kind to search for.
        Returns:
            (str): The name of the object.
    """
    for owr in owner_references:
        if deep_get(owr, DictPath("kind"), "") == kind:
            name = deep_get(owr, DictPath("name"))
            break
    return name


def get_holder_kind_from_owner_references(owner_references: list[dict], holder_name: str) -> str:
    """
    Given a holder-name, and a list of owner-reference dicts, return the kind matches the name.
    FIXME: Multiple owner-references may match the name; this returns the first one.
           It should also be modified to return a tuple rather than only str,
           or possibly removed completely.

        Parameters:
            owner_references ([dict[str, Any]]): A list of OWR dicts.
            name (str): The name to search for.
        Returns:
            (str): The kind of the object.
    """
    holder_kind: str = ""

    for owr in owner_references:
        if deep_get(owr, DictPath("name")) == holder_name:
            holder_kind = deep_get(owr, DictPath("kind"), "")
            break

    return holder_kind


def get_pod_log_by_name_namespace_container(name: str, namespace: str, container: str,
                                            tail_lines: int = DEFAULT_TAIL_LINES) \
        -> tuple[str, bool]:
    """
    Given name, namespace, and container, returns pod logs.
    FIXME: This should be moved to kubernetes_helper.py.

        Parameters:
            name (str): The name of the object to get logs for
            namespace (str): The namespace of the object to get logs for
            container (str): The container to get logs for
            tail_lines (int): The maximum number of log lines to fetch
        Returns:
            ((str, bool)):
                (str): The raw log message (with embedded newlines)
                (bool): True if everything went OK, False if there was an error
    """
    internal_error: bool = False

    rawmsg, status = \
        kh.read_namespaced_pod_log(name, namespace, container=container, tail_lines=tail_lines)
    if status == 200:
        # Everything is successful
        internal_error = False
    elif status == 400:
        # Not successful; error in rawmsg
        rawmsg = f"{datetime.now(timezone.utc):%Y-%m-%d %H:%M:%S} CRITICAL: {rawmsg}"
        internal_error = True
    elif status == 500:
        # Not successful; error in rawmsg
        internal_error = True
    else:
        rawmsg = f"{datetime.now(timezone.utc):%Y-%m-%d %H:%M:%S} CRITICAL: Failed to fetch log " \
                 f"for pod (name: {name}, namespace: {namespace}, container: {container}); " \
                 f"Request Status: {status}"
        internal_error = True

    if rawmsg.startswith("unable to retrieve container logs for"):
        rawmsg = f"{datetime.now(timezone.utc):%Y-%m-%d %H:%M:%S} CRITICAL: {rawmsg}"
        internal_error = True

    return rawmsg, internal_error


# To make the failure case easier, return both the ref and the name of the control plane
def get_control_plane() -> tuple[dict[str, Any], str]:
    """
    Return the name and object reference to the control plane.
    FIXME: This does not support multiple control planes.

        Returns:
            ((dict[str, Any], str)):
                (dict[str, Any]): The object reference of the control plane
                (str): The name of the control plane
    """
    if not kubernetes_support:
        return {}, ""

    vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "", resource_cache=kh_cache)
    control_planes = []

    if vlist is None or not vlist or status != 200:
        return {}, ""

    # Find control planes; but for now only return the first match
    for obj in vlist:
        labels = deep_get(obj, DictPath("metadata#labels"), {})
        if "node-role.kubernetes.io/control-plane" in labels \
                or "node-role.kubernetes.io/master" in labels:
            control_planes.append((obj, deep_get(obj, DictPath("metadata#name"))))

    # If we have exactly one node, assume that it is the control plane even if it lacks that label
    if not control_planes and len(vlist) == 1:
        control_planes.append((vlist[0], deep_get(vlist[0], DictPath("metadata#name"))))

    if not control_planes:
        ansithemeprint([ANSIThemeStr("Error", "warning"),
                        ANSIThemeStr(": None of the nodes in the cluster are labelled as "
                                     "control planes. The cluster is most likely "
                                     "misconfigured.", "default")], stderr=True)
        return {}, ""
    if len(control_planes) > 1:
        ansithemeprint([ANSIThemeStr("Warning", "warning"),
                        ANSIThemeStr(": Multiple control planes not supported yet, "
                                     "found multiple; returning first entry:", "default")],
                       stderr=True)
        for control_plane in control_planes:
            ansithemeprint([ANSIThemeStr(f"  {control_plane[1]}", "default")], stderr=True)

    return control_planes[0][0], control_planes[0][1]


# pylint: disable-next=unused-argument
def set_cluster_context(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Set Kubernetes cluster context.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                selected (dict): The selected obj from a listpad
        Returns:
            (Retval): The return value
    """
    global force_refresh_apis  # pylint: disable=global-statement

    selected: Type = deep_get(kwargs, DictPath("selected"))
    # If we don't have any contexts we won't be able to set the context.
    if selected is None:
        return Retval.RETURNDONE

    name: str = getattr(selected, "name")

    # If we actually changed context we need to force an API reload,
    # since we might have changed between different clusters
    # (or switched to a role that does not have access to a particular API).
    if kh.set_context(name=name):
        force_refresh_apis = True
    return Retval.RETURNDONE


# pylint: disable-next=too-many-locals
def generate_list_header(uip: UIProps, field_dict: dict, is_taggable: bool = False) -> None:
    """
    Generate the header for the listpad.

        Parameters:
            uip (UIProps): A reference to the UI Properties object
            field_dict (dict): The dict containing the description of the field
            is_taggable (bool): Is the list taggable?
    """
    headerarray: list[Union[ThemeRef, ThemeStr]] = []
    first = True

    tabstops = []

    tabstop = 0

    # Is the list taggable?
    if is_taggable:
        tabstops.append(tabstop)
        headerarray.append(ThemeRef("separators", "tag"))
        tabstop = themearray_len(headerarray)

    for field in field_dict:
        generator = field_dict[field].get("generator")
        if generator is None:
            continue

        tabstops.append(tabstop)

        theme = get_theme_ref()
        if uip.get_sortcolumn() == field:
            if not uip.reversible:
                sort_direction_char = theme["boxdrawing"]["arrownone"]
            elif uip.sortorder_reverse:
                sort_direction_char = theme["boxdrawing"]["arrowup"]
            else:
                sort_direction_char = theme["boxdrawing"]["arrowdown"]
        else:
            sort_direction_char = theme["boxdrawing"]["arrownone"]

        # We always want this much padding between the headers,
        # except if this is the first header
        #
        # Note that we need to subtract the width of sort direction char
        # from the width of pad; this only works if len(pad) > 0
        if not first:
            separator_len = len(ThemeRef("separators", "pad"))
            direction_char_len = len(sort_direction_char)
            headerarray.append(ThemeStr("".ljust(separator_len - direction_char_len),
                                        ThemeAttr("types", "generic")))

        tabstop = themearray_len(headerarray)

        # This tells the length of the alignment of the header
        fieldlen = deep_get(field_dict, DictPath(f"{field}#fieldlen"))
        header = deep_get(field_dict, DictPath(f"{field}#header"))
        ralign = deep_get(field_dict, DictPath(f"{field}#ralign"), False)

        # We cannot use ljust/rjust on the string,
        # because we want the string and arrow in different colours,
        # so just prepend/append whitespace instead
        if ralign:
            headerarray.append(ThemeStr("".ljust(fieldlen - len(header)),
                                        ThemeAttr("types", "generic")))
        headerarray.append(ThemeStr(header, ThemeAttr("main", "listheader"),
                                    selected=uip.get_sortcolumn() == field))
        headerarray.append(ThemeStr(sort_direction_char,
                                    ThemeAttr("main", "listheader_arrows")))
        if not ralign:
            headerarray.append(ThemeStr("".ljust(fieldlen - len(header)),
                                        ThemeAttr("types", "generic")))
        first = False

    # We've got to account for the last entry
    if field_dict:
        tabstops.append(tabstop)

    # We've processed all fields, time to output the header
    uip.addthemearray(uip.headerpad, headerarray, y=0, x=0)
    uip.tabstops = tabstops


# pylint: disable-next=too-many-arguments,too-many-locals,too-many-positional-arguments
def generate_list_row(uip: UIProps, data: Type, field_dict: dict,
                      ypos: int, is_selected: bool, is_taggable: bool = False,
                      is_tagged: bool = False, is_deleted: bool = False) -> None:
    """
    Generate a list for the listpad.

        Parameters:
            uip (UIProps): A reference to the UI Properties object
            data (Type): The data to generate a list row from
            field_dict (dict[str, Any]): The dict containing the description of the field
            ypos (int): The list index
            is_selected (bool): Is the list item selected?
            is_taggable (bool): Is the list taggable?
            is_tagged (bool): Is the list item tagged?
            is_deleted (bool): Is the list item deleted?
    """
    first: bool = True
    i: int = 0

    for field in field_dict:
        i += 1

        if is_taggable:
            tagprefixlen = len(ThemeRef("separators", "tag"))

            if is_tagged:
                tagprefix: list[Union[ThemeRef, ThemeStr]] = [ThemeRef("separators", "tag")]
            else:
                tagprefix = [ThemeStr("".ljust(tagprefixlen), ThemeAttr("types", "generic"))]
        else:
            tagprefix = []
            tagprefixlen = 0

        generator = field_dict[field].get("generator")
        if generator is None:
            continue
        if isinstance(generator, str):
            generator = \
                deep_get(generator_allowlist, DictPath(generator), generators.generator_basic)

        fieldlen = field_dict[field]["fieldlen"]
        fpad = i < len(field_dict)

        ralign = field_dict[field].get("ralign", False)

        formatting: FormattingType = {
            "item_separator":
                field_dict[field].get("item_separator", ThemeRef("separators", "list")),
            "field_separators":
                field_dict[field].get("field_separators", [ThemeRef("separators", "field")]),
            "field_colors": field_dict[field].get("field_colors", [ThemeAttr("types", "field")]),
            "ellipsise": field_dict[field].get("ellipsise", -1),
            "ellipsis": field_dict[field].get("ellipsis", ThemeRef("separators", "ellipsis")),
            "field_prefixes": field_dict[field].get("field_prefixes", []),
            "field_suffixes": field_dict[field].get("field_suffixes", []),
            "mapping": field_dict[field].get("mapping", {}),
            "field_formatters": field_dict[field].get("field_formatters", []),
        }

        tmp = generator(data, field, fieldlen=fieldlen, pad=fpad,
                        ralign=ralign, selected=is_selected, **formatting)

        pos = field_dict[field]["pos"]

        if first and is_taggable:
            uip.addthemearray(uip.listpad, tagprefix, y=ypos, x=pos, deleted=is_deleted)
            first = False

        uip.addthemearray(uip.listpad, tmp, y=ypos, x=pos + tagprefixlen, deleted=is_deleted)


# noqa: E501 pylint: disable-next=too-many-locals,too-many-branches,too-many-statements,too-many-return-statements
def genericlistloop(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Generic main loop for listviews.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                view (str): The view to show
        Returns:
            (Retval): The return value
        Raises:
            ProgrammingError (view is invalid)
    """
    global executor  # pylint: disable=global-statement
    global selected_namespace  # pylint: disable=global-statement
    global initial_name  # pylint: disable=global-statement
    global initial_namespace  # pylint: disable=global-statement

    # Just in case there are leftover futures from other views
    executor.shutdown()
    executor = reexecutor.ReExecutor()

    view = deep_get(kwargs, DictPath("kind"))
    viewref = deep_get(views, DictPath(view), {})
    kind = deep_get(viewref, DictPath("kind"))

    if not (isinstance(stdscr, curses.window) and isinstance(view, str)):
        errmsg = [
            [("Function called with invalid argument(s):", "error")],
            [("stdscr = ", "default"),
             (f"{stdscr}", "argument"),
             (" (type: ", "default"),
             (f"{type(stdscr)}", "argument"),
             (", expected: ", "default"),
             (f"{curses.window}", "argument"),
             (")", "default")],
            [("view = ", "default"),
             (f"{view}", "argument"),
             (" (type: ", "default"),
             (f"{type(view)}", "argument"),
             (", expected: ", "default"),
             ("str", "argument"),
             (").", "default")],
        ]
        unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
        cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
        raise ProgrammingError(unformatted_msg,
                               severity=LogLevel.ERR,
                               formatted_msg=formatted_msg)

    denylist = deep_get(viewref, DictPath("field_denylist"), [])
    field_indexes = deep_get(viewref, DictPath("field_indexes"), {})

    if not (isinstance(field_indexes, dict) and field_indexes):
        errmsg = [
            [("genericlistloop()", "emphasis"),
             (" called with invalid argument(s):", "error")],
            [("field_indexes = ", "default"),
             (f"{field_indexes}", "argument"),
             (" (type: ", "default"),
             (f"{type(field_indexes)}", "argument"),
             (", expected: ", "default"),
             (f"{dict}", "argument"),
             (" with at least one element)", "default")],
        ]
        unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
        cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
        raise ProgrammingError(unformatted_msg,
                               severity=LogLevel.ERR,
                               formatted_msg=formatted_msg)

    if "Custom" in field_indexes:
        field_index = "Custom"
    elif "Wide" in field_indexes:
        field_index = "Wide"
    else:
        field_index = list(field_indexes.keys())[0]

    fieldgenerator_args = {
        "field_index": field_index,
        "field_indexes": field_indexes,
        "fields": deep_get(viewref, DictPath("fields")),
        "denylist": denylist,
    }
    field_dict, field_names, sortcolumn, sortorder_reverse = \
        generators.fieldgenerator(view=view, selected_namespace=selected_namespace,
                                  **fieldgenerator_args)

    uip = UIProps(stdscr)

    windowheader = view

    if kind is None or kind[0].startswith("__"):
        is_namespaced = False
    else:
        is_namespaced = kh.is_kind_namespaced(kind)

    helptext = generate_helptext(view, "listview", [], {})
    activatedfun = deep_get(viewref, DictPath("activatedfun"), genericinfoloop)
    on_activation = deep_get(viewref, DictPath("on_activation"), {})
    update_delay = deep_get(viewref, DictPath("update_delay"), -1)

    is_taggable = (deep_get(viewref, DictPath("is_taggable"), True)
                   and deep_get(viewref, DictPath("actions")) is not None)
    extra_vars = deep_get(viewref, DictPath("extra_vars"), {})

    uip.init_window(field_dict=field_dict, view=kind, windowheader=windowheader,
                    update_delay=update_delay, sortcolumn=sortcolumn,
                    sortorder_reverse=sortorder_reverse, helptext=helptext,
                    activatedfun=activatedfun, on_activation=on_activation)

    # The statusbar is always located at the bottom of the screen and fills the entire width
    uip.init_statusbar()

    # For the list
    uip.init_listpad(listheight=1, width=-1, ypos=1, xpos=1)

    label_selector = ""

    # These values can be toggled, so we need to read them first
    listview_args = copy.deepcopy(deep_get(viewref, DictPath("listview_args"), {}))

    listgetter = deep_get(viewref, DictPath("listgetter"))
    listgetter_async = deep_get(viewref, DictPath("listgetter_async"))
    listgetter_args = deep_get(viewref, DictPath("listgetter_args"), {})
    listgetter_args["label_selector"] = label_selector

    infogetter = deep_get(viewref, DictPath("infogetter"), infogetters.generic_infogetter)
    infogetter_extra_args = deep_get(viewref, DictPath("extra_vars#infogetter"),
                                     {"_view": view.strip("*")})
    infogetter_extra_args["_field_index"] = field_index.lower()
    infogetter_extra_args["_field_names"] = field_names
    infogetter_extra_args["_field_dict"] = field_dict
    if "filters" in listview_args:
        infogetter_extra_args["_filters"] = deep_get(listview_args, DictPath("filters"))

    uip.last_action = datetime.now()
    uip.idle_timeout = 5
    tagged_items: set[Type] = set()
    serverstatus: str = "ok"

    first_fetch: bool = True
    new_data: str = "false"
    uip.force_update()
    uip.listlen = 0

    # pylint: disable-next=too-many-nested-blocks
    while True:
        if listgetter_async is not None:
            # Temporary workaround
            # pylint: disable-next=comparison-with-callable
            if listgetter_async == listgetters_async.get_inventory_list and "hosts" not in executor:
                hosts = list(deep_get(ansible_get_inventory_dict(), DictPath("all#hosts")).keys())
                # The inventory doesn't change all that often,
                # but reading it every 10 seconds should be OK
                executor.trigger("hosts", 10, read_file_async, path=ANSIBLE_INVENTORY,
                                 filetype="yaml", **listgetter_args)
                async_data["hosts"] = copy.deepcopy(hosts)
                infogetter_extra_args["_match_key"] = "name"
                new_data = "pending"
                first_fetch = False
            # pylint: disable-next=comparison-with-callable
            elif listgetter_async == listgetters_async.get_context_list \
                    and (first_fetch or uip.update_forced):
                vlist, hosts = listgetters_async.get_context_list(kubernetes_helper=kh)
                async_data["hosts"] = copy.deepcopy(hosts)
                infogetter_extra_args["_vlist"] = copy.deepcopy(vlist)
                infogetter_extra_args["_match_key"] = "server_address"
                new_data = "pending"
                first_fetch = False
            # pylint: disable-next=comparison-with-callable
            elif listgetter_async == listgetters_async.get_kubernetes_list \
                    and ".".join(kind) not in executor:
                if "kubernetes_helper" not in listgetter_args:
                    listgetter_args["kubernetes_helper"] = kh
                    listgetter_args["kh_cache"] = kh_cache
                if "kind" not in listgetter_args:
                    listgetter_args["kind"] = kind
                if "namespace" not in listgetter_args:
                    listgetter_args["namespace"] = selected_namespace
                executor.trigger(".".join(kind), 5, listgetters_async.get_kubernetes_list,
                                 **listgetter_args)
            if listgetter_async in (listgetters_async.get_inventory_list,
                                    listgetters_async.get_context_list) and "pings" not in executor:
                facts_ping_playbook_path = get_playbook_path(FilePath("facts_ping.yaml"))
                # But the hosts can change status more frequently than that
                executor.trigger("pings", 5, run_ansible_play_async,
                                 playbook=facts_ping_playbook_path, selection=hosts, verbose=False)
        elif listgetter is not None:
            if first_fetch or uip.update_forced:
                if listgetter is not None:
                    if "kubernetes_helper" not in listgetter_args:
                        listgetter_args["kubernetes_helper"] = kh
                        listgetter_args["kh_cache"] = kh_cache
                    if kind[0].startswith("__"):
                        vlist, status = listgetter(**listgetter_args)
                    else:
                        # FIXME
                        raise ProgrammingError("We don't know how to handle this")
                    # else:
                    #     vlist, status = \
                    #         listgetter(deep_get(view, DictPath(f"{view}#kind")),
                    #                    selected_namespace,
                    #                    label_selector=label_selector, **listgetter_args)
                    infogetter_extra_args["_vlist"] = vlist
                new_data = "pending"
                uip.update_timestamp(update=new_data)
                first_fetch = False
        else:
            # We only have an infogetter
            new_data = "pending"
            uip.update_timestamp(update=new_data)
            first_fetch = False

        # The asynchronous UI follows these rules:
        # Idle:
        #   No user activity within the last idle_timeout seconds
        # Force refresh:
        #   User pressed [F5], changed sort column,
        #   or opened/closed a dialog ([F1], [F2], [F8], etc)
        # Additional blockers:
        #   Items are tagged, menus are open, etc.
        if executor:
            if (execution_result_dict := executor.get("hosts")) != ([], []):
                data, _host_statuses = execution_result_dict
                hosts = deep_get(cast(dict, data), DictPath("all#hosts"), {}).keys()
                hosts_set = set(hosts)
                async_data["hosts"] = list(hosts)
                if vlist := deep_get(infogetter_extra_args, DictPath("_vlist"), []):
                    vlist_hosts = [deep_get(item, DictPath("name")) for item in vlist]
                    vlist_hosts_set = set(vlist_hosts)
                else:
                    vlist_hosts = []
                    vlist_hosts_set = set()
                # Only add hosts that aren't part of vlist already
                inventory_dict = ansible_get_inventory_dict()
                for host in hosts_set - vlist_hosts_set:
                    vlist.append({
                        "name": host,
                        "ref": host,
                        "ips": [],
                        "ansible_groups": ansible_get_groups_by_host(inventory_dict, host),
                        "status": "UNKNOWN",
                        "__deleted": False,
                    })
                # Tag hosts in vlist that are no longer part of hosts as deleted
                for host in vlist_hosts_set - hosts_set:
                    for i, item in enumerate(vlist):
                        if deep_get(item, DictPath("name"), "") == host:
                            vlist[i]["status"] = "DELETED"
                            vlist[i]["__deleted"] = True
                infogetter_extra_args["_vlist"] = copy.deepcopy(vlist)
                if not uip.listlen:
                    uip.force_update()
                new_data = "pending"
                uip.update_timestamp(update=new_data)
                first_fetch = False
            elif (execution_result_dict := executor.get("pings")) != ([], []):
                ansible_results, _ansible_status = execution_result_dict
                vlist = deep_get(infogetter_extra_args, DictPath("_vlist"), [])
                for i, item in enumerate(vlist):
                    host = deep_get(item, DictPath(infogetter_extra_args["_match_key"]))
                    for result in deep_get(cast(dict[str, Any], ansible_results),
                                           DictPath(f"{host}"), []):
                        if deep_get(result, DictPath("task")) == "Ping":
                            if not deep_get(vlist[i], DictPath("__deleted"), False):
                                status = deep_get(result, DictPath("status"))
                                vlist[i]["status"] = status
                                ips = []
                                if (ip := deep_get(result,
                                                   DictPath("ansible_facts#"
                                                            "ansible_default_ipv4#address"), "")):
                                    ips.append(ip)
                                if (ip := deep_get(result,
                                                   DictPath("ansible_facts#"
                                                            "ansible_default_ipv6#address"), "")):
                                    ips.append(ip)
                                vlist[i]["ips"] = copy.deepcopy(ips)
                _pings_args, pings_kwargs = executor.get_parameters("pings")
                if set(async_data["hosts"]) != set(deep_get(pings_kwargs,
                                                            DictPath("selection"), [])):
                    executor.update("pings", selection=copy.deepcopy(async_data["hosts"]))
                    executor.retrigger("pings")
                infogetter_extra_args["_vlist"] = copy.deepcopy(vlist)
                if not uip.listlen:
                    uip.force_update()
                new_data = "pending"
                uip.update_timestamp(update=new_data)
                first_fetch = False
            elif (execution_result_list := executor.get(".".join(kind))) != ([], []):
                vlist, status = cast(tuple[list[Any], Any], execution_result_list)
                infogetter_extra_args["_vlist"] = copy.deepcopy(vlist)

                if status == 42503:
                    serverstatus = "Server Unavailable"
                elif status == 42504:
                    serverstatus = "Connection Timeout"
                else:
                    serverstatus = str(status)
                if not uip.listlen:
                    uip.force_update()
                new_data = "pending"
                uip.update_timestamp(update=new_data)
                first_fetch = False

        if uip.is_idle() or uip.is_update_triggered():
            # We need to generate the list info even if the list is empty,
            # otherwise we'll crash elsewhere
            if not uip.listlen and first_fetch \
                    or new_data == "pending" and (uip.update_forced or not tagged_items):
                if "kubernetes_helper" not in infogetter_extra_args:
                    infogetter_extra_args["kubernetes_helper"] = kh
                if "kh_cache" not in infogetter_extra_args:
                    infogetter_extra_args["kh_cache"] = kh_cache
                vinfo = infogetter(**infogetter_extra_args)
                uip.update_info(vinfo)
                uip.force_update()
                new_data = "true"
                tagged_items = set()
                uip.update_forced = False
        if uip.is_update_triggered():
            linelen = update_field_widths(field_dict, field_names, uip.info)
            if is_taggable:
                linelen += len("✓ ")
            uip.resize_listpad(linelen)
            uip.list_needs_regeneration(True)
            uip.update_window(update=new_data)
            if new_data == "true":
                new_data = "false"

        if uip.refresh:
            # The data in some fields might become shorter, so we need to trigger a clear
            if uip.statusbar is not None:
                uip.statusbar.erase()

            statusarray1: list[Union[ThemeRef, ThemeStr]] = []

            if view != "Contexts" and selected_namespace:
                statusarray1 += \
                    [ThemeStr("Namespace: ", ThemeAttr("statusbar", "infoheader")),
                     ThemeStr(f"{selected_namespace if selected_namespace else '<All>'}",
                              ThemeAttr("statusbar", "highlight"))]

            if statusarray1:
                statusarray1 += [ThemeRef("separators", "statusbar")]

            statusarray1 += [
                ThemeStr("Fields: ", ThemeAttr("statusbar", "infoheader")),
                ThemeStr(field_index, ThemeAttr("statusbar", "highlight"))
            ]
            if label_selector:
                if statusarray1:
                    statusarray1 += [ThemeRef("separators", "statusbar")]
                statusarray1 += [
                    ThemeStr("Label selector: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{label_selector}", ThemeAttr("statusbar", "highlight"))
                ]
            statusarray2: list[Union[ThemeRef, ThemeStr]] = []
            if read_only_mode:
                statusarray2 += [ThemeStr("Read Only Mode", ThemeAttr("statusbar", "highlight"))]

            if statusarray2:
                statusarray2 += [ThemeRef("separators", "statusbar")]
            statusarray2 += [
                ThemeStr("API Status: ", ThemeAttr("statusbar", "infoheader")),
                # Here we should probably highlight when something is bad
                ThemeStr(f"{serverstatus}", ThemeAttr("statusbar", "default")),
            ]

            for status_data in deep_get(viewref, DictPath("statusmsg"), []):
                if len(status_data) == 2:
                    key_, path = status_data
                    default_status = "<unset>"
                else:
                    key_, path, default_status = status_data

                src_obj = listview_args

                # If path is a list the first item tells what source to use and the second
                # what path to fetch the value from
                if isinstance(path, list):
                    if path[0] == "config":
                        src_obj = cmtlib.cmtconfig
                    # elif path[0] == "obj":
                    #     value_path = obj
                    elif path[0] == "var":
                        src_obj = listview_args
                    value_path = DictPath(path[1])
                else:
                    src_obj = listview_args
                    value_path = DictPath(path)

                value_ = str(deep_get(src_obj, value_path, default_status))
                if statusarray2:
                    statusarray2 += [ThemeRef("separators", "statusbar")]
                statusarray2 += [
                    ThemeStr(key_, ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(value_, ThemeAttr("statusbar", "default")),
                ]

            uip.addthemearray(uip.statusbar, statusarray1, y=0, x=0)
            uip.addthemearray(uip.statusbar, statusarray2, y=1, x=0)

        uip.update_sorted_list()

        if uip.info:
            unique_match = uip.goto_first_match_by_name_namespace(initial_name, initial_namespace)
            initial_name = None
            initial_namespace = None
            if unique_match is not None:
                selected = uip.get_selected()
                if uip.activatedfun is not None:
                    if (retval := uip.activatedfun(uip.stdscr,
                                                   obj=unique_match,
                                                   kind=kind)) == Retval.RETURNFULL:
                        return retval
                    uip.force_update()
                    uip.force_refresh()
                    continue

        uip.refresh_selected()
        if not uip.is_list_regenerated():
            generate_list_header(uip, field_dict, is_taggable=is_taggable)
            for y in range(uip.yoffset,
                           min(uip.yoffset + uip.mincurypos + uip.maxcurypos + 1, uip.listlen)):
                item = uip.sorted_list[y]
                is_tagged = item in tagged_items
                is_deleted = getattr(item, "__deleted", False)
                generate_list_row(uip, item, field_dict, y - uip.yoffset,
                                  uip.is_selected(item), is_taggable=is_taggable,
                                  is_tagged=is_tagged, is_deleted=is_deleted)
            uip.list_needs_regeneration(False)

        uip.refresh_window()
        uip.refresh_listpad()
        uip.refresh_statusbar()
        if first_fetch:
            __win = curses_helper.notice(uip.listpad, message="Checking for data")
        curses.doupdate()

        uip.stdscr.timeout(100)
        c = uip.stdscr.getch()
        retval: Retval = uip.generic_keycheck(c)

        if retval == Retval.MATCH:
            continue
        if retval == Retval.RETURNONE:
            try:
                # This is to get the necessary stack info
                raise UserWarning
            except UserWarning:
                # Calling function; if we're at the top level view we shouldn't return further,
                # but we should clear selections
                if (exc_info_ := sys.exc_info()[2]) is None:
                    return Retval.RETURNDONE

                if (f_back_ := exc_info_.tb_frame.f_back) is None:
                    return Retval.RETURNDONE

                if f_back_.f_code.co_name in ("setupui",):
                    if tagged_items:
                        tagged_items = set()
                        uip.list_needs_regeneration(True)
                else:
                    return Retval.RETURNDONE
        if retval == Retval.RETURNFULL:
            return retval

        if c == curses.KEY_F2:
            if (retval := selectwindow(uip)) == Retval.RETURNFULL:
                return retval
            uip.refresh_all()
        elif c == curses.KEY_F3:
            if (retval := selectwindow(uip, refresh_apis=True)) == Retval.RETURNFULL:
                return retval
            uip.refresh_all()
        elif c == ord("B"):
            uip.toggle_borders()
            uip.refresh_all()
            uip.force_update()
            uip.update_window(update="false")
        elif c == ord("W"):
            if not field_indexes:
                continue

            _list = list(field_indexes.keys())
            _index = _list.index(field_index)
            field_index = _list[(_index + 1) % len(field_indexes)]

            fieldgenerator_args = {
                "field_index": field_index,
                "field_indexes": field_indexes,
                "fields": deep_get(viewref, DictPath("fields")),
                "denylist": denylist,
            }
            field_dict, field_names, sortcolumn, sortorder_reverse = \
                generators.fieldgenerator(view=view,
                                          selected_namespace=selected_namespace,
                                          **fieldgenerator_args)
            infogetter_extra_args["_field_index"] = field_index.lower()
            infogetter_extra_args["_field_names"] = field_names
            infogetter_extra_args["_field_dict"] = field_dict
            vinfo = infogetter(**infogetter_extra_args)
            uip.update_info(vinfo)
            update_field_widths(field_dict, field_names, uip.info)
            uip.reinit_window(field_dict=field_dict, sortcolumn=sortcolumn)
            uip.resize_listpad(width=-1)
            uip.refresh_all()
            uip.force_update()
            uip.update_window(update="false")
        # pylint: disable-next=too-many-nested-blocks
        elif c == curses.KEY_F7:
            action_title: str = "Perform cluster-wide actions"
            action_src_list: dict[str, dict[str, dict[str, Any]]] = listviewactions

            # Populate the list of actions
            actions, actionlist = populate_actionlist(action_list=action_src_list)

            if not actions:
                continue

            tmpselection = \
                curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                           uip.maxy // 2, uip.maxx // 2, actions,
                                           title=action_title)
            selection = None
            if tmpselection is not None and tmpselection != "":
                selection = ""
                for i, element in enumerate(tmpselection):
                    if element:
                        selection += str(element[0])
            uip.refresh_all()
            curses.doupdate()

            actionfunc_args: dict = {}
            if selection is not None and selection != "":
                actionfunc = None

                # Map the description back to key
                action = None
                for action in actionlist:
                    description = deep_get(actionlist, DictPath(f"{action}#description"))
                    tmpdescription = ""
                    if isinstance(description, str):
                        tmpdescription = description
                    else:
                        for i, element in enumerate(description):
                            tmpdescription += element[0]
                    tmpmetadata = deep_get(actionlist, DictPath(f"{action}#metadata"), [])
                    for metadata in tmpmetadata:
                        tmpdescription += metadata[0]
                    if tmpdescription == selection:
                        actionfunc = \
                            deep_get(actionlist, DictPath(f"{action}#actionfunc"), command_hosts)
                        if isinstance(actionfunc, str):
                            actionfunc = deep_get(actionfunc_allowlist, DictPath(actionfunc))
                        actionfunc_args = \
                            deep_get(actionlist, DictPath(f"{action}#actionfunc_args"), {})
                        # These are only relevant for node and inventory view
                        # allowoncontrolplane = \
                        #     deep_get(actionlist,
                        #              DictPath(f"{action}#allow_on_control_plane"), True)
                        # singleoncontrolplane = \
                        #     deep_get(actionlist,
                        #              DictPath(f"{action}#single_on_control_plane"), False)
                        confirm = deep_get(actionlist, DictPath(f"{action}#confirm"), False)
                        query = deep_get(actionlist, DictPath(f"{action}#query"))
                        queryval = deep_get(actionlist, DictPath(f"{action}#queryval"))
                        queryfunc = deep_get(actionlist, DictPath(f"{action}#queryfunc"))
                        extravars = deep_get(actionlist, DictPath(f"{action}#extravars"), {})
                        break

                if actionfunc is None:
                    continue

                selection_vars = extravars

                # This should be modified; we might want to ask multiple queries.
                # At the very least asking for one input plus confirmation.
                # A multi input box might be useful too.
                if queryfunc is not None and queryval is not None and query is not None:
                    if queryfunc in ("int", "string"):
                        # Not supported by inputbox widget
                        # querydefault = ""
                        query_title = f"{query}: "
                        if not (string := curses_helper.inputbox(uip.stdscr, title=query_title)):
                            continue
                        if queryfunc == "int":
                            try:
                                string = int(string)
                            except ValueError:
                                message = f"{queryval} is not an integer"
                                curses_helper.alert(uip.stdscr, message=message,
                                                    wait_for_keypress=True)
                                continue
                        selection_vars[queryval] = string
                        deep_set(selection_vars, DictPath(f"values#{queryval}"), string,
                                 create_path=True)
                    elif queryfunc == "confirm":
                        querydefault = False
                        query_title = f"{query}?"
                        if not curses_helper.confirmationbox(uip.stdscr, title=query_title,
                                                             default=querydefault):
                            continue
                    elif queryfunc == "filechooser":
                        # It is a programming error if either of these two are not set,
                        # so it is OK to get an exception
                        listgetter = extravars["listgetter"]
                        basedir = extravars["basedir"]
                        selected_file = None
                        selected_ptype = None

                        while basedir is not None:
                            tmp_file_list = listgetter(basedir)
                            file_list = []
                            for item in tmp_file_list:
                                realpath, filename, ptype = item
                                if ptype in ("File", "Configuration File", "Kustomization"):
                                    fmt = ThemeAttr("windowwidget", "default")
                                elif ptype == "<dir>":
                                    fmt = ThemeAttr("windowwidget", "highlight")
                                else:
                                    errmsg = [
                                        [("filechooser", "emphasis"),
                                         (" called with invalid argument(s):", "error")],
                                        [("ptype = ", "default"),
                                         (f"{ptype}", "argument"),
                                         (" (expected one of: ", "default"),
                                         ("File", "argument"),
                                         (", ", "default"),
                                         ("Configuration File", "argument"),
                                         (", ", "default"),
                                         ("Kustomization", "argument"),
                                         (", or ", "default"),
                                         ("<dir>", "argument"),
                                         (")", "default")],
                                    ]
                                    unformatted_msg, formatted_msg = \
                                        ANSIThemeStr.format_error_msg(errmsg)
                                    cmtlog.log(LogLevel.ERR,
                                               msg=unformatted_msg,
                                               messages=formatted_msg)
                                    continue

                                file_list.append({
                                    "lineattrs": WidgetLineAttrs.NORMAL,
                                    "columns": [[ThemeStr(f"{filename}", fmt)],
                                                [ThemeStr(f"{ptype}",
                                                          ThemeAttr("windowwidget",
                                                                    "description"))]],
                                    "retval": filename,
                                })
                            tmpselection = \
                                curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                           uip.maxy // 2, uip.maxx // 2, file_list,
                                                           title=query, cursor=True)
                            if tmpselection is None or tmpselection == "":
                                # This will break out of the loop
                                basedir = None
                                selected_file = None
                                continue
                            selected_entry = tmpselection
                            # Find entry in tmp_file_list
                            for item in tmp_file_list:
                                realpath, filename, ptype = item
                                if filename == selected_entry:
                                    if ptype == "<dir>":
                                        basedir = realpath
                                        uip.refresh_all()
                                    elif ptype in ("File", "Configuration File", "Kustomization"):
                                        selected_file = realpath
                                        selected_ptype = ptype
                                        basedir = None
                                        break

                        if selected_file is None:
                            uip.force_update()
                            continue
                        selection_vars = extra_vars
                        selection_vars["resource_path"] = (selected_file, selected_ptype)

                if confirm:
                    query_title = f"Perform “{description}“?"
                    if not curses_helper.confirmationbox(uip.stdscr, title=query_title,
                                                         default=False):
                        continue

                retval = actionfunc(uip=uip, items=[], action=actionlist[action],
                                    values=selection_vars, kind=kind,
                                    **actionfunc_args)
                if retval is not None and retval == Retval.RETURNFULL:
                    return retval

                uip.force_update()
                continue
        elif c == ord("N"):
            if not is_namespaced:
                continue

            all_ns = "<All>"
            if selected_namespace == "":
                preselection: Union[str, set] = all_ns
            else:
                preselection = selected_namespace
            namespace_list = [{
                "lineattrs": WidgetLineAttrs.NORMAL,
                "columns": [[ThemeStr(f"{all_ns}", ThemeAttr("windowwidget", "default"))]],
                "retval": all_ns,
            }]

            tmp, status = \
                kh.get_list_by_kind_namespace(("Namespace", ""), "", resource_cache=kh_cache)
            if status == 200:
                for ns in (deep_get(item, DictPath("metadata#name")) for item in tmp):
                    namespace_list.append({
                        "lineattrs": WidgetLineAttrs.NORMAL,
                        "columns": [[ThemeStr(f"{ns}", ThemeAttr("windowwidget", "default"))]],
                        "retval": ns,
                    })

            tmpselection = \
                curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                           uip.maxy // 2, uip.maxx // 2, namespace_list,
                                           title="Select Namespace", cursor=True,
                                           preselection=preselection)
            selection = None
            if isinstance(tmpselection, str):
                selection = tmpselection

            if selection is not None and selection:
                if selection == all_ns:
                    selected_namespace = ""
                else:
                    selected_namespace = selection

            fieldgenerator_args = {
                "field_index": field_index,
                "field_indexes": field_indexes,
                "fields": deep_get(viewref, DictPath("fields")),
                "denylist": denylist,
            }
            field_dict, field_names, sortcolumn, sortorder_reverse = \
                generators.fieldgenerator(view=view,
                                          selected_namespace=selected_namespace,
                                          **fieldgenerator_args)

            update_field_widths(field_dict, field_names, uip.info)
            tagged_items.clear()
            uip.reinit_window(field_dict=field_dict, sortcolumn=sortcolumn)
            uip.resize_listpad(width=-1)
            uip.refresh_all()
            uip.update_info([])
            uip.force_update()
            if ".".join(kind) in executor:
                executor.update(".".join(kind), namespace=selected_namespace)
            uip.update_window(update="false")
            uip.list_needs_regeneration(True)
            infogetter_extra_args["_vlist"] = []
        elif c in (ord("t"), ord(" ")) and is_taggable:
            selected = uip.get_selected()

            if selected is not None:
                if selected in tagged_items:
                    tagged_items.discard(selected)
                    uip.list_needs_regeneration(True)
                else:
                    tagged_items.add(selected)
                    uip.list_needs_regeneration(True)
                # After we tag an item we advance the cursor (when possible);
                # this way we can select multiple continuous items in a straight-forward manner
                uip.move_cur_with_offset(1)
        elif c == ord("T") and is_taggable:
            # Tag by pattern
            tag_title = f"Tag “{uip.sortcolumn.rstrip().lower()}“ matching: "
            if not (pattern := curses_helper.inputbox(uip.stdscr, title=tag_title)):
                continue
            compiled_pattern: re.Pattern[str] = re.compile(pattern)

            # XXX: This should search the specified sortcolumn, not always in name
            for item in uip.sorted_list:
                try:
                    tmp = compiled_pattern.match(item.name)

                    if tmp is not None and tmp[0]:
                        if item not in tagged_items:
                            tagged_items.add(item)
                            uip.list_needs_regeneration(True)
                except re.error:
                    continue
        elif c == ord("") and is_taggable:
            if not tagged_items:
                continue

            # Untag by pattern
            untag_title = f"Untag “{(uip.sortcolumn).rstrip().lower()}“ matching: "
            if not (pattern := curses_helper.inputbox(uip.stdscr, title=untag_title)):
                continue
            compiled_pattern = re.compile(pattern)

            # XXX: This should search the specified sortcolumn, not always in name
            for item in uip.sorted_list:
                try:
                    tmp = compiled_pattern.match(item.name)

                    if tmp is not None and tmp[0]:
                        tagged_items.discard(item)
                        uip.list_needs_regeneration(True)
                except re.error:
                    continue
        elif c == ord("l") and is_taggable and vlist is not None and uip.listlen:
            # List the union of all labels of the tagged objects (if the objects support labels)
            if not tagged_items:
                selected = uip.get_selected()
                tagged_items.add(selected)
                uip.list_needs_regeneration(True)
            labellist = []
            labels = []
            if "namespace" in deep_get(vlist[0], DictPath("metadata"), "") \
                    and hasattr(item, "namespace"):
                itemlist = [(item.namespace, item.name) for item in tagged_items]
            else:
                itemlist = [item.name for item in tagged_items]

            if not itemlist:
                continue

            for obj in vlist:
                if isinstance(itemlist[0], tuple):
                    if (deep_get(obj, DictPath("metadata#namespace"), ""),
                            deep_get(obj, DictPath("metadata#name"))) not in itemlist:
                        continue
                else:
                    if deep_get(obj, DictPath("metadata#name")) not in itemlist:
                        continue

                labelpath = deep_get(viewref, DictPath("labels"), "metadata#labels")
                labelref = deep_get(obj, DictPath(labelpath), {})
                for key in labelref:
                    if (key, labelref[key]) not in labels:
                        labels.append((key, labelref[key]))
            if not labels:
                tagged_items.clear()
                uip.list_needs_regeneration(True)
                continue
            for key_, value_ in cast(list[tuple[str, str]], natsorted(labels)):
                labellist.append({
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr(f"{key_}", ThemeAttr("windowwidget", "default"))],
                                [ThemeStr(f"{value_}", ThemeAttr("windowwidget", "default"))]],
                })
            label_headers = ["Label:", "Value:"]
            curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                       uip.maxy // 2, uip.maxx // 2,
                                       labellist, headers=label_headers,
                                       cursor=False)
            tagged_items.clear()
            uip.list_needs_regeneration(True)
            uip.refresh_all()
            curses.doupdate()
        elif c == ord("f") and is_taggable and vlist is not None and uip.listlen:
            # List the union of all labels of the tagged objects and create a label selector
            # from the choices made by the user (if the objects support labels)
            if not tagged_items:
                selected = uip.get_selected()
                tagged_items.add(selected)
                uip.list_needs_regeneration(True)

            labellist = []
            labels = []
            if "namespace" in deep_get(vlist[0], DictPath("metadata"), ""):
                itemlist = [(item.namespace, item.name) for item in tagged_items]
            else:
                itemlist = [item.name for item in tagged_items]

            if not itemlist:
                continue

            for obj in vlist:
                if isinstance(itemlist[0], tuple):
                    if (deep_get(obj, DictPath("metadata#namespace"), ""),
                            deep_get(obj, DictPath("metadata#name"))) not in itemlist:
                        continue
                else:
                    if deep_get(obj, DictPath("metadata#name")) not in itemlist:
                        continue

                labelref = deep_get(obj, DictPath("metadata#labels"), {})
                for key in labelref:
                    if (key, labelref[key]) not in labels:
                        labels.append((key, labelref[key]))
            if not labels:
                continue
            for key, value in labels:
                labellist.append({
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr(f"{key}", ThemeAttr("windowwidget", "default"))],
                                [ThemeStr(f"{value}", ThemeAttr("windowwidget", "default"))]],
                })
            label_headers = ["Label:", "Value:"]
            tagged_labels = cast(set, curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                                 uip.maxy // 2, uip.maxx // 2,
                                                                 labellist, headers=label_headers,
                                                                 title="Labels", cursor=True,
                                                                 taggable=True))
            if tagged_labels:
                selectors = {}
                for i, label in enumerate(labels):
                    if i in tagged_labels:
                        selectors[label[0]] = label[1]
                label_selector = make_label_selector(selectors)
                uip.force_update()
            tagged_items.clear()
            uip.update_info([])
            uip.force_update()
            if ".".join(kind) in executor:
                executor.update(".".join(kind), label_selector=label_selector)
            uip.update_window(update="false")
            uip.list_needs_regeneration(True)
            infogetter_extra_args["_vlist"] = []
        elif c == ord("A") and view == "Inventory" and not tagged_items:
            selected = uip.get_selected()
            groups = ansible_get_groups(ANSIBLE_INVENTORY)
            inventory = ansible_get_inventory_dict()

            # These Ansible groups should not be possible to toggle on/off
            for skip in ["all", "controlplane", "controlplanes", "master", "node", "nodes"]:
                try:
                    groups.remove(skip)
                except (KeyError, ValueError):
                    pass
            host_groups = ansible_get_groups_by_host(inventory, selected.name)
            grouplist = []
            preselection = set()
            for i, group in enumerate(groups):
                grouplist.append({
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr(f"{group}",
                                          ThemeAttr("windowwidget", "default"))]],
                })
                if group in host_groups:
                    preselection.add(i)
            group_headers = ["Ansible Groups:"]
            selection = \
                curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                           uip.maxy // 2, uip.maxx // 2, grouplist,
                                           headers=group_headers,
                                           title=f"Toggle Ansible groups for {selected.name}:",
                                           cursor=True, taggable=True, preselection=preselection)
            new_groups = []
            for keep in ["all", "controlplane", "controlplanes", "master", "node", "nodes"]:
                if keep in host_groups:
                    new_groups.append(keep)
            for i in selection:
                new_groups.append(groups[i])

            add_groups = set(new_groups) - set(host_groups)
            remove_groups = set(host_groups) - set(new_groups)

            for group in add_groups:
                retval = ansible_add_hosts(inventory=ANSIBLE_INVENTORY,
                                           hosts=[selected.name], group=group, skip_all=False)
            for group in remove_groups:
                retval = ansible_remove_hosts(inventory=ANSIBLE_INVENTORY,
                                              hosts=[selected.name], group=group)

            if add_groups or remove_groups:
                uip.force_update()
            uip.refresh_all()
            curses.doupdate()
        elif c == ord("F") and is_taggable:
            # Clear the label selector
            if label_selector:
                label_selector = ""
                uip.force_update()
                uip.refresh_all()
                curses.doupdate()
                tagged_items.clear()
                uip.update_info([])
                uip.force_update()
                if ".".join(kind) in executor:
                    executor.update(".".join(kind), label_selector=label_selector)
                uip.update_window(update="false")
                uip.list_needs_regeneration(True)
                infogetter_extra_args["_vlist"] = []
        elif c == ord("L") and is_taggable:
            # List tagged items
            taggeditemlist = []
            if not tagged_items:
                continue
            # XXX: Currently windowwidget cannot handle ThemeRefs
            bullet = str(ThemeRef("separators", "widgetbullet"))
            for item in tagged_items:
                taggeditemlist.append({
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr(f"{bullet}{item.name}",
                                          ThemeAttr("windowwidget", "default"))]],
                })
            curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2,
                                       taggeditemlist, title="Tagged items", cursor=False)
            uip.refresh_all()
            curses.doupdate()
        # pylint: disable-next=too-many-nested-blocks
        elif c == ord(";") and is_taggable and uip.listlen:
            cluster_available = True
            items = []
            autoitem = False
            control_plane_selected = False

            if not tagged_items:
                selected = uip.get_selected()
                tagged_items.add(selected)
                uip.list_needs_regeneration(True)
                autoitem = True

            for item in tagged_items:
                # XXX Once all infogetters have been fixed we do not need to check for <none>
                if not hasattr(item, "name") \
                        or not getattr(item, "name") or getattr(item, "name") == "<none>":
                    errmsg = [
                        [("Kind ", "default"),
                         (f"{kind}", "argument"),
                         (" either lacks the ", "default"),
                         ("name", "argument"),
                         (" attribute or has an empty value; ", "default"),
                         ("currently tagging requires that attribute.", "default")],
                    ]
                    unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
                    cmtlog.log(LogLevel.WARNING, msg=unformatted_msg, messages=formatted_msg)
                    break

                if hasattr(item, "roles"):
                    if isinstance(item.roles, (list, tuple)):
                        if ("control-plane", "") in item.roles:
                            control_plane_selected = True
                        if ("<unknown>", "") in item.roles:
                            cluster_available = False
                    else:
                        if "control-plane" in item.roles:
                            control_plane_selected = True
                        if "<unknown>" in item.roles:
                            cluster_available = False
                if hasattr(item, "namespace"):
                    items.append((item.namespace, item.name))
                else:
                    items.append(item.name)

            if not items:
                tagged_items.clear()
                uip.list_needs_regeneration(True)
                continue

            action_title = deep_get(viewref, DictPath("actions#title"),
                                    "Perform action on tagged items")
            tmp_action_src_list = deep_get(viewref, DictPath("actions#actionlist"), {})

            action_src_list = {}

            for action in tmp_action_src_list:
                # Override default actions by passing an empty action by the same name
                if action in action_src_list and tmp_action_src_list[action] == {}:
                    action_src_list.pop(action)
                elif action:
                    action_src_list[action] = tmp_action_src_list[action]

            # Populate the list of actions
            actions, actionlist = \
                populate_actionlist(action_list=action_src_list,
                                    control_plane_selected=control_plane_selected,
                                    single_item=(len(items) == 1),
                                    cluster_available=cluster_available)

            # If there are playbook actions, add those too
            if deep_get(viewref, DictPath("actions#playbooklist"), {}):
                playbook_context = \
                    deep_get(viewref, DictPath("actions#playbooklist#context"))
                actions, actionlist = \
                    populate_playbooklist(context=playbook_context,
                                          actions=[],
                                          action_list=actionlist,
                                          control_plane_selected=control_plane_selected,
                                          single_item=(len(items) == 1),
                                          cluster_available=cluster_available)

            if not actions:
                if autoitem:
                    tagged_items.clear()
                    uip.list_needs_regeneration(True)
                continue

            tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                      uip.maxy // 2, uip.maxx // 2, actions,
                                                      title=action_title)
            selection = None
            if tmpselection is not None and tmpselection != "":
                selection = ""
                for i, element in enumerate(tmpselection):
                    if element:
                        selection += str(element[0])
            uip.refresh_all()
            curses.doupdate()

            if selection is not None and selection != "":
                actionfunc = None

                # Map the description back to key
                for action in actionlist:
                    description = deep_get(actionlist, DictPath(f"{action}#description"))
                    tmpdescription = ""
                    if isinstance(description, str):
                        tmpdescription = description
                    else:
                        for i, segment in enumerate(description):
                            tmpdescription += segment[0]
                    tmpmetadata = deep_get(actionlist, DictPath(f"{action}#metadata"), [])
                    for metadata in tmpmetadata:
                        tmpdescription += metadata[0]
                    if tmpdescription == selection:
                        actiontype = deep_get(actionlist, DictPath(f"{action}#action"))
                        if actiontype is not None:
                            if actiontype == "execute":
                                actionfunc = action_execute_command
                        else:
                            actionfunc = deep_get(actionlist, DictPath(f"{action}#actionfunc"),
                                                  command_hosts)
                            if isinstance(actionfunc, str):
                                actionfunc = deep_get(actionfunc_allowlist, DictPath(actionfunc))
                            actionfunc_args = \
                                deep_get(actionlist, DictPath(f"{action}#actionfunc_args"), {})
                        action_args = deep_get(actionlist, DictPath(f"{action}#action_args"), {})
                        # These are only relevant for node and inventory view
                        # allowoncontrolplane = \
                        #     deep_get(actionlist,
                        #              DictPath(f"{action}#allow-on-control-plane"), True)
                        # singleoncontrolplane = \
                        #     deep_get(actionlist,
                        #              DictPath(f"{action}#single-on-control-plane"), False)
                        confirm = deep_get(actionlist, DictPath(f"{action}#confirm"), False)
                        query = deep_get(actionlist, DictPath(f"{action}#query"))
                        queryval = deep_get(actionlist, DictPath(f"{action}#queryval"))
                        queryfunc = deep_get(actionlist, DictPath(f"{action}#queryfunc"))
                        extravars = deep_get(actionlist, DictPath(f"{action}#extravars"), {})
                        title = deep_get(actionlist, DictPath(f"{action}#title"))
                        break

                if actionfunc is None:
                    continue

                selection_vars = extravars

                # This should be modified; we might want to ask multiple queries.
                # At the very least asking for one input plus confirmation.
                # A multi input box might be useful too.
                if queryfunc is not None and queryval is not None and query is not None:
                    if queryfunc in ("int", "string"):
                        # Not supported by inputbox widget
                        # querydefault = ""
                        query_title = f"{query}: "
                        if not (string := curses_helper.inputbox(uip.stdscr, title=query_title)):
                            continue
                        if queryfunc == "int":
                            try:
                                string = int(string)
                            except ValueError:
                                message = f"{queryval} is not an integer"
                                curses_helper.alert(uip.stdscr, message=message,
                                                    wait_for_keypress=True)
                                continue
                        selection_vars[queryval] = string
                        deep_set(selection_vars, DictPath(f"values#{queryval}"), string,
                                 create_path=True)
                    elif queryfunc == "confirm":
                        querydefault = False
                        query_title = f"{query}?"
                        if not curses_helper.confirmationbox(uip.stdscr, title=query_title,
                                                             default=querydefault):
                            continue
                    elif queryfunc == "filechooser":
                        # It is a programming error if either of these two are not set,
                        # so it is OK to get an exception
                        listgetter = extravars["listgetter"]
                        basedir = extravars["basedir"]
                        selected_file = None
                        selected_ptype = None

                        while basedir is not None:
                            tmp_file_list = listgetter(basedir)
                            file_list = []
                            for item in tmp_file_list:
                                realpath, filename, ptype = item
                                if ptype in ("File", "Configuration File", "Kustomization"):
                                    fmt = ThemeAttr("windowwidget", "default")
                                elif ptype == "<dir>":
                                    fmt = ThemeAttr("windowwidget", "highlight")
                                else:
                                    errmsg = [
                                        [("filechooser", "emphasis"),
                                         (" called with invalid argument(s):", "error")],
                                        [("ptype = ", "default"),
                                         (f"{ptype}", "argument"),
                                         (" (expected one of: ", "default"),
                                         ("File", "argument"),
                                         (", ", "default"),
                                         ("Configuration File", "argument"),
                                         (", ", "default"),
                                         ("Kustomization", "argument"),
                                         (", or ", "default"),
                                         ("<dir>", "argument"),
                                         (")", "default")],
                                    ]
                                    unformatted_msg, formatted_msg = \
                                        ANSIThemeStr.format_error_msg(errmsg)
                                    cmtlog.log(LogLevel.ERR,
                                               msg=unformatted_msg,
                                               messages=formatted_msg)
                                    continue

                                file_list.append({
                                    "lineattrs": WidgetLineAttrs.NORMAL,
                                    "columns": [[ThemeStr(f"{filename}", fmt)],
                                                [ThemeStr(f"{ptype}",
                                                          ThemeAttr("windowwidget",
                                                                    "description"))]],
                                    "retval": filename,
                                })
                            tmpselection = \
                                curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                           uip.maxy // 2, uip.maxx // 2, file_list,
                                                           title=query, cursor=True)
                            if tmpselection is None or tmpselection == "":
                                # This will break out of the loop
                                basedir = None
                                selected_file = None
                                continue
                            selected_entry = selection
                            # Find entry in tmp_file_list
                            for item in tmp_file_list:
                                realpath, filename, ptype = item
                                if filename == selected_entry:
                                    if ptype == "<dir>":
                                        basedir = realpath
                                        uip.refresh_all()
                                    elif ptype in ("File", "Configuration File", "Kustomization"):
                                        selected_file = realpath
                                        selected_ptype = ptype
                                        basedir = None
                                        break

                        if selected_file is None:
                            uip.force_update()
                            continue
                        selection_vars["resource_path"] = (selected_file, selected_ptype)

                if confirm:
                    query_title = f"Are you sure you want to perform “{description}“?"
                    if not curses_helper.confirmationbox(uip.stdscr, title=query_title,
                                                         default=False):
                        continue

                selection_vars["_tagged_items"] = list(tagged_items)
                selection_vars["action_args"] = action_args
                retval = actionfunc(uip=uip, items=items, action=actionlist[action],
                                    values=selection_vars, kind=kind, title=title,
                                    **actionfunc_args)
                if retval is not None and retval == Retval.RETURNFULL:
                    return retval

                uip.force_update()
                uip.update_forced = True
                tagged_items.clear()
                uip.list_needs_regeneration(True)
                continue
            tagged_items.clear()
            uip.list_needs_regeneration(True)

        shortcuts = deep_get(viewref, DictPath("shortcuts"), {})

        for key, value in shortcuts.items():
            read_only = deep_get(value, DictPath("read_only"), False)
            if read_only_mode and not read_only:
                continue

            if (shortcut_keys := deep_get(value, DictPath("shortcut"))) is None:
                continue

            if c not in shortcut_keys:
                continue

            query = deep_get(value, DictPath("query"))
            queryval = deep_get(value, DictPath("queryval"))
            queryfunc = deep_get(value, DictPath("queryfunc"))
            # Force update data
            force_update = deep_get(value, DictPath("force_update"), False)
            # Force update UI
            force_refresh = deep_get(value, DictPath("force_refresh"), False)

            selection_vars = None

            # This should be modified; we might want to ask multiple queries.
            # At the very least asking for one input plus confirmation.
            # A multi input box might be useful too.
            if queryfunc is not None and queryval is not None and query is not None:
                if queryfunc == "string":
                    # Not supported by inputbox widget
                    # querydefault = ""
                    query_title = f"{query}: "
                    if not (string := curses_helper.inputbox(uip.stdscr, title=query_title)):
                        continue
                    selection_vars = {queryval: string}
                elif queryfunc == "confirm":
                    querydefault = False
                    query_title = f"{query}?"
                    if not curses_helper.confirmationbox(uip.stdscr, title=query_title,
                                                         default=querydefault):
                        continue
            if deep_get(value, DictPath("confirm")):
                uip.force_update()
                query_title = deep_get(value, DictPath("title"), "")
                if not curses_helper.confirmationbox(uip.stdscr, title=query_title, default=False):
                    continue

            selected = uip.get_selected()

            action = deep_get(value, DictPath("action"), None)
            if action is not None:
                action_args = deep_get(value, DictPath("action_args"), {})
                if "_pass_obj" in action_args and selected is not None:
                    action_args["obj"] = selected.ref
                if "_pass_kind" in action_args:
                    action_args["kind"] = kind
                if "_pass_selected" in action_args and selected is not None:
                    action_args["selected"] = selected
                if "_pass_selection_vars" in action_args:
                    action_args["selection_vars"] = selection_vars
                if "_parent_namespace_path" in action_args and selected is not None:
                    parent_namespace_path = \
                        deep_get(action_args, DictPath("_parent_namespace_path"))
                    action_args["_parent_namespace"] = deep_get(obj, parent_namespace_path, "")
                if "_named_title" in action_args and selected is not None:
                    title = deep_get(action_args, DictPath("title"), "")
                    title_name = ""
                    if "_name_path" in action_args:
                        title_name_path = deep_get(action_args, DictPath("_name_path"), "")
                        title_name = deep_get(selected.ref, DictPath(title_name_path), "")
                    elif "_name_tuple_paths" in action_args:
                        title_name_paths = deep_get(action_args, DictPath("_name_tuple_paths"), [])
                        title_name = deep_get_str_tuple_paths(selected.ref, title_name_paths, "")
                    elif selected is not None:
                        title_name = getattr(selected, "name", "")
                    if title_name != "":
                        title_name = f" ({title_name})"
                    action_args["named_title"] = f"{title}{title_name}"
                action_call = deep_get(value, DictPath("action_call"))
                if action == "toggle_var":
                    var = deep_get(action_args, DictPath("var"))
                    if var is not None:
                        tmp = deep_get(listview_args, DictPath(var))
                        deep_set(listview_args, DictPath(var), not tmp)
                elif action == "call" and action_call is not None:
                    retval = action_call(uip.stdscr, **action_args)
                    if retval is not None and retval == Retval.RETURNFULL:
                        return retval
                elif action == "command" and action_args is not None:
                    do_command(uip.stdscr, **action_args)

            if force_refresh:
                uip.force_refresh()

            if force_update:
                uip.update_forced = True
                uip.force_update()


def __switch_resource_map(**kwargs: Any) -> tuple[Retval, dict]:
    uip = deep_get(kwargs, DictPath("uip"))
    uip.refresh_all()
    return Retval.MATCH, {
        "selected_heatmap": deep_get(kwargs, DictPath("next_resource_map"))
    }


# pylint: disable-next=too-many-branches,too-many-statements
def __resource_map_cursor(**kwargs: Any) -> tuple[Retval, dict]:
    uip = deep_get(kwargs, DictPath("uip"))
    keypress = deep_get(kwargs, DictPath("__keypress"))
    selected = deep_get(kwargs, DictPath("selected"))
    info = deep_get(kwargs, DictPath("info"))
    if info is None:
        return Retval.MATCH, {
            "selected": 0,
            "ypos": 0,
            "xpos": 0,
        }

    status_len = len(info)
    heatmap_width = deep_get(kwargs, DictPath("heatmap_width"))
    stride = deep_get(kwargs, DictPath("stride"), 1)

    maxval = status_len - 1
    oldval = selected

    if keypress == curses.KEY_LEFT:
        selected = clamp(oldval - 1, 0, maxval)
        uip.refresh_all()
    if keypress == curses.KEY_RIGHT:
        selected = clamp(oldval + 1, 0, maxval)
        uip.refresh_all()
    elif keypress == curses.KEY_UP:
        if (oldval - (heatmap_width + 1)) >= 0:
            selected = oldval - (heatmap_width + 1)
    elif keypress == curses.KEY_DOWN:
        if (oldval + heatmap_width + 1) <= maxval:
            selected = oldval + heatmap_width + 1
    elif keypress == curses.KEY_PPAGE:
        if (oldval - ((heatmap_width + 1) * stride)) >= 0:
            selected = oldval - (heatmap_width + 1) * stride
    elif keypress == curses.KEY_NPAGE:
        if (oldval + ((heatmap_width + 1) * stride)) <= maxval:
            selected = oldval + (heatmap_width + 1) * stride
    elif keypress == curses.KEY_HOME:
        selected = max((oldval // (heatmap_width + 1)) * (heatmap_width + 1), 0)
    elif keypress == curses.KEY_END:
        selected = \
            min((oldval // (heatmap_width + 1)) * (heatmap_width + 1) + heatmap_width, maxval)
    elif keypress == curses.KEY_SHOME:
        selected = oldval - (oldval // (heatmap_width + 1)) * (heatmap_width + 1)
    elif keypress == curses.KEY_SEND:
        rowwidth = heatmap_width + 1
        if maxval > rowwidth:
            selected = (rowwidth * (maxval // rowwidth)) + (oldval % rowwidth)
            if selected > maxval:
                selected -= rowwidth
    elif keypress == ord("\t"):
        if oldval < maxval:
            for i in range(selected + 1, len(info)):
                if info[i].status_group != StatusGroup.OK:
                    selected = i
                    uip.force_update()
                    break
    elif keypress == curses.KEY_BTAB:
        if oldval > 0:
            for i in range(1, selected):
                if info[selected - i].status_group != StatusGroup.OK:
                    selected -= i
                    uip.force_update()
                    break

    xpos = selected % (heatmap_width + 1)
    ypos = selected // (heatmap_width + 1)
    return Retval.MATCH, {
        "selected": selected,
        "ypos": ypos,
        "xpos": xpos,
    }


def __open_listview(**kwargs: Any) -> tuple[Retval, dict]:
    uip = deep_get(kwargs, DictPath("uip"))
    kind = deep_get(kwargs, DictPath("kind"), "")
    api_family = deep_get(kwargs, DictPath("api_family"), "")
    return listviewdispatch(uip.stdscr, obj={}, kind=(kind, api_family), root=True), {}


def __open_reference(**kwargs: Any) -> tuple[Retval, dict]:
    uip = deep_get(kwargs, DictPath("uip"))
    keypress = deep_get(kwargs, DictPath("__keypress"))
    pod_name = deep_get(kwargs, DictPath("pod_name"))
    namespace = deep_get(kwargs, DictPath("namespace"))
    node = deep_get(kwargs, DictPath("node"))

    if keypress == ord("d"):
        if node is None:
            return Retval.MATCH, {}
        name = node
        namespace = ""
        kind = ("Node", "")
    elif keypress == ord("N"):
        if namespace is None:
            return Retval.MATCH, {}
        name = namespace
        namespace = ""
        kind = ("Namespace", "")
    else:
        if pod_name is None:
            return Retval.MATCH, {}
        name = pod_name
        kind = ("Pod", "")

    ref = kh.get_ref_by_kind_name_namespace(kind, name, namespace, resource_cache=kh_cache)
    retval = resourceinfodispatch(uip.stdscr, obj=ref, kind=kind)
    if retval is not None and retval == Retval.RETURNFULL:
        return retval, {}
    uip.force_update()
    return Retval.MATCH, {}


def __fetch_package_versions(**kwargs: Any) -> tuple[Retval, dict]:
    uip = deep_get(kwargs, DictPath("uip"))
    hostname = deep_get(kwargs, DictPath("hostname"))

    _win = curses_helper.notice(uip.stdscr, message="Fetching package versions...")
    _package_versions = get_package_versions(hostname)
    package_versions = []
    for package, version in _package_versions:
        if version == "N/A":
            fmt = ThemeAttr("windowwidget", "dim")
        else:
            fmt = ThemeAttr("windowwidget", "default")
        package_versions.append({
            "lineattrs": WidgetLineAttrs.NORMAL,
            "columns": [[ThemeStr(f"{package}", ThemeAttr("windowwidget", "default"))],
                        [ThemeStr(f"{version}", fmt)]],
        })
    uip.refresh_window()
    uip.refresh_infopad()
    uip.refresh_listpad()
    uip.refresh_statusbar()
    curses.doupdate()
    if not package_versions:
        return Retval.MATCH, {}
    title = "Package Versions:"
    headers = ["Package:", "Version:"]
    curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2, uip.maxx // 2,
                               package_versions, title=title, headers=headers, cursor=False)
    return Retval.MATCH, {}


clusteroverview_shortcuts = {
    "__common_shortcuts": [
        "Toggle mouse on/off",
        "Toggle borders",
        "Show this helptext",
        "Switch main view",
        "Switch main view (recheck available API resources)",
        "Show information about the program",
    ],
    "Open list page for Events": {
        "helptext": ("[Shift] + E", "Open list page for Events"),
        "shortcut": [ord("E")],
        "helpgroup": 2,
        "action": "key_callback",
        "action_call": __open_listview,
        "action_args": {
            "kind": "Event",
        },
    },
    "Open info page for Node": {
        "helptext": ("D", "Open info page for Node"),
        "shortcut": [ord("d")],
        "helpgroup": 2,
        "action": "key_callback",
        "action_call": __open_reference,
    },
    "Open info page for Namespace [Pod context only]": {
        "helptext": ("[Shift] + N", "Open info page for Namespace [Pod context only]"),
        "shortcut": [ord("N")],
        "helpgroup": 2,
        "action": "key_callback",
        "action_call": __open_reference,
    },
    "Open info page for Pod [Pod context only]": {
        "helptext": ("[Shift] + P", "Open info page for Pod [Pod context only]"),
        "shortcut": [ord("P")],
        "helpgroup": 2,
        "action": "key_callback",
        "action_call": __open_reference,
    },
    "Show package versions": {
        "helptext": ("[Shift] + V", "Show package versions"),
        "shortcut": [ord("V")],
        "helpgroup": 2,
        "action": "key_callback",
        "action_call": __fetch_package_versions,
    },
    "Move cursor up / down / left / right within resource map": {
        "helptext": ("[Cursor keys]", "Move cursor up / down / left / right within resource map"),
        "shortcut": [curses.KEY_LEFT, curses.KEY_RIGHT, curses.KEY_UP, curses.KEY_DOWN],
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
    "Move cursor 10 rows up / down within resource map": {
        "helptext": ("[Page Up]", "Move cursor 10 rows up / down within resource map"),
        "shortcut": [curses.KEY_PPAGE, curses.KEY_NPAGE],
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
        "action_args": {
            "stride": 10,
        }
    },
    "Switch to previous resource map": {
        "shortcut": [curses.KEY_SLEFT],
        "helptext": ("[Shift] + [Left]", "Switch to previous resource map"),
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __switch_resource_map,
        "action_args": {
            "next_resource_map": "Node",
        }
    },
    "Switch to next resource map": {
        "helptext": ("[Shift] + [Right]", "Switch to next resource map"),
        "shortcut": [curses.KEY_SRIGHT],
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __switch_resource_map,
        "action_args": {
            "next_resource_map": "Pod",
        }
    },
    "Jump to first column of resource map": {
        "helptext": ("[Home]", "Jump to first column of resource map"),
        "shortcut": [curses.KEY_HOME],
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
    "Jump to last column of resource map": {
        "helptext": ("[End]", "Jump to last column of resource map"),
        "shortcut": [curses.KEY_END],
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
    "Jump to next elevated severity in resource map": {
        "helptext": ("[Tab]", "Jump to next elevated severity in resource map"),
        "shortcut": [ord("\t")],
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
    "Jump to first row of resource map": {
        "helptext": ("[Shift] + [Home]", "Jump to first row of resource map"),
        "shortcut": [curses.KEY_SHOME],
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
    "Jump to last row of resource map": {
        "helptext": ("[Shift] + [End]", "Jump to last row of resource map"),
        "shortcut": [curses.KEY_SEND],
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
    "Jump to previous elevated severity in resource map": {
        "helptext": ("[Shift] + [Tab]", "Jump to previous elevated severity in resource map"),
        "shortcut": [curses.KEY_BTAB],
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __resource_map_cursor,
    },
}


# pylint: disable-next=unused-argument
def read_file_async(*args: Any, **kwargs: Any) -> tuple[list[Any], list[StatusGroup]]:
    """
    Asynchronously read the contents of a file.

        Parameters:
            *args(Any): [unused]
            **kwargs (dict[str, Any]): Keyword arguments
                file_not_found_status (str): The status message to return on file not found
                path (str): The path to get the data from
                filetype (str): The filetype
        Returns:
            (([Any], dict)):
                ([Any]): The list of results
                (status): The status message
    """
    file_not_found_status: str = deep_get(kwargs,
                                          DictPath("file_not_found_status"), "File not found")
    path: str = deep_get(kwargs, DictPath("path"))
    filetype: str = deep_get(kwargs, DictPath("filetype"), "string")

    status: StatusGroup = StatusGroup.OK
    result: Union[dict, list[str]] = []

    try:
        if filetype == "string":
            result = secure_read_string(FilePath(path), directory_is_symlink=True).splitlines()
        elif filetype == "yaml":
            result = secure_read_yaml(FilePath(path),
                                      directory_is_symlink=True,
                                      asynchronous=True)
    except FilePathAuditError as e:
        if "SecurityStatus.PARENT_DOES_NOT_EXIST" in str(e) \
                or "SecurityStatus.DOES_NOT_EXIST" in str(e):
            status = file_not_found_status
        else:
            raise

    return result, status


# pylint: disable-next=unused-argument
def run_ansible_play_async(*args: Any, **kwargs: Any) -> tuple[dict[str, Any], list[StatusGroup]]:
    """
    Asynchronously run an Ansible playbook.

        Parameters:
            *args(Any): [unused]
            **kwargs (dict[str, Any]): Keyword arguments
                playbook (FilePath): The playbook to run
                selection ([str]): The hosts to run the play on
                verbose (bool): Output status updates for every new Ansible event?
        Returns:
            ((dict, int)):
                (dict): The results of the run
                (int): The status from ansible_run_playbook();
                       -errno.ENOENT if the inventory is missing or empty
    """
    playbook = deep_get(kwargs, DictPath("playbook"))
    selection = deep_get(kwargs, DictPath("selection"))
    verbose = deep_get(kwargs, DictPath("verbose"), False)
    status, result = ansible_run_playbook_on_selection(playbook=playbook,
                                                       selection=selection, verbose=verbose)
    return result, status


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def clusteroverviewloop(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Main loop for the Cluster Overview.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                kind ((str, str)): The view to show [unused]
        Returns:
            (Retval): The return value
        Raises:
            ProgrammingError (view is invalid)
    """
    global executor  # pylint: disable=global-statement

    # Just in case there are leftover futures from other views
    executor.shutdown()
    executor = reexecutor.ReExecutor()

    view: str = deep_get(kwargs, DictPath("kind"))

    field_dict: dict[str, Any] = {}
    sortcolumn: str = ""
    uip = UIProps(stdscr)

    windowheader = view
    activatedfun = views[view]["activatedfun"]
    on_activation = deep_get(views[view], DictPath("on_activation"), {})
    update_delay = views[view].get("update_delay", -1)

    sortorder_reverse = views[view].get("sortorder_reverse", False)

    uip.init_window(field_dict=field_dict, windowheader=windowheader, update_delay=update_delay,
                    sortcolumn=sortcolumn, sortorder_reverse=sortorder_reverse,
                    activatedfun=activatedfun, on_activation=on_activation)

    infopadheight = 10
    eventpadheight = 7

    # For generic information
    uip.init_infopad(height=infopadheight, width=-1, ypos=1, xpos=1)

    # For the status panes
    uip.init_listpad(listheight=1, width=-1,
                     ypos=infopadheight + eventpadheight + 2, xpos=1, header=False)

    # For the status bar; position is always at the bottom of the screen
    # and the entire width of the screen
    uip.init_statusbar()

    selected_heatmap: str = "Node"
    selected_node: int = 0
    selected_pod: int = 0

    # Get control plane node
    control_plane_node, control_plane_name = get_control_plane()
    control_plane_addresses = deep_get(control_plane_node, DictPath("status#addresses"), [])
    name, iips, eips = infogetters.get_node_addresses(control_plane_addresses)

    hostname: str = socket.gethostname()
    islocal: bool = hostname == name

    stat_regex: re.Pattern[str] = re.compile(r"^[A-Za-z]+ +(\d+) +(\d+) +(\d+) +(\d+) "
                                             r"(\d+) +(\d+) +(\d+) +(\d+) +(\d+) (\d+)$")

    loadavg_raw: list[str] = []
    meminfo_raw: list[str] = []
    stat_raw: list[str] = []

    podinfo: list[Type] = []
    nodeinfo: list[Type] = []

    pod_heatmap_width: int = 0
    node_heatmap_width: int = 0

    pod_curypos = 0
    node_curypos = 0

    cputimeuser = 0
    cputimeusernice = 0
    cputimetotalsystem = 0
    cputimetotalguest = 0
    cputimetotal = 1
    cputimetotalused = 0
    memused = 0
    memcached = 0
    buffers = 0
    memtotal = 1
    swapused = 0
    running = 0
    tasks = 0

    swaptotal = 0

    node_statuses: list[StatusGroup] = []
    node_heatmap: list[list[Union[ThemeRef, ThemeStr]]] = []
    pod_statuses: list[StatusGroup] = []
    pod_heatmap: list[list[Union[ThemeRef, ThemeStr]]] = []
    events: list[dict[str, Any]] = []

    if not islocal:
        ping_playbook_path = get_playbook_path(FilePath("load_ping.yaml"))
        executor.trigger("sysinfo", 5, run_ansible_play_async,
                         playbook=ping_playbook_path, selection=[control_plane_name])
    executor.trigger("node", 5, listgetters_async.get_kubernetes_list, kind=("Node", ""),
                     namespace="", fetch_args={"sort_key": "metadata#name", "postprocess": "node"},
                     kubernetes_helper=kh, kh_cache=kh_cache)
    executor.trigger("pod", 5, listgetters_async.get_kubernetes_list, kind=("Pod", ""),
                     namespace="", fetch_args={"postprocess": "pod"},
                     kubernetes_helper=kh, kh_cache=kh_cache)
    executor.trigger("event", 5, listgetters_async.get_kubernetes_list, kind=("Event", ""),
                     namespace="",
                     fetch_args={"sort_key": "lastTimestamp", "sort_reverse": True, "limit": 5},
                     kubernetes_helper=kh, kh_cache=kh_cache)

    # pylint: disable-next=too-many-nested-blocks
    while True:
        if (result := executor.get("sysinfo")) != ([], []):
            ansible_results, ansible_status = result
            if ansible_status == 0:
                for ansible_result in deep_get(ansible_results, DictPath(control_plane_name), []):
                    task = deep_get(ansible_result, DictPath("task"), "")
                    if task == "Fetching /proc/loadavg":
                        loadavg_raw = deep_get(ansible_result, DictPath("stdout_lines"), [])
                    elif task == "Fetching /proc/meminfo":
                        meminfo_raw = deep_get(ansible_result, DictPath("stdout_lines"), [])
                    elif task == "Fetching /proc/stat":
                        stat_raw = deep_get(ansible_result, DictPath("stdout_lines"), [])
                    uip.force_update()
        if (result := executor.get("node")) != ([], []):
            nodeinfo, node_statuses = result
        if (result := executor.get("pod")) != ([], []):
            podinfo, pod_statuses = result
        if (result := executor.get("event")) != ([], []):
            events, _status = result

        if uip.is_update_triggered():
            # The data in some fields might become shorter, so we need to trigger a clear
            if uip.infopad is not None:
                uip.infopad.erase()
            if uip.statusbar is not None:
                uip.statusbar.erase()

            uip.update_window()

            if islocal:
                tmp: str = secure_read_string(FilePath("/proc/loadavg"))
                loadavg_raw = tmp.splitlines()
                tmp = secure_read_string(FilePath("/proc/meminfo"))
                meminfo_raw = tmp.splitlines()
                tmp = secure_read_string(FilePath("/proc/stat"))
                stat_raw = tmp.splitlines()

            if loadavg_raw:
                try:
                    _avg1min, _avg5min, _avg15min, tasks_running, _latest_pid = \
                        loadavg_raw[0].split()
                    running, tasks = tasks_running.split("/")
                except ValueError:
                    loadavg_raw = []

            if meminfo_raw:
                memtotal = 0
                memfree = 0
                memcached = 0
                sreclaimable = 0
                memshared = 0
                swaptotal = 0
                swapfree = 0
                try:
                    for tmp in meminfo_raw:
                        values = tmp.split()
                        if values[0] == "MemTotal:":
                            memtotal = int(values[1])
                        elif values[0] == "MemFree:":
                            memfree = int(values[1])
                        elif values[0] == "MemShared:":
                            memshared = int(values[1])
                        elif values[0] == "Buffers:":
                            buffers = int(values[1])
                        elif values[0] == "Cached:":
                            memcached = int(values[1])
                        elif values[0] == "SwapTotal:":
                            swaptotal = int(values[1])
                        elif values[0] == "SwapFree:":
                            swapfree = int(values[1])
                        elif values[0] == "Shmem:":
                            memshared = int(values[1])
                        elif values[0] == "SReclaimable:":
                            sreclaimable = int(values[1])
                except (IndexError, ValueError):
                    meminfo_raw = []

                # Total used mem; includes buffers and cache
                memused = memtotal - memfree
                memcached = memcached + sreclaimable - memshared
                swapused = swaptotal - swapfree
                # FIXME
                # threads = 42

            # cpu  30175835 25947 13018006 435764225 200633 0   3229829 0     0     0
            # ...  normal   niced system   idle      iowait irq softirq steal guest guest_nice
            #      1        2     3        4         5      6   7       8     9     10
            if stat_raw:
                tmp = stat_regex.match(stat_raw[0])
                if tmp is not None:
                    cputimeuser = int(tmp[1])
                    cputimeusernice = int(tmp[2])
                    cputimesystem = int(tmp[3])
                    cputimeidle = int(tmp[4])
                    cputimeiowait = int(tmp[5])
                    cputimeirq = int(tmp[6])
                    cputimesoftirq = int(tmp[7])
                    cputimesteal = int(tmp[8])
                    cputimeguest = int(tmp[9])
                    cputimeguestnice = int(tmp[10])
                    cputimeuser = cputimeuser - cputimeguest
                    cputimeusernice = cputimeusernice - cputimeguestnice
                    cputimetotalidle = cputimeidle + cputimeiowait
                    cputimetotalsystem = cputimesystem + cputimeirq + cputimesoftirq
                    cputimetotalguest = cputimeguest + cputimeguestnice
                    cputimetotal = cputimeuser + cputimeusernice + cputimetotalsystem \
                        + cputimetotalidle + cputimesteal + cputimetotalguest
                    cputimetotalused = cputimeuser + cputimeusernice + cputimetotalsystem \
                        + cputimesteal + cputimetotalguest
                else:
                    stat_raw = []

            # We most likely have far more nodes than pods, so give the nodes 20% of the width
            # and the pods 80% of the width; even this is probably too much for the nodes,
            # but we can adjust that later
            node_heatmap_width = ((uip.maxx - uip.minx - 1) // 5) - 2
            pod_heatmap_width = ((uip.maxx - uip.minx - 1) * 4 // 5) - 1

        k8s_distro, _status = kh.identify_k8s_distro()

        if k8s_distro is not None:
            k8s_distro_string = ThemeStr(f"{k8s_distro}", ThemeAttr("types", "generic"))
        else:
            k8s_distro_string = ThemeStr("<unknown>", ThemeAttr("types", "unset"))

        internal_ips_array = generators.format_list(iips, fieldlen=0, pad=False)
        external_ips_array = generators.format_list(eips, fieldlen=0, pad=False)

        infoarrays: list[list[Union[ThemeRef, ThemeStr]]] = [
            [
                ThemeStr("Control Plane: ", ThemeAttr("main", "infoheader")),
                ThemeStr(f"{name}", ThemeAttr("types", "generic")),
            ], [
                ThemeStr("Cluster Name: ", ThemeAttr("main", "infoheader")),
                ThemeStr(f"{kh.cluster_name}", ThemeAttr("types", "generic")),
            ], [
                ThemeStr("Cluster Context: ", ThemeAttr("main", "infoheader")),
                ThemeStr(f"{kh.context_name}", ThemeAttr("types", "generic")),
            ], [
                ThemeStr("Kubernetes Distro: ", ThemeAttr("main", "infoheader")),
                k8s_distro_string,
            ], [
                ThemeStr("Internal IP-address(es): ", ThemeAttr("main", "infoheader")),
            ] + internal_ips_array, [  # type: ignore
                ThemeStr("External IP-address(es): ", ThemeAttr("main", "infoheader")),
            ] + external_ips_array, [  # type: ignore
                # Kubernetes port
                # KubeDNS
                # control plane load, disk, mem, uptime (requires ansible or local)
                # ], [
            ]
        ]

        y = 0
        for i, row in enumerate(infoarrays):
            uip.addthemearray(uip.infopad, row, y=y + i, x=0)
        y += i

        # cpu usage:
        # low-priority (bold blue) / normal (green) / kernel (red) / virtualized (cyan)
        # This is aggregate over all CPUs
        percentagebar_cpu: list[Union[ThemeRef, ThemeStr]] = \
            curses_helper.percentagebar(7, uip.infopadwidth - 10, cputimetotal, [
                (cputimeusernice, ThemeRef("strings", "cputime_user_nice")),
                (cputimeuser, ThemeRef("strings", "cputime_user")),
                (cputimetotalsystem, ThemeRef("strings", "cputime_total_system")),
                (cputimetotalguest, ThemeRef("strings", "cputime_total_guest"))
            ])

        # memory usage:
        # used (green) / buffers (bold blue) / cache (yellow)
        percentagebar_mem: list[Union[ThemeRef, ThemeStr]] = \
            curses_helper.percentagebar(7, uip.infopadwidth - 10, memtotal, [
                (memused - memcached - buffers, ThemeRef("strings", "mem")),
                (buffers, ThemeRef("strings", "buffers")),
                (memcached, ThemeRef("strings", "cached"))
            ])

        # swap usage:
        # used (red)
        if swaptotal:
            percentagebar_or_string_swap: list[Union[ThemeRef, ThemeStr]] = \
                curses_helper.percentagebar(6, uip.infopadwidth - 10, swaptotal, [
                    (swapused, ThemeRef("strings", "swap_used"))])
            percentagebar_or_string_swap += [
                ThemeStr(f"{100 * swapused // swaptotal}", ThemeAttr("main", "dim")),
                ThemeRef("separators", "percentage"),
            ]
        else:
            percentagebar_or_string_swap = [ThemeStr("Disabled", ThemeAttr("types", "none"))]

        tasksarrays: list[list[Union[ThemeRef, ThemeStr]]] = [
            [
                ThemeStr("Tasks: ", ThemeAttr("main", "infoheader")),
                ThemeStr(f"{running}", ThemeAttr("types", "numerical")),
                ThemeRef("separators", "fraction"),
                ThemeStr(f"{tasks} ", ThemeAttr("types", "numerical")),
                ThemeStr("running", ThemeAttr("types", "generic")),
            ], [
                ThemeStr("  CPU: ", ThemeAttr("main", "infoheader")),
                ThemeStr("[", ThemeAttr("types", "generic"))
            ] + percentagebar_cpu + [
                ThemeStr("]", ThemeAttr("types", "generic")),
                ThemeStr(f"{str(100 * cputimetotalused // cputimetotal).rjust(3)}",
                         ThemeAttr("types", "numerical")),
                ThemeRef("separators", "percentage"),
            ], [
                ThemeStr("  Mem: ", ThemeAttr("main", "infoheader")),
                ThemeStr("[", ThemeAttr("types", "generic"))
            ] + percentagebar_mem + [
                ThemeStr("]", ThemeAttr("types", "generic")),
                ThemeStr(str(100 * memused // memtotal).rjust(3),
                         ThemeAttr("types", "numerical")),
                ThemeRef("separators", "percentage"),
            ], [
                ThemeStr(" Swap: ", ThemeAttr("main", "infoheader")),
            ] + percentagebar_or_string_swap,  # type: ignore
        ]

        if loadavg_raw and meminfo_raw and stat_raw:
            for i, row in enumerate(tasksarrays):
                uip.addthemearray(uip.infopad, row, y=y + i, x=0)
            y += i + 1
        else:
            y += len(tasksarrays)

        # Namespace, Name, Last Seen, Type, Reason, Message
        evheaders = [
            "Namespace:",
            "Name:",
            "Last Seen:",
            "Type:",
            "Reason:",
            "Message:",
        ]

        # path(s), type
        evfields = [
            ([DictPath("metadata#namespace")], "namespace"),
            ([DictPath("metadata#name")], "str"),
            ([DictPath("series#lastObservedTime"),
              DictPath("deprecatedLastTimestamp"),
              DictPath("lastTimestamp"),
              DictPath("eventTime"),
              DictPath("deprecatedFirstTimestamp"),
              DictPath("firstTimestamp")],
             "timestamp"),
            ([DictPath("type")], "event_type"),
            ([DictPath("reason")], "str"),
            ([DictPath("message"), DictPath("note")], "str"),
        ]

        evlens = [len(header) for header in evheaders]

        for event in events:
            for i, evfield in enumerate(evfields):
                paths, ptype = evfield
                val = deep_get_with_fallback(event, paths, "")
                if ptype == "timestamp":
                    timestamp = timestamp_to_datetime(cast(str, val))
                    formatted_timestamp = format_timestamp(timestamp)
                    evlens[i] = max(evlens[i], themearray_len(formatted_timestamp))
                else:
                    evlens[i] = max(evlens[i], len(val))

        # Draw the events over the bottom of the visible area of the listpad
        eventarrays: list[list[Union[ThemeRef, ThemeStr]]] = [
            [ThemeStr("E", ThemeAttr("main", "listheader_compact_shortcut")),
             ThemeStr("vents:", ThemeAttr("main", "listheader_compact"))],
        ]

        tmp2: list[Union[ThemeRef, ThemeStr]] = []
        for i, header in enumerate(evheaders):
            tmp2.append(ThemeStr(header.ljust(evlens[i]), ThemeAttr("main", "listheader")))
            if i < len(evheaders):
                tmp2.append(ThemeStr("  ", ThemeAttr("main", "listheader")))
        eventarrays.append(tmp2)

        for evindex in range(0, 5):
            tmp2 = []

            if evindex < len(events):
                event = events[evindex]
                for i, evfield in enumerate(evfields):
                    paths, ptype = evfield
                    val = deep_get_with_fallback(event, paths, "")
                    if ptype == "timestamp":
                        timestamp = timestamp_to_datetime(cast(str, val))
                        formatted_timestamp = format_timestamp(timestamp)
                        tmp2 += formatted_timestamp
                        ft_len = evlens[i] - themearray_len(formatted_timestamp)
                        if ft_len:
                            tmp2.append(ThemeStr("".ljust(ft_len), ThemeAttr("main", "default")))
                    elif ptype == "namespace":
                        tmp2.append(ThemeStr(val.ljust(evlens[i]),
                                             ThemeAttr("types", "namespace")))
                    elif ptype == "event_type":
                        if val == "Error":
                            event_type = "status_not_ok"
                        elif val == "Warning":
                            event_type = "status_admin"
                        else:
                            event_type = "status_ok"
                        tmp2.append(ThemeStr(val.ljust(evlens[i]), ThemeAttr("main", event_type)))
                    else:
                        tmp2.append(ThemeStr(val.ljust(evlens[i]), ThemeAttr("main", "default")))

                    if i < len(evheaders):
                        tmp2.append(ThemeStr("  ", ThemeAttr("main", "default")))
            else:
                tmp2.append(ThemeStr("<none>", ThemeAttr("types", "none")))
            eventarrays.append(tmp2)

        y += 1
        curses_helper.window_tee_hline(uip.stdscr, y=y, start=0, end=uip.maxx)

        for i, row in enumerate(eventarrays):
            uip.addthemearray(uip.stdscr, row, y=y + i, x=1)
        y += i + 1
        curses_helper.window_tee_hline(uip.stdscr, y=y, start=0, end=uip.maxx)

        selected_pod = min(selected_pod, len(podinfo))
        selected_node = min(selected_node, len(nodeinfo))

        if nodeinfo or podinfo:
            node_heatmap_xpos = 0
            pod_heatmap_xpos = uip.maxx - pod_heatmap_width - 2

            taints = []
            if nodeinfo:
                taints = getattr(nodeinfo[selected_node], "taints", ["<none>"])
            if not taints:
                taints = ["<none>"]
            selectednodetaints = \
                generators.format_list(taints, fieldlen=node_heatmap_width, pad=False,
                                       field_colors=[ThemeAttr("types", "key"),
                                                     ThemeAttr("types", "effect")],
                                       field_separators=[ThemeRef("separators", "keyvalue")])

            node_name = "<none>"
            node_status = "<none>"
            node_status_group = StatusGroup.UNKNOWN

            if nodeinfo:
                node_name = nodeinfo[selected_node].name
                node_status = nodeinfo[selected_node].status
                node_status_group = nodeinfo[selected_node].status_group

            nodearrays: list[list[Union[ThemeRef, ThemeStr]]] = [
                [
                    ThemeStr(f"Node ({selected_node + 1}/{len(nodeinfo)}):",
                             ThemeAttr("main", "listheader"),
                             selected=selected_heatmap == "Node"),
                    ThemeStr("".ljust(node_heatmap_width),
                             ThemeAttr("types", "generic")),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("No", ThemeAttr("main", "listheader")),
                    ThemeStr("d", ThemeAttr("main", "listheader"),
                             selected=selected_heatmap == "Node"),
                    ThemeStr("e: ", ThemeAttr("main", "listheader")),
                    ThemeStr(f"{node_name}".ljust(node_heatmap_width),
                             ThemeAttr("main", "highlight")),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("Status: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{node_status}".ljust(node_heatmap_width),
                             color_status_group(node_status_group)),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("Taints: ", ThemeAttr("main", "infoheader")),
                ] + selectednodetaints, [  # type: ignore
                    # Empty line
                ], [
                    # Empty line
                ],
            ]

            node_heatmap = \
                curses_helper.generate_heatmap(node_heatmap_width, node_statuses, selected_node)
            nodearrays += node_heatmap

            pod_name = "<none>"
            pod_namespace = "<none>"
            pod_node = "<none>"
            pod_status = "<none>"
            pod_status_group = StatusGroup.UNKNOWN

            if podinfo:
                pod_name = podinfo[selected_pod].name
                pod_namespace = podinfo[selected_pod].namespace
                pod_node = podinfo[selected_pod].node
                pod_status = podinfo[selected_pod].status
                pod_status_group = podinfo[selected_pod].status_group

            podarrays: list[list[Union[ThemeRef, ThemeStr]]] = [
                [
                    ThemeStr(f"Pod ({selected_pod + 1}/{len(podinfo)}):",
                             ThemeAttr("main", "listheader"),
                             selected=selected_heatmap == "Pod"),
                    ThemeStr("".ljust(pod_heatmap_width), ThemeAttr("types", "generic")),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("P", ThemeAttr("main", "listheader"),
                             selected=selected_heatmap == "Pod"),
                    ThemeStr("od: ", ThemeAttr("main", "listheader")),
                    ThemeStr(f"{pod_name}".ljust(pod_heatmap_width),
                             ThemeAttr("main", "highlight")),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("N", ThemeAttr("main", "listheader"),
                             selected=selected_heatmap == "Pod"),
                    ThemeStr("amespace: ", ThemeAttr("main", "listheader")),
                    ThemeStr(f"{pod_namespace}".ljust(pod_heatmap_width),
                             ThemeAttr("main", "highlight")),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("No", ThemeAttr("main", "infoheader")),
                    ThemeStr("d", ThemeAttr("main", "listheader"),
                             selected=selected_heatmap == "Pod"),
                    ThemeStr("e: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{pod_node}".ljust(pod_heatmap_width),
                             ThemeAttr("main", "highlight")),
                ], [
                    ThemeStr(" ", ThemeAttr("main", "listheader")),
                    ThemeStr("Status: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{pod_status}".ljust(pod_heatmap_width),
                             color_status_group(pod_status_group)),
                ], [
                    # Empty line
                ]
            ]

            pod_heatmap = \
                curses_helper.generate_heatmap(pod_heatmap_width, pod_statuses, selected_pod)
            podarrays += pod_heatmap

            # Resize the list pad
            uip.resize_listpad(max(len(node_heatmap), len(pod_heatmap)))

            for y, row in enumerate(nodearrays):
                uip.addthemearray(uip.listpad, row, y=y, x=node_heatmap_xpos)

            for y, row in enumerate(podarrays):
                uip.addthemearray(uip.listpad, row, y=y, x=pod_heatmap_xpos)

        if podinfo and selected_heatmap == "Pod":
            uip.maxcurypos = len(pod_heatmap) - 1
            uip.curypos = pod_curypos
            uip.maxyoffset = 0
            uip.yoffset = 0
        elif nodeinfo and selected_heatmap == "Node":
            uip.maxcurypos = len(node_heatmap) - 1
            uip.curypos = node_curypos
            uip.maxyoffset = 0
            uip.yoffset = 0

        uip.refresh_window()
        uip.refresh_infopad()
        uip.refresh_listpad()
        uip.refresh_statusbar()
        curses.doupdate()

        if podinfo and selected_heatmap == "Pod":
            __node_name = podinfo[selected_pod].node
            __pod_name = podinfo[selected_pod].name
            __namespace = podinfo[selected_pod].namespace
            __info = podinfo
            __selected = selected_pod
            heatmap_width = pod_heatmap_width
        elif nodeinfo and selected_heatmap == "Node":
            __node_name = nodeinfo[selected_node].name
            __namespace = None
            __pod_name = None
            __info = copy.deepcopy(nodeinfo)
            __selected = selected_node
            heatmap_width = node_heatmap_width
        else:
            __node_name = None
            __namespace = None
            __pod_name = None
            __info = None
            __selected = None
            heatmap_width = 0

        # These are arguments that *might* be needed by the callbacks
        input_args = {
            "uip": uip,
            "selectwindow": selectwindow,
            "read_only": read_only_mode,
            "hostname": control_plane_name,
            "node": __node_name,
            "pod_name": __pod_name,
            "namespace": __namespace,
            "selected_heatmap": selected_heatmap,
            "info": __info,
            "selected": __selected,
            "heatmap_width": heatmap_width,
        }

        retval, return_args = uip.generic_inputhandler(clusteroverview_shortcuts, **input_args)

        if "selected" in return_args:
            if selected_heatmap == "Pod":
                selected_pod = deep_get(return_args, DictPath("selected"))
                pod_curypos = deep_get(return_args, DictPath("ypos"), pod_curypos)
            else:
                selected_node = deep_get(return_args, DictPath("selected"))
                node_curypos = deep_get(return_args, DictPath("ypos"), node_curypos)
        if "selected_heatmap" in return_args:
            selected_heatmap = deep_get(return_args, DictPath("selected_heatmap"))

        if retval == Retval.MATCH:
            continue
        if retval == Retval.RETURNONE:
            return Retval.RETURNDONE
        if retval == Retval.RETURNFULL:
            return retval


# pylint: disable-next=too-many-locals,too-many-branches
def check_cni_updates(cni: str, current_version: str) -> str:
    """
    Check whether there are newer versions of the CNI available.

        Parameters:
            cni (str): The CNI
            current_version (str): The current version
        Returns:
            (str): The newest available version
    """
    candidate_version = None

    security_policy = SecurityPolicy.ALLOWLIST_RELAXED
    fallback_allowlist = ["/bin", "/sbin", "/usr/bin", "/usr/sbin",
                          "/usr/local/bin", "/usr/local/sbin", f"{HOMEDIR}/bin"]

    if cni == "weave":
        # GET /report -H 'Accept: application/json'
        # This should be the IP address of the control plane
        # XXX: We probably need to do this locally on the control plane (via ansible)
        # rather than remotely connecting to the control plane
        weaveaddr = "127.0.0.1"

        conn = http.client.HTTPConnection(weaveaddr, 6784)
        headers = {
            "Accept": "application/json"
        }

        try:
            conn.request("GET", "/report", headers=headers)
            r1 = conn.getresponse()
        except ConnectionRefusedError:
            return "<Version check failed>"

        if r1.status == 200:
            try:
                weavestatus = json.loads(r1.read())
                if deep_get(weavestatus, DictPath("VersionCheck#Enabled"), False) \
                        and deep_get(weavestatus, DictPath("VersionCheck#Success"), False):
                    candidate_version = deep_get(weavestatus,
                                                 DictPath("VersionCheck#NewVersion"), None)
            except DecodeException:
                # We got a response, but the data is malformed
                pass
        conn.close()
    elif cni == "cilium":
        try:
            cpath = secure_which(FilePath(os.path.join(BINDIR, "cilium")),
                                 fallback_allowlist=fallback_allowlist,
                                 security_policy=security_policy)
        except FileNotFoundError:
            cpath = None

        if cpath is not None:
            args = [cpath, "version"]
            result = subprocess.run(args, stdout=PIPE, stderr=PIPE,
                                    universal_newlines=True, check=False)
            if result is not None:
                versionoutput = result.stdout.splitlines()
                version_regex: re.Pattern[str] = re.compile(r"^cilium image \(default\): (.*)")
                for line in versionoutput:
                    tmp = version_regex.match(line)
                    if tmp is not None:
                        candidate_version = tmp[1]
                        break
    else:
        candidate_version = "<Update check not implemented>"

    if candidate_version is not None:
        if versiontuple(current_version) < versiontuple(candidate_version):
            candidate_version = ""
        else:
            candidate_version = "No newer version found"

    return candidate_version


# pylint: disable-next=unused-argument
def update_cni(stdscr: curses.window, cni: str, current_version: str, candidate_version: str,
               dry_run: bool = False) -> bool:
    """
    Update the CNI.

        Parameters:
            stdscr (opaque): A curses stdscr reference
            cni (str): The CNI
            current_version (str): The current version
            candidate_version (str): The candidate version
            dry_run (bool): If True just verify that the update method is valid
        Returns:
            (bool): True on success, False on failure
    """
    security_policy = SecurityPolicy.ALLOWLIST_RELAXED
    fallback_allowlist = ["/bin", "/sbin", "/usr/bin", "/usr/sbin",
                          "/usr/local/bin", "/usr/local/sbin", f"{HOMEDIR}/bin"]

    retval = True

    if cni == "Unknown":
        retval = False
    elif cni == "weave":
        # XXX: Currently we do not have any reliable update method for weave
        retval = False
    elif cni == "cilium":
        try:
            cpath = secure_which(FilePath(os.path.join(BINDIR, "cilium")),
                                 fallback_allowlist=fallback_allowlist,
                                 security_policy=security_policy)
        except FileNotFoundError:
            cpath = None

        if dry_run or cpath is None:
            return cpath is not None

        args = [cpath, "upgrade"]
        curses.endwin()
        _retval = clear_screen()

        ansithemeprint([ANSIThemeStr("Updating Cilium:", "phase")])
        print()
        retval = execute_command(args)
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])

    return retval


def __update_cni(uip: UIProps, **kwargs: Any) -> Retval:
    cni = deep_get(kwargs, DictPath("cni"))
    cni_version = deep_get(kwargs, DictPath("cni_version"))
    candidate_version = deep_get(kwargs, DictPath("candidate_version"))

    # If we do not recognise the CNI or we do not support updates we cannot update it
    if not update_cni(uip.stdscr, cni, cni_version, candidate_version, dry_run=True):
        return Retval.MATCH

    # Try to download and install an update
    query_title = f"Update {cni} to version {candidate_version}:"
    if curses_helper.confirmationbox(uip.stdscr, title=query_title, default=False):
        update_cni(uip.stdscr, cni, cni_version, candidate_version)
    uip.refresh_all()

    return Retval.MATCH


cniloop_shortcuts = {
    "__common_shortcuts": [
        "Toggle mouse on/off",
        "Toggle borders",
        "Show this helptext",
        "Switch main view",
        "Switch main view (recheck available API resources)",
        "Refresh information",
        "Show information about the program",
    ],
    "Update Cluster Network Interface": {
        "shortcut": [ord("U")],
        "helptext": ("[Shift] + U",
                     "Update Cluster Network Interface (if a newer candidate is available)"),
        "helpgroup": 3,
        "action": "key_callback",
        "action_call": __update_cni,
    },
}


# pylint: disable-next=too-many-locals,too-many-statements
def cniloop(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Main loop for the Container Network Interface view.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                kind ((str, str)): The view to show [unused]
        Returns:
            (Retval): The return value
        Raises:
            ProgrammingError (view is invalid)
    """
    global executor  # pylint: disable=global-statement

    # Just in case there are leftover futures from other views
    executor.shutdown()
    executor = reexecutor.ReExecutor()

    view: str = deep_get(kwargs, DictPath("kind"))

    uip = UIProps(stdscr)

    windowheader = view
    activatedfun = views[view]["activatedfun"]
    on_activation = deep_get(views[view], DictPath("on_activation"), {})
    update_delay = views[view].get("update_delay", -1)

    uip.init_window(windowheader=windowheader, update_delay=update_delay,
                    sortcolumn="", activatedfun=activatedfun, on_activation=on_activation)

    # For generic information
    uip.init_infopad(height=9, width=-1, ypos=1, xpos=1)

    # The statusbar is always located at the bottom of the screen and fills the entire width
    uip.init_statusbar()

    candidate_version = ""

    cni = None

    while True:
        if uip.is_update_triggered():
            # The data in some fields might become shorter, so we need to trigger a clear
            if uip.infopad is not None:
                uip.infopad.erase()
            if uip.statusbar is not None:
                uip.statusbar.erase()

            uip.update_window()

            # Try to figure out which CNI we are using, if any
            _cnis = kh.identify_cni()

            if not _cnis:
                cni = "<unknown>"
                cnistr: list[Union[ThemeRef, ThemeStr]] = [
                    ThemeStr(f"{cni}", color_status_group(StatusGroup.UNKNOWN))
                ]
                cni_version = "N/A"
                cni_version_str = [
                    ThemeStr(f"{cni_version}", color_status_group(StatusGroup.UNKNOWN))
                ]
                cni_status = ("N/A", StatusGroup.UNKNOWN)
            elif len(_cnis) == 1:
                cni = _cnis[0][0]
                cnistr = [
                    ThemeStr(f"{cni}", ThemeAttr("types", "generic"))
                ]
                cni_version = _cnis[0][1]
                cni_version_str = [
                    ThemeStr(f"{cni_version}", ThemeAttr("types", "version"))
                ]
                cni_status = _cnis[0][2]
            else:
                cni = "<unknown>"
                cnistr = [
                    ThemeStr("Could not uniquely identify CNI ",
                             ThemeAttr("main", "status_not_ok")),
                    ThemeStr("(", ThemeAttr("types", "generic")),
                    ThemeStr("Candidates: ", ThemeAttr("main", "infoheader"))]
                for i, _cni in enumerate(_cnis):
                    cnistr += [
                        ThemeStr(f"{_cni[0]}", ThemeAttr("types", "generic")),
                        ThemeRef("separators", "version"),
                        ThemeStr(f"{_cni[1]}", ThemeAttr("types", "version"))]
                    if i < len(_cnis) - 1:
                        cnistr.append(ThemeRef("separators", "list"))
                cnistr.append(ThemeStr(")", ThemeAttr("types", "generic")))
                cni_version = "N/A"
                cni_version_str = [
                    ThemeStr(f"{cni_version[0]}", color_status_group(StatusGroup.UNKNOWN))
                ]
                cni_status = ("N/A", StatusGroup.UNKNOWN)

            cni_status_str = [
                ThemeStr(f"{cni_status[0]}", color_status_group(cni_status[1]))
            ]

            versionarray: list[Union[ThemeRef, ThemeStr]] = [
                ThemeStr("Version: ", ThemeAttr("main", "infoheader")),
            ]
            versionarray += cni_version_str
            candidateversionarray: list[Union[ThemeRef, ThemeStr]] = [
                ThemeStr("Candidate version: ", ThemeAttr("main", "infoheader")),
            ]

            candidate_version = check_cni_updates(cni, cni_version)
            candidateversionarray.append(ThemeStr(f"{candidate_version}",
                                                  ThemeAttr("types", "version")))

            namearray: list[Union[ThemeRef, ThemeStr]] = [
                ThemeStr("Container Network Interface: ", ThemeAttr("main", "infoheader")),
            ]
            namearray += cnistr
            statusarray: list[Union[ThemeRef, ThemeStr]] = [
                ThemeStr("Status: ", ThemeAttr("main", "infoheader")),
            ]
            statusarray += cni_status_str

            uip.addthemearray(uip.infopad, namearray, y=0, x=0)
            uip.addthemearray(uip.infopad, versionarray, y=1, x=0)
            uip.addthemearray(uip.infopad, candidateversionarray, y=2, x=0)
            uip.addthemearray(uip.infopad, statusarray, y=3, x=0)

        uip.refresh_window()
        uip.refresh_infopad()
        uip.refresh_statusbar()
        curses.doupdate()

        # These are arguments that *might* be needed by the callbacks
        input_args = {
            "uip": uip,
            "selectwindow": selectwindow,
            "read_only": read_only_mode,
            "cni": cni,
            "cni_version": cni_version,
            "candidate_version": candidate_version,
        }

        retval, _return_args = uip.generic_inputhandler(cniloop_shortcuts, **input_args)

        if retval == Retval.MATCH:
            continue
        if retval == Retval.RETURNONE:
            return Retval.RETURNDONE
        if retval == Retval.RETURNFULL:
            return retval


def decode_and_view_data(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Decode and view data.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict[str, Any]): An object to extract data from
                selected (Info): An InfoClass object to extract data from
                path (str): The path into the obj
                title (str): The title to use for the window
        Returns:
            (Retval): The return value
    """
    if "selected" in kwargs:
        bvalue = kwargs["selected"].value
        title = kwargs["selected"].key
        bvtype = kwargs["selected"].vtype
        vtype, value = decode_value(bvalue)
        if bvalue == value:
            vtype = bvtype
    elif "path" in kwargs:
        obj = deep_get(kwargs, DictPath("obj"), {})
        path = deep_get(kwargs, DictPath("path"), "")
        bvalue = deep_get(obj, DictPath(path), "")
        title = deep_get(kwargs, DictPath("title"), "")
        vtype, value = decode_value(bvalue)
    else:
        return Retval.RETURNDONE

    if vtype == "empty" or vtype.startswith(("base64-binary", "gzip")):
        return Retval.RETURNDONE

    if vtype.startswith("string"):
        obj = value
    elif vtype.startswith("base64-utf-8"):
        obj = base64.b64decode(value).decode("utf-8")
    else:
        errmsg = [
            [("decode_and_view_data()", "emphasis"),
             (" could not identify vtype:", "error")],
            [("vtype = ", "default"),
             (f"{vtype}", "argument"),
             (" (expected one of ", "default"),
             ("empty", "argument"),
             (", ", "default"),
             ("base64-binary", "argument"),
             (", ", "default"),
             ("gzip", "argument"),
             (", ", "default"),
             ("string", "argument"),
             (", ", "default"),
             ("base64-utf-8", "argument"),
             (")", "default")],
        ]
        unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
        cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)

        curses_helper.alert(stdscr, message=f"Failed to decode data; unsupported format {vtype}",
                            wait_for_keypress=True)
        return Retval.RETURNDONE
    if title.endswith((".crt", "tls.key", ".pem", "CAKey")) \
            or isinstance(obj, str) and obj.startswith(("-----BEGIN", "-----END")):
        formatter = formatters.format_crt
    elif title == ".dockercfg" or title.endswith(".json"):
        formatter = formatters.reformat_json
    elif title.endswith(".yaml"):
        formatter = formatters.format_yaml
    else:
        formatter = formatters.format_none
    return resourceinfodispatch(stdscr, obj=obj, kind=("__ResourceView", ""),
                                title=title, formatter=formatter)


def decode_and_view_file_templates(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Decode and view file templates.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict[str, Any]): An object to extract data from
                selection (Any): The selection data
                name_path (str): The path to the name
                file_path (str): The path to the filename
        Returns:
            (Retval): The return value
    """
    selection = deep_get(kwargs, DictPath("selection"), {})
    if not selection:
        return Retval.RETURNDONE
    obj = deep_get(kwargs, DictPath("obj"), {})
    if not obj:
        return Retval.RETURNDONE
    name_path = deep_get(kwargs, DictPath("name_path"))
    name = selection[1][name_path][0]
    file_path = deep_get(kwargs, DictPath("file_path"))
    files = deep_get(obj, DictPath(file_path))
    for file in files:
        if deep_get(file, DictPath("path"), "") == name:
            break
    else:
        return Retval.RETURNDONE
    encoding = deep_get(file, DictPath("encoding"), "")
    content = deep_get(file, DictPath("content"))
    title = name
    if encoding == "":
        formatter = formatters.map_dataformat(title)
        return resourceinfodispatch(stdscr, obj=content, kind=("__ResourceView", ""),
                                    title=title, formatter=formatter)

    vtype, value = decode_value(content)
    if vtype.startswith("string"):
        obj = value
    elif vtype.startswith("base64-utf-8"):
        obj = base64.b64decode(value).decode("utf-8")
    elif vtype.startswith(("base64-binary", "gzip")):
        return Retval.RETURNDONE
    formatter = formatters.map_dataformat(title)
    return resourceinfodispatch(stdscr, obj=obj, kind=("__ResourceView", ""),
                                title=title, formatter=formatter)


# pylint: disable-next=too-many-branches,too-many-locals
def export_data(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Export data to a file.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                selected (dict): The selected obj from a listpad
                obj (dict[str, Any]): An object to extract data from
                extra_args (dict[str, Any]):
                    base_path (str): The path to the value to export
                    name_attr (str): The attribute containing the file name
                    raw_export (bool): Export without decoding data?
    """
    selected = deep_get(kwargs, DictPath("selected"))
    obj = deep_get(kwargs, DictPath("obj"))

    if selected is None and obj is None:
        return Retval.RETURNDONE

    extra_args = deep_get(kwargs, DictPath("_extra_args"), {})
    base_path = deep_get(extra_args, DictPath("base_path"))
    name_attr = deep_get(extra_args, DictPath("name_attr"), "value")
    raw_export = deep_get(extra_args, DictPath("raw_export"), False)

    value = None
    if selected is not None:
        value = getattr(selected, name_attr)
    if obj is not None:
        if value is not None:
            value = deep_get(obj, DictPath(f"{base_path}#{value}"))
        else:
            value = deep_get(obj, DictPath(f"{base_path}"))

    raw_filename = deep_get(kwargs, DictPath("result"))
    if "/" not in raw_filename:
        filename = FilePath(Path.cwd()).joinpath(raw_filename)
    else:
        filename = FilePath(raw_filename)

    vtype, value = decode_value(value)

    if not raw_export and vtype in ("string", "base64-utf-8"):
        value = cast(str, value)
        if not value.endswith("\n"):
            value += "\n"
    if vtype.startswith("string") or raw_export:
        secure_write_string(filename, value)
    elif vtype.startswith("base64-utf-8"):
        tmp = base64.b64decode(value).decode("utf-8")
        secure_write_string(filename, tmp)
    elif vtype.startswith(("base64-binary", "gzip")):
        tmp = base64.b64decode(value)
        secure_write_string(filename, tmp, write_mode="wb")
    else:
        errmsg = [
            [("export_data()", "emphasis"),
             (" could not identify vtype:", "error")],
            [("vtype = ", "default"),
             (f"{vtype}", "argument"),
             (" (expected one of ", "default"),
             ("base64-binary", "argument"),
             (", ", "default"),
             ("gzip", "argument"),
             (", ", "default"),
             ("string", "argument"),
             (", ", "default"),
             ("base64-utf-8", "argument"),
             (")", "default")],
        ]
        unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
        cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)

        curses_helper.alert(stdscr, message=f"Failed to export data; unsupported format {vtype}",
                            wait_for_keypress=True)
    return Retval.RETURNDONE


# pylint: disable-next=too-many-branches,too-many-statements
def generate_helptext(view: Union[str, tuple[str, str]], viewtype: str,
                      additional_helptexts: list[tuple[str, str]],
                      shortcuts: dict[str, dict[str, Any]]) -> list[dict]:
    """
    Generate helptext for a view.

        Parameters:
            view (str | (str, str)): The view to generate helptext for
            viewtype (str): The view type (infoview or listview)
            additional_helptexts ([(str, str)]): Additional helptext
            shortcuts (dict[str, dict[str, Any]]): The shorts + helptexts to add
        Returns:
            ([dict]): Formatted helptext suitable for passing to windowwidget()
    """
    helptext: list[tuple[str, str]] = []

    if viewtype == "infoview":
        helptext += helptexts.infoviewheader_part1

        if view not in infoviews:
            helptext += helptexts.infoviewheader_part2
            helptext += helptexts.spacer
            helptext += additional_helptexts
            return format_helptext(helptext)

        viewref = infoviews[cast(tuple[str, str], view)]

        if "listpad" in viewref:
            helptext += helptexts.togglewidth
            helptext += helptexts.infoviewheader_part2
            if deep_get(viewref, DictPath("activatedfun")) is not None:
                helptext.append(("[Enter]", "Open info page for selected resource"))

        if additional_helptexts:
            helptext += helptexts.spacer
            helptext += additional_helptexts

        if shortcuts:
            for _shortcut, data in shortcuts.items():
                tmp = deep_get(data, DictPath("helptext"))
                if tmp is not None:
                    helptext.append(tmp)

        if "listpad" in viewref:
            helptext += helptexts.spacer

            if not deep_get(viewref, DictPath("reversible"), True):
                helptext += helptexts.irreversiblelistmovement
            else:
                helptext += helptexts.listmovement
        elif "logpad" in viewref:
            helptext += helptexts.linewrap
            helptext += helptexts.toggleformatter
            helptext += helptexts.spacer
            helptext += helptexts.logmovement
    elif viewtype == "listview":
        helptext += helptexts.listviewheader

        viewref = views[cast(str, view)]

        if viewref["kind"] in infoviews:
            helptext += helptexts.openresource

        if "shortcuts" in viewref:
            for shortcut in deep_get(viewref, DictPath("shortcuts")):
                read_only = deep_get(viewref, DictPath(f"shortcuts#{shortcut}#read_only"), False)
                if read_only_mode and not read_only:
                    continue
                tmp = deep_get(viewref, DictPath(f"shortcuts#{shortcut}#helptext"))
                if tmp is not None:
                    helptext.append(tmp)
            helptext += helptexts.spacer

        if deep_get(viewref, DictPath("is_taggable"), True):
            helptext += helptexts.tagactions
            helptext += helptexts.spacer
            if deep_get(viewref, DictPath("labels")):
                helptext += helptexts.selectoractions
                helptext += helptexts.spacer

        helptext += helptexts.listmovement

    return format_helptext(helptext)


def process_selection(**kwargs: Any) -> dict[str, Any]:
    """
    Process selected values.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                process_selection (dict[str, Any]): A lookup table for substitution
                                                    the output from input selections.
    """
    process_selection_dict: dict[str, dict[str, dict[str, Any]]] = \
        deep_get(kwargs, DictPath("process_selection"), {})

    for i, selection in enumerate(deep_get(kwargs, DictPath("selection"), [])):
        string: str = themearray_to_string(selection)
        values: dict[str, Any] = {}
        if i in process_selection_dict:
            default = deep_get(process_selection_dict[i], DictPath("__default"), {})
            values = deep_get(process_selection_dict[i], DictPath(string), default)
        for key, value in values.items():
            deep_set(kwargs, DictPath(key), value)
    return kwargs


# noqa: E501 pylint: disable-next=too-many-locals,too-many-branches,too-many-statements,too-many-return-statements
def genericinfoloop(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Generic main loop for infoviews.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict): The object to operate on
                kind ((str, str)): The view to show
        Returns:
            (Retval): The return value
        Raises:
            ProgrammingError (view is invalid)
    """
    global initial_container  # pylint: disable=global-statement
    global executor  # pylint: disable=global-statement

    # Just in case there are leftover futures from other views
    executor.shutdown()
    executor = reexecutor.ReExecutor()

    obj: dict[str, Any] = deep_get(kwargs, DictPath("obj"))
    view: tuple[str, str] = deep_get(kwargs, DictPath("kind"))

    # If we are using the logpad this can be used to format the data
    formatter_path = deep_get(kwargs, DictPath("formatter_path"))
    # formatter_path has precedence over formatter, to allow ConfigMaps to work properly
    formatter = deep_get(kwargs, DictPath("formatter"))
    formatter_args: dict[str, Any] = deep_get(kwargs, DictPath("formatter_args"), {})
    if formatter_path is not None:
        formatter = deep_get(obj, DictPath(formatter_path))
    elif isinstance(formatter, str):
        formatter = check_allowlist(formatter_allowlist, "formatter_allowlist", formatter)
    obj_path = deep_get(kwargs, DictPath("obj_path"))
    title = None
    if obj_path is not None:
        title_path = deep_get(kwargs, DictPath("title_path"))
        if title_path is not None:
            title = deep_get(obj, DictPath(title_path))
        if obj_path != "":
            obj = deep_get(obj, DictPath(obj_path))
        else:
            obj = [obj]

    uip = UIProps(stdscr)

    if view not in infoviews:
        return Retval.NOMATCH

    viewref = infoviews[view]

    objgetter = deep_get(viewref, DictPath("objgetter"))
    if objgetter is not None:
        obj = objgetter(obj)
        if obj is None or not obj:
            return Retval.NOMATCH

    # XXX: For now we do not support custom fields for the lists on the info pages
    field_indexes = deep_get(viewref, DictPath("field_indexes"), {})
    field_index = "Normal"

    field_denylist = deep_get(viewref, DictPath("field_denylist"), [])
    fieldgenerator_args = {
        "field_index": field_index,
        "field_indexes": field_indexes,
        "fields": deep_get(viewref, DictPath("fields")),
        "denylist": field_denylist,
    }
    field_dict, field_names, sortcolumn, sortorder_reverse = \
        generators.fieldgenerator(view=view,
                                  selected_namespace=selected_namespace,
                                  **fieldgenerator_args)

    windowheader = deep_get(viewref, DictPath("windowheader"), f"{view[0]} Info")

    # These values can be toggled, so we need to read them first
    infoview_args = copy.deepcopy(viewref.get("infoview_args", {}))

    # These are used for anything that uses ResourceViewer
    if title is not None:
        windowheader = title
    elif "title" in kwargs:
        windowheader = deep_get(kwargs, DictPath("title"))
    elif "title_path" in kwargs:
        windowheader = deep_get(obj, DictPath(title_path), windowheader)
    else:
        kind = deep_get(viewref, DictPath("kind"))
        if kind is not None and kind[1]:
            windowheader = f"{windowheader} ({kind[1]})"

    sortorder_reverse = deep_get(viewref, DictPath("sortorder_reverse"), False)
    reversible = deep_get(viewref, DictPath("reversible"), True)
    activatedfun = deep_get(viewref, DictPath("activatedfun"))
    on_activation = deep_get(viewref, DictPath("listpad#on_activation"), {})
    labels = deep_get(viewref, DictPath("labels"))
    annotations = deep_get(viewref, DictPath("annotations"))
    extraref = deep_get(viewref, DictPath("extraref"))
    data: Optional[dict] = None
    if deep_get(viewref, DictPath("data"), False):
        data = obj
    viewoverride = deep_get(viewref, DictPath("viewoverride"), view)
    infopadheight = 0
    if "infopad" in viewref:
        if "name_path" in viewref:
            name_path = deep_get(viewref, DictPath("name_path"))
        else:
            name_path = "metadata#name"
        if "namespace_path" in viewref:
            namespace_path = deep_get(viewref, DictPath("namespace_path"))
        else:
            namespace_path = "metadata#namespace"
        if "creation_timestamp_path" in viewref:
            creation_timestamp_path = deep_get(viewref, DictPath("creation_timestamp_path"))
        else:
            creation_timestamp_path = "metadata#creationTimestamp"

        # Number of fields added conditionally
        if name_path is not None and name_path and deep_get(obj, DictPath(name_path)) is not None:
            infopadheight += 1
        if namespace_path is not None and namespace_path \
                and deep_get(obj, DictPath(namespace_path)) is not None:
            infopadheight += 1
        if creation_timestamp_path is not None and creation_timestamp_path \
                and deep_get(obj, DictPath(creation_timestamp_path)) is not None:
            infopadheight += 1
        # Number of custom fields
        infopadheight += len(deep_get(viewref, DictPath("infopad"), {}))
        # If we *only* have an infopad, then it should cover at least the entire screen;
        # if not it should be as big as needed; it does not really matter if we allocate an
        # infopad larger than the screen, but this should be correct.
        if "listpad" not in viewref and "logpad" not in viewref:
            maxyx = stdscr.getmaxyx()
            infopadheight = max(infopadheight, maxyx[0] - 3)

    shortcuts = copy.deepcopy(deep_get(viewref, DictPath("shortcuts"), {}))

    # Shortcuts
    # Always include the shortcut for namespaces, unless overriden
    # or the namespace_path returns None
    #
    # An override is necessary if metadata#namespace is not the correct path
    # or some other changes are necessary
    if deep_get(shortcuts, DictPath("Namespace")) is None \
            and deep_get(obj, DictPath(namespace_path)) is not None:
        shortcuts["Namespace"] = {
            "shortcut": [ord("N")],
            "read_only": True,
            "helptext": ("[Shift] + N", "Open info page for Namespace"),
            "call": resourceinfodispatch,
            "kind": ("Namespace", ""),
            "name_path": namespace_path,
        }

    # Always include the shortcut for security contexts,
    # unless the path returns None
    if "securityContext" in deep_get(obj, DictPath("spec"), {}) \
            or "securityContext" in deep_get(obj, DictPath("spec#template#spec"), {}):
        shortcuts["Show Security Context"] = {
            "shortcut": [ord("x")],
            "read_only": True,
            "helptext": ("X", "Show security context information"),
            "widget": "windowwidget",
            "title": "Security Context Policies:",
            "headers": ["Policy:", "Value:"],
            "itemgetter": itemgetters.get_security_context,
            "formatting": [ThemeAttr("windowwidget", "default"),
                           ThemeAttr("windowwidget", "highlight")],
            "force_update": False,
        }

    # Always include the shortcut for conditions,
    # unless the path returns None
    if "conditions" in deep_get(obj, DictPath("status"), {}):
        shortcuts["Show Resource Conditions"] = {
            "shortcut": [ord("c")],
            "read_only": True,
            "helptext": ("C", "Show resource conditions"),
            "widget": "windowwidget",
            "title": "Conditions:",
            "headers": ["Type:", "Status:", "Last Probe:", "Last Transition:", "Message:"],
            "itemgetter": itemgetters.get_conditions,
            "force_update": False,
        }

    # Should log messages be prefixed with severity (when set)?
    severity_prefixes: bool = deep_get(cmtlib.cmtconfig, DictPath("Log#severity_prefixes"), False)

    # Note: This cannot be moved to populate_views() since there are shortcuts that are
    # populated conditionally.
    if deep_get(cmtlib.cmtconfig, DictPath("Internal#sanity_check_views"), False):
        _shortcuts: dict[int, str] = {}
        for shortcut in shortcuts:
            _shortcut = shortcuts[shortcut].get("shortcut", [])
            for _sc in _shortcut:
                if _sc in _shortcuts:
                    errmsg = [
                        [("Infoview ", "error"),
                         (f"{view}", "argument"),
                         (": The same keypress (", "error"),
                         (f"{_sc}", "argument"),
                         (") is used for both “", "error"),
                         (f"{shortcut}", "argument"),
                         ("“ and “", "error"),
                         (f"{_shortcuts[_sc]}", "argument"),
                         ("“; aborting.", "error")],
                    ]
                    unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
                    cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
                    sys.exit(unformatted_msg)
                else:
                    _shortcuts[_sc] = shortcut

    # Conditional helptexts
    additional_helptexts = []
    if deep_get(obj, DictPath(labels)) is not None:
        additional_helptexts += helptexts.labels
    if deep_get(obj, DictPath(annotations)) is not None:
        additional_helptexts += helptexts.annotations

    helptext = generate_helptext(view, "infoview", additional_helptexts, shortcuts=shortcuts)

    uip.init_window(field_dict=field_dict, windowheader=windowheader, helptext=helptext,
                    view=viewoverride, sortcolumn=sortcolumn, sortorder_reverse=sortorder_reverse,
                    reversible=reversible, activatedfun=activatedfun, on_activation=on_activation,
                    extraref=extraref, data=obj)

    # For generic information
    if infopadheight:
        uip.init_infopad(height=infopadheight, width=-1, ypos=1, xpos=1,
                         labels=deep_get(obj, DictPath(labels)),
                         annotations=deep_get(obj, DictPath(annotations)))

    # The statusbar is always located at the bottom of the screen and fills the entire width
    uip.init_statusbar()

    # For lists
    if deep_get(viewref, DictPath("listpad"), {}):
        if infopadheight == 0:
            uip.init_listpad(listheight=1, width=-1, ypos=1, xpos=1)
        else:
            uip.init_listpad(listheight=1, width=-1, ypos=infopadheight + 2, xpos=1)

    # For log pads; we cannot have both a logpad and a listpad simultaneously;
    # at least not with the current implementation
    if deep_get(viewref, DictPath("logpad")) is not None:
        if uip.listpad is not None:
            raise ValueError("We cannot have listpad and logpad simultaneously")

        show_timestamps: bool = deep_get_with_fallback(viewref, [DictPath("logpad#timestamps"),
                                                                 DictPath("timestamps")], True)
        uip.toggle_timestamps(show_timestamps)
        if infopadheight == 0:
            uip.init_logpad(width=-1, ypos=1, xpos=1, timestamps=show_timestamps)
        else:
            uip.init_logpad(width=-1, ypos=infopadheight + 2, xpos=1, timestamps=show_timestamps)

    wrap_lines: bool = False
    raw_output: bool = False

    first_fetch: bool = True

    # pylint: disable-next=too-many-nested-blocks
    while True:
        # Populate useful variables that can be used in the statusbar
        if formatter:
            deep_set(infoview_args, DictPath("formatter"), formatter.__name__)

        # Output infopad and listpad if we have one
        if uip.is_update_triggered():
            # The data in some fields might become shorter, so we need to trigger a clear
            if uip.infopad is not None:
                uip.infopad.erase()
            if uip.statusbar is not None:
                uip.statusbar.erase()

            statusarray1: list[Union[ThemeRef, ThemeStr]] = [
                ThemeStr("Fields: ", ThemeAttr("statusbar", "infoheader")),
                ThemeStr(field_index, ThemeAttr("statusbar", "highlight"))
            ]
            statusarray2: list[Union[ThemeRef, ThemeStr]] = []

            for status_data in deep_get(viewref, DictPath("statusmsg"), []):
                if len(status_data) == 2:
                    key, path = status_data
                    default_status = "<unset>"
                else:
                    key, path, default_status = status_data

                # If path is a list the first item tells what source to use and the second
                # what path to fetch the value from
                src_obj: dict[str, Any] = infoview_args
                if isinstance(path, list):
                    if path[0] == "config":
                        src_obj = cmtlib.cmtconfig
                    # elif path[0] == "obj":
                    #     value_path = obj
                    elif path[0] == "var":
                        src_obj = infoview_args
                    value_path = DictPath(path[1])
                else:
                    value_path = DictPath(path)

                value = str(deep_get(src_obj, value_path, default_status))
                if statusarray2:
                    statusarray2 += [ThemeRef("separators", "statusbar")]
                statusarray2 += [
                    ThemeStr(key, ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(value, ThemeAttr("statusbar", "default")),
                ]

            uip.addthemearray(uip.statusbar, statusarray1, y=0, x=0)
            uip.addthemearray(uip.statusbar, statusarray2, y=1, x=0)

            # Refresh obj whenever we reload,
            # unless this is a special view or "no_reload_on_refresh" is true
            if not view[0].startswith("__") \
                    and not deep_get(viewref, DictPath("no_reload_on_refresh"), False):
                obj_name = deep_get(obj, DictPath("metadata#name"))
                obj_namespace = deep_get(obj, DictPath("metadata#namespace"))
                obj = kh.get_ref_by_kind_name_namespace(view, obj_name, obj_namespace,
                                                        resource_cache=kh_cache)

                if obj is None:
                    title = "Error!"
                    errormsg = [{
                        "lineattrs": 0,
                        "columns": [[ThemeStr("Resource not available; "
                                              "it may have been deleted",
                                              ThemeAttr("types", "generic"))]],
                    }]
                    curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                               uip.maxy // 2, uip.maxx // 2, errormsg,
                                               title=title, cursor=False)
                    return Retval.RETURNDONE

            uip.update_window()

            if uip.infopad is not None:
                y = 0
                if name_path is not None and name_path:
                    fieldarray: list[Union[ThemeRef, ThemeStr]] = [
                        ThemeStr("Name:", ThemeAttr("main", "infoheader")),
                        ThemeStr(f" {deep_get(obj, DictPath(name_path))}",
                                 ThemeAttr("types", "generic"))
                    ]
                    uip.addthemearray(uip.infopad, fieldarray, y=y, x=0)
                    y += 1

                if namespace_path is not None and namespace_path \
                        and deep_get(obj, DictPath(namespace_path)) is not None:
                    fieldarray = [
                        ThemeStr("N", ThemeAttr("main", "infoheader_shortcut")),
                        ThemeStr("amespace:", ThemeAttr("main", "infoheader")),
                        ThemeStr(f" {deep_get(obj, DictPath(namespace_path))}",
                                 ThemeAttr("types", "namespace"))
                    ]
                    uip.addthemearray(uip.infopad, fieldarray, y=y, x=0)
                    y += 1

                for key, value in deep_get(viewref, DictPath("infopad"), {}).items():
                    # If there is a header field, this is from a view file;
                    # otherwise it is an old-style field
                    fieldarray = []
                    header = deep_get(value, DictPath("header"))

                    if header is not None:
                        fieldarray += header
                        # Only add stuff if there's a path
                        if "path" in value or "paths" in value:
                            # Use generic_infogetter for this
                            data = infogetters.get_obj(obj, field_dict={key: value},
                                                       field_names=[key],
                                                       field_index="Normal",
                                                       view="", filters={},
                                                       kubernetes_helper=kh,
                                                       kh_cache=kh_cache)
                            _formatter = {key: generators.get_formatter(value)}
                            _generator = deep_get(_formatter, DictPath(f"{key}#generator"))
                            if _generator is not None:
                                ralign = deep_get(_formatter, DictPath(f"{key}#ralign"))
                                formatting = deep_get(_formatter, DictPath(f"{key}#formatting"))
                                fieldarray += [ThemeStr(" ", ThemeAttr("types", "generic"))]
                                fieldarray += _generator(data, key, fieldlen=0, pad=False,
                                                         ralign=ralign,
                                                         selected=False, **formatting)
                        uip.addthemearray(uip.infopad, fieldarray, y=y, x=0)

                        y += 1
                        continue

                if creation_timestamp_path is not None \
                        and creation_timestamp_path \
                        and deep_get(obj, DictPath(creation_timestamp_path)) is not None:
                    timestamp: str = deep_get(obj, DictPath(creation_timestamp_path))

                    if timestamp is None:
                        field = [ThemeRef("strings", "unset")]
                    elif isinstance(timestamp, datetime):
                        field = format_timestamp(timestamp)
                    else:
                        timestamp = timestamp_to_datetime(timestamp)
                        field = format_timestamp(timestamp, localtimezone=True)
                    fieldarray = [
                        ThemeStr("Created: ", ThemeAttr("main", "infoheader")),
                    ]
                    fieldarray += field
                    uip.addthemearray(uip.infopad, fieldarray, y=y, x=0)
            uip.refresh_window()
            uip.refresh_infopad()
            curses.doupdate()

            vlist: list[dict[str, Any]] = []

            if uip.listpad is not None:
                listgetter = deep_get(viewref, DictPath("listpad#listgetter"))
                listgetter_args = deep_get(viewref, DictPath("listpad#listgetter_args"), {})
                _kind = deep_get(listgetter_args, DictPath("_kind"))
                _kind_path = deep_get(listgetter_args, DictPath("_kind_path"))
                _api_family = deep_get(listgetter_args, DictPath("_api_family"))
                _api_family_path = deep_get(listgetter_args, DictPath("_api_family_path"))
                _label_selector_path = deep_get(listgetter_args, DictPath("_label_selector_path"))
                _label_selector_key = deep_get(listgetter_args, DictPath("_label_selector_key"), "")
                _label_selector_key_values = \
                    deep_get(listgetter_args, DictPath("_label_selector_key_values"))
                if _label_selector_path is not None:
                    if isinstance(_label_selector_path, str):
                        _label_selector_path = [DictPath(_label_selector_path)]
                    _label_selector_data = deep_get_with_fallback(obj, _label_selector_path)
                    if isinstance(_label_selector_data, str):
                        if _label_selector_key:
                            listgetter_args["label_selector"] = \
                                make_label_selector({_label_selector_key: _label_selector_data})
                        else:
                            listgetter_args["label_selector"] = _label_selector_data
                    else:
                        listgetter_args["label_selector"] = \
                            make_label_selector(_label_selector_data)
                elif _label_selector_key_values is not None:
                    label_selectors = {}
                    for label_key, label_value in _label_selector_key_values:
                        if isinstance(label_value, str):
                            label_selectors[label_key] = label_value
                        elif isinstance(label_value, list):
                            label_selectors[label_key] = deep_get_with_fallback(obj, label_value)
                    listgetter_args["label_selector"] = make_label_selector(label_selectors)
                if not deep_get(listgetter_args, DictPath("label_selector"), "") \
                        and deep_get(listgetter_args, DictPath("_none_on_empty_selector"), False):
                    listgetter = listgetters.listgetter_noop
                _field_selector = deep_get(listgetter_args, DictPath("_field_selector"), {})
                if _field_selector:
                    field_selectors = {}
                    for field_key, field_value in _field_selector.items():
                        if isinstance(field_value, list):
                            field_selectors[field_key] = deep_get_with_fallback(obj, field_value)
                        else:
                            field_selectors[field_key] = field_value
                    listgetter_args["field_selector"] = make_label_selector(field_selectors)
                if _kind is None:
                    _kind = deep_get(obj, DictPath(_kind_path))
                if _api_family is None:
                    _api_family = deep_get(obj, DictPath(_api_family_path), "")
                if _kind is not None:
                    _kind = guess_kind((_kind, _api_family))
                _namespace = deep_get(listgetter_args, DictPath("namespace"))
                _namespace_path = deep_get(listgetter_args, DictPath("_namespace_path"), "")
                if _namespace is None:
                    _namespace = deep_get(obj, DictPath(_namespace_path), "")
                listgetter_args["kind"] = _kind
                listgetter_args["namespace"] = _namespace
                if "_pass_obj" in listgetter_args:
                    listgetter_args["_obj"] = obj

                uip.refresh_window()
                uip.refresh_statusbar()
                if first_fetch or uip.update_forced:
                    fetch_message = deep_get(listgetter_args, DictPath("message"), "Fetching data")
                    _win = curses_helper.notice(uip.listpad, message=fetch_message)
                    curses.doupdate()
                    if "kubernetes_helper" not in listgetter_args:
                        listgetter_args["kubernetes_helper"] = kh
                        listgetter_args["kh_cache"] = kh_cache
                    # pylint: disable-next=comparison-with-callable
                    if listgetter == listgetters.generic_listgetter:
                        vlist, _status = listgetter(**listgetter_args)
                    else:
                        vlist, _status = listgetter(obj, **listgetter_args)
                    first_fetch = False
                    uip.update_forced = False

                infogetter = deep_get(viewref, DictPath("listpad#infogetter"))
                infogetter_filters = deep_get(viewref, DictPath("listpad#infogetter_filters"), None)
                infogetter_args = deep_get(viewref, DictPath("listpad#infogetter_args"), {})

                filters = None
                if infogetter_filters is not None:
                    filters = []
                    if infogetter_filters is not None:
                        for key, value in infogetter_filters:
                            filters.append((ast.literal_eval(key), ast.literal_eval(value)))

                infogetter_args.pop("_vlist", None)
                infogetter_args["_vlist"] = vlist

                infogetter_args.pop("_field_index", None)
                infogetter_args["_field_index"] = field_index

                infogetter_args.pop("_field_names", None)
                infogetter_args["_field_names"] = field_names

                infogetter_args.pop("_field_dict", None)
                infogetter_args["_field_dict"] = field_dict

                infogetter_args.pop("_filters", None)
                infogetter_args["_filters"] = filters

                infogetter_args.pop("_obj", None)
                infogetter_args["_obj"] = obj

                if deep_get(infogetter_args, DictPath("_pass_caller_obj")):
                    infogetter_args["caller_obj"] = copy.deepcopy(obj)
                else:
                    infogetter_args["caller_obj"] = {}

                extra_data = {}
                for key, value in deep_get(infogetter_args, DictPath("_extra_data"), {}).items():
                    if isinstance(value, list):
                        tmp = deep_get_with_fallback(obj, value)
                        extra_data[key] = tmp
                    else:
                        extra_data[key] = value
                infogetter_args["extra_data"] = extra_data
                infogetter_args["kubernetes_helper"] = kh
                infogetter_args["kh_cache"] = kh_cache
                info = infogetter(**infogetter_args)

                uip.update_info(info)
                linelen = update_field_widths(field_dict, field_names, uip.info)
                uip.resize_listpad(linelen)
            elif uip.logpad is not None:
                decoded_obj: str = ""

                if deep_get(infoview_args, DictPath("decoder#override_decoder")):
                    decoder = deep_get(infoview_args, DictPath("decoder#decoder"))
                    if decoder is not None:
                        try:
                            decoded_obj = \
                                copy.deepcopy(base64.b64decode(cast(str, obj)).decode("utf-8"))
                        except (binascii.Error, TypeError, UnicodeDecodeError):
                            decoded_obj = cast(str, obj)
                else:
                    decoded_obj = cast(str, obj)

                if formatter is not None and decoded_obj is not None:
                    formatter_args = deep_get(infoview_args, DictPath("formatter_args"), {})
                    formatted_obj = formatter(decoded_obj, raw=raw_output, **formatter_args)
                else:
                    formatted_obj = decoded_obj

                infogetter = deep_get(viewref, DictPath("logpad#infogetter"))
                infogetter_args = deep_get(viewref, DictPath("logpad#infogetter_args"), {})
                infogetter_args["_show_raw"] = raw_output
                infogetter_args["severity_prefixes"] = severity_prefixes

                if infogetter is not None:
                    tmp = infogetter(formatted_obj, **infogetter_args)
                    timestamps: list[datetime] = []
                    facilities: list[Union[str, tuple[str, str]]] = []
                    severities: list[LogLevel] = []
                    if isinstance(tmp, tuple):
                        timestamps, facilities, severities, messages = tmp
                    else:
                        messages = tmp
                        severity_prefixes = False
                    uip.update_log_info(timestamps, facilities, severities, messages)

        # Output listpad if we have one
        remember_uid = uip.remember_uid
        uip.remember_uid = False
        if uip.listpad is not None:
            uip.update_sorted_list()
            if not uip.is_list_regenerated():
                generate_list_header(uip, field_dict)
                # Output the visible part of the list
                uip.selected = None
                for y in range(uip.yoffset,
                               min(uip.yoffset + uip.mincurypos + uip.maxcurypos + 1, uip.listlen)):
                    item = uip.sorted_list[y]
                    uip.select_if_y(y, item)
                    generate_list_row(uip, item, field_dict, y - uip.yoffset,
                                      uip.is_selected(item))
                uip.list_needs_regeneration(False)
        uip.remember_uid = remember_uid

        # Output logpad if we have one
        if uip.logpad is not None and uip.refresh:
            uip.logpad.erase()
            # This is needed in case we get a resize event or toggle borders
            uip.resize_logpad(uip.maxy - uip.logpadypos - 2, 0)
            maxx = 0
            yadd = 0

            tscount = 0
            for y in range(0, min(uip.logpadheight, len(messages))):
                facility: list[Union[ThemeRef, ThemeStr]] = []
                if uip.yoffset + y < len(facilities):
                    fac = facilities[uip.yoffset + y]

                    if fac:
                        if isinstance(fac, tuple):
                            fac0 = fac[0]
                            fac1 = fac[1]
                        else:
                            fac0 = fac
                            fac1 = ""

                        facility_prefix_len = len(ThemeRef("separators", "facility_prefix"))
                        facility_ext_prefix_len = \
                            len(ThemeRef("separators", "facility_extended_prefix"))
                        facility_suffix_len = len(ThemeRef("separators", "facility_suffix"))
                        facility_ext_suffix_len = \
                            len(ThemeRef("separators", "facility_extended_suffix"))
                        if not fac0.strip():

                            facility += [ThemeStr("".ljust(facility_prefix_len),
                                                  ThemeAttr("logview", "facility")),
                                         ThemeStr(fac0, ThemeAttr("logview", "facility")),
                                         ThemeStr("".ljust(facility_suffix_len),
                                                  ThemeAttr("logview", "facility"))]
                        else:
                            facility += [ThemeRef("separators", "facility_prefix"),
                                         ThemeStr(fac0, ThemeAttr("logview", "facility")),
                                         ThemeRef("separators", "facility_suffix")]
                        if fac1:
                            if not fac1.strip():
                                facility += \
                                    [ThemeStr("".ljust(facility_ext_prefix_len),
                                              ThemeAttr("logview", "facility")),
                                     ThemeStr(fac1, ThemeAttr("types", "facility_extended")),
                                     ThemeStr("".ljust(facility_ext_suffix_len),
                                              ThemeAttr("logview", "facility"))]
                            else:
                                facility += \
                                    [ThemeRef("separators", "facility_extended_prefix"),
                                     ThemeStr(fac1, ThemeAttr("types", "facility_extended")),
                                     ThemeRef("separators", "facility_extended_suffix")]
                        facility += [ThemeRef("separators", "facility_padding")]

                if uip.yoffset + y >= len(timestamps) \
                        or timestamps[uip.yoffset + y] == none_timestamp():
                    timestamp = "".ljust(uip.tspadwidth)
                else:
                    timestamp = str(timestamps[uip.yoffset + y]).ljust(uip.tspadwidth)
                    tscount += 1
                tsthemearray: list[Union[ThemeRef, ThemeStr]] = \
                    [ThemeStr(timestamp, ThemeAttr("logview", "timestamp"))]

                if uip.yoffset + y >= len(severities):
                    severity = LogLevel.INFO
                else:
                    severity = severities[uip.yoffset + y]

                message = copy.copy(messages[uip.yoffset + y])
                if isinstance(message, str):
                    message = [ThemeStr(message, color_log_severity(severity))]
                if severity_prefixes:
                    severitystr = loglevel_to_name(severity)
                    if uip.yoffset + y < len(timestamps) \
                            and timestamps[uip.yoffset + y] != none_timestamp():
                        message.insert(0, ThemeStr(f"{severitystr}: ",
                                                   color_log_severity(severity)))
                    else:
                        message.insert(0, ThemeStr("".ljust(len(severitystr) + 2),
                                                   color_log_severity(severity)))
                if uip.search_matches:
                    line_match = uip.yoffset + y in uip.search_matches
                    match_prefix: list[Union[ThemeRef, ThemeStr]] = \
                        [ThemeRef("separators", "matchbullet")]
                    if not line_match:
                        match_prefix = \
                            [ThemeStr("".ljust(len(themearray_to_string(match_prefix))),
                                      ThemeAttr("types", "generic"))]
                    message = match_prefix + message
                if wrap_lines:
                    sideadjust = 0
                    if not uip.borders:
                        sideadjust = 2
                    maxwidth = uip.logpadminwidth + sideadjust
                else:
                    maxwidth = -1
                if facility is not None:
                    message = facility + message
                untruncated_len = themearray_len(message)
                max_untruncated_len = 16384
                if wrap_lines or untruncated_len < max_untruncated_len:
                    lines_ = themearray_wrap_line(message, maxwidth,
                                                  wrap_marker=(uip.borders or get_mousemask() != 0))
                else:
                    lines_ = [themearray_truncate(message, max_untruncated_len - 1)]
                    severity_name = f"severity_{loglevel_to_name(LogLevel.ERR).lower()}"
                    lines_.append([ThemeStr(f"Line too long ({untruncated_len} bytes); "
                                            f"truncated to {max_untruncated_len} bytes "
                                            "(Use line wrapping to see the entire message)",
                                            ThemeAttr("logview", severity_name))])

                for i, _line in enumerate(lines_):
                    if y + yadd + i >= uip.logpadheight:
                        break
                    if i == 0 and timestamps and tscount:
                        uip.addthemearray(uip.tspad, tsthemearray, y=y + yadd, x=0)
                    _ypos, xpos = uip.addthemearray(uip.logpad, _line, y=y + yadd + i, x=0)
                    maxx = max(maxx, xpos)
                yadd += i
            uip.resize_logpad(-1, maxx)
            uip.update_window()

        uip.refresh_window()
        uip.refresh_infopad()
        uip.refresh_listpad()
        uip.refresh_logpad()
        uip.refresh_statusbar()
        curses.doupdate()
        uip.refresh = False

        # XXX: This should be done by the same code path as a regular activation;
        #      this solution is too ugly for words.
        if initial_container is not None:
            match = None

            if uip.info:
                match_count = 0

                obj_path = deep_get(viewref, DictPath("listpad#on_activation#obj_path"))
                for item in uip.info:
                    # If we are dealing with a config map we are interested in non-binary types
                    # If we are dealing with a pod we are interested in containers
                    if hasattr(item, "type") \
                            and item.type in ("[container]", "[init_container]", "[configmap]"):
                        name = item.ref["name"]
                        ikind = item.type
                    elif view == ("ConfigMap", "") \
                            and item.type in (rtype[4] for rtype in formatters.cmdata_format):
                        name = item.data
                        ikind = deep_get(viewref, DictPath("listpad#on_activation#kind"), "")
                        if isinstance(ikind, str):
                            iapi_family = \
                                deep_get(viewref, DictPath("listpad#on_activation#api_family"), "")
                            ikind = guess_kind((ikind, iapi_family))
                    else:
                        continue

                    # If name is not set we skip
                    if name is None:
                        continue

                    # If we have an exact match we do not care about partial matches
                    if name == initial_container:
                        if view == ("ConfigMap", ""):
                            match = item.data
                        else:
                            match = item.ref
                        match_count = 1
                        break

                    if name.startswith(initial_container):
                        # Since the exact match might occur later than the partial we cannot abort
                        # on partial matches; instead just save the match and continue searching.
                        # If we get more than one partial match we ignore the partial matches.
                        if match_count == 0:
                            if view == ("ConfigMap", ""):
                                match = item.data
                            else:
                                match = item.ref
                        match_count += 1

                initial_container = None

                if match is not None and match_count == 1:
                    on_activation_args = {}
                    formatter_path = deep_get(viewref,
                                              DictPath("listpad#on_activation#formatter_path"))
                    if deep_get(viewref,
                                DictPath("listpad#on_activation#formatter"), "") == "identify":
                        formatter = formatters.identify_formatter(None, kind=view,
                                                                  obj=obj, path=match)
                        on_activation_args["formatter"] = formatter
                    else:
                        formatter = deep_get(viewref, DictPath("listpad#on_activation#formatter"))
                        formatter_path = deep_get(viewref,
                                                  DictPath("listpad#on_activation#formatter_path"))
                        on_activation_args["formatter"] = formatter
                        on_activation_args["formatter_path"] = formatter_path
                    retval: Union[Retval, None] = None
                    if view == ("ConfigMap", "") and callable(uip.activatedfun):
                        retval = uip.activatedfun(uip.stdscr,
                                                  obj=deep_get(obj, DictPath(f"data#{match}"), ""),
                                                  kind=ikind, info=None, title=name,
                                                  **on_activation_args)
                    elif callable(uip.activatedfun):
                        retval = uip.activatedfun(uip.stdscr, obj=match, kind=ikind, info=obj,
                                                  **on_activation_args)
                    if retval == Retval.RETURNFULL:
                        return retval
                    uip.update_forced = True
                    uip.refresh_all()
                    uip.force_update()
                    continue

        uip.stdscr.timeout(100)
        c = uip.stdscr.getch()
        retval: Retval = uip.generic_keycheck(c)

        if retval == Retval.MATCH:
            continue
        if retval == Retval.RETURNONE:
            return Retval.RETURNDONE
        if retval == Retval.RETURNFULL:
            return retval

        if c == curses.KEY_F2:
            if (retval := selectwindow(uip)) == Retval.RETURNFULL:
                return retval
            uip.refresh_all()
            continue
        if c == curses.KEY_F3:
            if (retval := selectwindow(uip, refresh_apis=True)) == Retval.RETURNFULL:
                return retval
            uip.refresh_all()
            continue
        if c == ord("^"):
            retval = listviewdispatch(uip.stdscr, obj={}, kind=kind, root=True)
            if retval == Retval.RETURNFULL:
                return retval
            continue
        if c == ord("B"):
            uip.toggle_borders()
            uip.refresh_all()
            uip.update_forced = True
            uip.force_update()
            continue
        if c == ord("W") and uip.listpad is not None:
            if not field_indexes:
                continue

            _list = list(field_indexes.keys())
            _index = _list.index(field_index)
            field_index = _list[(_index + 1) % len(field_indexes)]

            fieldgenerator_args = {
                "field_index": field_index,
                "field_indexes": field_indexes,
                "fields": deep_get(viewref, DictPath("fields")),
                "denylist": [],
            }
            field_dict, field_names, sortcolumn, sortorder_reverse = \
                generators.fieldgenerator(view=view,
                                          selected_namespace=selected_namespace,
                                          **fieldgenerator_args)

            uip.reinit_window(field_dict=field_dict, sortcolumn=sortcolumn)
            uip.resize_listpad(width=-1)
            uip.refresh_all()
            uip.update_forced = True
            uip.force_update()
            continue
        if c == ord("R") and uip.logpad is not None:
            raw_output = not raw_output
            uip.refresh_all()
            uip.force_update()
            continue
        if c == ord("W") and uip.logpad is not None:
            wrap_lines = not wrap_lines
            uip.refresh_all()
            uip.force_update()
            continue
        if c == ord("S") and uip.logpad is not None and severities:
            severity_prefixes = not severity_prefixes
            uip.refresh_all()
            uip.force_update()
            continue
        if c == ord("T") and uip.logpad is not None and timestamps:
            uip.toggle_timestamps()
            uip.refresh_all()
            uip.force_update()
            continue

        for _key, sc_value in shortcuts.items():
            if (shortcut_keys := deep_get(sc_value, DictPath("shortcut"))) is None:
                continue

            if c not in shortcut_keys:
                continue

            widget: str = deep_get(sc_value, DictPath("widget"), "")
            force_update: Optional[bool] = deep_get(sc_value, DictPath("force_update"))
            tmpselection = None
            if widget == "windowwidget":
                w_title = deep_get(sc_value, DictPath("title"), "")
                w_headers = deep_get(sc_value, DictPath("headers"))
                if (w_itemgetter := deep_get(sc_value, DictPath("itemgetter"))) is None:
                    continue
                w_itemgetter_args = deep_get(sc_value, DictPath("itemgetter_args"), {})
                w_itemgetter_args["kubernetes_helper"] = kh
                w_itemgetter_args["kh_cache"] = kh_cache
                w_itemgetter_src = deep_get(w_itemgetter_args, DictPath("source"), "object")
                w_selectable = deep_get(sc_value, DictPath("selectable"), False)
                # w_kind = deep_get(sc_value, DictPath("kind"), view)
                if "_slow_task_msg" in w_itemgetter_args:
                    _w_win = curses_helper.notice(uip.stdscr,
                                                  message=deep_get(w_itemgetter_args,
                                                                   DictPath("_slow_task_msg")))

                if w_itemgetter_src == "selected":
                    selected = uip.get_selected()
                    if selected is not None:
                        w_ref = getattr(selected, "ref", None)
                        if w_ref is not None:
                            if "ref" in w_ref:
                                w_items = w_itemgetter(w_ref["ref"], **w_itemgetter_args)
                            else:
                                w_items = w_itemgetter(w_ref, **w_itemgetter_args)
                else:
                    w_items = w_itemgetter(obj, **w_itemgetter_args)

                # If the first element is an integer we assume that we've been provided
                # a pre-formatted list. Otherwise we apply formatting if available.
                # If not available we try to provide some sensible defaults.
                if w_items is not None and w_items \
                        and (isinstance(w_items[0], dict)
                             or (isinstance(w_items[0], (list, tuple))
                                 # pylint: disable-next=unidiomatic-typecheck
                                 and type(w_items[0][0]) != int)):  # noqa: E721
                    tmp_items = []
                    w_formatting = deep_get(sc_value, DictPath("formatting"),
                                            [ThemeAttr("windowwidget", "default")])
                    lineattrs = WidgetLineAttrs.NORMAL
                    # w_item is a line
                    for w_item in w_items:
                        ref = None
                        if isinstance(w_item, dict):
                            ref = deep_get(w_item, DictPath("ref"))
                            w_item = deep_get(w_item, DictPath("fields"))
                        # w_item[i] is a column
                        tmp = []
                        for i, column in enumerate(w_item):
                            tmp_formatting = w_formatting[min(i, len(w_formatting) - 1)]
                            if isinstance(tmp_formatting, list):
                                formatting = ThemeAttr(tmp_formatting[0], tmp_formatting[1])
                            else:
                                formatting = tmp_formatting
                            tmp.append([ThemeStr(column, formatting)])

                        tmp_items.append({
                            "lineattrs": lineattrs,
                            "columns": tmp,
                            "retval": ref,
                        })
                    w_items = tmp_items

                if w_items is not None and w_items:
                    w_sortcolumn = deep_get(sc_value, DictPath("sortcolumn"))
                    tmpselection = \
                        curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                   uip.maxy // 2, uip.maxx // 2,
                                                   items=w_items, headers=w_headers,
                                                   title=w_title, cursor=w_selectable,
                                                   sortcolumn=w_sortcolumn)
                    if not tmpselection:
                        continue
            elif widget == "inputbox":
                selected = uip.get_selected()
                w_title = deep_get(sc_value, DictPath("inputtitle"), "")
                if not (w_result := curses_helper.inputbox(uip.stdscr, title=w_title)):
                    continue
                # This is necessary because we never go through
                # the normal update cycle for the listpad and infopad
                uip.refresh_infopad()
                uip.refresh_listpad()
                uip.refresh_logpad()
                uip.refresh_statusbar()
                curses.doupdate()
                # Check this condition before confirming
                # FIXME: This should probably be moved to populate_views()
                w_confirm: Union[str, bool, Callable] = \
                    deep_get(sc_value, DictPath("confirm"), False)
                if isinstance(w_confirm, str):
                    if w_confirm == "path_exists":
                        w_confirm = os.path.exists(w_result)
                    else:
                        sys.exit("Unknown value for w_confirm; "
                                 "must be either boolean or path_exists")
                if w_confirm:
                    curses.doupdate()
                    w_confirmtitle = deep_get(sc_value, DictPath("confirmtitle"))
                    if not curses_helper.confirmationbox(uip.stdscr,
                                                         title=w_confirmtitle, default=False):
                        continue
            elif widget == "command":
                if force_update is None:
                    force_update = True
                w_args = deep_get(sc_value, DictPath("widget_args"), {})
                if "_pass_obj" in w_args:
                    w_args["obj"] = obj
                elif "_pass_selected_obj" in w_args:
                    selected = uip.get_selected()
                    if selected is not None:
                        w_args["obj"] = getattr(selected, "ref")
                do_command(uip.stdscr, **w_args)
            elif widget == "executecommand":
                selected = uip.get_selected()
                if (w_kinds := deep_get_with_fallback(sc_value,
                                                      [DictPath("widget_args#kinds"),
                                                       DictPath("kinds")])) is None:
                    continue
                w_ref = None
                if selected is not None:
                    w_ref = getattr(selected, "ref", None)
                if w_kinds != ["<native>"] \
                        and [deep_get(w_ref, DictPath("kind"), ""),
                             deep_get(w_ref, DictPath("api_group"), "")] not in w_kinds \
                        and w_kinds != [("", "")]:
                    continue

                w_inputtitle = deep_get_with_fallback(sc_value,
                                                      [DictPath("widget_args#inputtitle"),
                                                       DictPath("inputtitle")])
                if w_inputtitle is not None:
                    if not (w_input := curses_helper.inputbox(uip.stdscr, title=w_inputtitle)):
                        continue
                    w_command = w_input.split()
                else:
                    w_command = deep_get_with_fallback(sc_value,
                                                       [DictPath("widget_args#command"),
                                                        DictPath("command")], [])
                if not w_command:
                    continue

                w_waitforkeypress = deep_get(sc_value,
                                             DictPath("widget_args#wait_for_keypress"), False)
                containername: str = ""
                if not (w_kinds == ["<native>"] and w_command == ["<dnsutils>"]):
                    containername = deep_get(w_ref, DictPath("name"), "")
                if w_command == ["<ephemeral>"]:
                    ephemeral_image = \
                        deep_get(cmtlib.cmtconfig, DictPath("Debug#ephemeral_image"), "busybox")
                    msg = [ANSIThemeStr("Creating ephemeral ", "action"),
                           ANSIThemeStr(ephemeral_image, "programname"),
                           ANSIThemeStr(" container sharing process namespace with ",
                                        "action"),
                           ANSIThemeStr(f"{containername}", "path")]
                elif w_command == ["<dnsutils>"]:
                    node_name = deep_get(obj, DictPath("metadata#name"))
                    containername = None
                    msg = [ANSIThemeStr("Opening dnsutils container on ", "action"),
                           ANSIThemeStr(node_name, "hostname")]
                else:
                    msg = [ANSIThemeStr("Executing ", "action"),
                           ANSIThemeStr(w_command[0], "programname"),
                           ANSIThemeStr(" inside ", "action"),
                           ANSIThemeStr(containername, "path")]
                executecommand(uip.stdscr, obj, containername, msg,
                               command=w_command, waitforkeypress=w_waitforkeypress)
            if "action" in sc_value:
                selected = uip.get_selected()
                action = deep_get(sc_value, DictPath("action"), "<missing>")
                if action == "<missing>":
                    # No action defined; unless we're forced to update
                    # we don't.
                    if force_update is None:
                        continue
                if action == "from_ref":
                    ref = tmpselection
                    action = deep_get(ref, DictPath("action"))
                    action_call = deep_get(ref, DictPath("action_call"))
                    _action_call = deep_get(action_call_allowlist, DictPath(action_call))
                    if _action_call is None:
                        sys.exit(f"{action_call} is not in the action_call allow list")
                    action_call = _action_call
                    action_args = deep_get(ref, DictPath("action_args"), {})
                else:
                    action_call = deep_get(sc_value, DictPath("action_call"))
                    action_args = deep_get(sc_value, DictPath("action_args"), {})
                if "_pass_obj" in action_args:
                    action_args["obj"] = obj
                if "_pass_result" in action_args:
                    action_args["result"] = w_result
                if "_pass_selected" in action_args and selected is not None:
                    action_args["selected"] = selected
                if "_pass_selected_obj" in action_args and selected is not None:
                    action_args["selected_obj"] = getattr(selected, "ref", None)
                if "_parent_namespace_path" in action_args:
                    parent_namespace_path = \
                        deep_get(action_args, DictPath("_parent_namespace_path"))
                    action_args["_parent_namespace"] = \
                        deep_get(obj, DictPath(parent_namespace_path), "")
                if "_named_title" in action_args:
                    title = deep_get(action_args, DictPath("title"), "")
                    title_name: str = ""
                    if selected is not None:
                        ref = getattr(selected, "ref", None)
                    elif tmpselection is not None:
                        ref = tmpselection
                    if "_name_path" in action_args and ref is not None:
                        title_name_path = deep_get(action_args, DictPath("_name_path"), "")
                        title_name = deep_get(ref, DictPath(title_name_path), "")
                    elif "_name_tuple_paths" in action_args:
                        title_name_paths = deep_get(action_args, DictPath("_name_tuple_paths"), [])
                        title_name = deep_get_str_tuple_paths(cast(dict, ref), title_name_paths, "")
                    elif selected is not None:
                        title_name = getattr(selected, "name", "")
                    if title_name != "":
                        title_name = f" ({title_name})"
                    action_args["named_title"] = f"{title}{title_name}"

                if tmpselection is not None:
                    action_args["selection"] = tmpselection
                if action == "call" and action_call is not None:
                    if "process_selection" in action_args:
                        action_args = process_selection(**action_args)
                    retval = action_call(uip.stdscr, **action_args)
                    if retval is not None:
                        if retval == Retval.RETURNFULL:
                            return retval
                        if retval == Retval.NOMATCH and force_update is None:
                            continue
                elif action == "toggle_var":
                    var = deep_get(action_args, DictPath("var"))
                    if var is not None:
                        tmp = deep_get(infoview_args, DictPath(var))
                        deep_set(infoview_args, DictPath(var), not tmp)
                elif action == "execute":
                    _command = deep_get(action_args, DictPath("command"), [])
                    # replace paths with data
                    if _command:
                        command = []
                        for _cmd in _command:
                            if isinstance(_cmd, list):
                                command.append(deep_get_with_fallback(obj, _cmd))
                            else:
                                command.append(_cmd)
                    # Check this condition before confirming
                    w_confirm = deep_get(sc_value, DictPath("confirm"), False)
                    if isinstance(w_confirm, str):
                        if w_confirm == "path_exists":
                            w_confirm = os.path.exists(w_result)
                        else:
                            sys.exit("Unknown value for w_confirm; "
                                     "must be either boolean or path_exists")
                    if w_confirm:
                        curses.doupdate()
                        w_confirmtitle = deep_get(sc_value, DictPath("confirmtitle"))
                        if not curses_helper.confirmationbox(uip.stdscr,
                                                             title=w_confirmtitle, default=False):
                            continue
                    _values: dict[str, dict[str, Any]] = {
                        "action_args": {
                            "command": command,
                            "iterate": True,
                        }
                    }
                    items = [(deep_get(obj, DictPath("metadata#namespace"), ""),
                              deep_get(obj, DictPath("metadata#name")))]
                    action_execute_command(uip, items=items, action={},
                                           values=_values)
                if force_update is None:
                    force_update = True
            else:
                call = deep_get(sc_value, DictPath("call"))
                call_name = None
                owner_references_path = deep_get(sc_value, DictPath("owner_references_path"))
                owner_references_kind = deep_get(sc_value, DictPath("owner_references_kind"))
                holder_identity_path = deep_get(sc_value, DictPath("holder_identity_path"))
                if owner_references_path is not None:
                    owner_reference = deep_get(obj, DictPath(owner_references_path), [])
                    if holder_identity_path is not None:
                        if not owner_reference:
                            continue
                        call_name = deep_get(obj, DictPath(holder_identity_path))
                        kind = get_holder_kind_from_owner_references(owner_reference, call_name)
                    elif owner_references_kind is not None:
                        call_name = get_name_by_kind_from_owner_references(owner_reference,
                                                                           owner_references_kind)
                        kind = owner_references_kind
                    else:
                        kind, call_name = get_controller_from_owner_references(owner_reference)
                    if kind == ("", "") or not call_name:
                        continue
                else:
                    call_name_path = deep_get(sc_value, DictPath("name_path"))
                    if (kind := deep_get(sc_value, DictPath("kind"))) is None:
                        kind_path = deep_get(value, DictPath("kind_path"), "")
                        if isinstance(kind_path, tuple):
                            kind = (deep_get(obj, DictPath(kind_path[0])),
                                    deep_get(obj, DictPath(kind_path[1])))
                        else:
                            kind = deep_get(obj, DictPath(kind_path))
                    if call_name_path is not None:
                        call_name = deep_get(obj, DictPath(call_name_path))

                call_namespace = ""
                call_namespace_path = deep_get(sc_value, DictPath("namespace_path"))
                if call_namespace_path is not None:
                    call_namespace = deep_get(obj, DictPath(call_namespace_path))

                if call is not None and call_name is not None:
                    if kind is None or kind == ("", ""):
                        retval = call(uip.stdscr, **{"selected": call_name})
                        if retval is not None and retval == Retval.RETURNFULL:
                            return retval
                    elif kind:
                        if isinstance(kind, str):
                            kind = guess_kind(kind)
                        ref = kh.get_ref_by_kind_name_namespace(kind, call_name, call_namespace,
                                                                resource_cache=kh_cache)
                        retval = call(uip.stdscr, obj=ref, kind=kind)
                        if retval is not None and retval == Retval.RETURNFULL:
                            return retval
                if force_update is None:
                    force_update = True
            if force_update is not None and force_update:
                uip.update_forced = True
                uip.force_update()


def eventdispatch(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Dispatch from an event to the infoview of an involved object;
    this could probably be achieved using the regular dispatcher.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict): The object to get information from
                kind_path (DictPath): The path to get the kind from
                api_version_path (DictPath): The path to get the API-version from
                name_path (DictPath): The path to get name from
                namespace_path (DictPath): The path to get namespace from
        Returns:
            (Retval): Retval.RETURNDONE if no match was found, otherwise
                      Retval from the involved object whenever that returns.
    """
    obj = deep_get(kwargs, DictPath("obj"))
    if obj is None:
        return Retval.RETURNDONE

    kind_path = deep_get(kwargs, DictPath("kind_path"))
    kind = deep_get_with_fallback(obj, kind_path)
    # In some cases we don't get a kind from involvedObject/regarding;
    # just return, otherwise we'll crash in guess_kind().
    if kind is None:
        return Retval.RETURNDONE
    api_version_path = deep_get(kwargs, DictPath("api_version_path"))
    api_version = deep_get_with_fallback(obj, api_version_path, "")
    # Is this a core API?
    if "/" not in api_version:
        api_family = ""
    else:
        api_family = api_version.split("/")[0]
    kind = (kind, api_family)

    name_path = deep_get(kwargs, DictPath("name_path"))
    name = deep_get_with_fallback(obj, name_path)
    namespace_path = deep_get(kwargs, DictPath("namespace_path"))
    namespace = deep_get_with_fallback(obj, namespace_path + ["metadata#namespace"], "")
    ref = kh.get_ref_by_kind_name_namespace(kind, name, namespace, resource_cache=kh_cache)
    return resourceinfodispatch(stdscr, obj=ref, kind=kind)


# pylint: disable-next=too-many-arguments,too-many-positional-arguments
def log_add_line(timestamps: list[datetime],
                 facilities: list[Union[str, tuple[str, str]]],
                 severities: list[LogLevel],
                 messages: list[Union[list[Union[ThemeRef, ThemeStr]], str]],
                 timestamp: Optional[datetime], facility: str,
                 severity: LogLevel, message: list[Union[ThemeRef, ThemeStr]],
                 facility_extended: list[Union[ThemeRef, ThemeStr]]) \
        -> tuple[list[datetime], list[Union[str, tuple[str, str]]], list[LogLevel],
                 list[Union[list[Union[ThemeRef, ThemeStr]], str]]]:
    """
    Add a new line to the log.

        Parameters:
            timestamps ([datetime]): The list of timestamps
            facilities ([str|(str, str)]): The list of facilities
            severities ([LogLevel]): The list of severities
            messages ([[ThemeRef|ThemeStr]|str]): The list of log messages
            timestamp (Optional[datetime]): The timestamp of the message to add
            facility ([str]): The facility of the message to add
            severity ([LogLevel]): The severity of the message to add
            message ([ThemeRef|ThemeStr]|str): The message to add
            facility_extended ([ThemeRef|ThemeStr): A formatted facility;
                                                      used in podlog-viewer
        Returns:
            (([datetime], [str], [LogLevel], [ThemeRef|ThemeStr])):
                ([datetime]): The updated list of timestamps
                ([str|(str, str)]): The updated list of facilities
                ([LogLevel]): The updated list of severities
                ([[ThemeRef|ThemeStr]|str]): The updated list of log messages
    """
    if timestamp is not None and timestamp != none_timestamp():
        timestamps.append(timestamp.astimezone())
    else:
        timestamps.append(none_timestamp())
    if not facility_extended:
        facilities.append(facility)
    else:
        facilities.append((facility_extended, facility))
    severities.append(severity)
    messages.append(message)

    return timestamps, facilities, severities, messages


# noqa: E501 pylint: disable-next=too-many-locals,too-many-branches,too-many-statements,too-many-return-statements
def containerinfoloop(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Info loop for showing container logs.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                container (dict[str, Any]): The container object
                obj (dict): The object to operate on
                kind ((str, str)): The view to show
        Returns:
            (Retval): The return value
        Raises:
            ProgrammingError (view is invalid)
    """
    global executor  # pylint: disable=global-statement
    global override_tail_lines  # pylint: disable=global-statement

    # Just in case there are leftover futures from other views
    executor.shutdown()
    executor = reexecutor.ReExecutor()

    container: dict[str, Any] = deep_get(kwargs, DictPath("container"))
    kind: tuple[str, str] = deep_get(kwargs, DictPath("kind"))
    obj: dict[str, Any] = deep_get(kwargs, DictPath("obj"), {})

    multilog_containers_full = deep_get(kwargs, DictPath("multilog_containers_full"), [])
    multilog_containers = deep_get(kwargs, DictPath("multilog_containers"), [])
    all_same_namespace: bool = deep_get(kwargs, DictPath("all_same_namespace"), False)
    multilog_prefix: list[str] = ["namespace", "podname", "container"]
    facility_extended: list[Union[ThemeRef, ThemeStr]] = []

    uip: UIProps = UIProps(stdscr)

    helptext: list[dict] = format_helptext(helptexts.containerinfo)
    uip.init_window(windowheader="Container Info", helptext=helptext)

    # For generic information
    uip.init_infopad(height=7, width=-1, ypos=1, xpos=1)

    # For the pod log
    uip.init_logpad(width=-1, ypos=9, xpos=1)

    # For the status bar; position is always at the bottom of the screen
    # and the entire width of the screen
    uip.init_statusbar()

    # Number of lines of log to show by default
    if override_tail_lines is None:
        override_tail_lines = deep_get(cmtlib.cmtconfig,
                                       DictPath("Pod#logsize"), DEFAULT_TAIL_LINES)

    tail_lines = override_tail_lines

    uip.continuous_log = False
    merge_repeats = deep_get(cmtlib.cmtconfig, DictPath("Pod#merge_repeated_messages"), False)
    saved_merge_repeats = merge_repeats
    raw_logs = False
    tmp_log_level = deep_get(cmtlib.cmtconfig, DictPath("Pod#loglevel"), "Info")
    log_level = name_to_loglevel(tmp_log_level)
    show_borders = deep_get(cmtlib.cmtconfig, DictPath("Pod#show_borders"), True)
    uip.toggle_borders(borders=show_borders)
    show_timestamps = deep_get(cmtlib.cmtconfig, DictPath("Pod#show_timestamps"), True)
    uip.toggle_timestamps(show_timestamps)
    wrap_lines = False
    # Show severity as text
    severity_prefix = deep_get(cmtlib.cmtconfig, DictPath("Pod#severity_prefix"), [])
    # Backwards compatibility
    # pylint: disable-next=unidiomatic-typecheck
    if type(severity_prefix) == bool:  # noqa: E721
        if not severity_prefix:
            severity_prefix = []
        else:
            severity_prefix = ["[", "4LETTER", "] "]

    # This decides whether or not compound log messages,
    # such as Python dicts and JSON, should be expanded
    fold_msg = deep_get(cmtlib.cmtconfig, DictPath("Pod#fold_msg"), True)
    saved_fold_msg = fold_msg

    # This decides whether or not to show the facility,
    # and if so how it is to be displayed
    show_facility = deep_get(cmtlib.cmtconfig, DictPath("Pod#show_facility"), "Full")
    override_parser = None
    _parser = None

    uip.update_window()
    uip.force_update()
    uip.refresh_window()
    uip.refresh_statusbar()
    curses.doupdate()

    facility_regex: re.Pattern[str] = re.compile(r"^.*/(.*)")

    # pylint: disable-next=too-many-nested-blocks
    while True:
        if uip.is_update_triggered():
            # When following the log we update the log continuously, but tail lines is limited to
            # the number of lines that fits on the screen, and cursor movements are disabled; as
            # soon as the user presses a key the log will stop scrolling and the whole log
            # (default number of tail lines) will be loaded
            if uip.continuous_log:
                tail_lines = uip.logpadheight

            if not multilog_containers:
                pod_info = infogetters.get_pod_info(**{"vlist": [obj]}, kubernetes_helper=kh,
                                                    kh_cache=kh_cache)[0]
                podname = pod_info.name
                namespace = pod_info.namespace
                containername = deep_get(container, DictPath("name"))

                if kind == ("InitContainer", ""):
                    src_statuses = \
                        deep_get(pod_info.ref, DictPath("status#initContainerStatuses"), [])
                    container_type = "init_container"
                else:
                    src_statuses = \
                        deep_get(pod_info.ref, DictPath("status#containerStatuses"), [])
                    container_type = "container"
                container_status = None
                for container_status in src_statuses:
                    if deep_get(container_status, DictPath("name")) == containername:
                        break
                if container_status is not None:
                    image_id = deep_get(container_status, DictPath("imageID"), "")
                    image = deep_get(container_status, DictPath("image"), "")
                    if image.startswith("sha256:"):
                        image = image_id
                else:
                    image = "<unavailable>"

            # We do not want the "Fetching Log" notification every few seconds;
            # we are just loading a few lines...
            if not uip.continuous_log:
                notice = curses_helper.notice(None, y=uip.maxy // 2, x=uip.maxx // 2,
                                              message="Fetching log")
            if not multilog_containers:
                rawmsg, internal_error = \
                    get_pod_log_by_name_namespace_container(podname, namespace, containername,
                                                            tail_lines=tail_lines)
                splitmsg = split_msg(rawmsg)
            else:
                container_type = "container"
                splitmsg = []
                image_id = None
                for namespace, podname, containername, image_id in multilog_containers_full:
                    if len(multilog_containers) == 1:
                        facility_extended = []
                    elif multilog_prefix == ["container"]:
                        facility_extended = [
                            ThemeRef("separators", "facility_extended_prefix"),
                            ThemeStr(f"{containername}",
                                     ThemeAttr("types", "facility_extended")),
                            ThemeRef("separators", "facility_extended_suffix"),
                        ]
                    elif multilog_prefix == ["podname", "container"] \
                            or multilog_prefix == ["namespace", "podname", "container"] \
                            and all_same_namespace:
                        facility_extended = [
                            ThemeRef("separators", "facility_extended_prefix"),
                            ThemeStr(f"{podname}", ThemeAttr("types", "facility_extended")),
                            ThemeRef("separators", "container"),
                            ThemeStr(f"{containername}",
                                     ThemeAttr("types", "facility_extended")),
                            ThemeRef("separators", "facility_extended_suffix"),
                        ]
                    elif multilog_prefix == ["namespace", "podname", "container"]:
                        facility_extended = [
                            ThemeRef("separators", "facility_extended_prefix"),
                            ThemeStr(f"{namespace}", ThemeAttr("types", "facility_extended")),
                            ThemeRef("separators", "namespace"),
                            ThemeStr(f"{podname}", ThemeAttr("types", "facility_extended")),
                            ThemeRef("separators", "container"),
                            ThemeStr(f"{containername}",
                                     ThemeAttr("types", "facility_extended")),
                            ThemeRef("separators", "facility_extended_suffix"),
                        ]
                    rawmsg, internal_error = \
                        get_pod_log_by_name_namespace_container(podname, namespace, containername,
                                                                tail_lines=tail_lines)
                    if internal_error:
                        splitmsg = split_msg(rawmsg)
                        break
                    # Now we have one per line; now we need to add
                    # (podname, containername, image, facility_extended) to each line,
                    # to allow the logparser to function without guessing
                    for line in split_msg(rawmsg):
                        splitmsg.append((line, podname, containername, image_id, facility_extended))
                splitmsg = cast(list[tuple[str, str, str, str, list[Union[ThemeRef, ThemeStr]]]],
                                natsorted(splitmsg, key=itemgetter(0)))

            if not uip.continuous_log:
                del notice
            uip.refresh_window()
            uip.refresh_infopad()
            uip.refresh_logpad()
            uip.refresh_statusbar()
            curses.doupdate()

            timestamps: list[datetime] = []
            facilities: list[Union[str, tuple[str, str]]] = []
            severities: list[LogLevel] = []
            messages: list[Union[list[Union[ThemeRef, ThemeStr]], str]] = []
            parser = None
            prev_timestamp = none_timestamp()
            prev_facility: str = ""
            prev_severity: LogLevel = LogLevel.INFO
            prev_message: list[Union[ThemeRef, ThemeStr]] = \
                [ThemeStr("", ThemeAttr("types", "generic"))]
            prev_remnants: list = []
            repeat_count: int = 0

            total_msgs: int = 0
            hidden_msgs: int = 0
            merged_lines: int = 0

            linecount: int = len(splitmsg)
            linepercent: int = int(linecount * 0.1)

            progressbar: Optional[curses.window] = None
            if linecount > 1000:
                progressbar = curses_helper.progressbar(None, y=uip.maxy // 2, minx=(uip.minx + 8),
                                                        maxx=(uip.maxx - 8), progress=0,
                                                        title="Parsing log")

            i: int = 0
            while i < len(splitmsg):
                _line = splitmsg[i]

                # We probably need a progress bar once we reach this many lines
                if linecount > 1000 and (i % linepercent) == 0:
                    curses_helper.progressbar(progressbar, y=uip.maxy // 2, minx=(uip.minx + 8),
                                              maxx=(uip.maxx - 8),
                                              progress=100 - 100 * ((linecount - i) // linecount))
                    if progressbar:
                        progressbar.timeout(10)
                        c = progressbar.getch()
                        if c == 27:  # ESCAPE
                            return Retval.RETURNDONE

                if isinstance(_line, tuple):
                    line, podname, containername, image, facility_extended = _line
                    # We need to identify parser again and again and again for every line
                    _parser = None
                else:
                    line = _line
                if internal_error:
                    timestamp_, facility, severity, message, remnants, parser, _parser = \
                        logparser("internal_error", "", "", message=line,
                                  container_type=container_type, line=i)
                elif raw_logs:
                    timestamp_, facility, severity, message, remnants, parser, _parser = \
                        logparser("raw", "", "", message=line,
                                  container_type=container_type, line=i)
                elif override_parser is not None or _parser is None or parser is None:
                    timestamp_, facility, severity, message, remnants, parser, _parser = \
                        logparser(podname, containername, image, message=line, fold_msg=fold_msg,
                                  override_parser=override_parser,
                                  container_type=container_type, line=i)
                else:
                    timestamp_, facility, severity, message, remnants = \
                        logparser_initialised(parser=_parser, message=line,
                                              fold_msg=fold_msg, line=i)

                i += 1

                # In some cases rather than expanding a single line into multiple lines,
                # we want to parse multiple lines as a single block;
                # we signal this by returning message == ["start_block", processor],
                # then continue parsing until we either get ["end_block", *],
                # ["break", *], or reach the end of the file
                if isinstance(message, tuple) and message[0] == "start_block" and not raw_logs:
                    _logentries = [(timestamp_, facility, severity, remnants)]
                    processor = message
                    options = processor[2]
                    _block_state = "none"
                    for j in range(i, len(splitmsg)):
                        if not callable(processor[1]):
                            raise ProgrammingError(f"processor: {processor} does not "
                                                   "contain a valid processor")
                        processor, _logentry = \
                            processor[1](splitmsg[j], fold_msg=fold_msg, options=options)
                        _block_state = processor[0]
                        if _block_state != "end_block_not_processed":
                            _logentries.append(_logentry)

                        if _block_state in ("end_block", "end_block_not_processed"):
                            # OK, we've got a block; start by appending the first line
                            if _logentries:
                                timestamps, facilities, severities, messages = \
                                    log_add_line(timestamps, facilities, severities, messages,
                                                 timestamp_, facility, severity,
                                                 _logentries[0][3], facility_extended)
                            if len(_logentries) > 1:
                                for _timestamp, _facility, _severity, _message in _logentries[1:]:
                                    timestamps, facilities, severities, messages = \
                                        log_add_line(timestamps, facilities, severities, messages,
                                                     _timestamp, "".ljust(len(facility)), severity,
                                                     _message, facility_extended)
                                break
                        elif _block_state == "break":
                            # We got something indicating that this is not a valid block; abort
                            break
                    else:
                        if _logentries \
                                and deep_get(options, DictPath("eof"), "break") == "end_block":
                            for _timestamp, _facility, _severity, _message in _logentries:
                                timestamps, facilities, severities, messages = \
                                    log_add_line(timestamps, facilities, severities, messages,
                                                 _timestamp, "".ljust(len(facility)), severity,
                                                 _message, facility_extended)
                            _block_state = "end_block"
                        else:
                            _block_state = "break"

                    if _block_state == "end_block":
                        # We got a block and it has been appended, so go on
                        i = j + 1
                        continue

                    if _block_state == "end_block_not_processed":
                        # We got a block and it has been appended,
                        # but the last line needs processing again
                        i = j
                        continue

                    message = remnants
                    remnants = []

                total_msgs += 1

                if severity > log_level:
                    hidden_msgs += 1
                    continue

                # pylint: disable-next=too-many-boolean-expressions
                if prev_message == message \
                        and prev_facility == facility \
                        and prev_severity == severity \
                        and (themearray_len(prev_message) or not prev_remnants) \
                        and prev_remnants == remnants:
                    repeat_count += 1
                    prev_timestamp = timestamp_
                    if merge_repeats:
                        merged_lines += 1
                        continue
                else:
                    if repeat_count and merge_repeats:
                        timestamps, facilities, severities, messages = \
                            log_add_line(timestamps, facilities, severities, messages,
                                         prev_timestamp, prev_facility, prev_severity,
                                         [ThemeStr("[previous message repeated ",
                                                   color_log_severity(prev_severity)),
                                          ThemeStr(f"{repeat_count}",
                                                   ThemeAttr("logview", "repeat_count")),
                                          ThemeStr(" times]",
                                                   color_log_severity(prev_severity))],
                                         facility_extended)
                    repeat_count = 0
                    prev_timestamp = timestamp_
                    prev_facility = facility
                    prev_severity = severity
                    prev_message = message
                    prev_remnants = remnants

                timestamps, facilities, severities, messages = \
                    log_add_line(timestamps, facilities, severities, messages, timestamp_,
                                 facility, severity, message, facility_extended)

                if remnants is not None and remnants:
                    # Remnants are used for unfolding multi-line messages that have been
                    # folded into one, such as YAML/JSON, etc.
                    #
                    # Remnants can, for the time being, be either:
                    # (list of string, severity)
                    # (string(newline separated strings), severity)
                    # or
                    # [(string, severity), ...]
                    if isinstance(remnants, tuple):
                        tmpmessages, severity = remnants
                        if isinstance(tmpmessages, list):
                            tmpmsg = tmpmessages
                        else:
                            tmpmsg = tmpmessages.split("\n")

                        for message in tmpmsg:
                            timestamps, facilities, severities, messages = \
                                log_add_line(timestamps, facilities, severities, messages, None,
                                             "".ljust(len(facility)), severity, message,
                                             facility_extended)
                    else:
                        for message, severity in remnants:
                            timestamps, facilities, severities, messages = \
                                log_add_line(timestamps, facilities, severities, messages, None,
                                             "".ljust(len(facility)), severity, message,
                                             facility_extended)

            # The data in some fields might become shorter, so we need to trigger a clear
            if uip.infopad is not None:
                uip.infopad.erase()
            if uip.statusbar is not None:
                uip.statusbar.erase()

            del progressbar

            # If the last message in the log is a repeat we need to add the repeat signature
            if repeat_count and merge_repeats:
                timestamps, facilities, severities, messages = \
                    log_add_line(timestamps, facilities, severities, messages, prev_timestamp,
                                 prev_facility, prev_severity,
                                 [ThemeStr("[previous message repeated ",
                                           color_log_severity(prev_severity)),
                                  ThemeStr(f"{repeat_count}",
                                           ThemeAttr("logview", "repeat_count")),
                                  ThemeStr(" times]", color_log_severity(prev_severity))],
                                 facility_extended)

            uip.update_log_info(timestamps, facilities, severities, messages)
            uip.update_window()

            if not multilog_containers:
                containertypearray = f" [Type: {kind[0]}]"
                if kind == ("InitContainer", ""):
                    src_statuses = deep_get(pod_info.ref, DictPath("status#initContainerStatuses"))
                else:
                    src_statuses = deep_get(pod_info.ref, DictPath("status#containerStatuses"))

                if src_statuses is None or not src_statuses:
                    break

                for container_status in src_statuses:
                    if deep_get(container_status, DictPath("name")) == containername:
                        break

                status, status_group, restarts, status_message, _age = \
                    datagetters.get_container_status(src_statuses, containername)
                containerarray: list[Union[ThemeRef, ThemeStr]] = [
                    ThemeStr("Container: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{containername}{containertypearray}", ThemeAttr("types", "generic"))
                ]
                statusarray: list[Union[ThemeRef, ThemeStr]] = [
                    ThemeStr("Status: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{status}", color_status_group(status_group))
                ]
                if status_message != "":
                    status_message_ = "\\n".join(split_msg(status_message))
                    statusarray.append(ThemeStr(f" ({status_message_})",
                                       ThemeAttr("types", "generic")))
                restartsarray: list[Union[ThemeRef, ThemeStr]] = [
                    ThemeStr("Restarts: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{restarts}", ThemeAttr("types", "numerical"))
                ]
                podarray: list[Union[ThemeRef, ThemeStr]] = [
                    ThemeStr("Pod: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{pod_info.name}", ThemeAttr("types", "generic")),
                ]
                containeridarray: list[Union[ThemeRef, ThemeStr]] = [
                    ThemeStr("Container ID: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{deep_get(container_status, DictPath('containerID'))}",
                             ThemeAttr("types", "generic")),
                ]
                image_name, image_version = \
                    get_image_tuple(deep_get(container_status, DictPath("image")))
                imagearray: list[Union[ThemeRef, ThemeStr]] = [
                    ThemeStr("Image: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{image_name}", ThemeAttr("types", "generic")),
                    ThemeRef("separators", "version"),
                    ThemeStr(f"{image_version}", ThemeAttr("types", "version")),
                ]
                image_id = deep_get(container_status, DictPath("imageID"))
                imageidarray: list[Union[ThemeRef, ThemeStr]] = [
                    ThemeStr("I", ThemeAttr("main", "infoheader_shortcut")),
                    ThemeStr("mage ID: ", ThemeAttr("main", "infoheader")),
                    ThemeStr(f"{image_id}", ThemeAttr("types", "generic")),
                ]
                uip.addthemearray(uip.infopad, containerarray, y=0, x=0)
                uip.addthemearray(uip.infopad, statusarray, y=1, x=0)
                uip.addthemearray(uip.infopad, restartsarray, y=2, x=0)
                uip.addthemearray(uip.infopad, podarray, y=3, x=0)
                uip.addthemearray(uip.infopad, containeridarray, y=4, x=0)
                uip.addthemearray(uip.infopad, imagearray, y=5, x=0)
                uip.addthemearray(uip.infopad, imageidarray, y=6, x=0)
            else:
                if len(multilog_containers) == 1:
                    containerarray = [
                        ThemeStr("Container: ", ThemeAttr("main", "infoheader")),
                        ThemeStr(f"{containername}", ThemeAttr("types", "generic")),
                    ]
                    podarray = [
                        ThemeStr("Pod: ", ThemeAttr("main", "infoheader")),
                        ThemeStr(f"{podname}", ThemeAttr("types", "generic")),
                    ]
                    namespacearray: list[Union[ThemeRef, ThemeStr]] = [
                        ThemeStr("Namespace: ", ThemeAttr("main", "infoheader")),
                        ThemeStr(f"{namespace}", ThemeAttr("types", "namespace")),
                    ]
                    containeridarray = [
                        ThemeStr("I", ThemeAttr("main", "infoheader_shortcut")),
                        ThemeStr("mage ID: ", ThemeAttr("main", "infoheader")),
                        ThemeStr(f"{image_id}", ThemeAttr("types", "generic")),
                    ]
                    uip.addthemearray(uip.infopad, podarray, y=1, x=0)
                    uip.addthemearray(uip.infopad, namespacearray, y=2, x=0)
                    uip.addthemearray(uip.infopad, containeridarray, y=3, x=0)
                else:
                    containerarray = [
                        ThemeStr("Containers: ", ThemeAttr("main", "infoheader")),
                    ]
                    containerarray += \
                        generators.format_list(multilog_containers, fieldlen=0, pad=False,
                                               field_colors=[
                                                   ThemeAttr("types", "namespace"),
                                                   ThemeAttr("types", "generic"),
                                                   ThemeAttr("types", "generic")
                                               ],
                                               field_separators=[
                                                   ThemeRef("separators", "namespace"),
                                                   ThemeRef("separators", "container")
                                               ],
                                               ellipsise=3)
                    if all_same_namespace:
                        namespacearray = [
                            ThemeStr("Namespace: ", ThemeAttr("main", "infoheader")),
                            ThemeStr(f"{namespace}", ThemeAttr("types", "namespace")),
                        ]
                        uip.addthemearray(uip.infopad, namespacearray, y=1, x=0)
                uip.addthemearray(uip.infopad, containerarray, y=0, x=0)

            uip.refresh = True

        if uip.refresh:
            # FIXME: the status stuff should be done by curses_helper
            if uip.statusbar is not None:
                uip.statusbar.erase()

            if uip.continuous_log:
                interval = "Follow"
            else:
                interval = "Manual"

            if tail_lines == sys.maxsize:
                loglimit = "Unlimited"
            else:
                loglimit = f"{tail_lines}"

            loglevel_str = loglevel_to_name(log_level)

            # We have two different widths of the statusbar
            if uip.maxx - uip.minx > 108:
                # Wide version
                statusarray1: list[Union[ThemeRef, ThemeStr]] = [
                    ThemeStr("Updates: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{interval}", ThemeAttr("statusbar", "highlight")),
                    ThemeRef("separators", "statusbar"),
                    ThemeStr("Loglvl: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{loglevel_str}", ThemeAttr("statusbar", "highlight")),
                    ThemeRef("separators", "statusbar"),
                    ThemeStr("Log length: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{uip.loglen} ", ThemeAttr("statusbar", "highlight")),
                    ThemeStr("lines (", ThemeAttr("statusbar", "default")),
                ]
                if hidden_msgs:
                    statusarray1 += [
                        ThemeStr(f"{hidden_msgs}", ThemeAttr("statusbar", "highlight")),
                        ThemeStr(" messages hidden)", ThemeAttr("statusbar", "dim")),
                        ThemeStr("; ", ThemeAttr("statusbar", "default")),
                    ]
                statusarray1 += [
                    ThemeStr("limit: ", ThemeAttr("statusbar", "default")),
                    ThemeStr(f"{loglimit}", ThemeAttr("statusbar", "highlight")),
                    ThemeStr(")", ThemeAttr("statusbar", "default")),
                ]
                statusarray2: list[Union[ThemeRef, ThemeStr]] = []
                if not fold_msg:
                    statusarray2 += [
                        ThemeStr("Unfolding messages", ThemeAttr("statusbar", "highlight")),
                        ThemeRef("separators", "statusbar"),
                    ]
                if merge_repeats:
                    statusarray2 += [
                        ThemeStr("Repeats merged", ThemeAttr("statusbar", "highlight")),
                        ThemeRef("separators", "statusbar"),
                    ]

                statusarray2 += [
                    ThemeStr("Facility: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{show_facility}", ThemeAttr("statusbar", "highlight")),
                    ThemeRef("separators", "statusbar"),
                    ThemeStr("Format: ", ThemeAttr("statusbar", "infoheader")),
                ]
            else:
                # Compact version
                statusarray1 = [
                    ThemeStr("Updates: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{interval}", ThemeAttr("statusbar", "highlight")),
                    ThemeRef("separators", "statusbar_compact"),
                    ThemeStr("Loglvl: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{loglevel_str}", ThemeAttr("statusbar", "highlight")),
                    ThemeRef("separators", "statusbar_compact"),
                    ThemeStr(f"{uip.loglen} ", ThemeAttr("statusbar", "highlight")),
                    ThemeStr("lines (", ThemeAttr("statusbar", "default")),
                ]
                if hidden_msgs:
                    statusarray1 += [
                        ThemeStr(f"{hidden_msgs}", ThemeAttr("statusbar", "highlight")),
                        ThemeStr(" hidden", ThemeAttr("statusbar", "dim")),
                        ThemeStr("; ", ThemeAttr("statusbar", "default")),
                    ]
                statusarray1 += [
                    ThemeStr("max: ", ThemeAttr("statusbar", "default")),
                    ThemeStr(f"{loglimit}", ThemeAttr("statusbar", "highlight")),
                    ThemeStr(")", ThemeAttr("statusbar", "default")),
                ]
                statusarray2 = [
                ]
                if not fold_msg:
                    statusarray2 += [
                        ThemeStr("Unfolding", ThemeAttr("statusbar", "highlight")),
                        ThemeRef("separators", "statusbar_compact"),
                    ]
                if merge_repeats:
                    statusarray2 += [
                        ThemeStr("Repeats merged", ThemeAttr("statusbar", "highlight")),
                        ThemeRef("separators", "statusbar_compact"),
                    ]

                statusarray2 += [
                    ThemeStr("Facility: ", ThemeAttr("statusbar", "infoheader")),
                    ThemeStr(f"{show_facility}", ThemeAttr("statusbar", "highlight")),
                    ThemeRef("separators", "statusbar_compact"),
                    ThemeStr("Format: ", ThemeAttr("statusbar", "infoheader")),
                ]

            if not rawmsg:
                statusarray2 += [
                    ThemeStr("Empty", ThemeAttr("main", "format_empty")),
                ]
            elif parser is None or parser[0] == "unknown":
                statusarray2 += [
                    ThemeStr("Unknown", ThemeAttr("main", "format_unknown")),
                ]
            elif raw_logs:
                statusarray2 += [
                    ThemeStr("Raw", ThemeAttr("main", "format_raw")),
                ]
            else:
                if uip.maxx - uip.minx > 118:
                    statusarray2 += [
                        ThemeStr(f"{parser[0]}:{parser[1]}", ThemeAttr("statusbar", "highlight")),
                    ]
                else:
                    statusarray2 += [
                        ThemeStr(f"{parser[0]}", ThemeAttr("statusbar", "highlight")),
                    ]
                if uip.maxx - uip.minx > 128 and LogparserConfiguration.using_bundles:
                    statusarray2 += [
                        ThemeStr(" (Bundle)", ThemeAttr("statusbar", "dim")),
                    ]

            uip.addthemearray(uip.statusbar, statusarray1, y=0, x=0)
            uip.addthemearray(uip.statusbar, statusarray2, y=1, x=0)

            maxlen = 0
            latest_facility_len = -1

            if uip.tspad is not None:
                uip.tspad.erase()
            if uip.logpad is not None:
                uip.logpad.erase()
            # This is needed in case we get a resize event or toggle borders
            uip.resize_logpad(uip.maxy - uip.logpadypos - 2, 0)
            yadd = 0
            timestamp: str = ""
            tscount = 0
            for y in range(0, min(uip.logpadheight, uip.loglen)):
                if timestamps is None or uip.yoffset + y >= len(timestamps) \
                        or timestamps[uip.yoffset + y] == none_timestamp():
                    timestamp = "".ljust(uip.tspadwidth)
                else:
                    timestamp = str(timestamps[uip.yoffset + y]).ljust(uip.tspadwidth)
                    tscount += 1

                if y + yadd > uip.logpadheight:
                    continue

                tsthemearray: list[Union[ThemeRef, ThemeStr]] = \
                    [ThemeStr(timestamp, ThemeAttr("logview", "timestamp"))]

                if show_facility == "None" or uip.yoffset + y >= len(facilities):
                    facility_extended = ""
                    facility = ""
                elif show_facility == "Short":
                    _facility = facilities[uip.yoffset + y]
                    if isinstance(_facility, tuple):
                        facility_extended, _facility = _facility
                    if _facility is None:
                        _facility = ""
                    tmp = facility_regex.match(_facility)
                    if tmp is not None:
                        facility = tmp[1]
                        latest_facility_len = len(facility)
                    elif len(_facility.strip()) != len(_facility) and not _facility.strip():
                        if latest_facility_len == -1:
                            facility = _facility
                        else:
                            facility = _facility[0:latest_facility_len]
                    else:
                        facility = _facility
                else:
                    facility = facilities[uip.yoffset + y]
                    if isinstance(facility, tuple):
                        facility_extended, facility = facility
                    if facility is None:
                        facility = ""

                if uip.yoffset + y >= len(severities):
                    severity = LogLevel.INFO
                else:
                    severity = severities[uip.yoffset + y]

                msgstrarray: list[Union[ThemeRef, ThemeStr]] = []

                if severity_prefix:
                    _prefix, _severity_type, _suffix = severity_prefix
                    if _severity_type.lower() == "letter":
                        _severity_str = lvl_to_letter_severity(severity)
                    elif _severity_type.lower() == "4letter":
                        _severity_str = lvl_to_4letter_severity(severity)
                    elif _severity_type.lower() == "full":
                        _severity_str = lvl_to_word_severity(severity)

                    if _severity_type.startswith(("LE", "4LE", "FU")):
                        _severity_str = f"{_prefix}{_severity_str.upper()}{_suffix}"
                    elif _severity_type.startswith(("Le", "4Le", "Fu")):
                        _severity_str = f"{_prefix}{_severity_str.capitalize()}{_suffix}"
                    else:
                        _severity_str = f"{_prefix}{_severity_str.lower()}{_suffix}"

                    if timestamp.strip() or y >= len(timestamps):
                        msgstrarray.append(ThemeStr(f"{_severity_str}",
                                                    color_log_severity(severity)))
                    else:
                        msgstrarray.append(ThemeStr("".ljust(len(f"{_severity_str}")),
                                                    color_log_severity(severity)))

                if facility_extended is not None and facility_extended:
                    msgstrarray += facility_extended

                if facility != "":
                    facilitystr: list[Union[ThemeRef, ThemeStr]] = [
                        ThemeRef("separators", "facility_prefix"),
                        ThemeStr(facility, ThemeAttr("logview", "facility")),
                        ThemeRef("separators", "facility_suffix"),
                        ThemeRef("separators", "facility_padding"),
                    ]
                    # We do not actually want any prefix,
                    # but we want empty padding of the same length
                    if facility.rstrip() == "":
                        facilitystr = [ThemeStr("".ljust(themearray_len(facilitystr)),
                                                ThemeAttr("logview", "severity_debug"))]
                    msgstrarray += facilitystr

                msg = messages[uip.yoffset + y]
                if not isinstance(msg, list):
                    msgstrarray.append(ThemeStr(msg, color_log_severity(severity)))
                else:
                    msgstrarray += msg
                if wrap_lines:
                    sideadjust = 0
                    if not uip.borders:
                        sideadjust = 2
                    maxwidth = uip.maxx - uip.logpadxpos + sideadjust
                else:
                    maxwidth = -1
                msgstrarrays = \
                    themearray_wrap_line(msgstrarray, maxwidth,
                                         wrap_marker=(uip.borders or get_mousemask() != 0))
                for i, msgstrarray in enumerate(msgstrarrays):
                    if y + yadd + i >= uip.logpadheight:
                        break
                    if i == 0 and uip.tspad is not None and tscount:
                        uip.addthemearray(uip.tspad, tsthemearray, y=y + yadd, x=0)
                    _cury, _curx = uip.addthemearray(uip.logpad, msgstrarray, y=y + yadd + i, x=0)
                    maxlen = max(maxlen, themearray_len(msgstrarray))
                yadd += i
            uip.resize_logpad(-1, maxlen)

            uip.refresh_window()
            uip.refresh_infopad()
            uip.refresh_logpad()
            uip.refresh_statusbar()
            curses.doupdate()
            uip.refresh = False

        uip.stdscr.timeout(100)
        c = uip.stdscr.getch()
        retval: Retval = uip.generic_keycheck(c)

        if retval == Retval.MATCH:
            continue
        if retval == Retval.RETURNONE:
            return Retval.RETURNDONE
        if retval == Retval.RETURNFULL:
            return retval

        if c == curses.KEY_F2:
            if (retval := selectwindow(uip)) == Retval.RETURNFULL:
                return retval
            uip.refresh_all()
        elif c == curses.KEY_F3:
            if (retval := selectwindow(uip, refresh_apis=True)) == Retval.RETURNFULL:
                return retval
            uip.refresh_all()
        elif c == ord("B"):
            uip.toggle_borders()
            uip.refresh_all()
            uip.force_update()
        elif c == curses.KEY_F4:
            if uip.continuous_log:
                # Disable log tailing
                uip.continuous_log = False
                tail_lines = override_tail_lines
                uip.set_update_delay(-1)
                # When we disable tailing we would ideally want to be at the end,
                # but we do not know where the end is, so, stay on top...
            else:
                # Enable log tailing
                uip.continuous_log = True
                tail_lines = uip.logpadheight
                uip.set_update_delay(10)
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == curses.KEY_F8:
            if uip.continuous_log:
                continue

            # Toggle full logs; this might be VERY slow
            uip.continuous_log = False

            if tail_lines == override_tail_lines:
                query_title = "Show full log (Potentially very slow):"
                if curses_helper.confirmationbox(uip.stdscr, title=query_title, default=False):
                    tail_lines = sys.maxsize
            else:
                tail_lines = override_tail_lines

            uip.refresh_infopad()
            uip.refresh_logpad()
            uip.refresh_statusbar()
            curses.doupdate()
            uip.force_update()
        elif c == ord("I"):
            # XXX: This is very inefficient
            _vlist = infogetters.get_container_info(kubernetes_helper=kh, kh_cache_=kh_cache)
            retval = None
            for _obj in _vlist:
                if _obj.name == containername and _obj.image_id == image_id:
                    retval = resourceinfodispatch(stdscr, obj=_obj.ref, kind=("__Container", ""))
                    uip.force_update()
                    break
            if retval is not None and retval == Retval.RETURNFULL:
                return retval
        elif c == ord("O"):
            option_list = [
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Pop timestamps", ThemeAttr("windowwidget", "default"))]],
                    "retval": "pop_ts",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Pop severity", ThemeAttr("windowwidget", "default"))]],
                    "retval": "pop_severity",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Pop facility", ThemeAttr("windowwidget", "default"))]],
                    "retval": "pop_facility",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Extract message",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "msg_extract",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Message first", ThemeAttr("windowwidget", "default"))]],
                    "retval": "msg_first",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Override severity",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "override_severity",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Replace bullets",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "msg_realbullets",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Collector bullets",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "bullet_collectors",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Merge starting version",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "merge_starting_version",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Expand newlines (WIP)",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "expand_newlines",
                },
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Expand tabs (WIP)",
                                 ThemeAttr("windowwidget", "default"))]],
                    "retval": "expand_tabs",
                },
            ]
            preselection = set()

            for i, option in enumerate(option_list):
                retval = False
                option_path = deep_get(option, DictPath("retval"))
                if option_path is not None:
                    retval = getattr(LogparserConfiguration, option_path, False)
                if retval:
                    preselection.add(i)

            tmpselection = \
                curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2,
                                           uip.maxx // 2, option_list, title="Parser options",
                                           cursor=True, preselection=preselection, taggable=True)
            selection = None
            if tmpselection is not None and tmpselection != "":
                selection = tmpselection
            uip.refresh_all()

            # Some option changed, so we need to re-render the log
            if selection is not None and preselection != selection:
                # Perform the changes
                modified_options = preselection.symmetric_difference(selection)
                for i in modified_options:
                    option_path = deep_get(option_list[i], DictPath("retval"))
                    value = not getattr(LogparserConfiguration, option_path, False)
                    setattr(LogparserConfiguration, option_path, value)

                uip.yoffset = 0
                uip.xoffset = 0
                uip.force_update()
        elif c == ord("R"):
            if uip.continuous_log:
                continue

            if not raw_logs:
                saved_fold_msg = fold_msg
                saved_merge_repeats = merge_repeats
                fold_msg = True
                merge_repeats = False
            else:
                fold_msg = saved_fold_msg
                merge_repeats = saved_merge_repeats
            raw_logs = not raw_logs
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("P"):
            parserlist = [{
                "lineattrs": WidgetLineAttrs.NORMAL,
                "columns": [[ThemeStr("<autodetect>", ThemeAttr("windowwidget", "default"))]],
                "retval": "<autodetect>",
            }]
            for parser in natsorted(get_parser_list()):
                parserlist.append({
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr(f"{parser}", ThemeAttr("windowwidget", "default"))]],
                    "retval": parser,
                })

            if override_parser is None:
                preselection = "<autodetect>"
            else:
                preselection = override_parser
            tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                      uip.maxy // 2, uip.maxx // 2, parserlist,
                                                      title="Override Logparser", cursor=True,
                                                      preselection=preselection)
            selection = None
            if tmpselection is not None and tmpselection != "":
                selection = tmpselection
            uip.refresh_all()
            if selection is not None and selection:
                if selection == "<autodetect>":
                    override_parser = None
                else:
                    override_parser = selection
                _parser = None
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("L"):
            loglevellist = []
            for lvl in get_loglevel_names():
                if lvl.startswith("Diff"):
                    continue
                loglevellist.append({
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr(f"{lvl}", ThemeAttr("windowwidget", "default"))]],
                    "retval": lvl,
                })

            tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                      uip.maxy // 2, uip.maxx // 2, loglevellist,
                                                      title="Select Loglevel", cursor=True,
                                                      preselection=loglevel_to_name(log_level))
            selection = None
            if tmpselection is not None and tmpselection != "":
                selection = tmpselection
            uip.refresh_all()
            if isinstance(selection, str) and selection:
                log_level = name_to_loglevel(selection)
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("W"):
            wrap_lines = not wrap_lines
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("F"):
            if uip.continuous_log or raw_logs:
                continue

            fold_msg = not fold_msg
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("D"):
            if uip.continuous_log or raw_logs:
                continue

            merge_repeats = not merge_repeats
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("T"):
            uip.toggle_timestamps()
            uip.refresh_all()
            uip.force_update()
        elif c == ord("V"):
            facilitylist = [
                {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Full", ThemeAttr("windowwidget", "default"))]],
                    "retval": "Full",
                }, {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("Short", ThemeAttr("windowwidget", "default"))]],
                    "retval": "Short",
                }, {
                    "lineattrs": WidgetLineAttrs.NORMAL,
                    "columns": [[ThemeStr("None", ThemeAttr("windowwidget", "default"))]],
                    "retval": "None",
                }
            ]

            tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                                      uip.maxy // 2, uip.maxx // 2, facilitylist,
                                                      title="Select Facility Level", cursor=True,
                                                      preselection=show_facility)
            selection = None
            if tmpselection is not None and tmpselection != "":
                selection = tmpselection
            uip.refresh_all()
            if selection is not None and selection:
                show_facility = selection
            uip.yoffset = 0
            uip.xoffset = 0
            uip.force_update()
        elif c == ord("E"):
            if uip.continuous_log:
                continue

            uip.refresh = True
            if raw_logs:
                rawprefix = "Raw "
            else:
                rawprefix = ""
            export_title = f"Export {rawprefix}log to file: "
            if not (filename := curses_helper.inputbox(uip.stdscr, title=export_title)):
                continue

            # This is necessary because we never go through the normal update cycle
            # for the logpad and infopad
            uip.refresh_infopad()
            uip.refresh_logpad()
            curses.doupdate()

            if os.path.exists(filename):
                curses.doupdate()
                query_title = f"File “{filename}“ already exists; overwrite?:"
                if not curses_helper.confirmationbox(uip.stdscr, title=query_title, default=False):
                    continue

            data = ""

            for y in range(0, uip.loglen):
                # Even when the log is raw we want the first timestamp
                if y >= len(timestamps) or isinstance(timestamps[y], str) \
                        or timestamps[uip.yoffset + y] == none_timestamp():
                    timestamp = "".ljust(uip.tspadwidth)
                else:
                    timestamp = str(timestamps[y])[0:uip.tspadwidth]

                if y >= len(facilities) or facilities[y] == "":
                    facility = ""
                else:
                    if facilities[y].strip() == "":
                        facility = f" {facilities[y]}  "
                    else:
                        facility = f"<{facilities[y]}> "

                if uip.yoffset + y >= len(severities):
                    severity_str = f"{lvl_to_4letter_severity(LogLevel.INFO)}: "
                else:
                    severity_str = f"{lvl_to_4letter_severity(severities[y])}: "

                message = themearray_to_string(messages[y])

                if raw_logs:
                    data += f"{timestamp}  {message}\n"
                else:
                    data += f"{timestamp}  {severity_str}{facility}{message}\n"

            secure_write_string(FilePath(filename), data, allow_relative_path=True)

    # Should be unreachable
    return Retval.RETURNFULL


# pylint: disable-next=too-many-locals,too-many-branches
def do_command(stdscr: curses.window, **kwargs: Any) -> None:
    """
    Execute a command on localhost.
    XXX: This should be renamed.

        Parameters:
            stdscr (opaque): A curses stdscr reference
            **kwargs (dict): Additional parameters
                obj (dict): An object to get data from
                command ([str]): The command to execute
                input_path (str): The path to get input from
                wait_for_keypress (bool): Wait for a keypress after executing the command
                msg (str): The message to show before executing the command
    """
    security_policy: SecurityPolicy = SecurityPolicy.ALLOWLIST_RELAXED
    fallback_allowlist: list[str] = ["/bin", "/sbin", "/usr/bin", "/usr/sbin",
                                     "/usr/local/bin", "/usr/local/sbin", f"{HOMEDIR}/bin"]

    _args: list[Union[str, list[str]]] = deep_get(kwargs, DictPath("command"), [])
    input_path: str = deep_get(kwargs, DictPath("input_path"))

    if not _args:
        return

    obj = deep_get(kwargs, DictPath("obj"), {})

    if input_path is not None:
        if input_path:
            command_input = deep_get(obj, DictPath(input_path))
        else:
            command_input = obj
        if not isinstance(command_input, str):
            command_input = None
        else:
            command_input = command_input.encode("utf-8")
    else:
        command_input = None

    args = []
    for arg in _args:
        if isinstance(arg, str):
            args.append(arg)
        elif isinstance(arg, list):
            for path in arg:
                tmp = deep_get(obj, DictPath(path))
                if isinstance(tmp, str):
                    args.append(tmp)
                elif isinstance(tmp, list):
                    args += tmp
                else:
                    sys.exit("widget_args: command requested incorrect data type; "
                             "only str and list are valid")

    wait_for_keypress = deep_get(kwargs, DictPath("wait_for_keypress"), False)

    curses.endwin()
    _retval = clear_screen()
    if (msg := deep_get(kwargs, DictPath("msg"), "")):
        ansithemeprint([ANSIThemeStr(f"{msg}\n", "action")])

    try:
        _cpath = secure_which(FilePath(args[0]),
                              fallback_allowlist=fallback_allowlist,
                              security_policy=security_policy)
    except FileNotFoundError:
        ansithemeprint([ANSIThemeStr("Error", "error"),
                        ANSIThemeStr(": “", "default"),
                        ANSIThemeStr(f"{args[0]}", "programname"),
                        ANSIThemeStr("“ does not exist.\n", "default")], stderr=True)
        wait_for_keypress = True
    else:
        _retval = subprocess.run(args, check=False, input=command_input).returncode

    if wait_for_keypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    stdscr.refresh()


# noqa: E501 pylint: disable-next=too-many-arguments,too-many-locals,too-many-branches,too-many-positional-arguments,too-many-statements
def executecommand(stdscr: curses.window,
                   obj: dict, container: str, msg: list[ANSIThemeStr],
                   command: list[str], waitforkeypress: bool) -> None:
    """
    Executes a command in a container.
    XXX: This should be renamed.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            obj (dict): The object to operate on
            container (str): The name of the container to execute the command in
            msg ([ANSIThemeStr]): The message to output before executing the command
            command ([str]): The command to execute
            waitforkeypress (bool): Wait for a keypress after executing the command?
                                    True to wait, False to return immediately
    """
    try:
        kubectl_path = secure_which(FilePath("/usr/bin/kubectl"),
                                    fallback_allowlist=["/etc/alternatives"],
                                    security_policy=SecurityPolicy.ALLOWLIST_RELAXED)
    except FileNotFoundError:
        curses_helper.alert(stdscr, message="Could not find kubectl; is it installed?",
                            wait_for_keypress=True)
        return

    # This should probably be done using connect_get_namespaced_pod_exec()
    curses.endwin()
    _retval = clear_screen()
    ansithemeprint(msg)
    print()
    if obj is not None:
        obj_name = deep_get(obj, DictPath("metadata#name"))
        obj_namespace = deep_get(obj, DictPath("metadata#namespace"))
        # This is a request to create a new ephemeral container
        if command == ["<ephemeral>"]:
            ephemeral_image = \
                deep_get(cmtlib.cmtconfig, DictPath("Debug#ephemeral_image"), "busybox")
            args = [kubectl_path, "debug", obj_name, "--target", container, "-n", obj_namespace,
                    "--profile", "general", "-i", "-t", "--image", ephemeral_image]
            result = subprocess.run(args, check=False)
            if result.returncode != 0:
                ansithemeprint([ANSIThemeStr("Error", "error"),
                                ANSIThemeStr(": Failed to create debug image", "default")],
                               stderr=True)
                waitforkeypress = True
        elif command == ["<dnsutils>"]:
            dnsutils_image = deep_get(cmtlib.cmtconfig, DictPath("Debug#network_image"),
                                      "registry.k8s.io/e2e-test-images/jessie-dnsutils:1.7")
            args = [kubectl_path, "debug", f"node/{obj_name}", "-n", "default", "-i", "-t",
                    "--profile", "netadmin", "--image", dnsutils_image, "--attach=false"]
            result = subprocess.run(args, stdout=PIPE, stderr=STDOUT, check=False)
            if result.returncode != 0:
                ansithemeprint([ANSIThemeStr("Error", "error"),
                                ANSIThemeStr(": Failed to create debug image", "default")],
                               stderr=True)
                waitforkeypress = True
            else:
                output = result.stdout.decode("utf-8", errors="replace")
                tmp = re.match(r"^Creating debugging pod (\S+) with container (\S+) .*", output)
                if tmp is not None:
                    pod_name = tmp[1]
                    container_name = tmp[2]

                    # Wait for the pod to be ready
                    ansithemeprint([ANSIThemeStr("Waiting for debug pod to be ready "
                                                 "(timeout: 60s).", "default")])
                    args = [kubectl_path, "wait", "--for=condition=ready",
                            "--timeout=60s", "-n", "default", "pod", pod_name]
                    result = subprocess.run(args, stdout=PIPE, stderr=STDOUT, check=False)
                    if result.returncode != 0:
                        ansithemeprint([ANSIThemeStr("Error", "error"),
                                        ANSIThemeStr(": The pod failed to become ready before "
                                                     "timeout.", "default")], stderr=True)
                        waitforkeypress = True
                    else:
                        # Attach to the debug container
                        args = [kubectl_path, "attach", "-n", "default", pod_name,
                                "-c", container_name,
                                "-i", "-t", "--pod-running-timeout=1m0s"]
                        _result = subprocess.run(args, check=False)
                else:
                    errmsg = [
                        [("Failed to parse output from kubectl debug; {output}.", "default")]
                    ]
                    unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
                    cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
                    formatted_msg[0].insert(0, ANSIThemeStr("Error: ", "error"))
                    for line in formatted_msg:
                        ansithemeprint(line)

                # Delete the pod
                ansithemeprint([ANSIThemeStr("Forcibly deleting pod.", "default")])
                _message, _status = \
                    kh.delete_obj_by_kind_name_namespace(("Pod", ""), pod_name,
                                                         "default", force=True)
                waitforkeypress = True
        else:
            args = [kubectl_path, "exec", obj_name, "-n", obj_namespace,
                    "-i", "-t", "--container", container, "--"] + command
            _result = subprocess.run(args, check=False).returncode
    else:
        errmsg = [
            [("Function called with invalid argument(s):", "default")],
            [("obj = ", "default"),
             (f"{obj}", "argument"),
             (" (type: ", "default"),
             (f"{type(obj)}", "argument"),
             (", expected: ", "default"),
             (f"{dict}", "argument"),
             (")", "default")],
        ]
        unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
        cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
        formatted_msg[0].insert(0, ANSIThemeStr("Error: ", "error"))
        for line in formatted_msg:
            ansithemeprint(msg)
        waitforkeypress = True

    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    stdscr.refresh()


# pylint: disable-next=too-many-branches
def listviewdispatch(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Dispatch from an object to listview of a Kind

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict): The object to get information from
                kind_path (DictPath): The path to get the kind from
                api_version_path (DictPath): The path to get the API-version from
        Returns:
            (Retval): Retval.NOMATCH if no match was found
                      otherwise Retval from the involved object whenever that returns.
    """
    global defaultview  # pylint: disable=global-statement

    root: bool = deep_get(kwargs, DictPath("root"), False)
    obj = deep_get(kwargs, DictPath("obj"))
    selection = deep_get(kwargs, DictPath("selection"))
    if not root and obj is None and selection is None:
        return Retval.RETURNDONE

    kind = deep_get(kwargs, DictPath("kind"))
    kind_path = deep_get(kwargs, DictPath("kind_path"))
    if kind_path is not None:
        if isinstance(kind_path, str):
            kind_path = [kind_path]
            kind = deep_get_with_fallback(obj, kind_path)
        elif isinstance(kind_path, int) and selection is not None and selection:
            tmp = selection[kind_path]
            if tmp is not None:
                kind = themearray_to_string(tmp)
    api_family = deep_get_with_fallback(kwargs, [DictPath("api_family"), DictPath("api_group")])
    api_group_path = \
        deep_get_with_fallback(kwargs, [DictPath("api_family_path"), DictPath("api_group_path")])
    if api_group_path is not None:
        if isinstance(api_group_path, str):
            api_group_path = [api_group_path]
            api_family = deep_get_with_fallback(obj, api_group_path)
        else:
            tmp = selection[api_group_path]
            if tmp is not None:
                api_family = themearray_to_string(tmp)

    if kind is None:
        return Retval.RETURNDONE
    if api_family is None:
        api_family = ""
    if "/" in api_family:
        api_family, _api_version = api_family.split("/")
    else:
        # Is the api_family only a version#? Then it's a core API
        tmp = re.match(r"^v\d+(alpha\d+|beta\d+|)", api_family)
        if tmp is not None:
            api_family = ""

    if isinstance(kind, str):
        kind = (kind, api_family)
    view = checkforview(kind)

    if view is not None:
        if root:
            defaultview = view
            return Retval.RETURNFULL

        if "viewfunc" in views[view]:
            viewfunc = views[view]["viewfunc"]
        else:
            viewfunc = genericlistloop
        return viewfunc(stdscr, kind=view)

    return Retval.RETURNDONE


# pylint: disable-next=unused-argument
def patch_object(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Patch an object.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                kind ((str, str)): The kind of the object to patch
                name (str): The name of the object to patch
                namespace (str): The namespace of the object to patch
                subresource (str): The name of the subresource to patch (optional)
                strategic_merge (bool): Perform a strategic merge?
                patch (dict): The patch to apply
        Returns:
            (Retval): The return value
    """
    kind: tuple[str, str] = deep_get(kwargs, DictPath("kind"))
    name: str = deep_get(kwargs, DictPath("name"))
    namespace: str = deep_get(kwargs, DictPath("namespace"))
    patch: dict[str, Any] = deep_get(kwargs, DictPath("args#patch"))
    values: dict[str, Any] = deep_get(kwargs, DictPath("values"), {})
    path_substitutions: list[dict[str, Any]] = \
        deep_get(kwargs, DictPath("args#path_substitutions"), [])
    subresource: str = deep_get(kwargs, DictPath("args#subresource"), "")
    strategic_merge: bool = deep_get(kwargs, DictPath("args#strategic_merge"), False)

    for key_path, value_path in path_substitutions.items():
        value: Any = deep_get(values, DictPath(value_path))
        deep_set(patch, DictPath(key_path), value, create_path=True)

    _message, _status = kh.patch_obj_by_kind_name_namespace(kind, name, namespace, patch,
                                                            subresource=subresource,
                                                            strategic_merge=strategic_merge)
    return Retval.RETURNDONE


# This dispatches to info views; as soon as one is added this function will
# dispatch to that view.
def resourceinfodispatch(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Dispatch from an object to the infoview of another object.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict): The object to get information from
                kind_path (DictPath): The path to get the kind from
                api_version_path (DictPath): The path to get the API-version from
                name_path (DictPath): The path to get name from
                namespace_path (DictPath): The path to get namespace from
        Returns:
            (Retval): Retval.NOMATCH if no match was found or a container had invalid status,
                      otherwise Retval from the involved object whenever that returns.
    """
    kind: Union[str, tuple[str, str]] = deep_get(kwargs, DictPath("kind"), ("", ""))
    obj: dict = deep_get(kwargs, DictPath("obj"))
    info = deep_get(kwargs, DictPath("info"))

    if obj is None:
        return Retval.NOMATCH

    if kind == ("", ""):
        kind = deep_get(obj, DictPath("kind"), "")
        if isinstance(kind, str):
            api_version = deep_get(obj, DictPath("apiVersion"), "")
            # Is this a core API?
            if "/" not in api_version:
                api_family = ""
            else:
                api_family = api_version.split("/")[0]
            kind = (kind, api_family)
        kwargs.pop("apiVersion", None)
        kwargs["kind"] = kind

    # Exceptions
    if kind in (("Container", ""), ("InitContainer", ""), ("EphemeralContainer", "")):
        # Do not try to open pending containers
        containername = deep_get(obj, DictPath("name"), "")
        src_statuses = {}
        if kind == ("InitContainer", ""):
            src_statuses = deep_get(info, DictPath("status#initContainerStatuses"))
        else:
            src_statuses = deep_get(info, DictPath("status#containerStatuses"))
        # Get the status of the container
        status, _status_group, _restarts, _message, _age = \
            datagetters.get_container_status(src_statuses, containername)
        if status in ("ContainerCreating", "CreateContainerError", "ErrImagePull",
                      "ImagePullBackOff", "Pending", "PodInitializing", "UNKNOWN"):
            return Retval.NOMATCH
        return containerinfoloop(stdscr, obj=info, kind=kind, container=obj)

    if kind in infoviews:
        return genericinfoloop(stdscr, **kwargs)

    return Retval.RETURNDONE


def resourceinfodispatch_from_pod_resource_list(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Dispatch from a pod resource to the infoview of that object.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict): The object to get information from
                kind (str): The kind of the object to dispatch to
                api_version (str): The API-version of the object to dispatch to
        Returns:
            (Retval): Retval.RETURNDONE if no match was found, otherwise
                      Retval from the involved object whenever that returns.
    """
    kind = deep_get_with_fallback(kwargs, [DictPath("obj#ref#kind"),
                                           DictPath("obj#kind"),
                                           DictPath("kind")])
    api_family = deep_get_with_fallback(kwargs, [DictPath("obj#ref#api_group"),
                                                 DictPath("obj#api_group"),
                                                 DictPath("api_group")], "")
    kwargs["obj"] = deep_get_with_fallback(kwargs, [DictPath("obj#ref"), DictPath("obj")])
    kwargs["kind"] = (kind, api_family)

    return resourceinfodispatch(stdscr, **kwargs)


def resourceinfodispatch_from_selection(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Dispatch from a selection to the infoview of another object.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict): The object to get information from
                kind (str): The kind of the object to dispatch to
                api_version (str): The API-version of the object to dispatch to
        Returns:
            (Retval): Retval.RETURNDONE if no match was found, otherwise
                      Retval from the involved object whenever that returns.
    """
    # Do not pass both direct and _path versions at the same time
    obj = deep_get(kwargs, DictPath("selection"))
    kind = deep_get(kwargs, DictPath("kind"))
    api_family = deep_get(kwargs, DictPath("api_family"), "")
    kwargs.pop("kind", None)
    kwargs.pop("api_family", None)
    return resourceinfodispatch(stdscr, obj=obj, kind=(kind, api_family), **kwargs)


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def resourceinfodispatch_with_lookup(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Dispatch to an object after doing various types of path-based lookups from
    the source object.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict): The object to get information from
                selected (dict): The selected obj from a listpad
                selected_obj (dict): The selected obj from a widget list
                _selected_obj (dict): The selected obj from a widget list
                selection (Any): The selection data
                kind (str | (str, str)): The kind
                kind_path (DictPath): The path to get the kind from
                api_group (str): The API-group
                api_group_path (DictPath): The path to get the API-group from
                api_version (str): The API-version
                api_version_path (DictPath): The path to get the API-version from
                name (str): The object name
                name_path (DictPath): The path to get name from
                namespace (str): The object namespace
                namespace_path (DictPath): The path to get namespace from
                namespaced_name (str): A "namespace<separator>name" string
                namespaced_name_path (str): The path to a "namespace<separator>name" string
                namespaced_name_separator (str): The separator for the namespaced_name string
                _parent_namespace: Namespace of the parent object
                owner_reference_path (DictPath): The path to the owner reference
                holder_identity_path (DictPath): The path to the holder identity
        Returns:
            (Retval): Retval.NOMATCH if no match was found or the kind is unknown,
                      otherwise Retval from the involved object whenever that returns.
    """
    # Do not pass both direct and _path versions at the same time
    obj = deep_get(kwargs, DictPath("obj"))
    # pylint: disable-next=too-many-nested-blocks
    if obj is None:
        if "selected_obj" in kwargs:
            obj = deep_get(kwargs, DictPath("selected_obj"))
        elif "selected" in kwargs:
            selected = deep_get(kwargs, DictPath("selected"))
            if "_selected_objs" in kwargs:
                obj = {}
                for key, attribute in deep_get(kwargs, DictPath("_selected_objs"), []).items():
                    if isinstance(attribute, list):
                        tmp = getattr(selected, attribute[0])
                        if tmp is not None:
                            obj[key] = tmp[attribute[1]]
                        else:
                            obj[key] = None
                    else:
                        obj[key] = getattr(selected, attribute)
            else:
                obj = selected

    selection = deep_get(kwargs, DictPath("selection"))
    fields = []
    if isinstance(selection, dict):
        if obj is None:
            obj = selection
        tmp_fields = deep_get(selection, DictPath("fields"), [])
        if isinstance(tmp_fields, (list, tuple)):
            fields = tmp_fields
    elif isinstance(selection, (list, tuple)):
        fields = selection

    name = deep_get(kwargs, DictPath("name"))
    namespace = deep_get(kwargs, DictPath("namespace"))
    namespaced_name = deep_get(obj, DictPath("namespacedName"))
    namespaced_name_separator = deep_get(kwargs, DictPath("namespaced_name_separator"), "/")
    namespaced_name_enabled_path = deep_get(kwargs, DictPath("namespaced_name_enabled_path"))
    namespaced_name_enabled = True
    namespaced_name_path = None

    name_path = deep_get(kwargs, DictPath("name_path"))
    if isinstance(name_path, str):
        name_path = [name_path]
    namespace_path = deep_get(kwargs, DictPath("namespace_path"), "")
    if isinstance(namespace_path, str):
        namespace_path = [namespace_path]
    namespaced_name_path = deep_get(kwargs, DictPath("namespaced_name_path"), "")
    if isinstance(namespaced_name_path, str):
        namespaced_name_path = [namespaced_name_path]
        if namespaced_name_enabled_path is not None:
            namespaced_name_enabled = deep_get(obj, DictPath(namespaced_name_enabled_path), True)
    else:
        namespaced_name_enabled = False

    kind = deep_get(kwargs, DictPath("kind"))
    api_family = ""

    # If kind is a dict it contains further rules (and provides both kind and api_family)
    if isinstance(kind, dict):
        substitutions = deep_get(kind, DictPath("substitutions"), {})
        kind_path = deep_get(kind, DictPath("path"), "")
        kind = deep_get(obj, DictPath(kind_path))
        api_family = deep_get(substitutions, DictPath(f"{kind}#api_family"), "")
        kind = deep_get(substitutions, DictPath(f"{kind}#kind"), kind)

    kind_path = deep_get(kwargs, DictPath("kind_path"))
    if kind_path is not None:
        if isinstance(kind_path, str):
            kind_path = [kind_path]
        elif isinstance(kind_path, int) and fields:
            if not isinstance(selection, (list, tuple)) \
                    and not isinstance(deep_get(selection, DictPath("fields")), (list, tuple)):
                errmsg = [
                    [("kind_path", "argument"),
                     (" is an index, but ", "default"),
                     ("selection", "argument"),
                     (" is of non-indexable type ", "default"),
                     (f"{type(selection)}", "argument"),
                     (".", "default")],
                ]
                unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
                cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
                return Retval.NOMATCH
            if kind_path >= len(fields):
                errmsg = [
                    [("kind_path", "argument"),
                     (" index ", "default"),
                     (f"{kind_path}", "argument"),
                     (" is out of bounds; valid range: [", "default"),
                     ("0", "argument"),
                     ("-", "default"),
                     (f"{len(fields)}", "argument"),
                     ("].", "default")],
                ]
                unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
                cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
                return Retval.NOMATCH
            tmp = fields[kind_path]
            if tmp is not None:
                kind = themearray_to_string(tmp)

    api_group = deep_get_with_fallback(kwargs, [DictPath("api_family"),
                                                DictPath("api_group")], api_family)
    api_group_path = deep_get_with_fallback(kwargs, [DictPath("api_family_path"),
                                                     DictPath("api_group_path")])
    if api_group_path is not None:
        if isinstance(api_group_path, str):
            api_group_path = [api_group_path]
        elif isinstance(api_group_path, int) and fields:
            if not isinstance(selection, (list, tuple)) \
                    and not isinstance(deep_get(selection, DictPath("fields")), (list, tuple)):
                errmsg = [
                    [("api_group_path", "argument"),
                     (" is an index, but ", "default"),
                     ("selection", "argument"),
                     (" is of non-indexable type ", "default"),
                     (f"{type(selection)}", "argument"),
                     (".", "default")],
                ]
                unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
                cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
                return Retval.NOMATCH
            if api_group_path >= len(fields):
                errmsg = [
                    [("api_group_path", "argument"),
                     (" index ", "default"),
                     (f"{api_group_path}", "argument"),
                     (" is out of bounds; valid range: [", "default"),
                     ("0", "argument"),
                     ("-", "default"),
                     (f"{len(fields)}", "argument"),
                     ("].", "default")],
                ]
                unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
                cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
                return Retval.NOMATCH
            tmp = fields[api_group_path]
            if tmp is not None:
                api_group = themearray_to_string(tmp)

    api_version_path = deep_get(kwargs, DictPath("api_version_path"))
    if api_version_path is not None:
        if isinstance(api_version_path, str):
            api_version_path = [api_version_path]
        elif isinstance(api_version_path, int) and fields:
            if not isinstance(selection, (list, tuple)) \
                    and not isinstance(deep_get(selection, DictPath("fields")), (list, tuple)):
                errmsg = [
                    [("api_version_path", "argument"),
                     (" is an index, but ", "default"),
                     ("selection", "argument"),
                     (" is of non-indexable type ", "default"),
                     (f"{type(selection)}", "argument"),
                     (".", "default")],
                ]
                unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
                cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
                return Retval.NOMATCH
            if api_version_path >= len(fields):
                errmsg = [
                    [("api_version_path", "argument"),
                     (" index ", "default"),
                     (f"{api_version_path}", "argument"),
                     (" is out of bounds; valid range: [", "default"),
                     ("0", "argument"),
                     ("-", "default"),
                     (f"{len(fields)}", "argument"),
                     ("].", "default")],
                ]
                unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
                cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
                return Retval.NOMATCH
            tmp = fields[api_version_path]
            if tmp is not None:
                api_version = themearray_to_string(tmp)
                if api_version is not None:
                    if "/" in api_version:
                        api_group = api_version.split('/', maxsplit=1)[0]
                    else:
                        api_group = ""

    owner_reference_path = deep_get(kwargs, DictPath("owner_reference_path"))
    holder_identity_path = deep_get(kwargs, DictPath("holder_identity_path"))

    # When a path is an integer it references a field in selected
    if isinstance(name_path, int):
        if not isinstance(selection, (list, tuple)) \
                and not isinstance(deep_get(selection, DictPath("fields")), (list, tuple)):
            errmsg = [
                [("name_path", "argument"),
                 (" is an index, but ", "default"),
                 ("selection", "argument"),
                 (" is of non-indexable type ", "default"),
                 (f"{type(selection)}", "argument"),
                 (".", "default")],
            ]
            unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
            cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
            return Retval.NOMATCH
        if name_path >= len(fields):
            errmsg = [
                [("name_path", "argument"),
                 (" index ", "default"),
                 (f"{name_path}", "argument"),
                 (" is out of bounds; valid range: [", "default"),
                 ("0", "argument"),
                 ("-", "default"),
                 (f"{len(fields)}", "argument"),
                 ("].", "default")],
            ]
            unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
            cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
            return Retval.NOMATCH
        tmp = fields[name_path]
        if tmp is not None:
            name = themearray_to_string(tmp)
    if isinstance(namespace_path, int) and selection is not None and selection:
        if not isinstance(selection, (list, tuple)) \
                and not isinstance(deep_get(selection, DictPath("fields")), (list, tuple)):
            errmsg = [
                [("namespace_path", "argument"),
                 (" is an index, but ", "default"),
                 ("selection", "argument"),
                 (" is of non-indexable type ", "default"),
                 (f"{type(selection)}", "argument"),
                 (".", "default")],
            ]
            unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
            cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
            return Retval.NOMATCH
        if namespace_path >= len(fields):
            errmsg = [
                [("namespace_path", "argument"),
                 (" index ", "default"),
                 (f"{namespace_path}", "argument"),
                 (" is out of bounds; valid range: [", "default"),
                 ("0", "argument"),
                 ("-", "default"),
                 (f"{len(fields)}", "argument"),
                 ("].", "default")],
            ]
            unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
            cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
            return Retval.NOMATCH
        tmp = fields[namespace_path]
        if tmp is not None:
            namespace = themearray_to_string(tmp)

        # If an integer namespace is empty, the namespace is (most likely)
        # the same namespace as the parent. This should not interfere with non-namespaced
        # APIs, since they ignore the namespace
        if namespace is None or not namespace:
            namespace = deep_get(kwargs, DictPath("_parent_namespace"), "")

    if obj is not None:
        kind = deep_get_with_fallback(obj, kind_path, kind)
        if kind is not None and kind:
            if isinstance(api_version_path, list):
                api_version = deep_get_with_fallback(obj, api_version_path)
                if api_version is not None:
                    if "/" in api_version:
                        api_group = api_version.split("/")[0]
                    else:
                        api_group = ""
            api_group = deep_get_with_fallback(obj, api_group_path, api_group)

    if not isinstance(kind, tuple):
        if api_group is None:
            api_group = ""
        kind = (kind, api_group)

    controller = None
    non_controller = None

    holder_identity = None
    if holder_identity_path is not None:
        holder_identity = deep_get(obj, DictPath(holder_identity_path))

    if owner_reference_path is not None and obj is not None:
        # Search for a controller, or the first reference that matches the kind if specified
        owner_references = deep_get(obj, DictPath(owner_reference_path), [])
        for ref in owner_references:
            ref_name = deep_get(ref, DictPath("name"))

            # We only want to dispatch if there's an owner reference
            # that matches the holder identity
            if holder_identity is not None and ref_name != holder_identity:
                continue

            ref_kind = deep_get(ref, DictPath("kind"))
            ref_api_version = deep_get(ref, DictPath("apiVersion"))
            if "/" in ref_api_version:
                ref_api_family = ref_api_version.split("/")[0]
            else:
                ref_api_family = ""
            ref_kind = (ref_kind, ref_api_family)
            accept_only_owner = deep_get(kwargs, DictPath("accept_only_owner"), False)
            if deep_get(ref, DictPath("controller"), False):
                controller = (ref_kind, ref_name)
            elif kind is not None and kind == ref_kind \
                    or holder_identity is not None \
                    or accept_only_owner and len(owner_references) == 1:
                if non_controller is None:
                    non_controller = (ref_kind, ref_name)

    if controller is not None:
        kind, name = controller
    elif non_controller is not None:
        kind, name = non_controller
    else:
        if name is None and obj is not None:
            name = deep_get_with_fallback(obj, name_path)
            # This is needed since CiliumID, for instance, is an integer
            if name is not None:
                name = str(name)

    if kind is None or isinstance(kind, tuple) and kind[0] is None:
        return Retval.NOMATCH

    if namespaced_name_path is not None:
        namespaced_name = deep_get_with_fallback(obj, DictPath(namespaced_name_path))
    if namespaced_name is not None and namespaced_name_enabled:
        tmp = namespaced_name.split(namespaced_name_separator)
        if len(tmp) == 2:
            namespace, name = tmp

    if name is None or not name:
        return Retval.NOMATCH

    if namespace is None and obj is not None:
        namespace = deep_get_with_fallback(obj, namespace_path)

    parent_namespace = deep_get(kwargs, DictPath("_parent_namespace"), "")
    if namespace is None and parent_namespace is not None:
        namespace = parent_namespace

    # If the kind is unknown we will get NameError;
    # in this case we probably do not want to crash
    try:
        kind = guess_kind(kind)
    except NameError:
        obj = None

    # If the kind is unknown we will get NameError;
    # in this case we probably do not want to crash
    try:
        obj = kh.get_ref_by_kind_name_namespace(kind, name, namespace, resource_cache=kh_cache)
    except NameError:
        return Retval.NOMATCH

    return resourceinfodispatch(stdscr, obj=obj, kind=kind)


def __run_playbook(playbookpath: FilePath, hosts: list[str], **kwargs: Any) -> int:
    extra_values: dict[str, Any] = deep_get(kwargs, DictPath("extra_values"), {})
    quiet: bool = deep_get(kwargs, DictPath("quiet"), False)
    verbose: bool = deep_get(kwargs, DictPath("verbose"), False)

    # Set necessary Ansible keys before running playbooks
    http_proxy: str = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), "")
    https_proxy: str = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), "")
    no_proxy: str = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), "")

    use_proxy = "no"
    if http_proxy or https_proxy:
        use_proxy = "yes"

    values: dict[str, Any] = {
        "http_proxy": http_proxy,
        "https_proxy": https_proxy,
        "no_proxy": no_proxy,
        "use_proxy": use_proxy,
    }
    merged_values = {**values, **extra_values}

    retval, ansible_results = \
        ansible_run_playbook_on_selection(playbookpath, selection=hosts, values=merged_values,
                                          verbose=verbose, quiet=quiet)
    if verbose:
        ansithemeprint([ANSIThemeStr("", "default")])

    if not quiet:
        ansible_print_play_results(retval, ansible_results, verbose=verbose)

    return retval


def run_playbook(playbook: dict, hosts: list[str], values: Optional[dict] = None) -> int:
    """
    Run a playbook.

        Parameters:
            playbook (dict): The playbook to run.
            hosts ([str]): The hosts to run the playbook on.
            values (dict): A dict of parameters to pass to __run_playbook()
        Returns:
            (int): The return value from __run_playbook()
    """
    verbose: bool = deep_get(cmtlib.cmtconfig, DictPath("Ansible#verbose"), False)
    return __run_playbook(FilePath(cast(str, playbook.get("playbook"))), hosts,
                          extra_values=values, verbose=verbose)


def view_obj(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    View an object using the resource view.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict[str, Any]): An object to extract data from
                selection (Any): The selection data
                named_title (str): The title to use for the window
                title (str): The title to use for the window
                title_path (str): The path to fetch the title from
                path (str): The path to the data to view
                include_root (bool): Include the object root (currently necessary for list objects)
                formatter (Callable|str): The formatter to use to format the data
    """
    selection = deep_get(kwargs, DictPath("selection"))
    if selection is not None:
        obj = selection
    else:
        obj = deep_get(kwargs, DictPath("obj"))
    if obj is None:
        return Retval.RETURNDONE
    title = deep_get_with_fallback(kwargs, [DictPath("named_title"), DictPath("title")])
    title_path = deep_get(kwargs, DictPath("title_path"))
    if title_path is not None:
        title = deep_get(obj, DictPath(title_path))
    path = deep_get(kwargs, DictPath("path"))
    formatter = deep_get(kwargs, DictPath("formatter"), formatters.format_yaml)
    if path is not None:
        if deep_get(kwargs, DictPath("include_root"), False):
            obj = [{f"{path.rsplit('#')[-1]}": deep_get(obj, DictPath(path))}]
        # pylint: disable-next=comparison-with-callable
        elif formatter == formatters.format_yaml:
            obj = [deep_get(obj, DictPath(path))]
        else:
            obj = deep_get(obj, DictPath(path))
    else:
        obj = [obj]
    if isinstance(formatter, str):
        _formatter = deep_get(formatter_allowlist, DictPath(formatter))
        if _formatter is None:
            raise ValueError(f"{formatter} is not in formatter_allowlist")
        formatter = _formatter
    return resourceinfodispatch(stdscr, obj=obj, kind=("__ResourceView", ""),
                                title=title, formatter=formatter)


def view_yaml(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    View data formatted as YAML.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                selection (dict): The selected object
                obj (dict): The object to get information from
                path (str): The path to get the data from
                include_root (bool): Include the object root (currently necessary for list objects)
                named_title (str): The title to use for the window
                title (str): The title to use for the window
        Returns:
            (Retval): The return value
    """
    selection = deep_get(kwargs, DictPath("selection"))
    if selection is not None:
        obj = selection
    else:
        obj = deep_get(kwargs, DictPath("obj"))

    if obj is None:
        return Retval.RETURNDONE
    path = deep_get(kwargs, DictPath("path"))
    if path is not None:
        if deep_get(kwargs, DictPath("include_root"), False):
            _obj = {f"{path.rsplit('#')[-1]}": deep_get(obj, DictPath(path))}
        else:
            _obj = deep_get(obj, DictPath(path))
        if _obj is None:
            return Retval.RETURNDONE
        obj = [_obj]
    else:
        obj = [obj]
    title = deep_get_with_fallback(kwargs, [DictPath("named_title"), DictPath("title")])
    formatter = formatters.format_yaml
    return resourceinfodispatch(stdscr, obj=obj, kind=("__ResourceView", ""),
                                title=title, formatter=formatter)


def view_json(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    View data formatted as JSON.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                selection (dict): The selected object
                obj (dict): The object to get information from
                path (str): The path to get the data from
                include_root (bool): Include the object root (currently necessary for list objects)
                named_title (str): The title to use for the window
                title (str): The title to use for the window
        Returns:
            (Retval): The return value
    """
    selection = deep_get(kwargs, DictPath("selection"))
    if selection is not None:
        obj = selection
    else:
        obj = deep_get(kwargs, DictPath("obj"))

    if obj is None:
        return Retval.RETURNDONE
    path = deep_get(kwargs, DictPath("path"))
    if path is not None:
        if deep_get(kwargs, DictPath("include_root"), False):
            _obj = {f"{path.rsplit('#')[-1]}": deep_get(obj, DictPath(path))}
        else:
            _obj = deep_get(obj, DictPath(path))
        if _obj is None:
            return Retval.RETURNDONE
        obj = [_obj]
    else:
        obj = [obj]
    title = deep_get_with_fallback(kwargs, [DictPath("named_title"), DictPath("title")])
    formatter = formatters.reformat_json
    return resourceinfodispatch(stdscr, obj=obj, kind=("__ResourceView", ""),
                                title=title, formatter=formatter)


def view_pod_logs(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    View pod logs.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                selected (dict): The selected obj from a listpad
                _tagged_items (list): A list of tagged items
    """
    containers: list[tuple[str, str, str]] = []
    containers_full: list[tuple[str, str, str, str]] = []
    items = deep_get(kwargs, DictPath("_tagged_items"), [])
    selected = deep_get(kwargs, DictPath("selected"))
    if selected is not None:
        items = [selected]
    namespaces = set()
    for obj in items:
        namespace = getattr(obj, "namespace")
        namespaces.add(namespace)
        name = getattr(obj, "name")
        container_name = getattr(obj, "container")
        image_id = getattr(obj, "image_id")
        containers.append((namespace, name, container_name))
        containers_full.append((namespace, name, container_name, image_id))

    multilog_args: dict[str, Any] = {
        "multilog_containers": containers,
        "multilog_containers_full": containers_full,
        "all_same_namespace": len(namespaces) == 1,
    }

    return containerinfoloop(stdscr, container=None, kind=None, obj=None, **multilog_args)


def action_view_pod_logs(**kwargs: Any) -> Retval:
    """
    Action used by the Pod log viewer.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                uip (UIProps): A reference to the UI Properties object
                values (dict[str, Any]): The items to operate on
        Returns:
            (Retval): The return value
    """
    uip: UIProps = deep_get(kwargs, DictPath("uip"))
    values: dict = deep_get(kwargs, DictPath("values"))
    return view_pod_logs(uip.stdscr, **values)


def view_last_applied_configuration(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    View the last applied configuration (if available).

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                uip (UIProps): A reference to the UI Properties object
                obj (dict): The object to extract data from
                title (str): The title to use for the page
        Returns:
            (Retval): The return value
    """
    obj: dict[str, Any] = deep_get(kwargs, DictPath("obj"), {})

    last_applied_configuration_path = \
        DictPath("metadata#annotations#kubectl.kubernetes.io/last-applied-configuration")
    last_applied_configuration = \
        deep_get(obj, last_applied_configuration_path, {})
    if last_applied_configuration is None or not last_applied_configuration:
        return Retval.RETURNDONE

    try:
        data = json.loads(last_applied_configuration)
    except DecodeException:
        return Retval.RETURNDONE

    title = deep_get(kwargs, DictPath("title"), "")
    # themearrays = formatters.format_yaml([data])
    formatter = formatters.format_yaml
    return resourceinfodispatch(stdscr, obj=[data], kind=("__ResourceView", ""),
                                title=title, formatter=formatter)


# pylint: disable-next=too-many-locals
def delete_resource(**kwargs: Any) -> Retval:
    """
    Delete resources.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                uip (UIProps): A reference to the UI Properties object
                kind (str): The kind of the resource to delete
                items ([str]): The list of resources to delete
                force (bool): Force-delete the resources? True to force deletion,
                              False to delete gracefully
                delete_owner (bool): Delete the owner too?
                owner_reference_path (str): The path to the owner reference
        Returns:
            (Retval): The return value
    """
    success: bool = True
    uip: UIProps = deep_get(kwargs, DictPath("uip"))
    kind: tuple[str, str] = deep_get(kwargs, DictPath("kind"))
    force: bool = deep_get(kwargs, DictPath("force"), False)
    items: list[str] = deep_get(kwargs, DictPath("items"), [])
    delete_owner: bool = deep_get(kwargs, DictPath("delete_owner"), False)
    owner_reference_path: str = deep_get(kwargs, DictPath("owner_reference_path"), "")

    for item in items:
        if isinstance(item, tuple):
            namespace, name = item
        else:
            namespace = ""
            name = item

        # Should we delete the controller too? If so we first need to lookup the object
        if delete_owner:
            obj = kh.get_ref_by_kind_name_namespace(kind, name, namespace)
            owner_reference: list[dict[str, Any]] = \
                deep_get(obj, DictPath(owner_reference_path), [])
            controller: tuple[tuple[str, str], str] = \
                get_controller_from_owner_references(owner_reference)
            if controller:
                message, status = \
                    kh.delete_obj_by_kind_name_namespace(controller[0], controller[1],
                                                         namespace, force=force)
                if status != 200:
                    # Status messages can be very verbose; delete everything from URL and on
                    tmp = re.match(r"^(.+?), URL:.*", message)
                    if tmp is not None:
                        message = tmp[1]
                    win = curses_helper.alert(uip.stdscr, message=message)
                    success = False
                    break

        message, status = kh.delete_obj_by_kind_name_namespace(kind, name, namespace, force=force)
        if status != 200:
            # Status messages can be very verbose; delete everything from URL and on
            tmp = re.match(r"^(.+?), URL:.*", message)
            if tmp is not None:
                message = tmp[1]
            win = curses_helper.alert(uip.stdscr, message=message)
            success = False
            break

    # We successfully deleted everything
    if success:
        win = curses_helper.notice(uip.stdscr,
                                   message="Successfully deleted all specified resources")

    # Wait for a keypress
    while True:
        uip.stdscr.timeout(100)
        c = uip.stdscr.getch()
        if c != -1:
            del win
            break

    return Retval.RETURNDONE


def force_delete_resource(**kwargs: Any) -> Retval:
    """
    Force delete resources.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                uip (UIProps): A reference to the UI Properties object
                kind (str): The kind of the resource to delete
                items ([str]): The list of resources to delete
        Returns:
            (Retval): The return value
    """
    kwargs["force"] = True
    return delete_resource(**kwargs)


def create_namespace(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Create a namespace.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                selection_vars#namespace (str): The name of the namespace to create
        Returns:
            (Retval): Retval.RETURNDONE
    """
    name = deep_get(kwargs, DictPath("selection_vars#namespace"))

    curses.endwin()
    _retval = clear_screen()

    # Verify that the name of the new namespace is valid
    if not validate_name("dns-label", name):
        msg = [ANSIThemeStr("Error: ", "error"),
               ANSIThemeStr("“", "default"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“ is not a valid name", "default")]
        ansithemeprint(msg, stderr=True)
    elif kh.get_ref_by_kind_name_namespace(("Namespace", ""), name, "",
                                           resource_cache=kh_cache) is not None:
        msg = [ANSIThemeStr("Error: ", "error"),
               ANSIThemeStr("namespace “", "default"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“ already exists", "default")]
        ansithemeprint(msg, stderr=True)
    else:
        msg = [ANSIThemeStr("Creating namespace “", "default"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“", "default")]
        ansithemeprint(msg)
        _msg, _status = kh.create_namespace(name)

    print("\n")

    waitforkeypress = True
    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    stdscr.refresh()

    return Retval.RETURNDONE


# Valid kinds:
# ("DaemonSet", "apps")
# ("Deployment", "apps")
# ("StatefulSet", apps")
def __restart_resource(kind: tuple[str, str], namespace: str, name: str) -> int:
    try:
        kubectl_path = secure_which(FilePath("/usr/bin/kubectl"),
                                    fallback_allowlist=["/etc/alternatives"],
                                    security_policy=SecurityPolicy.ALLOWLIST_RELAXED)
    except FileNotFoundError:
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("kubectl", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    args = [kubectl_path, "rollout", "restart",
            f"{kind[0]}.{kind[1]}/{name}", f"--namespace={namespace}"]
    result = subprocess.run(args, stdout=PIPE, stderr=PIPE, universal_newlines=True, check=False)
    return result.returncode


def __get_resource_scale(**kwargs: Any) -> int:
    """
    Get the scale of an object

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                kind ((str, str)): The kind of the object
                name (str): The name of the object
                namespace (str): The namespace of the object
        path (str): [optional] The path to the scale
    """
    kind: tuple[str, str] = deep_get(kwargs, DictPath("kind"), ("", ""))
    namespace: str = deep_get(kwargs, DictPath("namespace"), "")
    name: str = deep_get(kwargs, DictPath("name"), "")
    path: str = deep_get(kwargs, DictPath("path"), "status#replicas")
    obj = kh.get_ref_by_kind_name_namespace(kind, name, namespace, resource_cache=kh_cache)
    return deep_get(obj, DictPath(path))


# Valid kinds:
# ("Deployment", "apps")
# ("ReplicaSet", "apps")
# ("ReplicationController", "")
# ("StatefulSet", apps")
def __scale_replicas(**kwargs: Any) -> int:
    """
    Scale an object

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                kind ((str, str)): The kind of the object
                name (str): The name of the object
                namespace (str): The namespace of the object
                scale (int): The new scale
    """
    kind: tuple[str, str] = deep_get(kwargs, DictPath("kind"), ("", ""))
    namespace: str = deep_get(kwargs, DictPath("namespace"), "")
    name: str = deep_get(kwargs, DictPath("name"), "")
    scale: int = deep_get(kwargs, DictPath("scale"))

    try:
        kubectl_path = secure_which(FilePath("/usr/bin/kubectl"),
                                    fallback_allowlist=["/etc/alternatives"],
                                    security_policy=SecurityPolicy.ALLOWLIST_RELAXED)
    except FileNotFoundError:
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("kubectl", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    args = [kubectl_path, "scale", f"{kind[0]}.{kind[1]}/{name}",
            f"--namespace={namespace}", f"--replicas={scale}"]
    result = subprocess.run(args, stdout=PIPE, stderr=PIPE, universal_newlines=True, check=False)
    return result.returncode


def __edit_resource(kind: tuple[str, str], namespace: str, name: str) -> tuple[int, list[str]]:
    try:
        kubectl_path = secure_which(FilePath("/usr/bin/kubectl"),
                                    fallback_allowlist=["/etc/alternatives"],
                                    security_policy=SecurityPolicy.ALLOWLIST_RELAXED)
    except FileNotFoundError:
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("kubectl", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    if namespace is None:
        args = [kubectl_path, "edit", f"{kind[0]}.{kind[1]}/{name}"]
    else:
        args = [kubectl_path, "edit", f"{kind[0]}.{kind[1]}/{name}", f"--namespace={namespace}"]
    result = subprocess.run(args, universal_newlines=True, check=False)
    return result.returncode, args


# pylint: disable-next=too-many-locals,too-many-branches
def perform_action_on_configuration(uip: UIProps, **kwargs: Any) -> Retval:
    """
    Perform an action on a Kubernetes configuration file or Kustomization.

        Parameters:
            uip (UIProps): A reference to the UI Properties object
            **kwargs (dict[str, Any]): Keyword arguments
                values (dict[str, Any]):
                    resource_path (str): The path to the file to act on
                    resource_url (str): A URL to act on
                action (dict[str, Any]):
                    extravars (dict[str, Any]):
                        action (str): The action to perform (delete, create, apply)
                        rtype (str): The resource type ("Configuration File" or "Kustomization")
        Returns:
            (int): The return value from subprocess.run()
    """
    values: dict[str, Any] = deep_get(kwargs, DictPath("values"))
    action: dict[str, Any] = deep_get(kwargs, DictPath("action"))

    try:
        kubectl_path = secure_which(FilePath("/usr/bin/kubectl"),
                                    fallback_allowlist=["/etc/alternatives"],
                                    security_policy=SecurityPolicy.ALLOWLIST_RELAXED)
    except FileNotFoundError:
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("kubectl", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    if (resource_url := deep_get(values, DictPath("resource_url"))) is not None:
        if not resource_url.startswith(("http://", "https://")):
            return Retval.MATCH
        resource_path = resource_url
        rtype = deep_get(action, DictPath("extravars#rtype"))
    else:
        resource_path, rtype = values["resource_path"]

    configuration_action = deep_get(action, DictPath("extravars#action"))
    if configuration_action is None:
        raise ProgrammingError("perform_action_on_configuration() called without action'")
    if configuration_action not in ("delete", "create", "apply"):
        raise ProgrammingError(f"perform_action_on_configuration() does not support "
                               f"the action '{configuration_action}'")

    curses.endwin()
    _retval = clear_screen()

    kubectl_major_version, kubectl_minor_version, _kubectl_git_version, \
        _server_major_version, _server_minor_version, _server_git_version = kubectl_get_version()
    if kubectl_major_version is None or kubectl_minor_version is None:
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not extract ", "default"),
                        ANSIThemeStr("kubectl", "programname"),
                        ANSIThemeStr(" version; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)
    args: list = [kubectl_path]
    extra_options = []

    if configuration_action == "apply":
        if kubectl_major_version <= 1 and kubectl_minor_version < 22:
            configuration_action = "create"
        else:
            extra_options = ["--server-side"]

    args.append(configuration_action)
    args += extra_options

    if rtype == "Configuration File":
        args.append("-f")
    elif rtype == "Kustomization":
        args.append("-k")
    else:
        raise TypeError(f"Unknown resource type {rtype}; this is a programming error.")

    args.append(resource_path)
    result = subprocess.run(args, universal_newlines=True, check=False)

    # waitforkeypress = deep_get(kwargs, DictPath("wait_for_keypress"), False)
    waitforkeypress = True

    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()

    return result.returncode


# pylint: disable-next=too-many-locals,too-many-branches
def diff_resource_configuration(uip: UIProps, **kwargs: Any) -> Retval:
    """
    Show the changes that applying a configuration file or Kustomization would result in.

        Parameters:
            uip (UIProps): A reference to the UI Properties object
            **kwargs (dict[str, Any]): Keyword arguments
                values (dict[str, Any]):
                    resource_path (str): The path to the file to act on
                    resource_url (str): A URL to act on
                action (dict[str, Any]):
                    extravars (dict[str, Any]):
                        action (str): The action to perform (delete, create, apply)
                        rtype (str): The resource type ("Configuration File" or "Kustomization")
        Returns:
            (Retval): Retval.MATCH
    """
    values: dict[str, Any] = deep_get(kwargs, DictPath("values"))

    if (resource_url := deep_get(values, DictPath("resource_url"))) is not None:
        if not resource_url.startswith(("http://", "https://")):
            return Retval.MATCH
        resource_path = resource_url
        rtype: str = deep_get(kwargs, DictPath("action#extravars#rtype"))
    else:
        resource_path, rtype = values["resource_path"]

    try:
        kubectl_path = secure_which(FilePath("/usr/bin/kubectl"),
                                    fallback_allowlist=["/etc/alternatives"],
                                    security_policy=SecurityPolicy.ALLOWLIST_RELAXED)
    except FileNotFoundError:
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("kubectl", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    if rtype == "Configuration File":
        args = [kubectl_path, "diff", "-f", resource_path]
    elif rtype == "Kustomization":
        args = [kubectl_path, "diff", "-k", resource_path]
    else:
        raise TypeError(f"Unknown resource type {rtype}; this is a programming error.")

    result = subprocess.run(args, stdout=PIPE, stderr=PIPE, universal_newlines=True, check=False)
    indent = deep_get(cmtlib.cmtconfig, DictPath("Global#indent"), 2)
    diff = []

    if not result.stdout:
        return Retval.MATCH

    diff_regex: re.Pattern[str] = re.compile(r"^(\s*)(.*)")

    for line in result.stdout.splitlines():
        if line.startswith("+"):
            fmt = ThemeAttr("windowwidget", "diffplus")
        elif line.startswith("-"):
            fmt = ThemeAttr("windowwidget", "diffminus")
        elif line.startswith("@@"):
            fmt = ThemeAttr("windowwidget", "diffatat")
        elif line.startswith("diff "):
            fmt = ThemeAttr("windowwidget", "diffheader")
        else:
            fmt = ThemeAttr("windowwidget", "diffsame")

        # kubectl shows the diff with a 2-space indent;
        # if a different indent is configured we have to modify this
        if indent != 2:
            prefix = line[0]
            tmp = diff_regex.match(line[1:])
            if tmp is not None and len(tmp[1]) % 2 == 0:
                line = prefix + "".ljust(int(len(tmp[1]) / 2) * indent) + tmp[2]

        diff.append({
            "lineattrs": WidgetLineAttrs.NORMAL,
            "columns": [[ThemeStr(line, fmt)]],
        })

    _tmpselection = curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx,
                                               uip.maxy // 2, uip.maxx // 2, diff,
                                               title="Difference if applying new configuration:",
                                               cursor=False)
    return Retval.MATCH


def format_commandline(args: list[str], implicit_command: bool = True) -> list[ANSIThemeStr]:
    """
    Given a command line as an array of strings, format it as an array of ANSIThemeStr.

        Parameters:
            args ([str]): The commandline
            implicit_command (bool): Is the first non-option command the command?
        Returns:
            ([ANSIThemeStr]): A list of ANSIThemeStr
    """
    themearray = []

    command = implicit_command

    for i, arg in enumerate(args):
        # The first argument is the program name
        if i == 0:
            themearray += [ANSIThemeStr(f"{arg}", "programname")]
        # This is an option
        elif arg.startswith(("-")):
            themearray += [ANSIThemeStr(f" {arg}", "option")]
        # The first non-option argument is the command
        elif not command:
            themearray += [ANSIThemeStr(f" {arg}", "command")]
            command = True
        else:
            themearray += [ANSIThemeStr(f" {arg}", "argument")]
    return themearray


def edit_resource(stdscr: curses.window, **kwargs: Any) -> None:
    """
    Edit a Kubernetes object.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict[str, Any]): An object to extract data from
                kind ((str, str)): The Kind of the object to operate on
                name (str): The path to the name of the object to edit
                namespace (str): The path to the namespace of the object to edit
    """
    obj = deep_get(kwargs, DictPath("obj"))
    kind = deep_get(kwargs, DictPath("kind"))
    name = deep_get(obj, DictPath("metadata#name"))
    namespace: str = deep_get(obj, DictPath("metadata#namespace"), "")
    if name is None:
        return

    curses.endwin()
    _retval = clear_screen()
    retval, args = __edit_resource(kind, namespace, name)

    waitforkeypress = False
    if waitforkeypress or retval > 0:
        if retval > 0:
            ansithemeprint([ANSIThemeStr("\nError", "error"),
                            ANSIThemeStr(": ", "default")]
                           + format_commandline(args, implicit_command=False)
                           + [ANSIThemeStr(" returned ", "default"),
                              ANSIThemeStr(f"{retval}", "errorvalue")], stderr=True)
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    stdscr.refresh()


def patch_resource(**kwargs: Any) -> Retval:
    """
    Patch resources.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                uip (UIProps): A reference to the UI Properties object
                kind (str): The kind of the resource to delete
                items ([str]): The list of resources to delete
                values (dict[str, Any]): Extra arguments
                    action_str (str): The string describing the action
                    args (dict): The arguments to pass to patch_object()
        Returns:
            (Retval): The return value
    """
    uip: UIProps = deep_get(kwargs, DictPath("uip"))
    kind: tuple[str, str] = deep_get(kwargs, DictPath("kind"))
    action_str: str = deep_get(kwargs, DictPath("values#action_str"))
    args: dict = deep_get(kwargs, DictPath("values#args"), {})
    values: dict = deep_get(kwargs, DictPath("values#values"), {})
    items: list[tuple[str, str]] = deep_get(kwargs, DictPath("items"), [])

    curses.endwin()
    _retval = clear_screen()

    for item in items:
        if isinstance(item, tuple):
            namespace, name = item
        else:
            namespace = ""
            name = item

        if action_str is not None:
            msg = [ANSIThemeStr(f"{action_str} {kind[0]}.{kind[1]} “", "default")]
            if namespace:
                msg += [ANSIThemeStr(namespace, "argument"),
                        ANSIThemeStr("::", "separator")]
            msg += [ANSIThemeStr(name, "argument"),
                    ANSIThemeStr("“", "default")]
            ansithemeprint(msg)

        patch_object(uip.stdscr, **{"kind": kind,
                                    "name": name,
                                    "namespace": namespace,
                                    "args": args,
                                    "values": values})

    print("\n")

    waitforkeypress = True
    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()

    return Retval.RETURNDONE


def restart_resource_rescale(**kwargs: Any) -> Retval:
    """
    Restart resources by rescaling them.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                uip (UIProps): A reference to the UI Properties object
                kind (str): The kind of the resource to delete
                items ([str]): The list of resources to delete
        Returns:
            (Retval): The return value
    """
    uip: UIProps = deep_get(kwargs, DictPath("uip"))
    kind: tuple[str, str] = deep_get(kwargs, DictPath("kind"))
    items: list[tuple[str, str]] = deep_get(kwargs, DictPath("items"), [])

    curses.endwin()
    _retval = clear_screen()

    for item in items:
        if isinstance(item, tuple):
            namespace, name = item
        else:
            namespace = ""
            name = item

        old_scale = __get_resource_scale(kind=kind, namespace=namespace, name=name)
        __scale_replicas(kind=kind, namespace=namespace, name=name, scale=0)
        __scale_replicas(kind=kind, namespace=namespace, name=name, scale=old_scale)
        msg = [ANSIThemeStr(f"Restarting {kind[0]}.{kind[1]} “", "default"),
               ANSIThemeStr(namespace, "argument"),
               ANSIThemeStr("::", "separator"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“ scale: ", "default"),
               ANSIThemeStr(f"{old_scale}", "emphasis")]
        ansithemeprint(msg)

    print("\n")

    waitforkeypress = True
    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()

    return Retval.RETURNDONE


def restart_resource_rollout(**kwargs: Any) -> Retval:
    """
    Restarts resources using rollout.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                uip (UIProps): A reference to the UI Properties object
                kind (str): The kind of the resource to delete
                items ([str]): The list of resources to delete
        Returns:
            (Retval): The return value
    """
    uip: UIProps = deep_get(kwargs, DictPath("uip"))
    kind: tuple[str, str] = deep_get(kwargs, DictPath("kind"))
    items: list[tuple[str, str]] = deep_get(kwargs, DictPath("items"), [])

    curses.endwin()
    _retval = clear_screen()

    for item in items:
        if isinstance(item, tuple):
            namespace, name = item
        else:
            namespace = ""
            name = item

        __restart_resource(kind, namespace, name)
        msg = [ANSIThemeStr(f"Restarting {kind[0]}.{kind[1]} “", "default"),
               ANSIThemeStr(namespace, "argument"),
               ANSIThemeStr("::", "separator"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“", "default")]
        ansithemeprint(msg)

    print("\n")

    waitforkeypress = True
    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()

    return Retval.RETURNDONE


def rescale_resource(**kwargs: Any) -> Retval:
    """
    Rescale resources.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                uip (UIProps): A reference to the UI Properties object
                kind (str): The kind of the resource to delete
                items ([str]): The list of resources to delete
                values (dict[str, Any]): The items to operate on
        Returns:
            (Retval): The return value
    """
    uip: UIProps = deep_get(kwargs, DictPath("uip"))
    kind: tuple[str, str] = deep_get(kwargs, DictPath("kind"))
    items: list[tuple[str, str]] = deep_get(kwargs, DictPath("items"), [])
    values: dict = deep_get(kwargs, DictPath("values"))

    curses.endwin()
    _retval = clear_screen()

    for item in items:
        if isinstance(item, tuple):
            namespace, name = item
        else:
            namespace = ""
            name = item

        scale = values["scale"]
        old_scale = __get_resource_scale(kind=kind, namespace=namespace,
                                         name=name,
                                         path=deep_get(kwargs, DictPath("action_args#path")))
        __scale_replicas(kind=kind, namespace=namespace, name=name, scale=scale)
        msg = [ANSIThemeStr(f"Rescaling {kind[0]}.{kind[1]} “", "default"),
               ANSIThemeStr(namespace, "argument"),
               ANSIThemeStr("::", "separator"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“ scale: ", "default"),
               ANSIThemeStr(f"{old_scale}", "emphasis"),
               ANSIThemeStr(" => ", "default"),
               ANSIThemeStr(f"{scale}", "emphasis")]
        ansithemeprint(msg)

    print("\n")

    waitforkeypress = True
    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()

    return Retval.RETURNDONE


# Valid kinds:
# ("Deployment", "apps")
def stop_resource_rescale(**kwargs: Any) -> Retval:
    """
    Stop resources by rescaling.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                uip (UIProps): A reference to the UI Properties object
                kind (str): The kind of the resource to delete
                items ([str]): The list of resources to delete
                values (dict[str, Any]): The items to operate on
        Returns:
            (Retval): The return value
    """
    uip: UIProps = deep_get(kwargs, DictPath("uip"))
    kind: tuple[str, str] = deep_get(kwargs, DictPath("kind"))
    items: list[tuple[str, str]] = deep_get(kwargs, DictPath("items"), [])

    curses.endwin()
    _retval = clear_screen()

    for item in items:
        if isinstance(item, tuple):
            namespace, name = item
        else:
            namespace = ""
            name = item

        old_scale = __get_resource_scale(kind=kind, namespace=namespace, name=name)
        __scale_replicas(kind=kind, namespace=namespace, name=name, scale=0)
        msg = [ANSIThemeStr(f"Stopping {kind[0]}.{kind[1]} “", "default"),
               ANSIThemeStr(namespace, "argument"),
               ANSIThemeStr("::", "separator"),
               ANSIThemeStr(name, "argument"),
               ANSIThemeStr("“ scale: ", "default"),
               ANSIThemeStr(f"{old_scale}", "emphasis"),
               ANSIThemeStr(" => ", "default"),
               ANSIThemeStr("0", "emphasis")]
        ansithemeprint(msg)

    print("\n")

    waitforkeypress = True
    if waitforkeypress:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()

    return Retval.RETURNDONE


def delete_logs(**kwargs: Any) -> Retval:
    """
    Delete log messages.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                items ([str]): The list of logs to delete
        Returns:
            (Retval): The return value
    """
    items = deep_get(kwargs, DictPath("items"), [])
    dirpath: str = deep_get(kwargs, DictPath("action#actionfunc_args#dirpath"))
    if dirpath is not None:
        dirpath = dirpath.replace("{HOME}", HOMEDIR)
    for item in items:
        ansible_delete_log(item, dirpath=dirpath)
    return Retval.RETURNDONE


# pylint: disable-next=too-many-locals,too-many-branches
def action_execute_command(uip: UIProps, **kwargs: Any) -> None:
    """
    Execute a command on localhost.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                values (dict[str, Any]): Values
                items ([(str, str)]): A list of items that can be substituted into argument lists
    """
    values: dict[str, Any] = deep_get(kwargs, DictPath("values"))
    items: list[tuple[str, str]] = deep_get(kwargs, DictPath("items"))

    tmpargs: list[str] = deep_get(values, DictPath("action_args#command"), [])
    iterate: bool = deep_get(values, DictPath("action_args#iterate"), False)
    if not tmpargs:
        return

    args: list[str] = []

    for arg in tmpargs:
        if arg == "<<<items>>>":
            args += items
        elif arg.startswith("<<<items:"):
            separator = arg.removeprefix("<<<items:").removesuffix(">>>")
            args.append(separator.join(items))
        else:
            args.append(arg)

    description = deep_get(kwargs, DictPath("action#description"))
    if description is None:
        description = " ".join(args)
    msg = [ANSIThemeStr("Executing “", "action"),
           ANSIThemeStr(description, "argument"),
           ANSIThemeStr("“\n", "action")]

    curses.endwin()
    _retval = clear_screen()

    ansithemeprint(msg)

    if iterate:
        iterations = items
    else:
        iterations = [items]

    for item in iterations:
        substitutions = {}
        if isinstance(item, tuple):
            for i, subitem in enumerate(item):
                substitutions[f"<<<item.{i}>>>"] = subitem
        else:
            substitutions["<<<item>>>"] = item
        iterargs = substitute_list(args, substitutions)

        try:
            result = subprocess.run(iterargs, check=False)
            retval = result.returncode
        except FileNotFoundError:
            ansithemeprint([ANSIThemeStr("Error", "error"),
                            ANSIThemeStr(": Command “", "default"),
                            ANSIThemeStr(f"{args[0]}", "programname"),
                            ANSIThemeStr("“ not found", "default")])
            retval = 2

    waitforkeypress = True
    if waitforkeypress or retval > 0:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()


# pylint: disable-next=too-many-locals,too-many-branches
def command_hosts(uip: UIProps, **kwargs: Any) -> None:
    """
    Execute a playbook on multiple hosts, including pre- and post-hooks.
    TODO: This should be renamed.

        Parameters:
            uip (UIProps): A reference to the UI Properties object
            **kwargs (dict[str, Any]): Keyword arguments
            values (dict[str, Any]): Values to pass to __run_playbook()
            actions (dict[str, Any]): The action data
            items ([str]): The hosts to execute the playbook(s) on
            verbose (bool): Output status updates for every new Ansible event?
    """
    values: dict[str, Any] = deep_get(kwargs, DictPath("values"))
    action: dict[str, Any] = deep_get(kwargs, DictPath("action"))
    items: list[str] = deep_get(kwargs, DictPath("items"), [])
    verbose: bool = deep_get(cmtlib.cmtconfig, DictPath("Ansible#verbose"), False)
    verbose = deep_get(kwargs, DictPath("verbose"), verbose)

    values.pop("_tagged_items", None)
    msg = \
        [ANSIThemeStr("Executing playbook “", "action"),
         ANSIThemeStr(action.get("description", "<description unset>"), "argument"),
         ANSIThemeStr("“ on the following hosts: ", "action")] \
        + ansithemestr_join_list(items, formatting="hostname",
                                 separator=ANSIThemeStr(", ", "separator")) \
        + [ANSIThemeStr("\n", "action")]

    curses.endwin()
    _retval = clear_screen()

    if action.get("requires_cluster_info") and kubernetes_support:
        ansithemeprint([ANSIThemeStr("[Gathering cluster information]\n", "phase")])
        gather_cluster_info(kubernetes_helper=kh, kh_cache=kh_cache)

    ansithemeprint(msg)

    # If run_before is set we have one or several playbooks that need to be run before this one
    runbefore = action.get("run_before", [])

    retval = 0

    for preplaybook in runbefore:
        preplaybookpath = get_playbook_path(FilePath(f"{preplaybook}.yaml"))
        if (tmpretval := __run_playbook(preplaybookpath, items,
                                        extra_values=values, verbose=verbose)):
            if retval == 0:
                retval = tmpretval
            break

    # If all pre-requisites completed successfully we perform the main task
    if not retval:
        retval = run_playbook(action, items, values=values)

    # If everything was successful it is time for the run_after playbooks
    if not retval:
        runafter = action.get("run_after", [])

        for postplaybook in runafter:
            postplaybookpath = get_playbook_path(FilePath(f"{postplaybook}.yaml"))
            if (tmpretval := __run_playbook(postplaybookpath, items,
                                            extra_values=values, verbose=verbose)):
                if retval == 0:
                    retval = tmpretval
                break

    # If everything was successful we execute the add_to_groups/remove_from_groups actions
    if not retval:
        for group in action.get("add_to_groups", []):
            ansible_add_hosts(ANSIBLE_INVENTORY, items, group=group, skip_all=True)

        for group in action.get("remove_from_groups", []):
            ansible_remove_hosts(ANSIBLE_INVENTORY, items, group=group)

    waitforkeypress = True
    if waitforkeypress or retval:
        ansithemeinput([ANSIThemeStr("\nPress Enter to continue...", "default")])
    uip.stdscr.refresh()


def cordon_node(**kwargs: Any) -> Retval:
    """
    Cordon node(s).

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                items ([str]): The list of nodes to cordon
        Returns:
            (Retval): The return value
    """
    items = deep_get(kwargs, DictPath("items"))
    for node in items:
        kh.cordon_node(node)
    return Retval.RETURNDONE


def drain_node(**kwargs: Any) -> Retval:
    """
    Drain node(s).

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                items ([str]): The list of nodes to drain
                force (bool): Force-drain the nodes? True to force drain, False to drain gracefully
        Returns:
            (Retval): The return value
    """
    items: list[str] = deep_get(kwargs, DictPath("items"), [])
    force: bool = deep_get(kwargs, DictPath("force"), False)
    for node in items:
        kh.drain_node(node, force=force)
    return Retval.RETURNDONE


def force_drain_node(**kwargs: Any) -> Retval:
    """
    Force drain node(s).

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                items ([str]): The list of nodes to drain
        Returns:
            (Retval): The return value
    """
    kwargs["force"] = True
    return drain_node(**kwargs)


def uncordon_node(**kwargs: Any) -> Retval:
    """
    Uncordon node(s).

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                items ([str]): The list of nodes to uncordon
        Returns:
            (Retval): The return value
    """
    items = deep_get(kwargs, DictPath("items"))
    for node in items:
        kh.uncordon_node(node)
    return Retval.RETURNDONE


# pylint: disable-next=too-many-locals
def ssh_to_host(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    SSH to a host

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                obj (dict[str, Any]): The object to fetch information from
                name_path (str): The path to the member of the object
                                 to fetch the name from (optional)
                name (str): The name of the host (optional)
        Returns:
            (Retval): Retval.RETURNDONE
    """
    host = None

    if "selected" in kwargs:
        selected = deep_get(kwargs, DictPath("selected"))
        if isinstance(selected, tuple):
            host = selected[0]
        elif isinstance(selected, str):
            host = selected
        else:
            ref = getattr(selected, "ref")
            _kind = deep_get(ref, DictPath("kind"), "")
            _api_group = deep_get(ref, DictPath("api_group"), "")
            try:
                kind = guess_kind((_kind, _api_group))
            except NameError:
                # If we cannot guess the kind we return
                return Retval.RETURNDONE

            if kind != ("Node", ""):
                # If this is not a Node object, return
                return Retval.RETURNDONE
            host = deep_get(ref, DictPath("name"), "")
    elif "obj" in kwargs:
        obj = deep_get(kwargs, DictPath("obj"), {})
        name_path = deep_get(kwargs, DictPath("name_path"), "")
        host = deep_get(obj, DictPath(name_path))
    host = deep_get(kwargs, DictPath("name"), host)

    if host is None or not host:
        return Retval.RETURNDONE

    msg = [ANSIThemeStr("SSH:ing to ", "action"),
           ANSIThemeStr(host, "hostname"),
           ANSIThemeStr(":\n", "action")]

    inventory = ansible_get_inventory_dict()

    # ansible_user in the inventory overrides that defined in cmt.yaml
    # thus we get these in ascending over of priority
    # if no user is specified we assume that we are to use the user we are running as
    sshuser = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_user"))
    sshuser = deep_get(inventory, DictPath("all#vars#ansible_user"), sshuser)
    sshuser = deep_get(inventory, DictPath(f"all#hosts#{host}#ansible_user"), sshuser)

    curses.endwin()
    _retval = clear_screen()
    ansithemeprint(msg)

    try:
        ssh_path = secure_which(SSH_BIN_PATH, fallback_allowlist=[])
    except FileNotFoundError:
        # Once we have support for logging we should probably just log an error
        # and return here instead
        curses.endwin()
        ansithemeprint([ANSIThemeStr("Critical", "critical"),
                        ANSIThemeStr(": Could not find ", "default"),
                        ANSIThemeStr("ssh", "path"),
                        ANSIThemeStr("; aborting.", "default")], stderr=True)
        sys.exit(errno.ENOENT)

    if sshuser is not None:
        host = f"{sshuser}@{host}"

    relaxed_ssh_hosts = deep_get(cmtlib.cmtconfig, DictPath("Network#relaxed_ssh_hosts"), [])
    if relaxed_ssh_hosts == ["ALL"] or host in relaxed_ssh_hosts:
        ssh_args = SSH_ARGS_RELAXED
    else:
        ssh_args = SSH_ARGS_STRICT
    args = [ssh_path] + ssh_args + [host]

    subprocess.run(args, check=False)

    stdscr.refresh()
    return Retval.RETURNDONE


def list_configuration_files(basedir: FilePath) -> list[tuple[str, str, str]]:
    """
    Scan a directory and a list of all {.yml,.yaml} files
    and directories with a kustomization.yaml file in it.

        Parameters:
            basedir (FilePath): The directory to scan
        Returns:
            ([(str, str, str]): A list of directory entries
                (str): The path to the file
                (str): The filename
                (str): The file type (Configuration File/Kustomization/<dir>)
    """
    plist: list[tuple[str, str, str]] = []
    files: list[tuple[str, str, str]] = []

    if os.path.isdir(basedir):
        for filename in os.listdir(basedir):
            if filename.startswith(("~", ".")):
                continue

            # real path, display name, type
            if filename.endswith((".yaml", ".yml")):
                files.append((f"{basedir}/{filename}", filename, "Configuration File"))
            elif os.path.isdir(f"{basedir}/{filename}"):
                if os.path.isfile(f"{basedir}/{filename}/kustomization.yaml"):
                    files.append((f"{basedir}/{filename}", filename, "Kustomization"))
                else:
                    files.append((f"{basedir}/{filename}", filename, "<dir>"))
            else:
                continue

    # Always provide a means to navigate up in the directory tree
    plist = [(f"{os.path.dirname(basedir)}", "..", "<dir>")]
    plist += cast(list[tuple[str, str, str]], natsorted(files))

    return plist


# pylint: disable-next=too-many-locals
def populate_actionlist(**kwargs: Any) -> tuple[list[dict[str, Any]], dict[str, Any]]:
    """
    Populate the list of actions based on context and policy.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                context (str): The context to populate actions for
                action_list ([dict]): The list of actions
                control_plane_selected (bool): Is the control plane part of the selection?
                single_item (bool): Has only a single item been selected?
        Returns:
            (([dict[str, Any]], dict[str, Any])):
                ([dict[str, Any]]): The formatted list of actions (for use with WindowWidget)
                (dict[str, Any]): The action list dict
    """
    action_list: dict[str, Any] = deep_get(kwargs, DictPath("action_list"), {})
    control_plane_selected: bool = deep_get(kwargs, DictPath("control_plane_selected"), False)
    single_item: bool = deep_get(kwargs, DictPath("single_item"), False)

    actions: list[dict[str, Any]] = []
    order: list[tuple[str, str, str]] = []

    for item in action_list:
        description: str = deep_get(action_list, DictPath(f"{item}#description"),
                                    "<description missing>")
        category: str = deep_get(action_list, DictPath(f"{item}#category"), "")
        name: str = item
        order.append((description, category, name))

    currentcategory = ""
    for item in natsorted(order, key=itemgetter(1, 0)):
        action = item[0]
        category = item[1]
        allowoncontrolplane = \
            deep_get(action_list, DictPath(f"{item[2]}#allow_on_control_plane"), True)
        singleoncontrolplane = \
            deep_get(action_list, DictPath(f"{item[2]}#single_on_control_plane"), False)
        singleonly = deep_get(action_list, DictPath(f"{item[2]}#single_only"), False)
        readonly = deep_get(action_list, DictPath(f"{item[2]}#read_only"), False)
        metadata = deep_get(action_list, DictPath(f"{item[2]}#metadata"), [])
        tmp = []
        for md in metadata:
            if isinstance(md, ThemeStr):
                tmp.append(md)
            elif isinstance(md[1], list):
                tmp.append(ThemeStr(md[0], ThemeAttr(md[1][0], md[1][1])))
            else:
                raise ValueError(f"Unknown type for metadata {type(md)} for metadata {md}; "
                                 "expected ThemeStr(str, ThemeAttr) or [str, [str, str]]")
        metadata = tmp
        if singleonly and not single_item:
            continue
        if singleoncontrolplane and control_plane_selected and not single_item:
            continue
        if not allowoncontrolplane and control_plane_selected:
            continue
        if not readonly and read_only_mode:
            continue

        if currentcategory != category:
            actions.append({
                "lineattrs": WidgetLineAttrs.SEPARATOR,
                "columns": [[ThemeStr(f" {category} ", ThemeAttr("windowwidget", "default"))],
                            [ThemeStr("", ThemeAttr("windowwidget", "default"))]],
            })
            currentcategory = category
        actions.append({
            "lineattrs": WidgetLineAttrs.NORMAL,
            "columns": [[ThemeStr(f"{action}", ThemeAttr("windowwidget", "default"))], metadata],
        })

    return actions, action_list


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def __populate_playbooklist(path: FilePath, action_list: dict) -> dict:
    if not os.path.isdir(path):
        return action_list

    yaml_regex: re.Pattern[str] = re.compile(r"^(.*)\.ya?ml$")

    for playbookpath in Path(path).iterdir():
        if playbookpath.name.startswith(("~", ".")):
            continue

        if (tmp := yaml_regex.match(playbookpath.name)) is None:
            continue

        playbookname = str(tmp[1])

        # Check if the playbook already exists in the action list,
        if playbookname in action_list:
            continue

        description = None

        try:
            d = list(secure_read_yaml(FilePath(playbookpath), directory_is_symlink=True))
        except (ruyaml.composer.ComposerError,
                ruyaml.constructor.DuplicateKeyError,
                ruyaml.parser.ParserError,
                ruyaml.scanner.ScannerError,
                TypeError):
            # This entry could not be parsed; add a dummy entry
            action_list[playbookname] = {
                "description": playbookpath,
                "playbook": FilePath(playbookpath),
                "category": "__INVALID__",
                "comments": "Failed to parse (Not valid YAML)",
            }
            continue

        # Empty files are used to disable playbooks completely
        if d is None or not d:
            action_list[playbookname] = {
                "description": playbookpath,
                "playbook": FilePath(playbookpath),
                "category": "__DISABLED__",
            }
            continue

        if not isinstance(d, list):
            # This entry could not be parsed; add a dummy entry
            action_list[playbookname] = {
                "description": playbookpath,
                "playbook": FilePath(playbookpath),
                "category": "__INVALID__",
                "comments": "Failed to parse (Not a list of plays)",
            }
            continue

        description = deep_get(d[0], DictPath("vars#metadata#description"))

        # Ignore all playbooks that lack a description;
        # typically they are internal playbooks
        if description is None:
            continue

        query = deep_get(d[0], DictPath("vars#metadata#query#string"))
        queryval = deep_get(d[0], DictPath("vars#metadata#query#variable"))
        queryfunc = deep_get(d[0], DictPath("vars#metadata#query#function"))

        # Sanity check
        if queryfunc is not None:
            if queryfunc not in ("int", "string", "yesno", "filechooser"):
                raise ValueError(f"unknown queryfunc “{queryfunc}“ provided")

        confirm = deep_get(d[0], DictPath("vars#metadata#confirm"), False)
        tmpallowoncontrolplane = deep_get(d[0], DictPath("vars#metadata#allow_on_control_plane"))
        if tmpallowoncontrolplane is None or tmpallowoncontrolplane == "always":
            allowoncontrolplane = True
            singleoncontrolplane = False
        elif tmpallowoncontrolplane.lower() == "single":
            allowoncontrolplane = True
            singleoncontrolplane = True
        elif tmpallowoncontrolplane.lower() == "never":
            allowoncontrolplane = False
            singleoncontrolplane = False
        else:
            raise ValueError(f"{playbookpath}: Invalid values for allow-on-control-plane")

        requiresclusterinfo = deep_get(d[0], DictPath("vars#metadata#requires_cluster_info"), False)
        runbefore = deep_get(d[0], DictPath("vars#metadata#run_before"), [])
        runafter = deep_get(d[0], DictPath("vars#metadata#run_after"), [])
        addtogroups = deep_get(d[0], DictPath("vars#metadata#add_to_groups"), [])
        removefromgroups = deep_get(d[0], DictPath("vars#metadata#remove_from_groups"), [])
        category = deep_get(d[0], DictPath("vars#metadata#category"), "Uncategorized")
        playbooktypes = deep_get(d[0], DictPath("vars#metadata#playbook_types"), [])
        comments = deep_get(d[0], DictPath("vars#metadata#comments"), "")
        readonly = deep_get(d[0], DictPath("vars#metadata#read_only"), False)
        extravars = {
            "quiet": deep_get(d[0], DictPath("vars#metadata#quiet"), False),
        }

        action_list[playbookname] = {
            "description": description,
            "playbook": FilePath(playbookpath),
            "query": query,
            "queryval": queryval,
            "queryfunc": queryfunc,
            "confirm": confirm,
            "allow_on_control_plane": allowoncontrolplane,
            "single_on_control_plane": singleoncontrolplane,
            "requires_cluster_info": requiresclusterinfo,
            "run_before": runbefore,
            "run_after": runafter,
            "add_to_groups": addtogroups,
            "remove_from_groups": removefromgroups,
            "category": category,
            "playbook_types": playbooktypes,
            "comments": comments,
            "read_only": readonly,
            "extravars": extravars,
        }

    return action_list


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def populate_playbooklist(**kwargs: Any) -> tuple[list[dict], dict]:
    """
    Populate the list of playbooks based on context and policy.

        Parameters:
            **kwargs (dict[str, Any]): Keyword arguments
                context (str): The context to populate playbooks for
                actions ([dict]): The actions to pass through
                action_list (dict): A dict of actions to append the playbook actions to
                control_plane_selected (bool): Is the control plane part of the selection?
                single_item (bool): Has only a single item been selected?
                cluster_available (bool): Is the cluster available?
    """
    context: Optional[dict] = deep_get(kwargs, DictPath("context"))
    actions: list[dict] = deep_get(kwargs, DictPath("actions"))
    action_list: dict = deep_get(kwargs, DictPath("action_list"), {})
    control_plane_selected: bool = deep_get(kwargs, DictPath("control_plane_selected"), False)
    single_item: bool = deep_get(kwargs, DictPath("single_item"), False)
    cluster_available: bool = deep_get(kwargs, DictPath("cluster_available"), True)

    local_playbooks = deep_get(cmtlib.cmtconfig, DictPath("Ansible#local_playbooks"), [])
    for playbook_path in local_playbooks:
        # Substitute {HOME}/ for {HOMEDIR}
        if playbook_path.startswith(("{HOME}/", "{HOME}\\")):
            playbook_path = HOMEDIR.joinpath(playbook_path[len('{HOME}/'):])
        # Skip non-existing playbook paths
        if not os.path.isdir(playbook_path):
            continue
        action_list = __populate_playbooklist(playbook_path, action_list=action_list)
    action_list = __populate_playbooklist(ANSIBLE_PLAYBOOK_DIR, action_list=action_list)
    action_list = __populate_playbooklist(SYSTEM_ANSIBLE_PLAYBOOK_DIR, action_list=action_list)

    order: list[tuple[str, str, str]] = []
    for item in action_list:
        playbooktypes: list[str] = action_list[item].get("playbook_types", [])
        if context is not None and playbooktypes != [] and context not in playbooktypes:
            continue

        description = action_list[item].get("description")
        category = action_list[item].get("category", "")
        name = item
        order.append((description, category, name))

    currentcategory = ""
    for item in natsorted(order, key=itemgetter(1, 0)):
        action = item[0]
        category = item[1]
        allowoncontrolplane = action_list[item[2]].get("allow_on_control_plane", True)
        singleoncontrolplane = action_list[item[2]].get("single_on_control_plane", True)
        readonly = action_list[item[2]].get("read_only", False)
        comments = action_list[item[2]].get("comments", "")
        lineattrs = WidgetLineAttrs.NORMAL
        if read_only_mode and not readonly:
            continue
        if singleoncontrolplane and control_plane_selected and not single_item:
            continue
        if not allowoncontrolplane and control_plane_selected:
            continue

        if action_list[item[2]].get("requires_cluster_info", False) and not cluster_available:
            metadata = []
            if comments:
                metadata.append(ThemeStr(f"{comments},", ThemeAttr("windowwidget", "highlight")))
            metadata.append(ThemeStr("<cluster not available>",
                                     ThemeAttr("windowwidget", "alert")))
            lineattrs = WidgetLineAttrs.UNSELECTABLE
        elif category == "__INVALID__":
            lineattrs = WidgetLineAttrs.UNSELECTABLE & WidgetLineAttrs.INVALID
            metadata = [ThemeStr(comments, ThemeAttr("windowwidget", "alert"))]
        elif category == "__DISABLED__":
            continue
        else:
            metadata = [ThemeStr(comments, ThemeAttr("windowwidget", "highlight"))]

        if currentcategory != category:
            if category == "__INVALID__":
                actions.append({
                    "lineattrs": WidgetLineAttrs.SEPARATOR,
                    "columns": [[ThemeStr(" INVALID ", ThemeAttr("windowwidget", "bright"))],
                                [ThemeStr("", ThemeAttr("windowwidget", "default"))]],
                })
                currentcategory = category
            else:
                actions.append({
                    "lineattrs": WidgetLineAttrs.SEPARATOR,
                    "columns": [[ThemeStr(f" {category} ",
                                          ThemeAttr("windowwidget", "default"))],
                                [ThemeStr("", ThemeAttr("windowwidget", "default"))]],
                })
                currentcategory = category
        if currentcategory == "__INVALID__":
            actions.append({
                "lineattrs": lineattrs,
                "columns": [[ThemeStr(f"{action}",
                                      ThemeAttr("windowwidget", "alert"))], metadata],
            })
        else:
            actions.append({
                "lineattrs": lineattrs,
                "columns": [[ThemeStr(f"{action}",
                                      ThemeAttr("windowwidget", "default"))], metadata],
            })

    return actions, action_list


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def format_selection_list(uip: UIProps, refresh_apis: bool = False) -> list[dict[str, Any]]:
    """
    Format the selection list.

        Parameters:
            uip (UIProps): A reference to the UI Properties object
            **kwargs (dict[str, Any]): Keyword arguments
                refresh_apis (bool): Should the list of available APIs be refreshed?
    """
    global force_refresh_apis  # pylint: disable=global-statement

    if force_refresh_apis:
        force_refresh_apis = False
        refresh_apis = True

    hide_unavailable: bool = \
        deep_get(cmtlib.cmtconfig,
                 DictPath("__Selector#hide_unavailable_apis"), True)
    categorise: bool = \
        deep_get(cmtlib.cmtconfig, DictPath("__Selector#categorise"), True)
    sortcolumn: bool = \
        deep_get(cmtlib.cmtconfig, DictPath("__Selector#sortcolumn"), "family")

    if sortcolumn == "family":
        if categorise:
            sortkey1 = 1
            sortkey2 = 2
        else:
            sortkey1 = 2
            sortkey2 = 0
    elif sortcolumn == "name":
        if categorise:
            sortkey1 = 1
            sortkey2 = 0
        else:
            sortkey1 = 0
            sortkey2 = 2
    else:
        sys.exit(f"Invalid sortcolumn {sortcolumn} for Selector; aborting.")

    if refresh_apis:
        _notice = curses_helper.notice(uip.stdscr, message="Refreshing list of available APIs")
        # Repopulate the list of views, on the offhand chance that a view file has been added
        populate_views(force_refresh=refresh_apis)
        curses.doupdate()

    if kubernetes_support:
        available_api_families, _status, _modified = kh.get_available_kinds()
    else:
        available_api_families = {}

    items = []
    order: list[tuple[str, str, str]] = []

    # Find the correct sort order
    for viewkey, viewref in views.items():
        kind = None
        if deep_get(viewref, DictPath("skip"), False):
            continue
        if hide_unavailable:
            kind = deep_get(viewref, DictPath("kind"), ("", ""))
            if kind is not None and kind != ("", ""):
                if not kind[0].startswith("__") \
                        and (kind not in available_api_families
                             or not deep_get(available_api_families[kind],
                                             DictPath("available"), False)):
                    continue
            check_availability = deep_get(viewref, DictPath("check_availability"), None)
            if check_availability is not None:
                if not check_availability():
                    continue
        group = deep_get(viewref, DictPath("group"))
        # XXX: Do override in a nicer manner; perhaps we want all "built-in" groups first?
        if group == "Administration":
            group = "0"
        elif group == "Core":
            group = "1"
        elif group == "Workloads":
            group = "2"
        elif "(Deprecated)" in group:
            # This should ensure that all deprecated groups end up last, but still sorted
            group = "ZZZZZ" + group

        view_name = deep_get(viewref, DictPath("windowheader"))

        if kind is not None:
            api_group = kind[1]
        else:
            api_group = ""

        if group is None:
            raise ValueError(f"group should not be None unless skip=True; view: {view_name}")

        order.append((view_name, group, api_group))

    currentgroup = ""
    for item in natsorted(order, key=itemgetter(sortkey1, sortkey2)):
        view = item[0]
        viewkey = view
        api_group = item[2]
        if api_group:
            viewkey = f"{view} ({api_group})"
        viewref = views[viewkey]

        # This allows us to override the sort order
        group = deep_get(viewref, DictPath("group"), "")
        kind = deep_get(viewref, DictPath("kind"), ("", ""))
        if kind is not None:
            api_group = kind[1]
        else:
            api_group = ""

        if currentgroup != group and categorise:
            items.append({
                "lineattrs": WidgetLineAttrs.SEPARATOR,
                "columns": [[ThemeStr(f" {group} ", ThemeAttr("windowwidget", "highlight"))],
                            [ThemeStr("", ThemeAttr("windowwidget", "default"))]],
            })
            currentgroup = group
        lineattrs = WidgetLineAttrs.NORMAL
        if kind is not None and kind != ("", "") and not kind[0].startswith("__") \
                and (kind not in available_api_families
                     or not deep_get(available_api_families[kind], DictPath("available"), False)):
            lineattrs = WidgetLineAttrs.UNSELECTABLE
        if api_group == "":
            items.append({
                "lineattrs": lineattrs,
                "columns": [[ThemeStr(f"{view}", ThemeAttr("windowwidget", "default"))],
                            [ThemeStr("", ThemeAttr("windowwidget", "dim"))]],
                "retval": viewkey,
            })
        else:
            items.append({
                "lineattrs": lineattrs,
                "columns": [[ThemeStr(f"{view}", ThemeAttr("windowwidget", "default"))],
                            [ThemeStr(f"<{api_group}>", ThemeAttr("windowwidget", "dim"))]],
                "retval": viewkey,
            })

    return items


def selectwindow(uip: UIProps, **kwargs: Any) -> Retval:
    """
    The view selector.

        Parameters:
            uip (UIProps): A reference to the UI Properties object
            **kwargs (dict[str, Any]): Keyword arguments
                refresh_apis (bool): Should the list of available APIs be refreshed?
        Returns:
            (Retval): Retval.RETURNFULL when switching to a new view,
                      Retval.NOMATCH if [ESC] was pressed
    """
    # Ideally we want to return to the same selection
    global defaultview  # pylint: disable=global-statement

    refresh_apis: bool = deep_get(kwargs, DictPath("refresh_apis"), False)

    uip.refresh_all()
    items = format_selection_list(uip, refresh_apis)
    title = "Choose view"

    selection = None

    categorise = deep_get(cmtlib.cmtconfig, DictPath("__Selector#categorise"), True)

    while selection is None:
        extra_args = {"KEY_F6": True}
        tmpselection = \
            curses_helper.windowwidget(uip.stdscr, uip.maxy, uip.maxx, uip.maxy // 2,
                                       uip.maxx // 2, items, title=title,
                                       preselection=defaultview, **extra_args)
        if tmpselection is not None:
            # pylint: disable-next=unidiomatic-typecheck
            if type(tmpselection) == int and tmpselection < 0:  # noqa: E721
                if tmpselection == -curses.KEY_F6:
                    categorise = not categorise
                    deep_set(cmtlib.cmtconfig, DictPath("__Selector#categorise"),
                             categorise, create_path=True)
                    items = format_selection_list(uip, refresh_apis)
                    uip.refresh_all()
                    continue
            selection = tmpselection

    if selection != "":
        defaultview = selection
        return Retval.RETURNFULL

    return Retval.NOMATCH


def selectorloop(stdscr: curses.window, **kwargs: Any) -> Retval:
    """
    Main loop for the Selector.

        Parameters:
            stdscr (curses.window): The curses window to operate on
            **kwargs (dict[str, Any]): Keyword arguments
                view (str): The view to show
        Returns:
            (Retval): The return value
        Raises:
            ProgrammingError (view is invalid)
    """
    global executor  # pylint: disable=global-statement

    # Just in case there are leftover futures from other views
    executor.shutdown()
    executor = reexecutor.ReExecutor()

    view: tuple[str, str] = deep_get(kwargs, DictPath("kind"))

    field_dict: dict = {}
    sortcolumn: str = ""
    uip = UIProps(stdscr)

    windowheader = deep_get(views, DictPath(f"{view}#windowheader"), view)

    uip.init_window(field_dict=field_dict, windowheader=windowheader, sortcolumn=sortcolumn)

    while True:
        retval = selectwindow(uip)
        if retval == Retval.RETURNFULL:
            return retval


listviewactions: dict[str, dict[str, Any]] = {
    "Apply configuration (local)": {
        "description": "Apply configurations from file/Kustomization (autodetected)",
        "confirm": True,
        "actionfunc": perform_action_on_configuration,
        "query": "Choose file or Kustomization to apply:",
        "queryval": "resource_path",
        "queryfunc": "filechooser",
        "extravars": {
            "action": "apply",
            "listgetter": list_configuration_files,
            "basedir": DEPLOYMENT_DIR,
        },
        # "confirmfunc":
        # "confirmstring": "The following changes will be performed:",
    },
    "Create resources (local)": {
        "description": "Create resources from file/Kustomization (autodetected)",
        "actionfunc": perform_action_on_configuration,
        "query": "Choose file or Kustomization to create:",
        "queryval": "resource_path",
        "queryfunc": "filechooser",
        "extravars": {
            "action": "create",
            "listgetter": list_configuration_files,
            "basedir": DEPLOYMENT_DIR,
        },
    },
    "Apply configuration (URL to file)": {
        "description": "Apply configurations from URL (file)",
        "confirm": True,
        "actionfunc": perform_action_on_configuration,
        "query": "URL to apply",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "action": "apply",
            "rtype": "Configuration File",
        },
        # "confirmfunc":
        # "confirmstring": "The following changes will be performed:",
    },
    "Apply configuration (URL to Kustomization)": {
        "description": "Apply configurations from URL (Kustomization)",
        "confirm": True,
        "actionfunc": perform_action_on_configuration,
        "query": "URL to apply",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "action": "apply",
            "rtype": "Kustomization",
        },
        # "confirmfunc":
        # "confirmstring": "The following changes will be performed:",
    },
    "Create resources (URL to file)": {
        "description": "Create resources from URL (file)",
        "actionfunc": perform_action_on_configuration,
        "query": "URL to create resource from",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "action": "create",
            "rtype": "Configuration File",
        },
    },
    "Create resources (URL to Kustomization)": {
        "description": "Create resources from URL (Kustomization)",
        "actionfunc": perform_action_on_configuration,
        "query": "URL to create resource from",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "action": "create",
            "rtype": "Kustomization",
        },
    },
    "Delete resources (file)": {
        "description":
            "Delete resource by reverting configuration file/Kustomization (autodetected)",
        "actionfunc": perform_action_on_configuration,
        "query": "Choose file or Kustomization to delete:",
        "queryval": "resource_path",
        "queryfunc": "filechooser",
        "extravars": {
            "action": "delete",
            "listgetter": list_configuration_files,
            "basedir": DEPLOYMENT_DIR,
        },
    },
    "Delete resources (URL to file)": {
        "description": "Delete resource by reverting configuration URL (file)",
        "actionfunc": perform_action_on_configuration,
        "query": "URL to configuration file to revert",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "action": "delete",
            "rtype": "Configuration File",
        },
    },
    "Delete resources (URL to Kustomization)": {
        "description": "Delete resource by reverting configuration URL (Kustomization)",
        "actionfunc": perform_action_on_configuration,
        "query": "URL to configuration Kustomization to revert",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "action": "delete",
            "rtype": "Kustomization",
        },
    },
    "Diff resource creation (local)": {
        "description": "Show what changes applying file or Kustomization would make (autodetected)",
        "actionfunc": diff_resource_configuration,
        "query": "Choose file or Kustomization to show difference against:",
        "queryval": "resource_path",
        "queryfunc": "filechooser",
        "extravars": {
            "listgetter": list_configuration_files,
            "basedir": DEPLOYMENT_DIR,
        },
    },
    "Diff resource creation (URL to file)": {
        "description": "Show what changes applying URL would make (file)",
        "actionfunc": diff_resource_configuration,
        "query": "URL to file to show difference against",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "rtype": "Configuration File",
        },
    },
    "Diff resource creation (URL to Kustomization)": {
        "description": "Show what changes applying URL would make (Kustomization)",
        "actionfunc": diff_resource_configuration,
        "query": "URL to Kustomization to show difference against",
        "queryval": "resource_url",
        "queryfunc": "string",
        "extravars": {
            "rtype": "Kustomization",
        },
    },
}


# These functions are used to check whether an API is available
def is_kubernetes_supported() -> bool:
    """
    Check whether Kubernetes is supported/enabled

        Returns:
            (bool): True if Kubernetes is supported/enabled, False if not
    """
    return kubernetes_support


def is_cluster_reachable() -> bool:
    """
    Check whether the cluster is reachable

        Returns:
            (bool): True if the cluster is reachable, False if not
    """
    reachable: bool = False

    if kubernetes_support and kh is not None:
        reachable = kh.is_cluster_reachable()
    return reachable


availability_checker_allowlist: dict[str, Callable] = {
    "is_cluster_reachable": is_cluster_reachable,
    "is_kubernetes_supported": is_kubernetes_supported,
}


# action calls acceptable for direct use in view files
action_call_allowlist: dict[str, Callable] = {
    "create_namespace": create_namespace,
    "decode_and_view_data": decode_and_view_data,
    "decode_and_view_file_templates": decode_and_view_file_templates,
    "edit_resource": edit_resource,
    "eventdispatch": eventdispatch,
    "export_data": export_data,
    "listviewdispatch": listviewdispatch,
    "patch_object": patch_object,
    "resourceinfodispatch_from_pod_resource_list": resourceinfodispatch_from_pod_resource_list,
    "resourceinfodispatch_with_lookup": resourceinfodispatch_with_lookup,
    "resourceinfodispatch_from_selection": resourceinfodispatch_from_selection,
    "set_cluster_context": set_cluster_context,
    "ssh_to_host": ssh_to_host,
    "view_last_applied_configuration": view_last_applied_configuration,
    "view_obj": view_obj,
    "view_pod_logs": view_pod_logs,
    "view_json": view_json,
    "view_yaml": view_yaml,
}


# Actionfuncs acceptable for direct use in view files
actionfunc_allowlist: dict[str, Callable] = {
    "action_view_pod_logs": action_view_pod_logs,
    "cordon_node": cordon_node,
    "delete_logs": delete_logs,
    "delete_resource": delete_resource,
    "drain_node": drain_node,
    "force_delete_resource": force_delete_resource,
    "force_drain_node": force_drain_node,
    "patch_resource": patch_resource,
    "rescale_resource": rescale_resource,
    "restart_resource_rescale": restart_resource_rescale,
    "restart_resource_rollout": restart_resource_rollout,
    "stop_resource_rescale": stop_resource_rescale,
    "uncordon_node": uncordon_node,
}


# Activatedfuns acceptable for direct use in view files
activatedfun_allowlist: dict[str, Callable[..., Retval]] = {
    "resourceinfodispatch": resourceinfodispatch,
    "resourceinfodispatch_from_pod_resource_list": resourceinfodispatch_from_pod_resource_list,
    "resourceinfodispatch_with_lookup": resourceinfodispatch_with_lookup,
}


# These views are always defined internally and cannot be disabled,
# except if check_availability() returns False.
views_special: dict[str, dict[str, Any]] = {
    "Selector": {
        "windowheader": "Selector",
        "kind": ("__Selector", ""),
        "commandline": ["selector"],
        "viewfunc": selectorloop,
        "fields": None,
        "skip": True,
        "is_taggable": False,
        "view_file_path": "<builtin>",
    },
    "Cluster Overview": {
        "windowheader": "Cluster Overview",
        "kind": ("__ClusterOverview", ""),
        "commandline": ["clusteroverview", "co"],
        "group": "Administration",
        "viewfunc": clusteroverviewloop,
        "fields": None,
        "update_delay": 5,
        "sortcolumn": "",
        "activatedfun": None,
        "listgetter": None,
        "infogetter": None,
        "is_taggable": False,
        "check_availability": is_cluster_reachable,
        "view_file_path": "<builtin>",
    },
    "Container Network Interface Info": {
        "windowheader": "Container Network Interface Info",
        "kind": ("__ContainerNetworkInterface", ""),
        "commandline": ["cni"],
        "group": "Administration",
        "viewfunc": cniloop,
        "fields": None,
        "sortcolumn": "",
        "activatedfun": None,
        "listgetter": None,
        "infogetter": None,
        "check_availability": is_cluster_reachable,
        "view_file_path": "<builtin>",
    },
}


views = {**views_special}


key_mappings: dict[str, list[int]] = {
    "f1": [curses.KEY_F1],
    "f2": [curses.KEY_F2],
    "f3": [curses.KEY_F3],
    "f4": [curses.KEY_F4],
    "f5": [curses.KEY_F5],
    "f6": [curses.KEY_F6],
    "f7": [curses.KEY_F7],
    "f8": [curses.KEY_F8],
    "f9": [curses.KEY_F9],
    "f10": [curses.KEY_F10],
    "f11": [curses.KEY_F11],
    "f12": [curses.KEY_F12],
    "f13": [curses.KEY_F13],
    "f14": [curses.KEY_F14],
    "f15": [curses.KEY_F15],
    "f16": [curses.KEY_F16],
    "f17": [curses.KEY_F17],
    "f18": [curses.KEY_F18],
    "f19": [curses.KEY_F19],
    "f20": [curses.KEY_F20],
    "f21": [curses.KEY_F21],
    "f22": [curses.KEY_F22],
    "f23": [curses.KEY_F23],
    "f24": [curses.KEY_F24],
}


# pylint: disable-next=too-many-branches
def map_key(view_file: str, shortcut: str, activatedfun: Optional[Callable],
            key: str, modifier: str) -> tuple[list[int], str]:
    """
    Setup a shortcut mapping and return the key-code(s) + helptext.

        Parameters:
            view_file (str): The path to the view-file (used for error messages)
            shortcut (str): The shortcut description (used for error messages)
            activatedfun (Callable): The function to call upon activation;
                                     used to double-check whether the default shortcut
                                     for "enter" has been disabled.
            key (str): They base key
            modifier (str): The modifier (""/"shift"/"ctrl")
        Returns:
            ((int | [int], str)):
                ([int]): The shortcut key(s)
                (str): The helptext
    """
    if modifier and modifier not in ("ctrl", "shift"):
        sys.exit(f"View-file {view_file} is invalid: "
                 f"unknown modifier {modifier}; valid modifiers are shift, ctrl; aborting")

    if key in ("f1", "f2", "f3", "f4", "f5", "f6",
               "f7", "f8", "f9", "f10", "f11", "f12") and modifier in ("", "shift"):
        if not modifier:
            shortcut_key: list[int] = deep_get(key_mappings, DictPath(key))
            help_key: str = f"[{key.upper()}]"
        elif modifier == "shift":
            key_: str = key[0] + str(int(key[1:]) + 12)
            num = int(key[1:]) + 12
            shortcut_key = deep_get(key_mappings, DictPath(key_))
            help_key = f"[Shift] + [{key.upper()}] / [{key[0].upper()}{num}]"
        else:
            sys.exit(f"View-file {view_file} is invalid: "
                     f"the modifier {modifier}; cannot be combined with {key}; aborting")
    elif key in ("f13", "f14", "f15", "f16", "f17", "f18",
                 "f19", "f20", "f21", "f22", "f23", "f24") and not modifier:
        num = int(key[1:]) - 12
        key_ = key[0] + str(num)
        shortcut_key = deep_get(key_mappings, DictPath(key_))
        help_key = f"[Shift] + [{key[0].upper()}{num}] / [{key.upper()}]"
    elif key in ("enter", "return"):
        if modifier or activatedfun is None:
            help_key = "[Enter]"
            shortcut_key = [curses.KEY_ENTER, 10, 13]
        else:
            sys.exit(f"View-file “{view_file}“ is invalid: the listview shortcut “{shortcut}“"
                     " uses “enter“ as key; this conflicts with "
                     "built-in shortcut for “on_activation“.")
    elif modifier:
        if modifier == "shift":
            help_key = f"[Shift] + {key.upper()}"
            shortcut_key = [ord(key.upper())]
        elif modifier == "ctrl":
            help_key = f"[Ctrl] + {key.upper()}"
            shortcut_key = [ord(key) - 96]
        else:
            # This shouldn't be necessary since we check this at the beginning of the function,
            # but pylint complains otherwise.
            sys.exit(f"View-file {view_file} is invalid: "
                     f"unknown modifier {modifier}; valid modifiers are shift, ctrl; aborting")
    elif len(key) == 1:
        help_key = f"{key.upper()}"
        shortcut_key = [ord(key)]
    else:
        sys.exit(f"View-file {view_file} is invalid: "
                 f"unknown {key}; aborting")

    return shortcut_key, help_key


# pylint: disable-next=too-many-locals,too-many-branches,too-many-statements
def populate_views(force_refresh: bool = False) -> None:
    """
    Populate the list- and info-view data from view-files.

        Parameters:
            force_refresh (bool): Force fresh of the list of available APIs
    """
    global views  # pylint: disable=global-statement

    if kubernetes_support:
        tmp_available_api_families, _status, _modified = \
            kh.get_available_kinds(force_refresh=force_refresh)
    else:
        tmp_available_api_families = {}

    available_api_families: set[tuple[str, str]] = set()
    for kind, kind_data in tmp_available_api_families.items():
        if deep_get(kind_data, DictPath("available"), False):
            available_api_families.add(kind)

    # Get a full list of views from all view directories
    # Start by adding the system views, then add local additions;
    # this way local modifications will override system views.
    view_dirs: list[str] = []

    view_dirs.append(cmtpaths.SYSTEM_VIEWS_DIR)
    view_dirs.append(cmtpaths.VIEW_DIR)
    view_dirs += deep_get(cmtlib.cmtconfig, DictPath("General#local_views"), [])

    view_files = []

    views = {**views_special}

    yaml_regex: re.Pattern[str] = re.compile(r"^(.*)\.ya?ml$")

    for view_dir in view_dirs:
        if view_dir.startswith("{HOME}"):
            view_dir = view_dir.replace("{HOME}", HOMEDIR, 1)

        if not os.path.isdir(view_dir):
            continue

        for filename in natsorted(os.listdir(view_dir)):
            filename = cast(str, filename)
            if filename.startswith(("~", ".")):
                continue

            if (match_tmp := yaml_regex.match(filename)) is None:
                continue

            tmp = match_tmp[1]
            if "." in tmp:
                kind, api_family = tmp.split(".", 1)
            else:
                kind = tmp
                api_family = ""
            if (kind, api_family) in available_api_families or kind.startswith("__"):
                view_files.append(os.path.join(view_dir, filename))

    # pylint: disable-next=too-many-nested-blocks
    for view_file in view_files:
        has_listview: bool = False
        has_infoview: bool = False

        try:
            d = dict(secure_read_yaml(FilePath(view_file), directory_is_symlink=True))
        except (ruyaml.composer.ComposerError,
                ruyaml.constructor.DuplicateKeyError,
                ruyaml.parser.ParserError,
                ruyaml.scanner.ScannerError,
                TypeError) as e:
            printable_errmsg = [
                [("View-file ", "default"),
                 (f"{view_file}", "path"),
                 (" is invalid; skipping.", "default")],
            ]
            _, printable_formatted_msg = ANSIThemeStr.format_error_msg(printable_errmsg)
            tmplines = [[(line.replace("\"", "\\\""), "default")] for line in str(e).splitlines()]
            errmsg = [
                [("View-file ", "default"),
                 (f"{view_file}", "path"),
                 (" is invalid; skipping:", "default")],
            ]
            if tmplines:
                errmsg += [
                    [(f"{type(e)}", "error"),
                     (": ", "default")] + tmplines[0],

                ]
                errmsg += tmplines[1:]
            else:
                errmsg += [(".", "error")]

            unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
            cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
            for line in printable_formatted_msg:
                ansithemeprint(line, stderr=True)
            print()
            continue

        kind = deep_get(d, DictPath("kind"), "<missing>")
        default_command = deep_get(d, DictPath("default_command"), "<missing>")
        if kind is None or default_command is None or "<missing>" in (kind, default_command):
            errmsg = [
                [("View-file ", "default"),
                 (f"{view_file}", "path"),
                 (" is invalid:", "default")],
                [("The following fields cannot be missing or None:", "default")],
                [("  • ", "separator"), ("kind", "argument")],
                [("  • ", "separator"), ("default_command", "argument")],
                [("Skipping.", "default")],
            ]
            unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
            cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
            formatted_msg[0].insert(0, ANSIThemeStr("Warning: ", "error"))
            for line in formatted_msg:
                ansithemeprint(line, stderr=True)
            print()
            continue

        api_family = deep_get(d, DictPath("api_family"), "")
        # Use a set to avoid duplicates
        _command = set()
        if not kind.startswith("__"):
            # If there's a "." in the command it means the plural or singular
            # is not unique without api_family;
            # do not add the lowercase form of kind automagically
            if "." not in default_command:
                _command.add(kind.lower())
        if deep_get(d, DictPath("command"), []):
            _command = set.union(_command, set(deep_get(d, DictPath("command"), [])))
        # OK, we've got all commands we wanted; now we want the preferred form first
        _command.discard(default_command)
        _command.add(default_command)
        # Finally, now that we have a list, add variants with api_family suffixed
        command = list(_command)
        if api_family:
            for item in _command:
                command.append(f"{item}.{api_family}")

        listview_entry = None

        if "listview" not in d and "infoview" not in d:
            errmsg = [
                [("View-file ", "default"),
                 (f"{view_file}", "path"),
                 (" lacks both listview and infoview; ", "default")],
                [("there might be a typo somewhere. Skipping.", "default")],
            ]
            unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
            cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
            formatted_msg[0].insert(0, ANSIThemeStr("Warning: ", "error"))
            for line in formatted_msg:
                ansithemeprint(line, stderr=True)
            print()
            continue

        if "listview" in d:
            # Do we need to override kind?
            if deep_get(d, DictPath("listview#kind")) is not None:
                kind = deep_get(d, DictPath("listview#kind"))
                api_family = deep_get(d, DictPath("listview#api_family"), "")
            name = deep_get(d, DictPath("listview#name"), "<missing>")
            group = deep_get(d, DictPath("listview#group"))

            check_availability = \
                check_allowlist(availability_checker_allowlist,
                                "availability_checker_allowlist",
                                deep_get(d, DictPath("listview#check_availability")),
                                allow_none=True)

            sortcolumn = deep_get(d, DictPath("listview#sortcolumn"))
            reversible = deep_get(d, DictPath("listview#reversible"), True)
            sortorder_reverse = deep_get(d, DictPath("listview#sortorder_reverse"), False)
            fields = deep_get(d, DictPath("listview#fields"), {})

            field_indexes = {}
            _indexes = deep_get(d, DictPath("listview#field_indexes"), {})
            confkind = kind
            viewname = name
            if api_family:
                confkind = f"{confkind}.{api_family}"
                viewname = f"{viewname} ({api_family})"

            custom_index = deep_get(cmtlib.cmtconfig,
                                    DictPath(f"Views#{confkind}#listview#field_indexes#Custom"), [])
            if custom_index:
                _indexes["Custom"] = custom_index

            if not _indexes:
                errmsg = [
                    [("View-file ", "default"),
                     (f"{view_file}", "path"),
                     (" is invalid:", "default")],
                    [("field_indexes", "argument"),
                     (" is either missing or empty for the list view. Skipping.", "default")],
                ]
                unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
                cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
                formatted_msg[0].insert(0, ANSIThemeStr("Warning: ", "error"))
                for line in formatted_msg:
                    ansithemeprint(line, stderr=True)
                print()
                continue

            field_indexes = copy.deepcopy(_indexes)

            # Allow for overriding the default sortcolumn and sortorder_reverse
            for field_index, data in field_indexes.items():
                if field_index in deep_get(cmtlib.cmtconfig,
                                           DictPath(f"Views#{confkind}#listview#field_indexes"),
                                           {}):
                    default_field_index_sortcolumn = \
                        deep_get(data, DictPath("sortcolumn"), sortcolumn)
                    default_field_index_sortorder_reverse = \
                        deep_get(data, DictPath("sortorder_reverse"), sortorder_reverse)
                    field_index_sortcolumn = \
                        deep_get(cmtlib.cmtconfig,
                                 DictPath(f"Views#{confkind}#listview#field_indexes#"
                                          f"{field_index}#sortcolumn"),
                                 default_field_index_sortcolumn)
                    field_index_sortorder_reverse = \
                        deep_get(cmtlib.cmtconfig,
                                 DictPath(f"Views#{confkind}#listview#field_indexes#"
                                          f"{field_index}#sortorder_reverse"),
                                 default_field_index_sortorder_reverse)
                    field_indexes[field_index]["sortcolumn"] = field_index_sortcolumn
                    field_indexes[field_index]["sortorder_reverse"] = field_index_sortorder_reverse

            if name is None or group is None or "<missing>" in (name, group):
                errmsg = [
                    [("View-file ", "default"),
                     (f"{view_file}", "path"),
                     (" is invalid:", "default")],
                    [("The following fields cannot be missing, empty or None:", "default")],
                    [("listview:", "default")],
                    [("  • ", "separator"), ("name", "argument")],
                    [("  • ", "separator"), ("group", "argument")],
                    [("Skipping.", "default")],
                ]
                unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
                cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
                formatted_msg[0].insert(0, ANSIThemeStr("Warning: ", "error"))
                for line in formatted_msg:
                    ansithemeprint(line, stderr=True)
                print()
                continue

            if viewname in views:
                # We allow for view-files to be overriden, but *only* if the override
                # is in another level of the directory stack. This way we'll probably
                # detect copy'n'paste errors, but at the same time allow for local overrides.
                conflicting_kind = deep_get(views[viewname], DictPath("kind"))
                conflicting_viewfile = deep_get(views[viewname], DictPath("view_file_path"))
                if os.path.dirname(conflicting_viewfile) == os.path.dirname(view_file):
                    sys.exit(f"Error when processing view-file {view_file} for kind: "
                             f"{(kind, api_family)};\n"
                             f"a view named {viewname} already exists "
                             f"for the kind: {conflicting_kind} "
                             f"in view-file {conflicting_viewfile}")
                else:
                    ansithemeprint([ANSIThemeStr("Note", "note"),
                                    ANSIThemeStr(": overriding view-file ", "default"),
                                    ANSIThemeStr(f"{conflicting_viewfile}", "path"),
                                    ANSIThemeStr(" with view-file ", "default"),
                                    ANSIThemeStr(f"{view_file}", "path"),
                                    ANSIThemeStr(".\n", "default")])

            # This complexity is required because if the key is missing we want to use the default,
            # but if the key is explicitly None we do not want any fallback
            if "infogetter" in deep_get(d, DictPath("listview")):
                infogetter = check_allowlist(infogetter_allowlist, "infogetter_allowlist",
                                             deep_get(d, DictPath("listview#infogetter")),
                                             allow_none=True)
            else:
                infogetter = infogetters.generic_infogetter

            listgetter_async = check_allowlist(listgetter_async_allowlist,
                                               "listgetter_async_allowlist",
                                               deep_get(d, DictPath("listview#listgetter_async")),
                                               allow_none=True)

            listgetter = check_allowlist(listgetter_allowlist, "listgetter_allowlist",
                                         deep_get(d, DictPath("listview#listgetter")),
                                         allow_none=True)

            # If both are unset we use the default asynchronous listgetter
            if "listgetter" not in deep_get(d, DictPath("listview")) and \
               "listgetter_async" not in deep_get(d, DictPath("listview")):
                listgetter_async = listgetters_async.get_kubernetes_list

            listgetter_args = deep_get(d, DictPath("listview#listgetter_args"), {})

            on_activation = deep_get(d, DictPath("listview#on_activation"))
            if on_activation is None or "call" not in on_activation:
                activatedfun: Callable[..., Retval] = genericinfoloop
            else:
                activatedfun = cast(Callable[..., Retval],
                                    check_allowlist(activatedfun_allowlist,
                                                    "activatedfun_allowlist",
                                                    deep_get(on_activation, DictPath("call")),
                                                    allow_none=True))

            if "labels" in deep_get(d, DictPath("listview"), {}):
                labels = deep_get(d, DictPath("listview#labels"))
            else:
                labels = "metadata#labels"

            listview_entry = {
                "kind": (kind, api_family),
                "commandline": command,
                "windowheader": name,
                "group": group,
                "check_availability": check_availability,
                "field_indexes": field_indexes,
                "fields": fields,
                "activatedfun": activatedfun,
                "listview_args": deep_get(d, DictPath("listview#listview_args"), {}),
                "statusmsg": deep_get(d, DictPath("listview#statusmsg"), {}),
                "is_taggable": deep_get(d, DictPath("listview#is_taggable"), True),
                "labels": labels,
                "listgetter": listgetter,
                "listgetter_async": listgetter_async,
                "listgetter_args": listgetter_args,
                "reversible": reversible,
                "infogetter": infogetter,
                "infogetter_args": deep_get(d, DictPath("listview#infogetter_args"), {}),
                "actions": deep_get(d, DictPath("listview#actions"), {}),
                "view_file_path": view_file,
            }

            shortcuts: dict[str, dict[str, Any]] = {}
            _shortcuts: dict[str, dict[str, Any]] = deep_get(d, DictPath("listview#shortcuts"), {})

            # Always include the shortcuts for YAML dump and JSON dump, unless overridden
            if "View YAML dump" not in _shortcuts:
                _shortcuts["View JSON dump of resource"] = {
                    "key": "j",
                    "read_only": True,
                    "helptext": "View JSON dump of resource",
                    "action": "call",
                    "action_call": "view_json",
                    "action_args": {
                        "title": "JSON dump",
                        "_named_title": True,
                        "_pass_obj": True,
                    },
                    "force_update": False,
                    "force_refresh": True,
                }
                _shortcuts["View YAML dump of resource"] = {
                    "key": "y",
                    "read_only": True,
                    "helptext": "View YAML dump of resource",
                    "action": "call",
                    "action_call": "view_yaml",
                    "action_args": {
                        "title": "YAML dump",
                        "_named_title": True,
                        "_pass_obj": True,
                    },
                    "force_update": False,
                    "force_refresh": True,
                }

            # Always include the shortcut for edit resource, unless overridden
            if "Edit resource" not in _shortcuts:
                _shortcuts["Edit resource"] = {
                    "key": "e",
                    "read_only": False,
                    "helptext": "Edit resource",
                    "action": "call",
                    "action_call": "edit_resource",
                    "action_args": {
                        "_pass_obj": True,
                        "_pass_kind": True,
                    },
                    "force_update": False,
                    "force_refresh": True,
                }

            for shortcut in _shortcuts:
                # If the shortcut is empty we are disabling a default shortcut
                if _shortcuts[shortcut] is None or not _shortcuts[shortcut]:
                    shortcuts[shortcut] = {}
                    continue

                key = deep_get(_shortcuts[shortcut], DictPath("key"), "<missing>")
                modifier = deep_get(_shortcuts[shortcut], DictPath("modifier"), "")
                helptext = deep_get(_shortcuts[shortcut], DictPath("helptext"), "<missing>")
                action = deep_get(_shortcuts[shortcut], DictPath("action"), "<missing>")
                action_args = deep_get(_shortcuts[shortcut], DictPath("action_args"), {})
                queryfunc = deep_get(_shortcuts[shortcut], DictPath("queryfunc"))
                queryval = deep_get(_shortcuts[shortcut], DictPath("queryval"))
                query = deep_get(_shortcuts[shortcut], DictPath("query"))
                read_only = deep_get(_shortcuts[shortcut], DictPath("read_only"), False)
                force_update = deep_get(_shortcuts[shortcut], DictPath("force_update"), True)
                force_refresh = deep_get(_shortcuts[shortcut], DictPath("force_refresh"), True)

                if key is None or helptext is None \
                        or action is None or "<missing>" in (key, helptext, action):
                    sys.exit(f"View-file {view_file} is invalid: "
                             "the following fields cannot be missing or None for a shortcut:\n"
                             f"key: {key}\n"
                             f"helptext: {helptext}\n"
                             f"action: {action}\n"
                             "Aborting.")

                key = key.lower()
                modifier = modifier.lower()

                shortcut_key, help_key = map_key(view_file, shortcut, activatedfun, key, modifier)

                shortcuts[shortcut] = {
                    "shortcut": shortcut_key,
                    "helptext": (help_key, helptext),
                    "action": action,
                    "action_args": action_args,
                    "action_call": action_args,
                    "queryfunc": queryfunc,
                    "queryval": queryval,
                    "query": query,
                    "read_only": read_only,
                    "force_update": force_update,
                    "force_refresh": force_refresh,
                }
                if action == "call":
                    shortcuts[shortcut]["action_call"] = \
                        check_allowlist(action_call_allowlist, "action_call_allowlist",
                                        deep_get(_shortcuts[shortcut], DictPath("action_call")),
                                        allow_none=True)

            if shortcuts:
                listview_entry["shortcuts"] = shortcuts

            # Replace existing listviews with the same name
            views.pop(name, None)

            # Add the new view
            has_listview = True
            views[viewname] = listview_entry

        infoview_entry = None

        if "infoview" in d:
            # Default kind and api_family unless overriden
            kind = deep_get(d, DictPath("kind"), "<missing>")
            api_family = deep_get(d, DictPath("api_family"), "")

            # Do we need to override kind?
            if deep_get(d, DictPath("infoview#kind")) is not None:
                kind = deep_get(d, DictPath("infoview#kind"))
                api_family = deep_get(d, DictPath("infoview#api_family"), "")
            name = deep_get(d, DictPath("infoview#name"), "<missing>")
            infopad: dict = deep_get(d, DictPath("infoview#infopad"), {})

            row_indexes: dict[str, dict[str, Any]] = {}
            row_fields: dict[str, Any] = {}

            _indexes = deep_get(infopad, DictPath("row_indexes"))

            if "row_indexes" in infopad:
                if not _indexes:
                    errmsg = [
                        [("View-file ", "default"),
                         (f"{view_file}", "path"),
                         (" is invalid:", "default")],
                        [("row_indexes", "argument"),
                         (" is empty for the info view. Skipping.", "default")],
                    ]
                    unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
                    cmtlog.log(LogLevel.ERR, msg=unformatted_msg, messages=formatted_msg)
                    formatted_msg[0].insert(0, ANSIThemeStr("Warning: ", "error"))
                    for line in formatted_msg:
                        ansithemeprint(line, stderr=True)
                    print()
                    continue

                # We are not using row_indexes in the same way field_indexes are used;
                # we do not support multiple profiles; since dicts are ordered by insertion
                # we get the rows in the right order if we order by row_indexes,
                # and we do not support resorting, so we do not need to include the row_indexes
                row_indexes = copy.deepcopy(deep_get(_indexes, DictPath("Normal#fields"), []))

                # Rows need to be reformatted
                infopad_rows = deep_get(infopad, DictPath("rows"), {})

                for row in row_indexes:
                    if row not in infopad_rows:
                        sys.exit(f"View {name}: row “{row}“ cannot be found in infoview\n"
                                 f"Infoview rows: {infopad_rows}\nrow names: {row_indexes}")
                    row_fields[row] = copy.deepcopy(deep_get(infopad_rows, DictPath(row), {}))
                    # We need to reformat the header
                    _header = deep_get(infopad_rows,
                                       DictPath(f"{row}#header"),
                                       [["<unset>", ["types", "unset"]]])
                    header: list[Union[ThemeRef, ThemeStr]] = []
                    try:
                        for string, formatting in _header:
                            header.append(ThemeStr(string,
                                                   ThemeAttr(formatting[0], formatting[1])))
                    except ValueError as e:
                        if str(e) == "not enough values to unpack (expected 2, got 1)":
                            sys.exit(f"Invalid header for info-header row \"{row}\" in file "
                                     f"\"{view_file}\"; this header doesn't "
                                     "seem to be a valid ThemeArray")
                    row_fields[row]["header"] = header

            listpad = deep_get(d, DictPath("infoview#listpad"), {})

            on_activation = deep_get(listpad, DictPath("on_activation"))
            activatedfun = cast(Callable[..., Retval],
                                check_allowlist(activatedfun_allowlist,
                                                "activatedfun_allowlist",
                                                deep_get(on_activation, DictPath("call")),
                                                allow_none=True))
            override_kind = deep_get(on_activation, DictPath("kind"))
            override_api_family = deep_get(on_activation, DictPath("api_family"), "")
            on_activation_extraref = deep_get(on_activation, DictPath("extraref"))
            on_activation_data = deep_get(on_activation, DictPath("data"))
            if override_kind is None:
                viewoverride = (kind, api_family)
            else:
                viewoverride = (override_kind, override_api_family)
                on_activation["kind"] = viewoverride
                on_activation.pop("api_family", "")

            if "labels" in deep_get(d, DictPath("listview"), {}):
                labels = deep_get(d, DictPath("listview#labels"))
            else:
                labels = "metadata#labels"
            if "annotations" in deep_get(d, DictPath("listview"), {}):
                annotations = deep_get(d, DictPath("infoview#annotations"))
            else:
                annotations = "metadata#annotations"

            sortcolumn = deep_get(listpad, DictPath("sortcolumn"))
            reversible = deep_get(listpad, DictPath("reversible"), True)
            sortorder_reverse = deep_get(listpad, DictPath("sortorder_reverse"), False)

            listpad_fields = deep_get(listpad, DictPath("fields"), {})

            listpad_field_indexes: dict[str, dict[str, Any]] = {}
            _indexes = deep_get(listpad, DictPath("field_indexes"), {})
            confkind = kind
            if api_family:
                confkind = f"{confkind}.{api_family}"
            custom_index = \
                deep_get(cmtlib.cmtconfig,
                         DictPath(f"Views#{confkind}#infoview#listpad#field_indexes#Custom"), [])
            if custom_index:
                _indexes["Custom"] = custom_index

            for key in _indexes:
                if isinstance(_indexes[key], list):
                    listpad_field_indexes[key] = {}
                    listpad_field_indexes[key]["fields"] = copy.deepcopy(_indexes[key])
                    listpad_field_indexes[key]["sortcolumn"] = sortcolumn
                    listpad_field_indexes[key]["sortorder_reverse"] = sortorder_reverse
                else:
                    listpad_field_indexes = copy.deepcopy(_indexes)

            infoview_entry = {
                "kind": (kind, api_family),
                "windowheader": name,
                "field_indexes": listpad_field_indexes,
                "fields": listpad_fields,
                "activatedfun": activatedfun,
                "infoview_args": deep_get(d, DictPath("infoview#infoview_args"), {}),
                "statusmsg": deep_get(d, DictPath("infoview#statusmsg"), {}),
                "viewoverride": viewoverride,
                "extraref": on_activation_extraref,
                "data": on_activation_data,
                "infopad": row_fields,
                "listpad": {},
                "reversible": reversible,
                "labels": labels,
                "annotations": annotations,
                "shortcuts": {},
                "no_reload_on_refresh": deep_get(d, DictPath("infoview#no_reload_on_refresh"),
                                                 False),
                "view_file_path": view_file,
            }
            infoview_entry["objgetter"] = \
                check_allowlist(objgetter_allowlist, "objgetter_allowlist",
                                deep_get(infopad, DictPath("objgetter")),
                                allow_none=True)

            if listpad:
                infoview_entry["listpad"]["on_activation"] = on_activation

            if infopad is not None:
                if "name_path" in infopad:
                    infoview_entry["name_path"] = deep_get(infopad, DictPath("name_path"))
                if "namespace_path" in infopad:
                    infoview_entry["namespace_path"] = deep_get(infopad, DictPath("namespace_path"))
                if "creation_timestamp_path" in infopad:
                    infoview_entry["creation_timestamp_path"] = \
                        deep_get(infopad, DictPath("creation_timestamp_path"))

            list_listgetter = deep_get(listpad, DictPath("listgetter"))
            list_listgetter_args = deep_get(listpad, DictPath("listgetter_args"), {})
            list_infogetter = deep_get(listpad, DictPath("infogetter"))
            list_infogetter_args = deep_get(listpad, DictPath("infogetter_args"))
            if list_infogetter is None:
                if listpad:
                    raise ValueError(f"View-file {view_file} is invalid: "
                                     "listpad specified, but no infogetter is provided")
            else:
                infoview_entry["listpad"]["infogetter"] = \
                    check_allowlist(infogetter_allowlist, "infogetter_allowlist",
                                    list_infogetter)
                infoview_entry["listpad"]["infogetter_args"] = list_infogetter_args
            if list_listgetter is None:
                if listpad:
                    raise ValueError(f"View-file {view_file} is invalid: "
                                     "listpad specified, but no listgetter is provided")
            else:
                infoview_entry["listpad"]["listgetter"] = \
                    check_allowlist(listgetter_allowlist, "listgetter_allowlist",
                                    list_listgetter)
                infoview_entry["listpad"]["listgetter_args"] = list_listgetter_args

            shortcuts = {}

            _shortcuts = deep_get(d, DictPath("infoview#shortcuts"), {})

            # Always include the shortcuts for YAML dump and JSON dump, unless overridden
            if "View YAML dump" not in _shortcuts:
                _shortcuts["View JSON dump of resource"] = {
                    "key": "j",
                    "read_only": True,
                    "helptext": "View JSON dump of resource",
                    "action": "call",
                    "action_call": "view_json",
                    "action_args": {
                        "title": "JSON dump",
                        "_named_title": True,
                        "_pass_obj": True,
                    },
                }
                _shortcuts["View YAML dump of resource"] = {
                    "key": "y",
                    "read_only": True,
                    "helptext": "View YAML dump of resource",
                    "action": "call",
                    "action_call": "view_yaml",
                    "action_args": {
                        "title": "YAML dump",
                        "_named_title": True,
                        "_pass_obj": True,
                    },
                }

            # Always include the shortcut for last applied configuration, unless overridden
            if "Last Applied Configuration" not in _shortcuts:
                _shortcuts["Last Applied Configuration"] = {
                    "key": "l",
                    "modifier": "shift",
                    "read_only": True,
                    "helptext": "Show last applied configuration",
                    "action": "call",
                    "action_call": "view_last_applied_configuration",
                    "action_args": {
                        "_pass_obj": True,
                        "title": "Last applied configuration",
                    }
                }

            # Always include the shortcut for events unless overriden
            if "Show Events" not in _shortcuts:
                _shortcuts["Show Events"] = {
                    "key": "e",
                    "read_only": True,
                    "helptext": "Show events",
                    "widget": "windowwidget",
                    "selectable": True,
                    "action": "call",
                    "action_call": "resourceinfodispatch_with_lookup",
                    "action_args": {
                        "kind": "Event",
                        "namespace_path": 0,
                        "name_path": 1,
                    },
                    "title": "Events:",
                    "headers": ["Namespace:", "Name:", "Last Seen:", "Status:",
                                "Reason:", "Source:", "First Seen:", "Count:", "Message:"],
                    "itemgetter": "get_events",
                }

            for shortcut in _shortcuts:
                # If the shortcut is empty we are disabling a default shortcut
                if _shortcuts[shortcut] is None or not _shortcuts[shortcut]:
                    shortcuts[shortcut] = {}
                    continue

                key = deep_get(_shortcuts[shortcut], DictPath("key"), "<missing>")
                modifier = deep_get(_shortcuts[shortcut], DictPath("modifier"), "")
                helptext = deep_get(_shortcuts[shortcut], DictPath("helptext"), "<missing>")
                action = deep_get(_shortcuts[shortcut], DictPath("action"), "<missing>")
                action_args = deep_get(_shortcuts[shortcut], DictPath("action_args"), {})
                queryfunc = deep_get(_shortcuts[shortcut], DictPath("queryfunc"))
                queryval = deep_get(_shortcuts[shortcut], DictPath("queryval"))
                query = deep_get(_shortcuts[shortcut], DictPath("query"))
                widget = deep_get(_shortcuts[shortcut], DictPath("widget"))
                widget_args = deep_get(_shortcuts[shortcut], DictPath("widget_args"))
                inputtitle = deep_get(_shortcuts[shortcut], DictPath("inputtitle"))
                confirm = deep_get(_shortcuts[shortcut], DictPath("confirm"))
                confirmtitle = deep_get(_shortcuts[shortcut], DictPath("confirmtitle"))
                w_title = deep_get(_shortcuts[shortcut], DictPath("title"))
                w_headers = deep_get(_shortcuts[shortcut], DictPath("headers"))
                w_selectable = deep_get(_shortcuts[shortcut], DictPath("selectable"))
                w_itemgetter = check_allowlist(itemgetter_allowlist, "itemgetter_allowlist",
                                               deep_get(_shortcuts[shortcut],
                                                        DictPath("itemgetter")),
                                               allow_none=True)
                w_itemgetter_args = deep_get(_shortcuts[shortcut], DictPath("itemgetter_args"), {})
                _w_formatting = deep_get(_shortcuts[shortcut], DictPath("formatting"))
                w_formatting = None
                if _w_formatting is not None:
                    w_formatting = []
                    for fmt in _w_formatting:
                        w_formatting.append(fmt)
                w_sortcolumn = deep_get(_shortcuts[shortcut], DictPath("sortcolumn"), {})

                if key is None or helptext is None \
                        or action is None or "<missing>" in (key, helptext):
                    sys.exit(f"View-file {view_file} is invalid: "
                             "the following fields cannot be missing or None for a shortcut:\n"
                             f"key: {key}\n"
                             f"helptext: {helptext}\n"
                             "Aborting.")

                if widget is None and "<missing>" == action:
                    sys.exit(f"View-file {view_file} is invalid: "
                             "at least one of [widget, action] needs to be specified.\n"
                             "Aborting.")

                key = key.lower()
                modifier = modifier.lower()

                shortcut_key, help_key = map_key(view_file, shortcut, activatedfun, key, modifier)

                shortcuts[shortcut] = {
                    "shortcut": shortcut_key,
                    "helptext": (help_key, helptext),
                    "action": action,
                    "action_args": action_args,
                    "action_call": None,
                    "queryfunc": queryfunc,
                    "queryval": queryval,
                    "query": query,
                    "widget": widget,
                    "widget_args": widget_args,
                    "inputtitle": inputtitle,
                    "confirm": confirm,
                    "confirmtitle": confirmtitle,
                    "title": w_title,
                    "headers": w_headers,
                    "itemgetter": w_itemgetter,
                    "itemgetter_args": w_itemgetter_args,
                    "selectable": w_selectable,
                    "formatting": w_formatting,
                    "sortcolumn": w_sortcolumn,
                }
                if action == "call":
                    shortcuts[shortcut]["action_call"] = \
                        check_allowlist(action_call_allowlist, "action_call_allowlist",
                                        deep_get(_shortcuts[shortcut], DictPath("action_call")),
                                        allow_none=True)

            if logpad := deep_get(d, DictPath("infoview#logpad"), {}):
                if deep_get(infoview_entry, DictPath("listpad"), {}):
                    sys.exit(f"View-file “{view_file}“ is invalid: "
                             "listpad and logpad cannot be used concurrently.")

                log_infogetter = deep_get(logpad, DictPath("infogetter"))
                if log_infogetter is None:
                    raise ValueError("View-file {view_file} is invalid: "
                                     "logpad specified, but no infogetter is provided")
                logpad["infogetter"] = deep_get(infogetter_allowlist, DictPath(log_infogetter))
                infoview_entry["logpad"] = copy.deepcopy(logpad)

            if not infoview_entry["listpad"]:
                infoview_entry.pop("listpad")

            if shortcuts:
                infoview_entry["shortcuts"] = shortcuts

            # Replace existing listviews with the same name
            if (kind, api_family) in infoviews:
                del infoviews[(kind, api_family)]

            # Add the new view
            infoviews[(kind, api_family)] = infoview_entry
            has_infoview = True

        if kubernetes_support:
            kh_update_api_status((kind, api_family), listview=has_listview, infoview=has_infoview)


def setupui(stdscr: curses.window) -> None:
    """
    Setup the curses UI.
    Note: We might want to move this to curses_helper.py.

        Parameters:
            stdscr (curses.window): The curses window to operate on
    """
    # Hide the cursor; seems some implementations of curses (or terminals?)
    # might not support toggling the cursor; they will throw an exception instead.
    # Catch this an pretend that everything is fine.
    try:
        curses.curs_set(False)
    except curses.error:
        pass
    # Disable CTRL+C, CTRL+Z, etc.
    curses.raw()
    # Enable mouse support
    enable_mouse = deep_get(cmtlib.cmtconfig, DictPath("Mouse#enable"), True)
    if enable_mouse:
        curses_helper.set_mousemask(-1)
    else:
        curses_helper.set_mousemask(0)
    curses_helper.init_curses()

    while True:
        if deep_get(views, DictPath(defaultview)) is not None:
            viewfunc = deep_get(views, DictPath(f"{defaultview}#viewfunc"))
            if viewfunc is None:
                viewfunc = genericlistloop
            check_availability = deep_get(views, DictPath(f"{defaultview}#check_availability"))
            if check_availability is not None and not check_availability():
                curses.endwin()
                ansithemeprint([ANSIThemeStr("Error", "error"),
                                ANSIThemeStr(": The requested view “", "default"),
                                ANSIThemeStr(defaultview, "argument"),
                                ANSIThemeStr("“ is not available; ", "default"),
                                ANSIThemeStr("the cluster may be offline or the API disabled.",
                                             "default")])
                sys.exit(errno.ENOTSUP)
            viewfunc(stdscr, kind=defaultview)
        else:
            curses.endwin()
            ansithemeprint([ANSIThemeStr("Error", "error"),
                            ANSIThemeStr(": Unknown view “", "default"),
                            ANSIThemeStr(defaultview, "argument"),
                            ANSIThemeStr("“; check “", "default"),
                            ANSIThemeStr(CMT_CONFIG_FILE, "path"),
                            ANSIThemeStr("“ and all files in “", "default"),
                            ANSIThemeStr(CMT_CONFIG_FILE_DIR, "path"),
                            ANSIThemeStr("“ for typos.", "default")], stderr=True)
            sys.exit(errno.ENOENT)


# pylint: disable-next=unused-argument
def list_namespaces(options: list[tuple[str, str]], args: list[str]) -> None:
    """
    List all available namespaces.

        Parameters:
            options ([(str, str)]): List of opt, optarg
            args ([str]): [unused]
    """
    color: str = "auto"

    # Valid formats:
    # default = Normal output format (default)
    # csv = Comma-separated values
    # ssv = Space-separated values
    # tsv = Tab-separated values
    output_format: str = "default"
    separator: str = ""

    for opt, optarg in options:
        if opt == "--color":
            color = optarg
        elif opt == "--format":
            output_format = optarg

    init_kubernetes_client()

    tmp, status = kh.get_list_by_kind_namespace(("Namespace", ""), "", resource_cache=kh_cache)
    if status in (42503, 42504):
        ansithemeprint([ANSIThemeStr("Error", "error"),
                        ANSIThemeStr(": API-server unavailable", "default")], stderr=True)
        sys.exit(errno.ENOENT)
    elif status != 200:
        ansithemeprint([ANSIThemeStr("Error", "error"),
                        ANSIThemeStr(": API-server returned ", "default"),
                        ANSIThemeStr(f"{status}", "errorvalue")], stderr=True)
        sys.exit(errno.EINVAL)

    namespaces = [deep_get(item, DictPath("metadata#name")) for item in tmp]

    if output_format == "default":
        ansithemeprint([ANSIThemeStr("Valid namespaces: ", "default")]
                       + ansithemestr_join_list(namespaces, formatting="namespace",
                                                separator=ANSIThemeStr(", ", "separator"))
                       + [ANSIThemeStr(".", "separator")], color=color)
    else:
        if output_format == "csv":
            separator = ","
        elif output_format == "ssv":
            separator = " "
        elif output_format == "tsv":
            separator = "\t"

        ansithemeprint(ansithemestr_join_list(namespaces, formatting="namespace",
                       separator=ANSIThemeStr(separator, "separator")), color=color)


# pylint: disable-next=unused-argument,disable-next=too-many-branches,too-many-statements
def list_views(options: list[tuple[str, str]], args: list[str]) -> None:
    """
    List available views and their supported fields and default sort column.

        Parameters:
            options ([(str, str)]): List of opt, optarg
            args ([str]): [unused]
    """
    viewfields = []
    maxviewlen = 0
    maxkindlen = 0

    # Customises the list views
    ansithemeprint([ANSIThemeStr("Stand by, updating list of supported views...\n", "default")])

    init_kubernetes_client()
    populate_views()
    customise_listviews()

    for view in cast(dict[str, dict[str, Any]], natsorted(views)):
        viewref = views[view]
        if "skip" in viewref:
            continue
        if "kind" not in viewref or viewref["kind"] is None:
            continue
        if "fields" not in viewref:
            continue

        fields = []
        fieldset = set()
        sortcolumn = ""
        # This is necessary because of built-in fields
        for values in deep_get(viewref, DictPath("field_indexes"), {}).values():
            fieldset.update(deep_get(values, DictPath("fields"), []))
            if not sortcolumn:
                sortcolumn = deep_get(values, DictPath("sortcolumn"), "")
        fieldset.union(set(deep_get(viewref, DictPath("fields"), {}).keys()))

        for fieldname in fieldset:
            if sortcolumn == "" and fieldname == "name":
                fields.append(ANSIThemeStr(f"[{fieldname}]", "note"))
            elif fieldname == sortcolumn:
                fields.append(ANSIThemeStr(f"<{fieldname}>", "emphasis"))
            else:
                fields.append(ANSIThemeStr(fieldname, "default"))
        kind = viewref["kind"][0]
        api_group = viewref["kind"][1]
        if api_group == "":
            viewfields.append((view, f"{kind}", fields))
            maxkindlen = max(maxkindlen, len(f"{kind}"))
        else:
            viewfields.append((view, f"{kind}.{api_group}", fields))
            maxkindlen = max(maxkindlen, len(f"{kind}.{api_group}"))
        maxviewlen = max(maxviewlen, len(view))

    ansithemeprint([ANSIThemeStr("View:", "header"),
                    ANSIThemeStr(f"{''.ljust(maxviewlen + 2 - len('View:'))}", "default"),
                    ANSIThemeStr("Kind:", "header"),
                    ANSIThemeStr(f"{''.ljust(maxkindlen + 2 - len('Kind:'))}", "default"),
                    ANSIThemeStr("Supported fields:", "header")])
    for view, kind, fields in viewfields:
        joined_fields = ansithemestr_join_list(fields, separator=ANSIThemeStr(", ", "separator"))
        ansithemeprint([ANSIThemeStr(f"{view.ljust(maxviewlen + 2)}"
                                     f"{kind.ljust(maxkindlen + 2)}",
                                     "default")] + joined_fields)

    ansithemeprint([ANSIThemeStr("\nList views can be customised to only show select fields "
                                 "by editing “", "default"),
                    ANSIThemeStr(CMT_CONFIG_FILE, "path"),
                    ANSIThemeStr("“.\n", "default")])
    ansithemeprint([ANSIThemeStr("Simply add “", "default"),
                    ANSIThemeStr("field:", "emphasis"),
                    ANSIThemeStr("“ followed by a list of the fields you want the list to a "
                                 "section named like", "default")])
    ansithemeprint([ANSIThemeStr("the list view you want to customise.\n", "default")])

    ansithemeprint([ANSIThemeStr("Note that the fields “", "default"),
                    ANSIThemeStr("name", "emphasis"),
                    ANSIThemeStr("“ and, if applicable “", "default"),
                    ANSIThemeStr("namespace", "emphasis"),
                    ANSIThemeStr("“, will unconditionally", "default")])
    ansithemeprint([ANSIThemeStr("be included even if the list of fields does not include "
                                 "them; including them", "default")])
    ansithemeprint([ANSIThemeStr("in the list will only allow reordering the "
                                 "fields.\n", "default")])

    ansithemeprint([ANSIThemeStr("The fields in this list are those supported by ", "default"),
                    ANSIThemeStr(f"{about.UI_PROGRAM_NAME}", "programname"),
                    ANSIThemeStr("; it is NOT an exhaustive list", "default")])
    ansithemeprint([ANSIThemeStr("of fields available in the resource.\n", "default")])

    ansithemeprint([ANSIThemeStr("If a field is marked ", "default"),
                    ANSIThemeStr("<field>", "emphasis"),
                    ANSIThemeStr(" it is the explicit sortcolumn.", "default")])
    ansithemeprint([ANSIThemeStr("If the field is marked ", "default"),
                    ANSIThemeStr("[field]", "note"),
                    ANSIThemeStr(" it is the implicit sortcolumn.", "default")])
    ansithemeprint([ANSIThemeStr("Note: the brackets (“<“, “>“, “[“, and “]“) are not part "
                                 "of the field names.", "default")])


def checkforview(arg: Union[str, tuple[str, str]]) -> Optional[str]:
    """
    Check whether a view exists.

        Parameters:
            arg (str|(str, str)): Either the name of a view or a (kind, api_family) tuple
        Returns:
            (str): The key for the matching view, or None if no such view was found
    """
    for view, viewref in views.items():
        if isinstance(arg, str):
            if arg in deep_get(viewref, DictPath("commandline"), []):
                return view
        else:
            if arg == deep_get(viewref, DictPath("kind"), ("", "")):
                return view
    return None


def customise_listviews() -> None:
    """
    Apply user-provided customisation to the list views.
    """
    for view, viewref in views.items():
        if "skip" in viewref:
            continue
        if "kind" not in viewref or viewref["kind"] is None:
            continue
        if "fields" not in viewref:
            continue

        # OK, we've now (hopefully) skipped all views that do not have a list view
        fields: list[str] = deep_get(cmtlib.cmtconfig, DictPath(f"Views#{view}#fields"), [])
        if not fields:
            continue

        custom_fields: dict = {}

        viewref_fields = deep_get(viewref, DictPath("fields"), [])

        if "namespace" in viewref_fields and "namespace" not in fields:
            custom_fields["namespace"] = None
        if "name" not in fields:
            custom_fields["name"] = None

        for field in fields:
            if field not in fields:
                ansithemeprint([ANSIThemeStr("Error", "error"),
                                ANSIThemeStr(": “", "default"),
                                ANSIThemeStr(field, "option"),
                                ANSIThemeStr("“ is not a valid field for the view “", "default"),
                                ANSIThemeStr(view, "argument"),
                                ANSIThemeStr("“; aborting.", "default")], stderr=True)
                sys.exit(errno.EINVAL)
            elif field in custom_fields:
                ansithemeprint([ANSIThemeStr("Warning", "warning"),
                                ANSIThemeStr(": “", "default"),
                                ANSIThemeStr(field, "option"),
                                ANSIThemeStr("“ is specified twice (or more) for the view “",
                                             "default"),
                                ANSIThemeStr(view, "argument"),
                                ANSIThemeStr("“; ignoring.", "default")], stderr=True)
                continue
            custom_fields[field] = None
        viewref["fields_custom"] = list(custom_fields)

        # Next up it is time for the field denylist
        if "denylist" in deep_get(cmtlib.cmtconfig, DictPath(f"Views#{view}"), {}):
            denylist = deep_get(cmtlib.cmtconfig, DictPath(f"Views#{view}#fields"), [])
            viewref["field_denylist"] = denylist

    # As a special case, the configuration option "Inventory#ping_hosts"
    # modifies the denylist, but *only* if the field denylist is unset
    ping_hosts = deep_get(cmtlib.cmtconfig, DictPath("__Inventory#ping_hosts"), "Lazy")
    if "Inventory" in views and ping_hosts == "Never" \
            and "field_denylist" not in views["Inventory"]:
        views["Inventory"]["field_denylist"] = ["status"]


# pylint: disable-next=too-many-branches,too-many-statements
def open_view(options: list[tuple[str, str]], args: list[str]) -> None:
    """
    Open the specified view.

        Parameters:
            options ([(str, str)]): List of opt, optarg
            args ([str]): The view to open,
                          followed by specifiers for object, namespace,
                          and--if applicable--container/configmap
    """
    global initial_name  # pylint: disable=global-statement
    global initial_namespace  # pylint: disable=global-statement
    global initial_container  # pylint: disable=global-statement
    global read_only_mode  # pylint: disable=global-statement
    global selected_namespace  # pylint: disable=global-statement
    global defaultview  # pylint: disable=global-statement
    global kubernetes_support  # pylint: disable=global-statement

    tmpdefaultview = deep_get(cmtlib.cmtconfig, DictPath("Global#defaultview"), "")

    for opt, optarg in options:
        if opt == "--namespace":
            selected_namespace = optarg
        elif opt == "--read-only":
            read_only_mode = True
        elif opt == "--disable-kubernetes":
            kubernetes_support = False

    init_kubernetes_client()

    # Customises the list views
    ansithemeprint([ANSIThemeStr("Populating list of supported views...\n", "default")])

    populate_views()
    customise_listviews()

    if args:
        tmpview = checkforview(args[0].lower())
        if tmpview is None:
            ansithemeprint([ANSIThemeStr("Unsupported or unavailable view “", "default"),
                            ANSIThemeStr(f"{args[0].lower()}", "command"),
                            ANSIThemeStr("“;", "default")], stderr=True)
            ansithemeprint([ANSIThemeStr("Use “", "default"),
                            ANSIThemeStr(f"{about.UI_PROGRAM_NAME} ", "programname"),
                            ANSIThemeStr("list-views", "command"),
                            ANSIThemeStr("“ to list available views.", "default")], stderr=True)
            sys.exit(errno.EINVAL)
        defaultview = tmpview
    else:
        if tmpdefaultview is not None and tmpdefaultview != "":
            defaultview = tmpdefaultview
        else:
            defaultview = "Selector"

    if len(args) > 1:
        # The argument is either OBJECT, NAMESPACE/OBJECT, OBJECT:MEMBER, or NAMESPACE/OBJECT:MEMBER
        initial_name = args[1]
        if "/" in initial_name:
            initial_namespace, initial_name = initial_name.split("/")
        if ":" in initial_name:
            initial_name, initial_container = initial_name.split(":")

        if initial_container is not None and \
                initial_container and defaultview not in ("Pods", "Config Maps"):
            ansithemeprint([ANSIThemeStr(f"{about.UI_PROGRAM_NAME}", "programname"),
                            ANSIThemeStr(": invalid syntax;", "default")], stderr=True)
            ansithemeprint([ANSIThemeStr("Specifying a member", "description"),
                            ANSIThemeStr(" is only supported for ", "default"),
                            ANSIThemeStr("pod", "command"),
                            ANSIThemeStr(" and ", "description"),
                            ANSIThemeStr("configmap", "command"),
                            ANSIThemeStr(" view.", "default")], stderr=True)
            ansithemeprint([ANSIThemeStr("Try “", "default"),
                            ANSIThemeStr(f"{about.UI_PROGRAM_NAME} ", "programname"),
                            ANSIThemeStr("help", "command"),
                            ANSIThemeStr("“ for more information.", "default")], stderr=True)
            sys.exit(errno.EINVAL)

    # We do not need escape sequences, so cut down on the delay to 25ms
    os.environ.setdefault("ESCDELAY", "25")

    init_kubernetes_client()
    ansithemeprint([ANSIThemeStr("Checking available Kubernetes APIs\n", "default")])
    if kubernetes_support:
        _available_api_families, _status, _modified = kh.get_available_kinds()

    # Customises the list views if necessary
    if not infoviews:
        ansithemeprint([ANSIThemeStr("Populating list of supported views...\n", "default")])
        populate_views()
        customise_listviews()

    try:
        wrapper(setupui)
    except curses.error as e:
        # We don't really know *why* it failed to close the window,
        # but we don't really care, since we're about to close down anyway.
        if str(e) == "endwin() returned ERR":
            pass
        elif str(e) == "setupterm: could not find terminal":
            term = os.getenv("TERM", "<unknown>")
            sys.exit(f"Error: Could not initialise curses; your terminal environment TERM={term}\n"
                     "might invalid or lack required features.")
        else:
            raise


COMMANDLINE: dict[str, CommandType] = {
    # This is purely for the benefit of the helptext generator
    "View": {
        "command": ["VIEW"],
        "description": [
            ANSIThemeStr("start in ", "description"),
            ANSIThemeStr("VIEW", "command")],
        "required_args": [],
        "optional_args": [],
        "callback": None,
    },
    "View [NAMESPACE/]OBJECT[:MEMBER]": {
        "command": ["VIEW"],
        "values": [ANSIThemeStr("[", "separator"),
                   ANSIThemeStr("NAMESPACE/", "argument"),
                   ANSIThemeStr("]", "separator"),
                   ANSIThemeStr("OBJECT", "argument"),
                   ANSIThemeStr("[", "separator"),
                   ANSIThemeStr(":", "argument"),
                   ANSIThemeStr("[", "separator"),
                   ANSIThemeStr("MEMBER", "argument"),
                   ANSIThemeStr("]]", "separator")],
        "description": [ANSIThemeStr("start in ", "description"),
                        ANSIThemeStr("VIEW", "command"),
                        ANSIThemeStr(" for ", "description"),
                        ANSIThemeStr("OBJECT", "argument")],
        "extended_description": [
            [ANSIThemeStr("Sometimes ", "description"),
             ANSIThemeStr("OBJECT", "argument"),
             ANSIThemeStr(" may need to be qualified by using", "description")],
            [ANSIThemeStr("NAMESPACE", "argument"),
             ANSIThemeStr(", but if there's only one unique match", "description")],
            [ANSIThemeStr(about.UI_PROGRAM_NAME, "programname"),
             ANSIThemeStr(" will open that match. If an object has members", "description")],
            [ANSIThemeStr("(containers or configmaps), these can be opened", "description")],
            [ANSIThemeStr("using the ", "description"),
             ANSIThemeStr(":MEMBER", "argument"),
             ANSIThemeStr(" syntax. If there's only one", "description")],
            [ANSIThemeStr("member specifying ", "description"),
             ANSIThemeStr(":", "argument"),
             ANSIThemeStr(" is sufficient.", "description")],
        ],
        "required_args": [],
        "optional_args": [],
        "callback": None,
    },
    "spacer1": {
        "command": [""],
        "description": [ANSIThemeStr("", "description")],
        "required_args": [],
        "optional_args": [],
        "callback": None,
    },
    "List Namespaces": {
        "command": ["list-namespaces"],
        "description": [ANSIThemeStr("List valid namespaces and exit", "description")],
        "options": {
            "--color": {
                "values": [ANSIThemeStr("WHEN", "argument")],
                "description":
                    [ANSIThemeStr("WHEN should the output use ANSI-colors", "description")],
                "extended_description": [
                    [ANSIThemeStr("Valid arguments are:", "description")],
                    [ANSIThemeStr("always", "argument"),
                     ANSIThemeStr(" (always color the output)", "description")],
                    [ANSIThemeStr("auto", "argument"),
                     ANSIThemeStr(" (color the output when outputting", "description")],
                    [ANSIThemeStr("to a terminal)", "description")],
                    [ANSIThemeStr("never", "argument"),
                     ANSIThemeStr(" (never color the output)", "description")],
                ],
                "requires_arg": True,
                "validation": {
                    "validator": "allowlist",
                    "allowlist": [
                        "always",
                        "auto",
                        "never",
                    ],
                },
            },
            "--format": {
                "values": [ANSIThemeStr("FORMAT", "argument")],
                "description": [ANSIThemeStr("Format the output as ", "description"),
                                ANSIThemeStr("FORMAT", "description")],
                "extended_description": [
                    [ANSIThemeStr("Valid formats are:", "description")],
                    [ANSIThemeStr("default", "argument"),
                     ANSIThemeStr(" (default format)", "description")],
                    [ANSIThemeStr("csv", "argument"),
                     ANSIThemeStr(" (comma-separated values)", "description")],
                    [ANSIThemeStr("ssv", "argument"),
                     ANSIThemeStr(" (space-separated values)", "description")],
                    [ANSIThemeStr("tsv", "argument"),
                     ANSIThemeStr(" (tab-separated values)", "description")],
                ],
                "requires_arg": True,
                "validation": {
                    "validator": "allowlist",
                    "allowlist": [
                        "default",
                        "csv",
                        "ssv",
                        "tsv",
                    ],
                },
            },
        },
        "required_args": [],
        "optional_args": [],
        "callback": list_namespaces,
    },
    "List Views": {
        "command": ["list-views"],
        "description": [ANSIThemeStr("List view information and exit", "description")],
        "required_args": [],
        "optional_args": [],
        "callback": list_views,
    },
    "__*": {
        "command": ["*"],
        "command_alias": "VIEW",
        "values": [ANSIThemeStr("[", "separator"),
                   ANSIThemeStr("NAMESPACE/", "argument"),
                   ANSIThemeStr("]", "separator"),
                   ANSIThemeStr("OBJECT", "argument"),
                   ANSIThemeStr("[", "separator"),
                   ANSIThemeStr(":", "argument"),
                   ANSIThemeStr("[", "separator"),
                   ANSIThemeStr("MEMBER", "argument"),
                   ANSIThemeStr("]]", "separator")],
        "description": [ANSIThemeStr("start in ", "description"),
                        ANSIThemeStr("VIEW", "command"),
                        ANSIThemeStr(" for ", "description"),
                        ANSIThemeStr("OBJECT", "argument")],
        "extended_description": [
            [ANSIThemeStr("Sometimes ", "description"),
             ANSIThemeStr("OBJECT", "argument"),
             ANSIThemeStr(" may need to be qualified by using", "description")],
            [ANSIThemeStr("NAMESPACE", "argument"),
             ANSIThemeStr(", but if there's only one unique match", "description")],
            [ANSIThemeStr(about.UI_PROGRAM_NAME, "programname"),
             ANSIThemeStr(" will open that match. If an object has members", "description")],
            [ANSIThemeStr("(containers or configmaps), these can be opened", "description")],
            [ANSIThemeStr("using the ", "description"),
             ANSIThemeStr(":MEMBER", "argument"),
             ANSIThemeStr(" syntax. If there's only one", "description")],
            [ANSIThemeStr("member specifying ", "description"),
             ANSIThemeStr(":", "argument"),
             ANSIThemeStr(" is sufficient", "description")],
        ],
        "required_args": [],
        "optional_args": [
            {
                "name": "view",
                "string": [ANSIThemeStr("VIEW", "command")],
                "validation": {
                    "validator": "regex",
                    "regex": r"^[a-zA-Z][a-zA-Z0-9.-]*?[a-zA-Z0-9]$"
                },
            },
            {
                "name": "object_namespace_member",
                "string": [ANSIThemeStr("NAME", "argument")],
                "validation": {
                    "validator": "regex",
                    # In order:
                    # object (RFC-1123 dns-subdomain)
                    # object (RFC-1123 dns-subdomain):container (RFC-1123 dns-label)
                    # namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain)
                    # namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain):container
                    # (RFC-1123 dns-label)
                    "regex":
                        r"^("
                        r"[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?|"
                        r"[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?:|"
                        r"[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?:[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]?|"
                        r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]/[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?|"
                        r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]/[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?:|"
                        r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]/[a-z0-9][a-z0-9.-]{0,251}[a-z0-9]?:"
                        r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]?"
                        r")$",
                },
            },
            {
                "name": "namespace",
                "string": [ANSIThemeStr("NAMESPACE", "command")],
                "validation": {
                    "validator": "regex",
                    # namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain)
                    "regex": r"^("
                             r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]|"
                             r")$",
                },
            },
            {
                "name": "member",
                "string": [ANSIThemeStr("CONTAINER", "command"),
                           ANSIThemeStr("/", "separator"),
                           ANSIThemeStr("CONFIGMAP", "command")],
                "validation": {
                    "validator": "regex",
                    # namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain)
                    "regex": r"^("
                             r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]?|"
                             r")$",
                },
            },
        ],
        "callback": open_view,
    },
    "spacer2": {
        "command": [""],
        "description": [ANSIThemeStr("", "description")],
        "required_args": [],
        "optional_args": [],
        "callback": None,
    },
    "__global_options": {
        "command": ["__global_options"],
        "description": [ANSIThemeStr("", "")],
        "options": {
            "--read-only": {
                "description":
                    [ANSIThemeStr("disable all commands that modify state", "description")],
            },
            "--disable-kubernetes": {
                "description": [ANSIThemeStr("disable Kubernetes support", "description")],
                "extended_description": [
                    [ANSIThemeStr("This option disables Kubernetes support;", "description")],
                    [ANSIThemeStr("this is typically only useful if you use", "description")],
                    [ANSIThemeStr(about.UI_PROGRAM_NAME, "programname"),
                     ANSIThemeStr(" to manage an Ansible inventory", "description")],
                ],
            },
            "--kube-config": {
                "values": [ANSIThemeStr("PATH", "argument")],
                "description": [ANSIThemeStr("PATH", "argument"),
                                ANSIThemeStr(" to kubeconfig file to use", "description")],
                "extended_description": [
                    [ANSIThemeStr("Use ", "description"),
                     ANSIThemeStr("PATH", "argument"),
                     ANSIThemeStr(" as kubeconfig; by default", "description")],
                    [ANSIThemeStr(KUBE_CONFIG_FILE, "path"),
                     ANSIThemeStr(" is used", "description")],
                ],
                "requires_arg": True,
                "validation": {
                    "validator": "path",
                },
            },
            "--namespace": {
                "values": [ANSIThemeStr("NAMESPACE", "argument")],
                "description": [ANSIThemeStr("only show objects in namespace ", "description"),
                                ANSIThemeStr("NAMESPACE", "argument")],
                "requires_arg": True,
                "validation": {
                    "validator": "regex",
                    # namespace (RFC-1123 dns-label)/name (RFC-1123 dns-subdomain)
                    "regex": r"^("
                             r"[a-z0-9][a-z0-9.-]{0,61}[a-z0-9]|"
                             r")$",
                },
            },
            "--theme": {
                "values": [ANSIThemeStr("THEME", "argument")],
                "description": [ANSIThemeStr("THEME", "argument"),
                                ANSIThemeStr(" to use", "description")],
                "requires_arg": True,
            },
        },
        "required_args": [],
        "optional_args": [],
        "callback": None,
    },
    "spacer3": {
        "command": [""],
        "description": [ANSIThemeStr("", "description")],
        "required_args": [],
        "optional_args": [],
        "callback": None,
    },
    "extended_description": [
        [ANSIThemeStr("If ", "description"),
         ANSIThemeStr("VIEW", "argument"),
         ANSIThemeStr(" is not specified ", "description"),
         ANSIThemeStr(about.UI_PROGRAM_NAME, "programname"),
         ANSIThemeStr(" will show a list with all available views", "description")],
        [ANSIThemeStr("", "separator")],
        [ANSIThemeStr("Note", "note"),
         ANSIThemeStr(": ", "description"),
         ANSIThemeStr(CMT_CONFIG_FILENAME, "path"),
         ANSIThemeStr(" or a file in ", "description"),
         ANSIThemeStr(CMT_CONFIG_FILE_DIRNAME, "path"),
         ANSIThemeStr(" can be used to set a ", "description"),
         ANSIThemeStr("VIEW", "argument"),
         ANSIThemeStr(" to use", "description")],
        [ANSIThemeStr("if no view is specified.", "description"),
         ANSIThemeStr(" To override this and open the selector instead,", "description")],
        [ANSIThemeStr("simply use “", "description"),
         ANSIThemeStr(about.UI_PROGRAM_NAME, "programname"),
         ANSIThemeStr(" selector", "argument"),
         ANSIThemeStr("“.", "description")],
    ],  # type: ignore
}


# pylint: disable-next=too-many-branches,too-many-statements,too-many-locals
def main() -> None:
    """
    Main function for the program.
    """
    global read_only_mode  # pylint: disable=global-statement

    # Before doing anything else, make sure that the user is not running as root
    if os.geteuid() == 0:
        sys.exit("CRITICAL: This program should not be run as the root user; aborting.")

    # Now check if all necessary paths exist
    if (violations := cmtlib.setup_paths()) != [SecurityStatus.OK]:
        violations_joined = cmtio.join_securitystatus_set(",", set(violations))
        sys.exit(f"Failed to create necessary directories; violated rules: {violations_joined}")

    # Then initialise the configuration file
    read_cmtconfig()

    defaultthemefile = DEFAULT_THEME_FILE
    tmpthemefile: str = defaultthemefile

    themeindex: int = -1
    try:
        themeindex = sys.argv.index("--theme")
        if themeindex + 1 < len(sys.argv):
            tmpthemefile = sys.argv[themeindex + 1]
        sys.argv.pop(themeindex)
        sys.argv.pop(themeindex)
    except ValueError:
        pass

    if themeindex < 0:
        tmpthemefile = deep_get(cmtlib.cmtconfig, DictPath("Global#theme"))
    themefile, theme_path_found = \
        expand_path(path=tmpthemefile,
                    search_paths=[os.getcwd(), THEME_DIR, cmtpaths.SYSTEM_THEMES_DIR],
                    suffixes=[".yaml"], fallback=defaultthemefile)

    try:
        read_theme(themefile, defaultthemefile)
    except ProgrammingError as e:
        if e.subexception is FileNotFoundError:
            print("Error: could not find a valid theme file; aborting.", file=sys.stderr)
            sys.exit(errno.ENOENT)
        raise

    # Initialise the logging subsystem
    tmp_loglevel = deep_get(cmtlib.cmtconfig, DictPath("Debug#loglevel"), "warning")
    loglevel = LogLevel.WARNING
    invalid_loglevel = False
    try:
        loglevel = name_to_loglevel(tmp_loglevel)
    except ProgrammingError:
        loglevel = LogLevel.WARNING
        invalid_loglevel = True

    cmtlog.set_logger(about.UI_PROGRAM_NAME, loglevel)

    if invalid_loglevel:
        errmsg = [
            [("cmtconfig:Debug#loglevel", "emphasis")],
            [("loglevel = ", "default"),
             (f"{loglevel}", "argument"),
             (" (type:", "default"),
             (f"{type(loglevel)}", "argument"),
             (", expected: ", "default"),
             (f"{LogLevel}", "argument"),
             (", with value being one of ", "default"),
             ("debug", "argument"),
             (", ", "default"),
             ("info", "argument"),
             (", ", "default"),
             ("warning", "argument"),
             (", ", "default"),
             ("error", "argument"),
             (", or ", "default"),
             ("critical", "argument"),
             (")", "default")],
            [("Defaulting to ", "default"),
             ("info", "argument"),
             (".", "default")],
        ]
        unformatted_msg, formatted_msg = ANSIThemeStr.format_error_msg(errmsg)
        cmtlog.log(LogLevel.WARNING, msg=unformatted_msg, messages=formatted_msg)

    CursesConfiguration.abouttext = helptexts.about
    CursesConfiguration.mousescroll_enable = \
        deep_get(cmtlib.cmtconfig, DictPath("Mouse#enablescroll"), False)
    # These values are ignored when scrolling is disabled, so the defaults do not matter
    CursesConfiguration.mousescroll_up = \
        deep_get(cmtlib.cmtconfig, DictPath("Mouse#scrollup"), 0)
    CursesConfiguration.mousescroll_down = \
        deep_get(cmtlib.cmtconfig, DictPath("Mouse#scrolldown"), 0)
    # Used by the ansible module
    ansible_configuration["ansible_forks"] = \
        deep_get(cmtlib.cmtconfig, DictPath("Ansible#forks"), 10)
    ansible_user = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_user"))
    if ansible_user is None or not ansible_user:
        ansible_user = getuser()
    ansible_configuration["ansible_user"] = ansible_user
    ansible_configuration["ansible_password"] = \
        deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_password"))
    ansible_configuration["disable_strict_host_key_checking"] = \
        deep_get(cmtlib.cmtconfig, DictPath("Node#disablestricthostkeychecking"), False)
    ansible_configuration["save_logs"] = \
        deep_get(cmtlib.cmtconfig, DictPath("Ansible#save_logs"), True)

    if "--developer-mode" in sys.argv:
        deep_set(cmtlib.cmtconfig, DictPath("Debug#developer_mode"), True, create_path=True)
        sys.argv.remove("--developer-mode")
        read_only_mode = True
    if "--use-testdata" in sys.argv:
        if deep_get(cmtlib.cmtconfig, DictPath("Debug#developer_mode")):
            # To be able to add support for APIs that we do not have setup in clusters
            # this allows injecting data; this is currently only supported by
            # get_list_by_kind_namespace() and get_ref_by_kind_name_namespace(),
            # with several limitations (no filtering possible, etc).
            deep_set(cmtlib.cmtconfig, DictPath("Debug#use_testdata"), True, create_path=True)
        else:
            print("Warning: --use-testdata is only supported in developer mode")
        sys.argv.remove("--use-testdata")

    command, options, args = \
        parse_commandline(about.UI_PROGRAM_NAME, about.UI_PROGRAM_VERSION,
                          PROGRAMDESCRIPTION, PROGRAMAUTHORS, sys.argv,
                          COMMANDLINE, default_command="*", theme=themefile)

    for key, value in options:
        if key == "__commandname" and value in ("help", "version"):
            break
    else:
        checks.check_netrc_permissions(verbose=False, exit_on_error=True, quiet_on_ok=True)

    for opt, optarg in options:
        # Currently we only support --kube-config, but in case
        # we add option aliases (which we probably should) this
        # is a good thing to have
        if opt in ("--kubeconfig", "--kube-config"):
            global kube_config_file  # pylint: disable=global-statement
            kube_config_file = optarg

    if themeindex >= 0 and not theme_path_found:
        ansithemeprint([ANSIThemeStr("Warning", "warning"),
                        ANSIThemeStr(": could not find theme “", "default"),
                        ANSIThemeStr(f"{tmpthemefile}", "path"),
                        ANSIThemeStr("“; using “", "default"),
                        ANSIThemeStr(f"{defaultthemefile}", "path"),
                        ANSIThemeStr("“ instead.\n", "default")])

    return command(options, args)


if __name__ == "__main__":
    main()
