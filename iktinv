#! /usr/bin/env python3
# Requires: python3 (>= 3.6)
# Requires: python3-natsort

"""
This program is used to query or modify the iKT inventory list

For usage, see:
	iktinv help
"""

import errno
import os
import sys
import typing # pylint: disable=unused-import
import yaml

try:
	from natsort import natsorted
except ModuleNotFoundError:
	sys.exit("ModuleNotFoundError: you probably need to install python3-natsort")

from ikttypes import FilePath
from iktpaths import HOMEDIR
from iktpaths import DEFAULT_THEME_FILE, KUBE_CONFIG_FILE

from commandparser import parse_commandline

from ansible_helper import ansible_configuration, ansible_get_inventory_pretty, ansible_get_groups
from ansible_helper import ansible_get_groups_by_host, ansible_get_hosts_by_group, ansible_add_hosts
from ansible_helper import ansible_remove_hosts, ansible_remove_groups, ansible_set_vars
from ansible_helper import ansible_set_hostvars, ansible_set_groupvars, ansible_unset_hostvars
from ansible_helper import ansible_unset_groupvars, ansible_create_groups, ansible_ping
from ansible_helper import ANSIBLE_INVENTORY

import iktlib # pylint: disable=unused-import
from iktlib import deep_get, iktconfig

from iktprint import iktprint

import about
PROGRAMDESCRIPTION = "Query or modify the host inventory"
PROGRAMAUTHORS = "Written by David Weinehall."

def set_host_vars(options, args) -> int:
	"""
	Set host-specific variables

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): Comma-separated list of key:value pairs, followed by comma-separated list of hosts
		Returns:
			0
	"""

	del options

	hostvars = []
	hosts = []

	if args is None or len(args) == 0:
		raise Exception("Programming error; no hosts provided")

	hosts = args[1].split(",")
	keyvals = args[0].split(",")

	for keyval in keyvals:
		try:
			key, value = keyval.split(":")
		except ValueError:
			iktprint([("Error: ", "error"), ("Setting a variable requires a ", "default"),
				  ("KEY", "argument"), (":", "separator"), ("VALUE ", "argument"), ("pair.", "default")], stderr = True)
			print()
			iktprint([("Try “", "default"),
				  (f"{about.INVENTORY_PROGRAM_NAME} ", "programname"), ("help", "command"),
				  ("“ for more information.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		hostvars.append((key, value))

	# Set vars
	if len(hostvars) > 0:
		retval = ansible_set_hostvars(inventory = ANSIBLE_INVENTORY, hosts = hosts, hostvars = hostvars)
		if retval is False:
			raise Exception(f"Programming error: failed to set vars for hosts {hosts}")

	return 0

def set_group_vars(options, args) -> int:
	"""
	Set group-specific variables

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): Comma-separated list of key:value pairs, followed by comma-separated list of groups
		Returns:
			0
	"""

	del options

	groupvars = []
	groups = []

	if args is None or len(args) == 0:
		raise Exception("Programming error; no groups provided")

	groups = args[1].split(",")
	keyvals = args[0].split(",")

	for keyval in keyvals:
		try:
			key, value = keyval.split(":")
		except ValueError:
			iktprint([("Error: ", "error"), ("Setting a variable requires a ", "default"),
				  ("KEY", "argument"), (":", "separator"), ("VALUE ", "argument"), ("pair.", "default")], stderr = True)
			print()
			iktprint([("Try “", "default"),
				  (f"{about.INVENTORY_PROGRAM_NAME} ", "programname"), ("help", "command"),
				  ("“ for more information.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		groupvars.append((key, value))

	# Set vars
	if len(groupvars) > 0:
		retval = ansible_set_groupvars(inventory = ANSIBLE_INVENTORY, groups = groups, groupvars = groupvars)
		if retval is False:
			raise Exception(f"Programming error: failed to set vars for groups {groups}")

	return 0

def set_global_vars(options, args) -> int:
	"""
	Set global variables

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): Comma-separated list of key:value pairs
		Returns:
			Return value from set_group_vars()
	"""

	return set_group_vars(options = options, args = [args[0], "all"])

def unset_host_vars(options, args) -> int:
	"""
	Unset host-specific variables

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): Comma-separated list of keys, followed by comma-separated list of hosts
		Returns:
			0
	"""

	del options

	hostvars = []
	hosts = []

	if args is None or len(args) == 0:
		raise Exception("Programming error; no hosts provided")

	hosts = args[1].split(",")
	hostvars = args[0].split(",")

	# Unset vars
	if len(hostvars) > 0:
		retval = ansible_unset_hostvars(inventory = ANSIBLE_INVENTORY, hosts = hosts, hostvars = hostvars)
		if retval is False:
			raise Exception(f"Programming error: failed to unset vars for hosts {hosts}")

	return 0

def unset_group_vars(options, args) -> int:
	"""
	Unset group-specific variables

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): Comma-separated list of keys, followed by comma-separated list of groups
		Returns:
			0
	"""

	del options

	groupvars = []
	groups = []

	if args is None or len(args) == 0:
		raise Exception("Programming error; no groups provided")

	groups = args[1].split(",")
	groupvars = args[0].split(",")

	# Unset vars
	if len(groupvars) > 0:
		retval = ansible_unset_groupvars(inventory = ANSIBLE_INVENTORY, groups = groups, groupvars = groupvars)
		if retval is False:
			raise Exception(f"Programming error: failed to unset vars for groups {groups}")

	return 0

def unset_global_vars(options, args) -> int:
	"""
	Unset global variables

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): Comma-separated list of keys
		Returns:
			Return value from unset_group_vars()
	"""
	return unset_group_vars(options = options, args = [args[0], "all"])

def add_groups(options, args) -> int:
	"""
	Add groups

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Comma-separated list of groups
		Returns:
			0
	"""

	groups = []
	groupvars = []

	if args is None or len(args) == 0:
		raise Exception("Programming error; no groups provided")

	groups = args[0].split(",")

	# We shouldn't try to add "all" (it may cause unexpected issues with variables)
	if "all" in groups:
		iktprint([("Warning: ", "warning"), ("ignoring attempt to add group “", "default"), ("all", "argument"), ("“.", "default")], stderr = True)
		groups.remove("all")
		if len(groups) == 0:
			return 0

	for opt, optarg in options:
		if opt == "--vars":
			tmp = optarg.split(",")
			for var in tmp:
				key, value = var.split(":")
				groupvars.append((key, value))
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	# Add the groups
	retval = ansible_create_groups(inventory = ANSIBLE_INVENTORY, groups = groups)

	if retval is False:
		raise Exception(f"Programming error: failed to add {groups} to inventory")

	# Set vars
	if len(groupvars) > 0:
		retval = ansible_set_groupvars(inventory = ANSIBLE_INVENTORY, groups = groups, groupvars = groupvars)
		if retval is False:
			raise Exception(f"Programming error: failed to set vars {groupvars} for groups {groups}")

	return 0

def add_hosts(options, args):
	"""
	Add hosts

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Comma-separated list of hosts
		Returns:
			0
	"""

	groups = []
	hostvars = []
	hosts = []
	groups = []

	if args is None or len(args) == 0:
		raise Exception("Programming error; no hosts provided")

	hosts = args[0].split(",")

	if len(args) > 1:
		groups = args[1].split(",")

	for opt, optarg in options:
		if opt == "--vars":
			tmp = optarg.split(",")
			for var in tmp:
				key, value = var.split(":")
				hostvars.append((key, value))
		elif opt == "--groups":
			if len(groups) > 0:
				iktprint([("Error: ", "error"), ("Invalid option; “", "default"),
					  (f"{opt}", "option"),
					  ("“ cannot be used with ", "default"),
					  ("HOST", "argument"), (",", "separator"), ("... ", "argument"),
					  ("GROUP", "argument"), (",", "separator"), ("... ", "argument"),
					  ("syntax.", "default")], stderr = True)
				print()
				iktprint([("Try “", "default"),
					  (f"{about.INVENTORY_PROGRAM_NAME} ", "programname"), ("help", "command"),
					  ("“ for more information.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
			groups = optarg.split(",")
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	retval = True
	# Add the host to every specified group
	if len(groups) == 0:
		retval = ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = hosts, skip_all = False)

		if retval is False:
			raise Exception(f"Programming error: failed to add {hosts}")
	else:
		group = ""

		for group in groups:
			retval = ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = hosts, group = group, skip_all = False)

		if retval is False:
			raise Exception(f"Programming error: failed to add {hosts} to group {group}")

	# Set vars
	if len(hostvars) > 0:
		retval = ansible_set_hostvars(inventory = ANSIBLE_INVENTORY, hosts = hosts, hostvars = hostvars)
		if retval is False:
			raise Exception(f"Programming error: failed to set vars for hosts {hosts}")

	return 0

def format_members(group, members):
	"""
	Format a list of group members as a themearray

		Parameters:
			group (str): The name of the group
			members (list[str]): A list of hostnames
		Returns:
			formatted (list[(str, themeref)]): A themearray
	"""

	formatted = [(f"{group}: ", "default")]
	i = 0
	for i, member in enumerate(members):
		if i < len(members) - 1:
			formatted += [(member, "yaml_key"), (", ", "separator")]
		else:
			formatted += [(member, "yaml_key")]

	return formatted

def remove_groups(options, args) -> int:
	"""
	Remove groups

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Comma-separated list of groups
		Returns:
			0
	"""

	groups = []
	extrahosts = []
	forceneeded = False
	force = False

	if args is None or len(args) == 0:
		raise Exception("Programming error; no groups provided")

	groups = args[0].split(",")

	for opt, _optarg in options:
		if opt == "--force":
			force = True
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	if "all" in groups:
		iktprint([("Error: ", "error"), ("The group “", "default"), ("all", "argument"), ("“ cannot be removed.", "default")], stderr = True)
		print()
		iktprint([("Try “", "default"),
			  (f"{about.INVENTORY_PROGRAM_NAME} ", "programname"), ("help", "command"),
			  ("“ for more information.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for group in groups:
		grouphosts = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, group)
		if len(grouphosts) > 0:
			forceneeded = True
			extrahosts.append((group, grouphosts))

	if forceneeded == True and force == False:
		if forceneeded == True:
			iktprint([("Error: ", "error"), ("The following groups are non-empty:", "default")])
			for group, hosts in extrahosts:
				iktprint(format_members(group, hosts))
		print()
		iktprint([("Removing groups that still contain hosts requires specifying “", "default"), ("--force", "option"), ("“.", "default")], stderr = True)
		print()
		iktprint([("Try “", "default"),
			  (f"{about.INVENTORY_PROGRAM_NAME} ", "programname"), ("help", "command"),
			  ("“ for more information.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	retval = ansible_remove_groups(inventory = ANSIBLE_INVENTORY, groups = groups, force = force)

	if retval is False:
		raise Exception(f"Programming error: failed to remove {groups}")

	return 0

def get_cluster_name():
	"""
	Return the name of the cluster
		Returns:
			cluster_name (str): On success
			None (None): On failure
	"""

	if os.path.exists(KUBE_CONFIG_FILE):
		with open(KUBE_CONFIG_FILE, "r", encoding = "utf-8") as f:
			d1 = yaml.safe_load(f)
	else:
		return None

	current_context = d1.get("current-context", None)
	if current_context is None:
		return None

	cluster_name = None

	for context in d1.get("contexts", []):
		if context.get("name", "") == current_context:
			cluster_name = context["context"].get("cluster", None)
			break

	return cluster_name

def rebuild_inventory(options, args) -> int:
	"""
	Build an inventory based on information from Kubernetes

		Parameters:
			options (list[(opt, optarg)]): A list of opt, optarg
			args (list[str]): Unused
		Returns:
			0
	"""

	del args

	force = False

	for opt, _optarg in options:
		if opt == "--force":
			force = True
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	# Is there a pre-existing inventory?
	if os.path.isfile(ANSIBLE_INVENTORY) and force == False:
		iktprint([("Error: ", "error"), ("Overwriting an existing inventory requires specifying “", "default"),
			  ("--force", "option"), ("“.", "default")], stderr = True)
		print()
		iktprint([("Try “", "default"),
			  (f"{about.INVENTORY_PROGRAM_NAME} ", "programname"), ("help", "command"),
			  ("“ for more information.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# We ideally want to iterate over all clusters here, but for now we only import the current-context
	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	cluster_name = get_cluster_name()
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	vlist, _status = kh.get_list_by_kind_namespace(("Node", ""), "")

	for node in vlist:
		roles = kh.get_node_roles(node)
		if "control-plane" in roles:
			groups = ["all", "controlplane", cluster_name]
		else:
			groups = ["all", "nodes", cluster_name]

		group = ""
		hosts = [deep_get(node, "metadata#name")]
		retval = True
		for group in groups:
			retval = ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = hosts, group = group, skip_all = False)

		if retval is False:
			raise Exception(f"Programming error: failed to add {hosts} to group {group}")

	# Finally import the hostkey into authorized_keys
	pubkey = None
	with open(FilePath(f"{HOMEDIR}/.ssh/id_ecdsa.pub"), "r", encoding = "utf-8") as f:
		tmp = f.readlines()
		if tmp is not None and len(tmp) > 0:
			pubkey = tmp[0]

	if pubkey == None:
		iktprint([("Error: ", "error"), ("Failed to read ", "default"), (f"{HOMEDIR}/.ssh/id_ecdsa.pub", "path"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	values = {
		"authorized_keys": [pubkey],
	}
	ansible_set_vars(ANSIBLE_INVENTORY, "all", values)

	return 0

def remove_hosts(options, args) -> int:
	"""
	Remove hosts

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Comma-separated list of hosts
		Returns:
			0
	"""

	hosts = []
	groups = ["all"]
	extragroups = []
	forceneeded = False
	force = False

	if args is None or len(args) == 0:
		raise Exception("Programming error; no hosts provided")

	hosts = args[0].split(",")

	if len(args) > 1:
		groups = args[1].split(",")

		# If the hosts are only members of "all"
		# (or aren't in the inventory at all),
		# it's OK to remove them without --force.
		#
		# All hosts are members of the groups "all";
		# this means that if len(hostgroups) > 1
		# we have auxilliary groups and --force is needed.
		for host in hosts:
			hostgroups = ansible_get_groups_by_host(inventory, host)
			if len(hostgroups) > 1:
				forceneeded = True
				hostgroups.remove("all")
				extragroups.append((host, hostgroups))

	for opt, _optarg in options:
		if opt == "--force":
			force = True
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	if "all" in groups and forceneeded == True and (force == False or len(groups) > 1):
		if forceneeded == True:
			iktprint([("Error: ", "error"), ("The following hosts are parts of other groups than “", "default"), ("all", "argument"), ("“:", "default")])
			for host, groups in extragroups:
				iktprint(format_members(host, groups))
		print()
		iktprint([("Removing hosts from “", "default"),
			  ("all", "argument"),
			  ("“ requires specifying “", "default"), ("--force", "option"), ("“", "default")], stderr = True)
		iktprint([("unless “", "default"),
			  ("all", "argument"),
			  ("“ is the only group or the hosts are not members of other groups.", "default")], stderr = True)
		print()
		iktprint([("Try “", "default"),
			  (f"{about.INVENTORY_PROGRAM_NAME} ", "programname"), ("help", "command"),
			  ("“ for more information.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	retval = True

	# If groups is ["all"] and "force" is specified we need to substitute ["all"] for a list of all groups
	if groups == ["all"]:
		groups = ansible_get_groups(inventory = ANSIBLE_INVENTORY)

	for group in groups:
		retval = ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = hosts, group = group)

		if retval is False:
			raise Exception(f"Programming error: failed to remove {hosts} to group {group}")

	return 0

def inventory(options, args) -> int:
	"""
	Show the inventory

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Comma-separated list of groups (optional)
		Returns:
			0
	"""

	include_groupvars = False
	include_hostvars = False

	for opt, _optarg in options:
		if opt == "--include-vars":
			include_groupvars = True
			include_hostvars = True
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	groups = None

	if args is not None and len(args) > 0:
		groups = args[0].split(",")

	for item in ansible_get_inventory_pretty(groups = groups, highlight = True, include_groupvars = include_groupvars, include_hostvars = include_hostvars):
		iktprint(item)

	return 0

def list_groups(options, args) -> int:
	"""
	List groups

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Unused
		Returns:
			0
	"""

	del args

	include_groupvars = False

	for opt, _optarg in options:
		if opt == "--include-vars":
			include_groupvars = True
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	for item in ansible_get_inventory_pretty(groups = None, highlight = True, include_groupvars = include_groupvars, include_hosts = False):
		iktprint(item)

	return 0

def list_hosts(options, args) -> int:
	"""
	List hosts

		Parameters:
			options (list[(str, str)]): List of opt, optarg
			args (list[str]): Unused
		Returns:
			0
	"""

	del args

	include_hostvars = False

	for opt, _optarg in options:
		if opt == "--include-vars":
			include_hostvars = True
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	groups = ["all"]

	for item in ansible_get_inventory_pretty(groups = groups, highlight = True, include_hostvars = include_hostvars):
		iktprint(item)

	return 0

def ping(options, args):
	"""
	Ping hosts or groups of hosts
	Default: ping all hosts
	A well-formed inventory should not have groups with the same name as any of the hosts,
	thus mixing group and host names should be OK; but if there are overlaps the group
	are prioritised over the hostname

		Parameters:
			options (list[(str, str)]): Unused
			args (list[str]): list of hosts or groups (optional)
		Returns:
			0
	"""

	del options

	hoststatuses = []

	if args is not None and len(args) > 0:
		groups_or_hosts = args[0].split(",")
		selection = []
		_all = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")
		for group_or_host in groups_or_hosts:
			# First check if there's a group by this name
			hosts = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, group_or_host)
			# If the group is empty let's try to see if it's a host
			if len(hosts) == 0:
				if group_or_host in _all:
					selection.append(group_or_host)
				else:
					iktprint([("Warning: ", "warning"), ("Skipping unknown host or group “", "default"), (group_or_host, "argument"), ("“", "default")], stderr = True)
			else:
				selection += hosts
		# Eliminate duplicates
		selection = list(set(selection))
	else:
		selection = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")

	print("Please stand by, attempting to ping hosts")
	print()

	output = ansible_ping(selection = selection)

	if output is None or len(output) == 0:
		raise Exception("Internal error; ansible -m ping failed")

	maxlen = 0

	# This needs to be improved; if there's a message we need to tell the difference
	# between "Permission denied" and "No route to host"
	for (host, status) in natsorted(output):
		maxlen = max(len(host), maxlen)
		status_group = "error"

		if status == "SUCCESS":
			status_group = "success"
		elif status == "COULD NOT RESOLVE":
			status_group = "critical"
		elif status == "MISSING INTERPRETER?":
			status_group = "warning"
		elif status in ("UNKNOWN", "UNKNOWN ERROR"):
			status_group = "unknown"

		hoststatuses.append((host, status, status_group))

	header = "Hostname:"

	maxlen = max(maxlen, len(header))

	if len(hoststatuses) > 0:
		iktprint([(header, "header"), (f"{''.ljust(maxlen - len(header))}  ", "default"), ("Status:", "header")])

		for hostname, status, status_group in hoststatuses:
			iktprint([(f"{hostname.ljust(maxlen)}  ", "default"), (f"{status}", status_group)])

	return 0

commandline = {
	"Add Groups": {
		"command": ["add-group", "add-groups"],
		"values": [("GROUP", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Add ", "description"), ("GROUP", "argument"), (",", "separator"), ("...", "argument"), (" to inventory", "description")],
		"options": {
			"--vars": {
				"values": [("KEY", "argument"), (":", "separator"), ("VALUE", "argument"), (",", "separator"), ("...", "argument")],
				"description": [("Set these group variables", "description")],
				"requires_arg": True,
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": add_groups,
	},
	"Add Hosts to Inventory": {
		"command": ["add-host", "add-hosts"],
		"values": [("HOST", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Add ", "description"), ("HOST", "argument"), (",", "separator"), ("...", "argument"), (" to inventory", "description")],
		"options": {
			"--groups": {
				"values": [("GROUP", "argument"), (",", "separator"), ("...", "argument")],
				"description": [("Add the hosts to these groups", "description")],
				"requires_arg": True,
			},
			"--vars": {
				"values": [("KEY", "argument"), (":", "separator"), ("VALUE", "argument"), (",", "separator"), ("...", "argument")],
				"description": [("Set these host variables", "description")],
				"requires_arg": True,
			},
		},
		"min_args": 1,
		"max_args": 2,
		"callback": add_hosts,
	},
	# This is purely for the benefit of the helptext generator
	"Add Hosts to Groups": {
		"command": ["add-host", "add-hosts"],
		"values": [("HOST", "argument"), (",", "separator"), ("... ", "argument"), ("GROUP", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Add ", "description"), ("HOST", "argument"), (",", "separator"), ("...", "argument"), (" to ", "description"), ("GROUP", "argument"), (",", "separator"), ("...", "argument")], # pylint: disable=line-too-long
	},
	"Inventory": {
		"command": ["inventory", "inv"],
		"values": [("[", "separator"), ("GROUP", "argument"), (",", "separator"), ("...", "argument"), ("]", "separator")],
		"description": [("Show inventory, optionally limited to ", "description"), ("GROUP", "argument"), (",", "separator"), ("...", "argument")],
		"options": {
			"--include-vars": {
				"description": [("Show variables", "description")],
			},
		},
		"min_args": 0,
		"max_args": 1,
		"callback": inventory,
	},
	"List Hosts": {
		"command": ["list-hosts"],
		"description": [("List all hosts", "description")],
		"options": {
			"--include-vars": {
				"description": [("Show host variables", "description")],
			},
		},
		"min_args": 0,
		"max_args": 0,
		"callback": list_hosts,
	},
	"List Groups": {
		"command": ["list-groups"],
		"description": [("List all groups", "description")],
		"options": {
			"--include-vars": {
				"description": [("Show group variables", "description")],
			},
		},
		"min_args": 0,
		"max_args": 0,
		"callback": list_groups,
	},
	"Ping": {
		"command": ["ping"],
		"values": [("[", "separator"), ("GROUP/HOST", "argument"), (",", "separator"), ("...", "argument"), ("]", "separator")],
		"description": [("Ansible ping ", "description"), ("GROUP", "argument"), (",", "separator"), ("...", "argument"), (" or ", "description"), ("HOST", "argument"), (",", "separator"), ("...", "argument"), (" (Default: “", "description"), ("all", "argument"), ("“)", "description")], # pylint: disable=line-too-long
		"min_args": 0,
		"max_args": 1,
		"callback": ping,
	},
	"Rebuild Inventory": {
		"command": ["rebuild-inventory"],
		"description": [("Create inventory for an existing Kubernetes cluster", "description")],
		"extended_description": [
			[("In cases where the cluster has not been setup using ", "description"), (f"{about.INVENTORY_PROGRAM_NAME}", "programname")],
			[("this can be used to build a barebones inventory", "description")],
			[("Note: ", "note"), ("This requires a running cluster", "description")],
		],
		"options": {
			"--force": {
				"description": [("Allow an ", "description"), ("existing", "underline"), (" inventory to be overwritten", "description")],
			},
		},
		"min_args": 0,
		"max_args": 0,
		"callback": rebuild_inventory,
	},
	"Remove Groups": {
		"command": ["remove-group", "remove-groups"],
		"values": [("GROUP", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Remove ", "description"), ("GROUP", "argument"), (",", "separator"), ("...", "argument"), (" from inventory", "description")],
		"extended_description": [
			[("Note: ", "note"), ("Removing the group “", "description"), ("all", "argument"), ("“ is not permitted", "description")],
		],
		"options": {
			"--force": {
				"description": [("Allow removal of ", "description"), ("non-empty", "underline"), (" groups", "description")],
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": remove_groups,
	},
	"Remove Hosts from ALL Groups": {
		"command": ["remove-host", "remove-hosts"],
		"values": [("HOST", "argument"), (",", "separator"), ("... ", "argument"), ("all", "argument")],
		"description": [("Remove ", "description"), ("HOST", "argument"), (",", "separator"), ("...", "argument"), (" from the inventory", "description")],
		"options": {
			"--force": {
				"description": [("Allow ", "description"), ("complete", "underline"), (" removal of hosts from the inventory", "description")],
			},
		},
		"min_args": 2,
		"max_args": 2,
		"callback": remove_hosts,
	},
	# This is purely for the benefit of the helptext generator
	"Remove Hosts": {
		"command": ["remove-host", "remove-hosts"],
		"values": [("HOST", "argument"), (",", "separator"), ("... ", "argument"), ("GROUP", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Remove ", "description"), ("HOST", "argument"), (",", "separator"), ("...", "argument"), (" from ", "description"), ("GROUP", "argument"), (",", "separator"), ("...", "argument")], # pylint: disable=line-too-long
	},
	"Set Global Variables": {
		"command": ["set-var", "set-vars"],
		"values": [("KEY", "argument"), (":", "separator"), ("VALUE", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Set global ", "description"), ("KEY", "argument"), (":", "separator"), ("VALUE", "argument"), (",", "separator"), ("...", "argument")],
		"extended_description": [
			[("Setting global variables is equivalent to setting variables", "description")],
			[("for the group “", "description"), ("all", "argument"), ("“", "description")],
		],
		"min_args": 1,
		"max_args": 1,
		"callback": set_global_vars,
	},
	"Set Group Variables": {
		"command": ["set-group-var", "set-group-vars"],
		"values": [("KEY", "argument"), (":", "separator"), ("VALUE", "argument"), (",", "separator"), ("... ", "argument"), ("GROUP", "argument"), (",", "separator"), ("...", "argument")], # pylint: disable=line-too-long
		"description": [("Set ", "description"), ("KEY", "argument"), (":", "separator"), ("VALUE", "argument"), (",", "separator"), ("...", "argument"), (" for ", "description"), ("GROUP", "argument"), (",", "separator"), ("...", "argument")], # pylint: disable=line-too-long
		"min_args": 2,
		"max_args": 2,
		"callback": set_group_vars,
	},
	"Set Host Variables": {
		"command": ["set-host-var", "set-host-vars"],
		"values": [("KEY", "argument"), (":", "separator"), ("VALUE", "argument"), (",", "separator"), ("... ", "argument"), ("HOST", "argument"), (",", "separator"), ("...", "argument")], # pylint: disable=line-too-long
		"description": [("Set ", "description"), ("KEY", "argument"), (":", "separator"), ("VALUE", "argument"), (",", "separator"), ("...", "argument"), (" for ", "description"), ("HOST", "argument"), (",", "separator"), ("...", "argument")], # pylint: disable=line-too-long
		"min_args": 2,
		"max_args": 2,
		"callback": set_host_vars,
	},
	"Unset Global Variables": {
		"command": ["unset-var", "unset-vars"],
		"values": [("KEY", "argument")],
		"description": [("Unset global ", "description"), ("KEY", "argument")],
		"extended_description": [
			[("Unsetting global variables is equivalent to unsetting variables", "description")],
			[("for the group “", "description"), ("all", "argument"), ("“", "description")],
		],
		"min_args": 1,
		"max_args": 1,
		"callback": unset_global_vars,
	},
	"Unset Group Variables": {
		"command": ["unset-group-var", "unset-group-vars"],
		"values": [("KEY ", "argument"), ("GROUP", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Unset ", "description"), ("KEY", "argument"), (" for ", "description"), ("GROUP", "argument"), (",", "separator"), ("...", "argument")],
		"min_args": 2,
		"max_args": 2,
		"callback": unset_group_vars,
	},
	"Unset Host Variables": {
		"command": ["unset-host-var", "unset-host-vars"],
		"values": [("KEY ", "argument"), ("HOST", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Unset ", "description"), ("KEY", "argument"), (" for ", "description"), ("HOST", "argument"), (",", "separator"), ("...", "argument")],
		"min_args": 2,
		"max_args": 2,
		"callback": unset_host_vars,
	},
	"spacer1": {
		"command": [""],
		"description": [("", "default")],
	},
}

def main() -> int:
	"""
	Main function for the program
	"""

	# Before doing anything else, make sure that the user isn't running as root
	if os.geteuid() == 0:
		sys.exit("CRITICAL: This program should not be run as the root user; aborting.")

	command, options, args = parse_commandline(about.INVENTORY_PROGRAM_NAME, about.INVENTORY_PROGRAM_VERSION, PROGRAMDESCRIPTION, PROGRAMAUTHORS,
						   sys.argv, commandline, default_command = "inventory", theme = DEFAULT_THEME_FILE)

	# iktinv was called without any parameters; assuming inventory
	if command is None:
		command = inventory

	# Used by the ansible module
	ansible_configuration["ansible_forks"] = deep_get(iktconfig, "Ansible#forks", 5)
	ansible_configuration["ansible_user"] = deep_get(iktconfig, "Ansible#ansible_user")
	ansible_configuration["ansible_password"] = deep_get(iktconfig, "Ansible#ansible_password")
	ansible_configuration["disable_strict_host_key_checking"] = deep_get(iktconfig, "Nodes#disablestricthostkeychecking", False)

	return command(options, args)

if __name__ == "__main__":
	main()
