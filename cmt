#! /usr/bin/env python3
# Requires: ansible
# Requires: python3 (>= 3.8)
# Requires: python3-natsort
# Requires: python3-openssl
# Recommends: python3-ujson

# pylint: disable=line-too-long

"""
This program is used to install, upgrade and uninstall nodes for Kubernetes clusters,
and to perform various other tasks; eventually this is meant to have most of the
features available in cmu

For usage, see:
	cmt help
"""

from cryptography import x509
from cryptography.hazmat.primitives import serialization
import errno
from getpass import getuser
import hashlib
import os
from pathlib import Path, PurePath
import re
import sys
from typing import cast, Dict, List, Optional, Sequence, Tuple

from cmttypes import deep_get, DictPath, FilePath, HostNameStatus
from cmtpaths import CMT_CONFIG_FILE, DEFAULT_THEME_FILE, KUBE_CONFIG_FILE

from commandparser import parse_commandline

from ansible_helper import ansible_configuration, ansible_run_playbook_on_selection, ansible_get_hosts_by_group, ansible_add_hosts, ansible_remove_hosts
from ansible_helper import ansible_print_action_summary, ansible_print_play_results, populate_playbooks_from_paths
from ansible_helper import ANSIBLE_PLAYBOOK_DIR, ANSIBLE_INVENTORY

import cmtlib
from cmtlib import read_cmtconfig
from cmtio import execute_command, secure_read_string, validate_fqdn
from cmtio_yaml import secure_read_yaml
from networkio import scan_and_add_ssh_keys

from kubernetes_helper import get_node_status, kubectl_get_version

from ansithemeprint import ANSIThemeString, ansithemestring_join_tuple_list, ansithemeprint, ansithemeinput, ansithemeinput_password

import about
PROGRAMDESCRIPTION = "Commandline tool for managing Kubernetes clusters"
PROGRAMAUTHORS = "Written by David Weinehall."

def request_ansible_password() -> None:
	"""
	Requests the ansible password
	"""

	# Check whether ansible_password is defined or not
	if ansible_configuration["ansible_password"] is None:
		ansithemeprint([ANSIThemeString("Attention: ", "warning"),
				ANSIThemeString("To be able to run playbooks you need to provide the ansible/ssh password.", "default")])
		ansithemeprint([ANSIThemeString("Since the systems will be reconfigured to use passwordless sudo and ssh keys this is a one-time thing.", "default")])

		ansible_password = ansithemeinput_password([ANSIThemeString("\nPassword: ", "default")])

		if ansible_password is None or len(ansible_password) == 0:
			ansithemeprint([ANSIThemeString("\nError", "error"),
					ANSIThemeString(": Empty password; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)

		ansible_configuration["ansible_password"] = ansible_password # type: ignore

def run_playbook(playbookpath: FilePath, hosts: List[str], extra_values: Optional[Dict] = None, quiet: bool = False) -> Tuple[int, Dict]:
	"""
	Run a playbook

		Parameters:
			playbookpath (FilePath): A path to the playbook to run
			hosts (list[str]): A list of hosts to run the playbook on
			extra_values (dict): A dict of values to set before running the playbook
			quiet (bool): Unused
		Returns:
			retval (int): The return value from ansible_run_playbook_on_selection()
			ansible_results (dict): A dict with the results from the run
	"""

	# Eventually we should be using this
	del quiet

	# Set necessary Ansible keys before running playbooks
	http_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), "")
	if http_proxy is None:
		http_proxy = ""
	https_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), "")
	if https_proxy is None:
		https_proxy = ""
	no_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), "")
	if no_proxy is None:
		no_proxy = ""
	insecure_registries = deep_get(cmtlib.cmtconfig, DictPath("Docker#insecure_registries"), [])
	registry_mirrors = deep_get(cmtlib.cmtconfig, DictPath("Containerd#registry_mirrors"), [])
	retval = 0

	use_proxy = "no"
	if len(http_proxy) > 0 or len(https_proxy) > 0:
		use_proxy = "yes"

	if extra_values is None:
		extra_values = {}

	values = {
		"http_proxy": http_proxy,
		"https_proxy": https_proxy,
		"no_proxy": no_proxy,
		"insecure_registries": insecure_registries,
		"registry_mirrors": registry_mirrors,
		"use_proxy": use_proxy,
	}
	merged_values = { **values, **extra_values }

	retval, ansible_results = ansible_run_playbook_on_selection(playbookpath, selection = hosts, values = merged_values)

	ansible_print_play_results(retval, ansible_results)

	return retval, ansible_results

def __format_none(string: Optional[str], fmt: str) -> ANSIThemeString:
	if string is None or string == "<none>":
		__string = ANSIThemeString("<none>", "none")
	else:
		__string = ANSIThemeString(string, fmt)
	return __string

def get_cluster_name() -> Optional[str]:
	"""
	Return the name of the cluster

		Returns:
			cluster_name (str): The name of the cluster
	"""
	try:
		d1 = secure_read_yaml(KUBE_CONFIG_FILE)
	except FileNotFoundError:
		return None

	current_context = d1.get("current-context", None)
	if current_context is None:
		return None

	cluster_name = None

	for context in d1.get("contexts", []):
		if context.get("name", "") == current_context:
			cluster_name = context["context"].get("cluster", None)
			break

	return cluster_name

def get_control_planes() -> List[Tuple[str, List[str]]]:
	controlplanes = []

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
	if status != 200:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": API-server returned ", "default"),
				ANSIThemeString(f"{status}", "errorvalue"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)
	if vlist is None:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": API-server did not return any data", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for node in vlist:
		name = deep_get(node, DictPath("metadata#name"))
		node_roles = kh.get_node_roles(cast(Dict, node))
		if "control-plane" in node_roles or "master" in node_roles:
			ipaddresses = []
			for address in deep_get(node, DictPath("status#addresses")):
				if deep_get(address, DictPath("type"), "") == "InternalIP":
					ipaddresses.append(deep_get(address, DictPath("address")))
			controlplanes.append((name, ipaddresses))

	return controlplanes

def show_configuration(hosts: List[str], cri: Optional[str] = None) -> None:
	"""
	Show cluster configuration

		Parameters:
			hosts (list[str]): The hosts that will be affected
	"""

	cluster_name = get_cluster_name()
	controlplanes = get_control_planes()

	http_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), "")
	if http_proxy is not None and http_proxy == "":
		http_proxy = None
	http_proxy_env = os.getenv("http_proxy")
	if http_proxy_env is not None and http_proxy_env == "":
		http_proxy_env = None
	https_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), "")
	if https_proxy is not None and https_proxy == "":
		https_proxy = None
	https_proxy_env = os.getenv("https_proxy")
	if https_proxy_env is not None and https_proxy_env == "":
		https_proxy_env = None
	no_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), "")
	if no_proxy is not None and no_proxy == "":
		no_proxy = None
	no_proxy_env = os.getenv("no_proxy")
	if no_proxy_env is not None and no_proxy_env == "":
		no_proxy_env = None

	ansithemeprint([ANSIThemeString("\n[Summary]", "phase")])
	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Configuration:", "action")])
	ansithemeprint([ANSIThemeString("        Cluster Name: ", "action"),
			ANSIThemeString(f"{cluster_name}", "hostname")])
	if cri is not None:
		ansithemeprint([ANSIThemeString("                 CRI: ", "action"),
				ANSIThemeString(f"{cri}", "programname")])
	ansithemeprint([ANSIThemeString("          HTTP Proxy: ", "action"),
			__format_none(http_proxy, "url"),
			ANSIThemeString(" (", "default"),
			ANSIThemeString(f"{CMT_CONFIG_FILE}", "path"),
			ANSIThemeString(")", "default")])
	ansithemeprint([ANSIThemeString("          HTTP Proxy: ", "action"),
			__format_none(http_proxy_env, "url"),
			ANSIThemeString(" (Environment)", "default")])
	ansithemeprint([ANSIThemeString("         HTTPS Proxy: ", "action"),
			__format_none(https_proxy, "url"),
			ANSIThemeString(" (", "default"),
			ANSIThemeString(f"{CMT_CONFIG_FILE}", "path"),
			ANSIThemeString(")", "default")])
	ansithemeprint([ANSIThemeString("         HTTPS Proxy: ", "action"),
			__format_none(https_proxy_env, "url"),
			ANSIThemeString(" (Environment)", "default")])
	ansithemeprint([ANSIThemeString("            No Proxy: ", "action"),
			__format_none(no_proxy, "url"),
			ANSIThemeString(" (", "default"),
			ANSIThemeString(f"{CMT_CONFIG_FILE}", "path"),
			ANSIThemeString(")", "default")])
	ansithemeprint([ANSIThemeString("            No Proxy: ", "action"),
			__format_none(no_proxy_env, "url"),
			ANSIThemeString(" (Environment)", "default")])

	ansithemeprint([ANSIThemeString("", "default")])
	ansithemeprint([ANSIThemeString("• ", "separator"),
			ANSIThemeString("Control Planes:", "action")])

	for controlplane in controlplanes:
		ansithemeprint([ANSIThemeString("  • ", "separator"),
				ANSIThemeString(f"{controlplane[0]} ", "emphasis"),
				ANSIThemeString("(", "default")] +
			       ansithemestring_join_tuple_list(controlplane[1], formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
			       [ANSIThemeString(")", "default")])

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Target Hosts:", "action")])
	for host in hosts:
		ansithemeprint([ANSIThemeString("  • ", "separator"),
				ANSIThemeString(host, "hostname")])

def run_playbooks(playbooks: List[Tuple[List[ANSIThemeString], FilePath]], hosts: Optional[List[str]] = None, extra_values: Optional[Dict] = None) -> bool:
	"""
	Run a set of playbooks

		Parameters:
			playbooks (list[(description, playbookpath)]): A list of playbooks
			hosts (str): The hosts to run the playbooks on
			extra_values (dict): Variables to set before running the playbooks
		Returns:
			True on success, False on failure
	"""

	if len(playbooks) == 0 or hosts == None:
		return True

	for string, playbookpath in playbooks:
		ansithemeprint(string)
		retval, _ansible_results = run_playbook(playbookpath, hosts = cast(List[str], hosts), extra_values = extra_values)

		# We do not want to continue executing playbooks if the first one failed
		if retval != 0:
			break

	return retval == 0

def get_selection(selection: List[str], kind: Optional[Tuple[str, str]] = None) -> Tuple[List[str], List[str], List[str]]:
	"""
	Based on input parameters, split the node list into nodes, non-existing nodes, and control planes

		Parameters:
			selection (list[str]): A list of nodes, or ALL to select all nodes
			kind (tuple): A Kubernetes kind; only supported for now is ("Node", "")
			_or_
			kind (str): For future use with playbooks, etc.
		Returns:
			(nodes, non_existing_nodes, controlplanes):
				nodes (list[str]): (str, str, str): The nodes
				non_existing_nodes (list[str]): The non-existing nodes
				controlplanes (list[str]): The control planes
	"""

	all_items = False
	items1 = []
	non_existing = []
	# Only used for controlplanes
	items2 = []

	if kind is None:
		raise Exception("kind is None; this is a programming error")

	if selection is None:
		raise ValueError("selection is None; this is a programming error")

	if "ALL" in selection:
		if len(selection) > 1:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": “", "default"),
					ANSIThemeString("ALL", "argument"),
					ANSIThemeString("“ cannot be combined with other arguments; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		else:
			all_items = True

	# Kubernetes resources
	if isinstance(kind, tuple):
		from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
		kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

		vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
		if status != 200:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": API-server returned ", "default"),
					ANSIThemeString(f"{status}", "errorvalue"),
					ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		if vlist is None:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": API-server did not return any data", "default")], stderr = True)
			sys.exit(errno.EINVAL)

		for node in vlist:
			name = deep_get(node, DictPath("metadata#name"))
			if all_items == False and name not in selection:
				continue

			node_roles = kh.get_node_roles(cast(Dict, node))
			if "control-plane" in node_roles or "master" in node_roles:
				items2.append(name)
				continue

			items1.append(name)
	# str kinds are things such as playbooks; for now cmt does not use them

	# Finally, generate a list of non-existing items
	if all_items == False:
		for item in selection:
			if item not in items1 + items2:
				non_existing.append(item)

	return items1, non_existing, items2

def cordon_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Cordon nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	include_control_planes = False
	header = True

	for opt, _optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")

	# It is OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes == True:
		nodes += controlplanes

	if len(non_existing) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +\
			       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
			       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		ansithemeprint([ANSIThemeString("\n[Cordoning nodes]", "phase")])

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for node in nodes:
		ansithemeprint([ANSIThemeString(f"{node}:", "hostname")])
		message, status = kh.cordon_node(node)
		if status in (200, 204):
			ansithemeprint([ANSIThemeString("  Cordoned", "success")])
			print(message)
		elif status == 42503:
			ansithemeprint([ANSIThemeString("\nCritical", "critical"),
					ANSIThemeString(": Cluster not available; aborting", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			ansithemeprint([ANSIThemeString("\nAPI call returned error:", "error")], stderr = True)
			ansithemeprint([ANSIThemeString(f"  {message}", "error")], stderr = True)
			sys.exit(errno.EINVAL)
	return 0

def drain_nodes(options: Sequence[Tuple[str, Optional[str]]], args: List[str]) -> int:
	"""
	Drain nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	include_control_planes = False
	header = True

	# Check kubectl version
	kubectl_major_version, kubectl_minor_version, _kubectl_git_version, _server_major_version, _server_minor_version, _server_git_version = kubectl_get_version()

	_args = ["/usr/bin/kubectl", "drain"]

	for opt, _optarg in options:
		if opt in ("--delete-emptydir-data", "--delete-local-data"):
			if kubectl_major_version >= 1 and kubectl_minor_version >= 20:
				_args.append("--delete-emptydir-data")
			else:
				_args.append("--delete-local-data")
		elif opt == "--disable-eviction":
			if kubectl_major_version >= 1 and kubectl_minor_version >= 18:
				_args.append(opt)
		elif opt == "--ignore-daemonsets":
			_args.append(opt)
		elif opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")

	# It is OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes == True:
		nodes += controlplanes

	if len(non_existing) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +\
			       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
			       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		ansithemeprint([ANSIThemeString("\n[Draining nodes]", "phase")])
	_args += nodes
	execute_command(_args)
	return 0

def uncordon_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Uncordon nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	include_control_planes = False
	header = True

	for opt, _optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")

	# It is OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes == True:
		nodes += controlplanes

	if len(non_existing) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +\
			       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
			       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		ansithemeprint([ANSIThemeString("\n[Uncordoning nodes]", "phase")])

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for node in nodes:
		ansithemeprint([ANSIThemeString(f"{node}:", "hostname")])
		message, status = kh.uncordon_node(node)
		if status in (200, 204):
			ansithemeprint([ANSIThemeString("  Uncordoned", "success")])
			print(message)
		elif status == 42503:
			ansithemeprint([ANSIThemeString("\nCritical", "critical"),
					ANSIThemeString(": Cluster not available; aborting", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			ansithemeprint([ANSIThemeString("\nAPI call returned error:", "error")], stderr = True)
			ansithemeprint([ANSIThemeString(f"  {message}", "error")], stderr = True)
			sys.exit(errno.EINVAL)
	return 0

def taint_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Taint nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	include_control_planes = False
	overwrite = False
	header = True

	for opt, _optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		elif opt == "--overwrite":
			overwrite = True
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")
	taint = args[1]

	if "=" not in taint:
		ansithemeprint([ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
				ANSIThemeString(": invalid syntax; the correct syntax is either “", "default"),
				ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" taint ", "command"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString("|", "separator"),
				ANSIThemeString("ALL ", "argument"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString("=", "separator"),
				ANSIThemeString("EFFECT", "argument"),
				ANSIThemeString("“ or “", "default"),
				ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" taint ", "command"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString("|", "separator"),
				ANSIThemeString("ALL ", "argument"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString(":", "separator"),
				ANSIThemeString("VALUE", "argument"),
				ANSIThemeString("=", "separator"),
				ANSIThemeString("EFFECT", "argument"),
				ANSIThemeString("“; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	taint, taint_new_effect = taint.split("=")
	if ":" in taint:
		taint_key, taint_value = taint.split(":")
	else:
		taint_key = taint
		taint_value = None

	if taint_new_effect not in ("NoSchedule", "PreferNoSchedule", "NoExecute"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Invalid effect; valid effects are: ", "default"),
				ANSIThemeString("NoSchedule", "argument"),
				ANSIThemeString(", ", "default"),
				ANSIThemeString("PreferNoSchedule", "argument"),
				ANSIThemeString(", and ", "default"),
				ANSIThemeString("NoExecute", "argument"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# It is OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes == True:
		nodes += controlplanes

	if len(non_existing) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +\
			       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
			       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		ansithemeprint([ANSIThemeString("\n[Tainting nodes]", "phase")])

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for node in nodes:
		node_info = kh.get_ref_by_kind_name_namespace(("Node", ""), node, "")
		node_status, _status_group, _taints, full_taints = get_node_status(node_info)
		if node_status == "Unknown":
			ansithemeprint([ANSIThemeString("Critical", "critical"),
					ANSIThemeString(": Failed to get node information; do you have a running cluster? Aborting.", "default")], stderr = True)
			sys.exit(errno.ENXIO)

		ansithemeprint([ANSIThemeString(node, "hostname")])
		_message, status = kh.taint_node(node, full_taints, (taint_key, taint_value, None, taint_new_effect), overwrite = overwrite)
		if status == 304:
			ansithemeprint([ANSIThemeString("  Not modified", "none")])
		elif status == 42304:
			ansithemeprint([ANSIThemeString("  Warning", "warning"),
					ANSIThemeString(": Ignoring request; node already has taint(s) with matching effect; use “", "default"),
					ANSIThemeString("--overwrite", "option"),
					ANSIThemeString("“ to override", "default")])
		elif status == 200:
			ansithemeprint([ANSIThemeString("  Tainted", "success")])
		else:
			ansithemeprint([ANSIThemeString("  Failed to modify taint", "error"),
					ANSIThemeString(f"; HTTP error {status}; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
	return 0

def untaint_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Untaint nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	include_control_planes = False
	header = True

	for opt, _optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")
	taint = args[1]

	if "=" in taint:
		taint, taint_old_effect = taint.split("=")
	else:
		taint_old_effect = None
	if ":" in taint:
		taint_key, taint_value = taint.split(":")
	else:
		taint_key = taint
		taint_value = None

	if taint_old_effect is not None and taint_old_effect not in ("NoSchedule", "PreferNoSchedule", "NoExecute"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Invalid effect; valid effects are: ", "default"),
				ANSIThemeString("NoSchedule", "argument"),
				ANSIThemeString(", ", "default"),
				ANSIThemeString("PreferNoSchedule", "argument"),
				ANSIThemeString(", and ", "default"),
				ANSIThemeString("NoExecute", "argument"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# It is OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes == True:
		nodes += controlplanes

	if len(non_existing) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +\
			       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
			       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		ansithemeprint([ANSIThemeString("\n[Untainting nodes]", "phase")])

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for node in nodes:
		node_info = kh.get_ref_by_kind_name_namespace(("Node", ""), node, "")
		node_status, _status_group, _taints, full_taints = get_node_status(node_info)
		if node_status == "Unknown":
			ansithemeprint([ANSIThemeString("Critical", "critical"),
					ANSIThemeString(": Failed to get node information; do you have a running cluster? Aborting.", "default")], stderr = True)
			sys.exit(errno.ENXIO)

		ansithemeprint([ANSIThemeString(node, "hostname")])
		_message, status = kh.taint_node(node, full_taints, (taint_key, taint_value, taint_old_effect, None))
		if status == 304:
			ansithemeprint([ANSIThemeString("  Not modified", "none")])
		elif status == 200:
			ansithemeprint([ANSIThemeString("  Untainted", "success")])
		else:
			ansithemeprint([ANSIThemeString("  Failed to modify taint", "error"),
					ANSIThemeString(f"; HTTP error {status}; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
	return 0

def prepare_hosts(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Install and configure pre-requisites for use as a node

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	ignore_existing = False
	no_password = False
	from_file = False
	confirm = True

	for opt, optarg in options:
		if opt == "--ignore-existing":
			ignore_existing = True
		elif opt == "--no-password":
			no_password = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--forks":
			ansible_configuration["forks"] = optarg
		elif opt == "--from-file":
			from_file = True
		elif opt == "-Y":
			confirm = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	if from_file == True:
		hostfile = args[0]
		hostfile_path = Path(hostfile)
		if not hostfile_path.exists():
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default"),
					ANSIThemeString(f"{hostfile}", "path"),
					ANSIThemeString(" does not exist; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		if not hostfile_path.is_file():
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default"),
					ANSIThemeString(f"{hostfile}", "path"),
					ANSIThemeString(" is not a file; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)

		hosts_raw = secure_read_string(FilePath(hostfile))
		hosts_raw_split = cast(List[str], hosts_raw.splitlines())

		if len(hosts_raw_split) == 1 and "," in hosts_raw_split[0]:
			selection = hosts_raw_split[0].split(",")
		else:
			selection = hosts_raw_split
	else:
		selection = args[0].split(",")
		if "ALL" in selection:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default"),
					ANSIThemeString("ALL", "hostname"),
					ANSIThemeString(" cannot be used with ", "default"),
					ANSIThemeString("prepare", "command"),
					ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)

	# Validate FQDN/hostname list
	retval = validate_fqdn(selection[0], message_on_error = True)
	if retval != HostNameStatus.OK:
		sys.exit(errno.EINVAL)

	# Correlate the list of hosts with the nodes in the cluster
	nodes, non_existing, controlplanes = get_selection(selection, kind = ("Node", ""))

	if len(nodes) > 0 or len(controlplanes) > 0:
		if ignore_existing == False:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default")] +\
				       ansithemestring_join_tuple_list(nodes + controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
				       [ANSIThemeString(" are already part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(errno.EEXIST)
		else:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": ", "default")] +\
				       ansithemestring_join_tuple_list(nodes + controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
				       [ANSIThemeString(" are already part of the cluster; ignoring them since “", "description"),
					ANSIThemeString("--ignore-existing", "option"),
					ANSIThemeString("“ was specified.", "default")], stderr = True)

	if len(non_existing) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No valid hosts specified; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# Check if the hosts are part of the inventory
	inventory = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")
	not_in_inventory = []
	for host in non_existing:
		if host not in inventory:
			not_in_inventory.append(host)

	if len(not_in_inventory) > 0:
		input_retval = ansithemeinput([ANSIThemeString("\nWarning", "warning"), ANSIThemeString(": ", "default")] +\
					      ansithemestring_join_tuple_list(not_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
					      [ANSIThemeString(" are not defined in the inventory; do you want to add them now? (No will abort the installation) [y/", "default"),
					       ANSIThemeString("N", "emphasis"), ANSIThemeString("]: ", "default")])
		if input_retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting", "error"),
					ANSIThemeString(": Nodes not added to the inventory.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	show_configuration(non_existing)

	prepare_playbooks = [
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_passwordless_ansible.yaml"))),
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_node.yaml")))
	]
	playbooks = populate_playbooks_from_paths(prepare_playbooks)
	ansible_print_action_summary(playbooks)

	ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = not_in_inventory, skip_all = False)

	if confirm == True:
		input_retval = ansithemeinput([ANSIThemeString("\nStart host preparation? [y/", "default"),
					       ANSIThemeString("N", "emphasis"),
					       ANSIThemeString("]: ", "default")])
		if input_retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting", "error"),
					ANSIThemeString(": User stopped host preparation.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	ansithemeprint([ANSIThemeString("\n[Preparing host(s)]", "phase")])

	scan_and_add_ssh_keys(non_existing)

	# We most likely will not be able to connect to the remote host without a password
	if no_password == False:
		request_ansible_password()

	extra_values = {
		"ansible_become_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
		"ansible_ssh_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
	}

	run_retval = run_playbooks(playbooks = playbooks, hosts = non_existing, extra_values = extra_values)
	if run_retval == True:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansithemeprint([ANSIThemeString("\nHosts successfully prepared", "success")])
	return 0

cri_data: Dict = {
	"containerd": {
		"socket": "unix:///run/containerd/containerd.sock",
	},
	"cri-o": {
		"socket": "unix:///run/crio/crio.sock",
	},
	"docker-shim": {
		"socket": "unix:///run/dockershim.sock",
	}
}

def add_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Add nodes to the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	ignore_existing = False
	ignore_non_existing = False
	from_file = False
	ca_cert_path = ""
	cri = None
	confirm = True

	for opt, optarg in options:
		if opt == "--ignore-existing":
			ignore_existing = True
		elif opt == "--ignore-non-existing":
			ignore_non_existing = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--ca-cert-path":
			ca_cert_path = optarg
		elif opt == "--forks":
			ansible_configuration["forks"] = optarg
		elif opt == "--cri":
			if optarg in ("dockershim", "containerd", "cri-o"):
				cri = optarg
			else:
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": Unknown CRI “", "default"),
						ANSIThemeString(optarg, "argument"),
						ANSIThemeString("“ specified; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
		elif opt == "--from-file":
			from_file = True
		elif opt == "-Y":
			confirm = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	if from_file == True:
		hostfile = args[0]
		if not os.path.exists(hostfile):
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default"),
					ANSIThemeString(f"{hostfile}", "path"),
					ANSIThemeString(" does not exist; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		elif not os.path.isfile(hostfile):
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default"),
					ANSIThemeString(f"{hostfile}", "path"),
					ANSIThemeString(" is not a file; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			hosts_raw = None
			with open(hostfile, "r", encoding = "utf-8") as f:
				hosts_raw = f.readlines()

			if hosts_raw is None:
				ansithemeprint([("Error", "error"), (": Failed to read hostnames from ", "default"), (f"{hostfile}", "path"), ("; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

			# strip newlines
			hosts_raw = [s.strip() for s in hosts_raw]

			if len(hosts_raw) == 1 and "," in hosts_raw[0]:
				selection = hosts_raw[0].split(",")
			else:
				selection = hosts_raw
	else:
		selection = args[0].split(",")

	if "ALL" in selection:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default"),
				ANSIThemeString("ALL", "hostname"),
				ANSIThemeString(" cannot be used with ", "default"),
				ANSIThemeString("add-node", "command"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# Correlate the list of hosts with the nodes in the cluster
	nodes, non_existing, controlplanes = get_selection(selection, kind = ("Node", ""))

	if len(nodes) > 0 or len(controlplanes) > 0:
		if ignore_existing == False:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default")] +\
				       ansithemestring_join_tuple_list(controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
				       [ANSIThemeString(" are already part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(errno.EEXIST)
		else:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": ", "default")] +\
				       ansithemestring_join_tuple_list(nodes + controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
				       [ANSIThemeString(" are already part of the cluster; ignoring them since “", "description"),
					ANSIThemeString("--ignore-existing", "option"),
					ANSIThemeString("“ was specified.", "default")], stderr = True)

	if len(non_existing) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No valid hosts specified; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# Check if the hosts are part of the inventory
	inventory = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")
	not_in_inventory = []
	for host in non_existing:
		if host not in inventory:
			not_in_inventory.append(host)

	if len(not_in_inventory) > 0:
		if ignore_non_existing == False:
			ansithemeprint([ANSIThemeString("Error", "error"), ANSIThemeString(": ", "default")] +\
				       ansithemestring_join_tuple_list(not_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
				       [ANSIThemeString(" are not defined in the inventory; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			ansithemeprint([ANSIThemeString("Warning", "warning"), ANSIThemeString(": ", "default")] +\
				       ansithemestring_join_tuple_list(not_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
				       [ANSIThemeString(" are not defined in the invetory; ignoring them since “", "description"),
					ANSIThemeString("--ignore-non-existing", "option"),
					ANSIThemeString("“ was specified.", "default")], stderr = True)

	show_configuration(non_existing, cri = cri)

	if confirm == True:
		input_retval = ansithemeinput([ANSIThemeString("\nStart node setup? [y/", "default"),
					       ANSIThemeString("N", "emphasis"),
					       ANSIThemeString("]: ", "default")])
		if input_retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting", "error"),
					ANSIThemeString(": User stopped node setup.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	# Time to setup and add the hosts to the cluster
	ansithemeprint([ANSIThemeString("\n[Adding nodes]", "phase")])

	# Get variables that need to be available when setting up nodes
	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	join_token = kh.get_join_token()
	if len(join_token) == 0:
		input_retval = ansithemeinput([ANSIThemeString("Error", "error"),
					       ANSIThemeString(": No join token found; create a one now? (No will abort the installation) [y/", "default"),
					       ANSIThemeString("N", "emphasis"),
					       ANSIThemeString("]: ", "default")])
		if input_retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting", "error"),
					ANSIThemeString(": No join token available.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			create_join_token_playbooks = [
				FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_create_join_token.yaml")))
			]
			playbooks = populate_playbooks_from_paths(create_join_token_playbooks)
			retval = run_playbooks(playbooks = playbooks, hosts = controlplanes)
			join_token = kh.get_join_token()
			if len(join_token) == 0:
				ansithemeprint([ANSIThemeString("Critical", "critical"),
						ANSIThemeString(": Failed to create join token; aborting", "default")], stderr = True)
				sys.exit(errno.EINVAL)

	ca_cert_hash = ""
	if len(ca_cert_path) == 0:
		ca_cert_hash = kh.get_ca_cert_hash()
	if len(ca_cert_hash) == 0:
		if len(ca_cert_path) == 0:
			ca_cert_path = "/etc/kubernetes/pki/ca.crt"
		input_retval = ansithemeinput([ANSIThemeString("Warning", "warning"),
					       ANSIThemeString(": Could not find ", "default"),
					       ANSIThemeString("ca.crt", "path"),
					       ANSIThemeString(" or a certificate-controller-token secret; try to use ", "default"),
					       ANSIThemeString(ca_cert_path, "path"),
					       ANSIThemeString("? No will abort the installation) [y/", "default"),
					       ANSIThemeString("N", "emphasis"),
					       ANSIThemeString("]: ", "default")])
		if input_retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting", "error"),
					ANSIThemeString(": No CA certificate available.", "default")], stderr = True)
			sys.exit(errno.EINTR)
		else:
			ca_cert = ""
			ca_cert_hash = ""

			try:
				ca_cert = secure_read_string(FilePath(ca_cert_path))
				if len(ca_cert) > 0:
					try:
						x509obj = x509.load_pem_x509_certificate(ca_cert.encode("utf-8"))
					except TypeError as e:
						if "load_pem_x509_certificate() missing 1 required positional argument: 'backend'" in str(e):
							from cryptography.hazmat.primitives import default_backend
							x509obj = x509.load_pem_x509_certificate(ca_cert.encode("utf-8"), backend = default_backend)
						else:
							raise
					pubkeyder = x509obj.public_key().public_bytes(encoding = serialization.Encoding.DER, format = serialization.PublicFormat.SubjectPublicKeyInfo)
					ca_cert_hash = hashlib.sha256(pubkeyder).hexdigest()
			except FileNotFoundError:
				pass

			if len(ca_cert_hash) == 0:
				ansithemeprint([ANSIThemeString("\nAborting", "error"),
						ANSIThemeString(": No CA certificate available.", "default")], stderr = True)
				sys.exit(errno.EINTR)

	control_plane_ip, control_plane_port = kh.get_control_plane_address()
	# Now that we have the IP address of the API-server we can use that to get the package
	# version for kubeadm
	_retval, ansible_results = ansible_run_playbook_on_selection(FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("get_versions.yaml"))), selection = [control_plane_ip])
	if len(ansible_results) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(f": Failed to get package versions from control-plane at {control_plane_ip} (retval: {retval}); aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	tmp = []

	for result in deep_get(ansible_results, DictPath(control_plane_ip), []):
		if deep_get(result, DictPath("task"), "") == "package versions":
			tmp = deep_get(result, DictPath("msg_lines"), [])
			break

	if len(tmp) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(f": Failed to get package versions from control-plane at {control_plane_ip} (playbook returned no valid data); aborting.", "default")], stderr = True)
		sys.exit(errno.EBADMSG)

	kubeadm_version = ""
	# Safe
	kubeadm_version_regex = re.compile(r"^(.*?): (.*)")

	for line in tmp:
		match_tmp = kubeadm_version_regex.match(line)
		if match_tmp is None:
			continue
		if match_tmp[1] == "kubeadm":
			kubeadm_version = match_tmp[2]
			break

	if len(kubeadm_version) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Failed to get ", "default"),
				ANSIThemeString("kubeadm", "programname"),
				ANSIThemeString(f" package version from control-plane at {control_plane_ip}; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	version_major, version_minor, _rest = kubeadm_version.split(".")

	if cri is None:
		if int(version_minor) < 24:
			cri = "dockershim"
		else:
			cri = "containerd"
	else:
		if int(version_minor) >= 24 and cri == "dockershim":
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": CRI cannot be “", "default"),
					ANSIThemeString("dockershim", "argument"),
					ANSIThemeString("“ for ", "default"),
					ANSIThemeString("Kubernetes ", "programname"),
					ANSIThemeString(">= ", "default"),
					ANSIThemeString("1.24", "version"),
					ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)

	# Add the CRI to the setup playbooks for the control plane;
	# the list is short enough that doing prepend isn't a performance issue
	if cri == "docker-shim":
		add_playbooks = [FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("setup_docker.io.yaml")))]
	elif cri == "containerd":
		add_playbooks = [FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("setup_containerd.yaml")))]
	elif cri == "cri-o":
		add_playbooks = [FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("setup_cri-o.yaml")))]
	cri_socket = deep_get(cri_data[cri], DictPath("socket"))

	add_playbooks += [
		# cmt does not use run_before/run_after/add_to_groups/remove_from_groups,
		# so we have to do all of that explicitly
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("add_kubernetes_repo.yaml"))),
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_setup_node.yaml")))
	]
	playbooks = populate_playbooks_from_paths(add_playbooks)

	extra_values = {
		"control_plane_ip": control_plane_ip,
		"control_plane_port": control_plane_port,
		"join_token": join_token,
		"ca_cert_hash": ca_cert_hash,
		"control_plane_k8s_version": kubeadm_version,
		"cri_socket": cri_socket,
		"kubernetes_major_minor_version": f"{version_major}.{version_minor}",
	}
	retval = run_playbooks(playbooks = playbooks, hosts = non_existing, extra_values = extra_values)
	if retval == True:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = non_existing, group = "nodes", skip_all = True)
	# XXX: We need to get the cluster name to do this
	#ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = non_existing, group = cluster_name, skip_all = True)
	ansithemeprint([ANSIThemeString("\nNodes successfully added", "success")])
	return 0

def remove_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Remove nodes from the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	force = False
	purge = False

	for opt, optarg in options:
		if opt == "--force":
			force = True
		elif opt == "--purge":
			purge = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--forks":
			ansible_configuration["forks"] = optarg
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0 and args[0] != "ALL":
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +\
			       ansithemestring_join_tuple_list(controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
			       [ANSIThemeString(" are control-plane(s) and should be removed using ", "default"),
				ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(non_existing) > 0:
		if force == False:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default")] +\
				       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
				       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": ", "default")] +\
				       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
				       [ANSIThemeString(" are not part of the cluster; attempting to purge them anyway since “", "description"),
					ANSIThemeString("--force", "option"),
					ANSIThemeString("“ was specified.", "default")], stderr = True)
			nodes += non_existing

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	ansithemeprint([ANSIThemeString("\n[Removing nodes]", "phase")])
	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Deleting nodes from the cluster", "action")])
	delete_playbooks = [
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("delete_node.yaml"))),
	]
	playbooks = populate_playbooks_from_paths(delete_playbooks)

	extra_values: Dict = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values)
	if retval == True:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	elif force == True:
		ansithemeprint([ANSIThemeString("NOT OK", "warning"),
				ANSIThemeString("; ignoring since “", "description"),
				ANSIThemeString("--force", "option"),
				ANSIThemeString("“ was specified.", "default")], stderr = True)
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Tearing down Kubernetes on the nodes", "action")])
	teardown_playbooks = [
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_teardown_node.yaml"))),
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("teardown_cni.yaml"))),
	]
	playbooks = populate_playbooks_from_paths(teardown_playbooks)

	extra_values = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values)
	if retval == True:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansithemeprint([ANSIThemeString("\nNodes successfully removed from cluster", "success")])

	if purge == True:
		purge_hosts(options = [("--ignore-non-existing", None)], args = [",".join(nodes)])

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Removing nodes from the inventory", "action")])
	ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = nodes, group = "nodes")
	# XXX: We need to get the cluster name to do this
	#ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = nodes, group = cluster_name)
	return 0

def purge_hosts(options: Sequence[Tuple[str, Optional[str]]], args: List[str]) -> int:
	"""
	Purge nodes from the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	ignore_non_existing = False

	selection = args[0].split(",")

	if "ALL" in selection:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default"),
				ANSIThemeString("ALL", "hostname"),
				ANSIThemeString(" cannot be used with ", "default"),
				ANSIThemeString("purge", "command"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for opt, optarg in options:
		if opt == "--ignore-non-existing":
			ignore_non_existing = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--forks":
			ansible_configuration["forks"] = optarg
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	nodes, _non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +\
			       ansithemestring_join_tuple_list(controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
			       [ANSIThemeString(" are control-plane(s) and should be removed using ", "default"),
				ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(nodes) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +\
			       ansithemestring_join_tuple_list(nodes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
			       [ANSIThemeString(" are still node(s) in the cluster; please run ", "default"),
				ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" remove-node", "command"),
				ANSIThemeString(" first to remove them from the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.EBUSY)

	hosts = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")

	not_in_inventory = []
	for host in selection:
		if host not in hosts:
			not_in_inventory.append(host)
			selection.remove(host)

	if len(not_in_inventory) > 0:
		if ignore_non_existing == False:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default")] +\
				       ansithemestring_join_tuple_list(not_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
				       [ANSIThemeString(" are not in the inventory; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": ", "default")] +\
				       ansithemestring_join_tuple_list(not_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
				       [ANSIThemeString(" are not in the inventory; ignoring them since “", "description"),
					ANSIThemeString("--ignore-non-existing", "option"),
					ANSIThemeString("“ was specified.", "default")], stderr = True)

	if len(selection) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": None of the specified hosts are part of the inventory; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Purging Kubernetes from the hosts", "action")])
	purge_playbooks = [
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_purge.yaml"))),
	]
	playbooks = populate_playbooks_from_paths(purge_playbooks)

	hosts = selection

	extra_values = {
		"packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
			"kubernetes-cni",
		],
		"held_packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
		]
	}
	retval = run_playbooks(playbooks = playbooks, hosts = hosts, extra_values = extra_values)
	if retval == True:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansithemeprint([ANSIThemeString("\nHosts successfully purged", "success")])
	return 0

def upgrade_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Upgrade nodes in the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	for opt, optarg in options:
		if opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--forks":
			ansible_configuration["forks"] = optarg
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0 and args[0] != "ALL":
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +\
			       ansithemestring_join_tuple_list(controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
			       [ANSIThemeString(" are control-plane(s) and should be upgraded using ", "default"),
				ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(non_existing) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +\
			       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +\
			       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	ansithemeprint([ANSIThemeString("\n[Upgrading nodes]", "phase")])
	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Drain nodes", "action")])
	drain_options = [
		("--delete-emptydir-data", None),
		("--disable-eviction", None),
		("--ignore-daemonsets", None),
		("--no-header", None),
	]
	drain_nodes(options = drain_options, args = [",".join(nodes)])

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Run upgrade playbooks on nodes", "action")])
	upgrade_playbooks = [
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_upgrade_node.yaml"))),
	]
	playbooks = populate_playbooks_from_paths(upgrade_playbooks)

	extra_values: Dict = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values)
	if retval == True:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Uncordon nodes", "action")])
	uncordon_nodes(options = [], args = [",".join(nodes)])

	ansithemeprint([ANSIThemeString("\nNode upgrade successful", "success")])
	return 0

# pylint: disable-next=pointless-string-statement
"""
def get_resource(options: List[Tuple[str, str]], args: List[str]) -> None:
	namespaces = ["default"]

	for opt, optarg in options:
		# This is a tuple option, so the easiest way is to check this way
		if "--all-namespaces" in opt:
			namespaces = None
		elif "--namespace" in opt:
			namespaces = optarg.split(",")
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	# We might have to get the resources across multiple namespaces, so we need to do multiple requests
	return
"""

CMT_COMMANDLINE = {
	"Cordon Node": {
		"command": ["cordon"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL", "argument")],
		"description": [ANSIThemeString("Cordon ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"options": {
			"--include-control-planes": {
				"description": [ANSIThemeString("Include control planes when ALL is used", "description")],
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": cordon_nodes,
	},
	"Drain Node": {
		"command": ["drain"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL", "argument")],
		"description": [ANSIThemeString("Drain ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"options": {
			"--delete-emptydir-data": {
				"description": [ANSIThemeString("Drain nodes even if this would cause ", "description"),
						ANSIThemeString("emptyDir", "emphasis"),
						ANSIThemeString(" data to be deleted", "description")],
			},
			"--delete-local-data": {
				"description": [ANSIThemeString("This is an alias for “", "description"),
						ANSIThemeString("--delete-emptydir-data", "option"),
						ANSIThemeString("“", "description")],
			},
			"--disable-eviction": {
				"description": [ANSIThemeString("Delete pods instead of using evict; this bypasses ", "description"),
						ANSIThemeString("PodDisruptionBudget", "emphasis")],
			},
			"--ignore-daemonsets": {
				"description": [ANSIThemeString("Ignore pods managed by daemonsets; by default ", "description"),
						ANSIThemeString("drain ", "command"),
						ANSIThemeString("will abort if there are such pods running on the node", "description")],
			},
			"--include-control-planes": {
				"description": [ANSIThemeString("Include control planes when ALL is used", "description")],
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": drain_nodes,
	},
	"Drain Node (Force)": {
		"command": ["force-drain"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL", "argument")],
		"description": [ANSIThemeString("Force-drain ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"extended_description": [
			[ANSIThemeString("When a node is force-drained, pods belonging to daemonsets are ignored, and ", "description"),
			 ANSIThemeString("emptyDir", "emphasis"),
			 ANSIThemeString(" data is deleted.", "description")],
		],
		"options": {
			"--disable-eviction": {
				"description": [ANSIThemeString("Delete pods instead of using evict; this bypasses ", "description"),
						ANSIThemeString("PodDisruptionBudget", "emphasis")],
			},
			"--include-control-planes": {
				"description": [ANSIThemeString("Include control planes when ALL is used", "description")],
			},
		},
		"implicit_options": [
			("--delete-emptydir-data", None),
			("--ignore-daemonsets", None),
		],
		"min_args": 1,
		"max_args": 1,
		"callback": drain_nodes,
	},
	"Uncordon Node": {
		"command": ["uncordon"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL", "argument")],
		"description": [ANSIThemeString("Uncordon ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"options": {
			"--include-control-planes": {
				"description": [ANSIThemeString("Include control planes when ALL is used", "description")],
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": uncordon_nodes,
	},
	"Taint Node": {
		"command": ["taint"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL ", "argument"),
			   ANSIThemeString("KEY", "argument"),
			   ANSIThemeString("[:", "separator"),
			   ANSIThemeString("VALUE", "argument"),
			   ANSIThemeString("]=", "separator"),
			   ANSIThemeString("EFFECT", "argument")],
		"description": [ANSIThemeString("Add the taint ", "description"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString("[:", "separator"),
				ANSIThemeString("VALUE", "argument"),
				ANSIThemeString("]", "separator"),
				ANSIThemeString(" with ", "description"),
				ANSIThemeString("EFFECT", "argument"),
				ANSIThemeString(" to ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"extended_description": [
			[ANSIThemeString("Valid values for ", "description"),
			 ANSIThemeString("EFFECT", "argument"),
			 ANSIThemeString(" are: ", "description"),
			 ANSIThemeString("NoSchedule", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("PreferNoSchedule", "argument"),
			 ANSIThemeString(",", "separator"),
			 ANSIThemeString(" and ", "description"),
			 ANSIThemeString("NoExecute", "argument"),
			 ANSIThemeString(".", "description")],
		],
		"options": {
			"--include-control-planes": {
				"description": [ANSIThemeString("Include control planes when ALL is used", "description")],
			},
			"--overwrite": {
				"description": [ANSIThemeString("Allow taints to be overwritten (by default conflicting taints are ignored)", "description")],
			}
		},
		"min_args": 2,
		"max_args": 2,
		"callback": taint_nodes,
	},
	"Untaint Node": {
		"command": ["untaint"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL ", "argument"),
			   ANSIThemeString("KEY", "argument"),
			   ANSIThemeString("[:", "separator"),
			   ANSIThemeString("VALUE", "argument"),
			   ANSIThemeString("][=", "separator"),
			   ANSIThemeString("EFFECT", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Remove the taint ", "description"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString("[:", "separator"),
				ANSIThemeString("VALUE", "argument"),
				ANSIThemeString("]", "separator"),
				ANSIThemeString(" with ", "description"),
				ANSIThemeString("EFFECT", "argument"),
				ANSIThemeString(" from ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"extended_description": [
			[ANSIThemeString("If ", "description"),
			 ANSIThemeString("EFFECT", "argument"),
			 ANSIThemeString(" is not specified, all taints matching ", "description"),
			 ANSIThemeString("KEY", "argument"),
			 ANSIThemeString("[:", "separator"),
			 ANSIThemeString("VALUE", "argument"),
			 ANSIThemeString("]", "separator"),
			 ANSIThemeString(" will be removed.", "description")],
		],
		"options": {
			"--include-control-planes": {
				"description": [ANSIThemeString("Include control planes when ALL is used", "description")],
			},
		},
		"min_args": 2,
		"max_args": 2,
		"callback": untaint_nodes,
	},
	"Prepare Host": {
		"command": ["prepare"],
		"values": [ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("PATH", "argument")],
		"description": [ANSIThemeString("Prepare ", "description"),
				ANSIThemeString("HOST", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" for use as a node in a Kubernetes cluster", "description")],
		"extended_description": [
			[ANSIThemeString("Note", "note"),
			 ANSIThemeString(": ", "description"),
			 ANSIThemeString("HOST", "argument"),
			 ANSIThemeString(" should be a resolvable hostname; using IP-addresses may cause issues.", "description")],
			[ANSIThemeString("If the hosts intended for use as nodes in the cluster do not have resolvable", "description")],
			[ANSIThemeString("hostnames it is recommended to add them to ", "description"),
			 ANSIThemeString("/etc/hosts", "path"),
			 ANSIThemeString(".", "default")],
		],
		"options": {
			"--ignore-existing": {
				"description": [ANSIThemeString("Ignore hosts that are already part of the cluster", "description")],
			},
			"--forks": {
				"values": [ANSIThemeString("FORKS", "argument")],
				"description": [ANSIThemeString("Max number of parallel connections when running Ansible playbooks (overrides ", "description"),
						ANSIThemeString("cmt.yaml", "argument"),
						ANSIThemeString("; default: ", "description"),
						ANSIThemeString("5", "argument"),
						ANSIThemeString(")", "description")],
				"requires_arg": True,
			},
			"--from-file": {
				"description": [ANSIThemeString("Treat the argument to ", "description"),
						ANSIThemeString("prepare", "command"),
						ANSIThemeString(" as the path to a file with hostnames instead of a list of hostnames.", "description")],
			},
			"--no-password": {
				"description": [ANSIThemeString("Do not prompt for a password; use this if the hosts you are preparing are already configured for login using an SSH key", "description")],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs; the logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation before performing actions", "description")],
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": prepare_hosts,
	},
	"Add Node": {
		"command": ["add-node", "add-nodes"],
		"values": [ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Add ", "description"),
				ANSIThemeString("HOST", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" as Kubernetes nodes to a cluster", "description")],
		"extended_description": [
			[ANSIThemeString("Note", "note"),
			 ANSIThemeString(": ", "description"),
			 ANSIThemeString("HOST", "argument"),
			 ANSIThemeString(" should be a resolvable hostname; using IP-addresses may cause issues.", "description")],
			[ANSIThemeString("If the hosts intended for use as nodes in the cluster do not have a resolvable", "description")],
			[ANSIThemeString("hostnames it is recommended to use ", "description"),
			 ANSIThemeString("/etc/hosts", "path"),
			 ANSIThemeString(" for this purpose.", "description")],
		],
		"options": {
			"--ca-cert-file": {
				"values": [ANSIThemeString("PATH", "argument")],
				"description": [ANSIThemeString("Use ", "description"),
						ANSIThemeString("PATH", "argument"),
						ANSIThemeString(" as token CA certificate", "description")],
				"requires_arg": True,
			},
			"--cri": {
				"values": [ANSIThemeString("CRI", "argument")],
				"description": [ANSIThemeString("Use ", "description"),
						ANSIThemeString("CRI", "argument"),
						ANSIThemeString(" instead of the default CRI", "description")],
				"extended_description": [
					[ANSIThemeString("Valid options for CRI (Container Runtime Interface) are:", "description")],
					[ANSIThemeString("dockershim", "argument"),
					 ANSIThemeString(" (", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" < ", "description"),
					 ANSIThemeString("1.24", "version"),
					 ANSIThemeString(")", "description"),
					 ANSIThemeString(", ", "separator"),
					 ANSIThemeString("containerd", "argument"),
					 ANSIThemeString(", ", "separator"),
					 ANSIThemeString("cri-o", "argument"),
					],
					[ANSIThemeString("The default CRI is ", "description"),
					 ANSIThemeString("dockershim", "argument"),
					 ANSIThemeString(" for ", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" < ", "description"),
					 ANSIThemeString("1.24", "version")],
					[ANSIThemeString("and ", "description"),
					 ANSIThemeString("containerd", "argument"),
					 ANSIThemeString(" for ", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.24", "version"),
					 ANSIThemeString(".", "description")],
					[ANSIThemeString("Note", "note"),
					 ANSIThemeString(": ", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.26", "version"),
					 ANSIThemeString(" requires ", "description"),
					 ANSIThemeString("containerd", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.6", "version"),
					 ANSIThemeString(".", "description")],
				],
				"requires_arg": True,
			},
			"--forks": {
				"values": [ANSIThemeString("FORKS", "argument")],
				"description": [ANSIThemeString("Max number of parallel connections when running Ansible playbooks (overrides ", "description"),
						ANSIThemeString("cmt.yaml", "argument"),
						ANSIThemeString("; default: ", "description"),
						ANSIThemeString("5", "argument"),
						ANSIThemeString(")", "description")],
				"requires_arg": True,
			},
			"--from-file": {
				"description": [ANSIThemeString("Treat the argument to ", "description"),
						ANSIThemeString("prepare", "command"),
						ANSIThemeString(" as the path to a file with hostnames instead of a list of hostnames.", "description")],
			},
			"--ignore-existing": {
				"description": [ANSIThemeString("Ignore hosts that are already part of the cluster", "description")],
			},
			"--ignore-non-existing": {
				"description": [ANSIThemeString("Ignore hosts that are not part of the inventory", "description")],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs; the logs can be viewed using “", "description"),
					        ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation before performing actions", "description")],
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": add_nodes,
	},
	"Remove Node": {
		"command": ["remove-node", "remove-nodes"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL", "argument")],
		"description": [ANSIThemeString("Remove ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" from a Kubernetes cluster", "description")],
		"options": {
			"--force": {
				"description": [ANSIThemeString("Attempt to teardown Kubernetes nodes that are no longer in the cluster", "description")],
			},
			"--forks": {
				"values": [ANSIThemeString("FORKS", "argument")],
				"description": [ANSIThemeString("Max number of parallel connections when running Ansible playbooks (overrides ", "description"),
						ANSIThemeString("cmt.yaml", "argument"),
						ANSIThemeString("; default: ", "description"),
						ANSIThemeString("5", "argument"),
						ANSIThemeString(")", "description")],
				"requires_arg": True,
			},
			"--purge": {
				"description": [ANSIThemeString("Purge hosts if teardown completes successfully", "description")],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs; the logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": remove_nodes,
	},
	"Purge": {
		"command": ["purge"],
		"values": [ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Remove Kubernetes configuration and packages from ", "description"),
				ANSIThemeString("HOST", "argument")],
		"options": {
			"--ignore-non-existing": {
				"description": [ANSIThemeString("Ignore hosts that cannot be found in the inventory", "description")],
			},
			"--forks": {
				"values": [ANSIThemeString("FORKS", "argument")],
				"description": [ANSIThemeString("Max number of parallel connections when running Ansible playbooks (overrides ", "description"),
						ANSIThemeString("cmt.yaml", "argument"),
						ANSIThemeString("; default: ", "description"),
						ANSIThemeString("5", "argument"),
						ANSIThemeString(")", "description")],
				"requires_arg": True,
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs; the logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": purge_hosts,
	},
	"Upgrade Node": {
		"command": ["upgrade-node", "upgrade-nodes"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL", "argument")],
		"description": [ANSIThemeString("Upgrade Kubernetes on ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"extended_description": [
			[ANSIThemeString("Upgrade Kubernetes on ", "description"),
			 ANSIThemeString("NODE", "argument"),
			 ANSIThemeString(",", "separator"),
			 ANSIThemeString("...", "argument"),
			 ANSIThemeString(" to the version in use on the control-plane(s);", "description")],
			[ANSIThemeString("run this on all nodes after running “", "description"),
			 ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
			 ANSIThemeString(" upgrade-control-plane", "command"),
			 ANSIThemeString("“.", "description")],
		],
		"options": {
			"--forks": {
				"values": [ANSIThemeString("FORKS", "argument")],
				"description": [ANSIThemeString("Max number of parallel connections when running Ansible playbooks (overrides ", "description"),
						ANSIThemeString("cmt.yaml", "argument"),
						ANSIThemeString("; default: ", "description"),
						ANSIThemeString("5", "argument"),
						ANSIThemeString(")", "description")],
				"requires_arg": True,
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs; the logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": upgrade_nodes,
	},
	"spacer1": {
		"command": [""],
		"description": [ANSIThemeString("", "default")],
	},
#	"Get": {
#		"command": ["get", "l", "list"],
#		"values": [ANSIThemeString("RESOURCE", "argument"),
#			   ANSIThemeString(",", "separator"),
#			   ANSIThemeString("...", "argument")],
#		"description": [ANSIThemeString("List information about ", "description"),
#				ANSIThemeString("RESOURCE", "argument"),
#				ANSIThemeString(",", "separator"),
#				ANSIThemeString("...", "argument")],
#		"options": {
#			("-N", "--namespace"): {
#				"values": [ANSIThemeString("NAMESPACE", "argument"),
#					   ANSIThemeString(",", "separator"),
#					   ANSIThemeString("...", "argument")],
#				"description": [ANSIThemeString("Only show resources belonging to ", "description"),
#						ANSIThemeString("NAMESPACE", "argument"),
#						ANSIThemeString(",", "separator"),
#						ANSIThemeString("...", "argument")],
#				"requires_arg": True,
#			},
#			("-A", "--all-namespaces"): {
#				"description": [ANSIThemeString("Show resources across all namespaces", "description")],
#			},
#		},
#		"min_args": 1,
#		"max_args": 1,
#		"callback": get_resource,
#	},
	"extended_description": [
		[ANSIThemeString("You can use “", "description"),
		 ANSIThemeString("ALL", "emphasis"),
		 ANSIThemeString("“ as a substitute for all resources in most cases;", "description")],
		[ANSIThemeString("for instance “", "description"),
		 ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
		 ANSIThemeString(" upgrade-node ", "command"),
		 ANSIThemeString("ALL", "emphasis"),
		 ANSIThemeString("“ will upgrade Kubernetes on all nodes", "description")],
		[ANSIThemeString("", "default")],
		[ANSIThemeString("Note that “", "description"),
		 ANSIThemeString("ALL", "emphasis"),
		 ANSIThemeString("“ excludes control planes when used on nodes; to include control planes", "description")],
		[ANSIThemeString("you need to pass the “", "description"),
		 ANSIThemeString("--include-control-planes", "option"),
		 ANSIThemeString("“ option (where available)", "description")],
	]
}

def get_programname(callname: str) -> Tuple[str, Dict]:
	"""
	Return the name that the program was called with;
	the eventual intention here is that the behaviour can be different
	depending on by what name the program was invoked

		Parameters:
			callname (str): The name that the program was invoked with
		Returns:
			(callname (str), commandline (List[str]))
	"""

	callnames = {
		"cmt": CMT_COMMANDLINE,		# main name
		#"cmtdep": DEP_COMMANDLINE,	# deployment shortcut
		#"cmtds": DS_COMMANDLINE,	# daemon set shortcut
		#"cmtrs": RS_COMMANDLINE,	# replica set shortcut
		#"cmtjob": JOB_COMMANDLINE,	# job shortcut
		#"cmtnode": NODE_COMMANDLINE,	# node shortcut
		#"cmtpod": POD_COMMANDLINE,	# pod shortcut
	}

	if callname not in callnames:
		sys.exit(f"{about.TOOL_PROGRAM_NAME} called with unknown name {callname}; aborting.")

	return callname, callnames[callname]

def main() -> int:
	"""
	Main function for the program
	"""

	# Before doing anything else, make sure that the user is not running as root
	if os.geteuid() == 0:
		sys.exit("CRITICAL: This program should not be run as the root user; aborting.")

	# Then initialise the configuration file
	read_cmtconfig()

	programname, commandline = get_programname(os.path.basename(sys.argv[0]))

	command, options, args = parse_commandline(programname, about.TOOL_PROGRAM_VERSION, PROGRAMDESCRIPTION, PROGRAMAUTHORS, sys.argv,
						   commandline, theme = DEFAULT_THEME_FILE)

	# Used by the ansible module
	ansible_configuration["ansible_forks"] = deep_get(cmtlib.cmtconfig, DictPath("Ansible#forks"), 10)
	ansible_user = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_user"))
	if ansible_user is None or len(ansible_user) == 0:
		ansible_user = getuser()
	ansible_configuration["ansible_user"] = ansible_user
	ansible_password = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_password"))
	if ansible_password is not None and len(ansible_password) > 0:
		ansible_configuration["ansible_password"] = ansible_password
	ansible_configuration["disable_strict_host_key_checking"] = deep_get(cmtlib.cmtconfig, DictPath("Nodes#disablestricthostkeychecking"), False)
	ansible_configuration["save_logs"] = deep_get(cmtlib.cmtconfig, DictPath("Ansible#save_logs"), False)

	return command(options, args)

if __name__ == "__main__":
	main()
