#! /bin/sh
# vim: filetype=python
# pylint: disable-next=anomalous-backslash-in-string,line-too-long
''''eval version=$( ls /usr/bin/python3.* | grep '.*[0-9]$' | sort -nr -k2 -t. | head -n1 ) && version=${version##/usr/bin/python3.} && [ ${version} ] && [ ${version} -ge 8 ] && exec /usr/bin/python3.${version} "$0" "$@" || exec /usr/bin/env python3 "$0" "$@"' #'''
__doc__ = "The above hack is to handle distros that don't have /usr/bin/python3 point to the latest version of python3 they provide"
# Requires: ansible
# Requires: python3 (>= 3.8)
# Requires: python3-natsort
# Requires: python3-openssl
# Recommends: python3-ujson

# pylint: disable=line-too-long

"""
This program is used to install, upgrade and uninstall nodes for Kubernetes clusters,
and to perform various other tasks; eventually this is meant to have most of the
features available in cmu

For usage, see:
	cmt help
"""

import errno
from getpass import getuser
import hashlib
from operator import itemgetter
import os
from pathlib import Path, PurePath
import re
import sys
from typing import Any, cast, Dict, List, Optional, Sequence, Tuple
try:
	import yaml
except ModuleNotFoundError:
	sys.exit("ModuleNotFoundError: Could not import yaml; you may need to (re-)run `cmt-install` or `pip3 install PyYAML`; aborting.")

from cryptography import x509
from cryptography.hazmat.primitives import serialization

try:
	from natsort import natsorted
except ModuleNotFoundError:
	sys.exit("ModuleNotFoundError: Could not import natsort; you may need to (re-)run `cmt-install` or `pip3 install natsort`; aborting.")

from cmttypes import deep_get, DictPath, FilePath, FilePathAuditError, HostNameStatus, SecurityChecks
from cmtpaths import CMT_CONFIG_FILE, CMT_CONFIG_FILENAME, DEFAULT_THEME_FILE, KUBE_CONFIG_FILE, VERSION_CACHE_DIR, VIEW_DIR

import commandparser
from commandparser import parse_commandline

from ansible_helper import ansible_configuration, ansible_run_playbook_on_selection, ansible_get_hosts_by_group, ansible_add_hosts, ansible_remove_hosts
from ansible_helper import ansible_print_action_summary, ansible_print_play_results, populate_playbooks_from_paths
from ansible_helper import ANSIBLE_PLAYBOOK_DIR, ANSIBLE_INVENTORY

import cmtlib
from cmtlib import identify_distro, read_cmtconfig
from cmtio import execute_command, secure_read_string, validate_fqdn
from cmtio_yaml import secure_read_yaml
from networkio import scan_and_add_ssh_keys

from kubernetes_helper import list_contexts, get_node_status, kubectl_get_version, update_api_status as kh_update_api_status, set_context

from ansithemeprint import ANSIThemeString, ansithemestring_join_tuple_list, ansithemeprint, ansithemeinput, ansithemeinput_password

import about
PROGRAMDESCRIPTION = "Commandline tool for managing Kubernetes clusters"
PROGRAMAUTHORS = "Written by David Weinehall."

def request_ansible_password() -> None:
	"""
	Requests the ansible password
	"""

	# Check whether ansible_password is defined or not
	if ansible_configuration["ansible_password"] is None:
		ansithemeprint([ANSIThemeString("Attention", "warning"),
				ANSIThemeString(": To be able to run playbooks you need to provide the ansible/ssh password.", "default")])
		ansithemeprint([ANSIThemeString("Since the systems will be reconfigured to use passwordless sudo and ssh keys this is a one-time thing.", "default")])

		ansible_password = ansithemeinput_password([ANSIThemeString("\nPassword: ", "default")])

		if ansible_password is None or len(ansible_password) == 0:
			ansithemeprint([ANSIThemeString("\nError", "error"),
					ANSIThemeString(": Empty password; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)

		ansible_configuration["ansible_password"] = ansible_password # type: ignore

def get_latest_kubernetes_upstream_version() -> str:
	# We are OK with the file not existing
	security_checks = [
		SecurityChecks.PARENT_RESOLVES_TO_SELF,
		SecurityChecks.OWNER_IN_ALLOWLIST,
		SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
		SecurityChecks.PERMISSIONS,
		SecurityChecks.PARENT_PERMISSIONS,
		SecurityChecks.IS_FILE,
	]

	kubernetes_upstream_version = None

	try:
		version_cache = secure_read_yaml(FilePath(str(PurePath(VERSION_CACHE_DIR).joinpath("kubernetes_current.yaml"))), checks = security_checks)
	except FileNotFoundError:
		version_cache = None
		pass

	if version_cache is not None:
		if len(schedules := deep_get(version_cache, DictPath("schedules"), [])) > 0:
			if len(previous_patches := deep_get(schedules[0], DictPath("previousPatches"), [])) > 0:
				kubernetes_upstream_version = deep_get(previous_patches[0], DictPath("release"), kubernetes_upstream_version)

	return kubernetes_upstream_version

def run_playbook(playbookpath: FilePath, hosts: List[str], extra_values: Optional[Dict] = None, quiet: bool = False, verbose: bool = False) -> Tuple[int, Dict]:
	"""
	Run a playbook

		Parameters:
			playbookpath (FilePath): A path to the playbook to run
			hosts (list[str]): A list of hosts to run the playbook on
			extra_values (dict): A dict of values to set before running the playbook
			quiet (bool): Should the results of the run be printed? (Unused)
			verbose (bool): If the results are printed, should skipped tasks be printed too?
		Returns:
			retval (int): The return value from ansible_run_playbook_on_selection()
			ansible_results (dict): A dict with the results from the run
	"""

	# The first patch revision that isn't available from the old repositories is 1.28.3;
	# this means that we need to include all minor versions from 28 and up.
	if (kubernetes_upstream_version := get_latest_kubernetes_upstream_version()) is None:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Could not get the latest upstream Kubernetes version; ", "default"),
				ANSIThemeString("this is either a network error or a bug; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# Split the version tuple
	upstream_major, upstream_minor, _rest = kubernetes_upstream_version.split(".")
	minor_versions = []
	for minor_version in range(28, int(upstream_minor) + 1):
		minor_versions.append(f"{minor_version}")

	# Set necessary Ansible keys before running playbooks
	http_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), "")
	if http_proxy is None:
		http_proxy = ""
	https_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), "")
	if https_proxy is None:
		https_proxy = ""
	no_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), "")
	if no_proxy is None:
		no_proxy = ""
	insecure_registries = deep_get(cmtlib.cmtconfig, DictPath("Docker#insecure_registries"), [])
	registry_mirrors = deep_get(cmtlib.cmtconfig, DictPath("Containerd#registry_mirrors"), [])
	retval = 0

	use_proxy = "no"
	if len(http_proxy) > 0 or len(https_proxy) > 0:
		use_proxy = "yes"

	if extra_values is None:
		extra_values = {}

	values = {
		"http_proxy": http_proxy,
		"https_proxy": https_proxy,
		"no_proxy": no_proxy,
		"insecure_registries": insecure_registries,
		"registry_mirrors": registry_mirrors,
		"use_proxy": use_proxy,
		"minor_versions": minor_versions,
	}
	merged_values = { **values, **extra_values }

	retval, ansible_results = ansible_run_playbook_on_selection(playbookpath, selection = hosts, values = merged_values)
	if retval == -errno.ENOENT and len(ansible_results) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default"),
				ANSIThemeString(f"{ANSIBLE_INVENTORY}", "path"),
				ANSIThemeString(" is either empty or missing; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if not quiet:
		ansible_print_play_results(retval, ansible_results, verbose = verbose)
		print()

	return retval, ansible_results

def __format_none(string: Optional[str], fmt: str) -> ANSIThemeString:
	if string is None or string == "<none>":
		__string = ANSIThemeString("<none>", "none")
	else:
		__string = ANSIThemeString(string, fmt)
	return __string

def get_cluster_name() -> Optional[str]:
	"""
	Return the name of the cluster

		Returns:
			cluster_name (str): The name of the cluster
	"""
	try:
		d1 = secure_read_yaml(KUBE_CONFIG_FILE)
	except FileNotFoundError:
		return None

	current_context = d1.get("current-context", None)
	if current_context is None:
		return None

	cluster_name = None

	for context in d1.get("contexts", []):
		if context.get("name", "") == current_context:
			cluster_name = context["context"].get("cluster", None)
			break

	return cluster_name

def get_control_planes() -> List[Tuple[str, List[str]]]:
	"""
	Get the list of control planes

		Returns:
			[(name, ipaddresses)]: The list of control planes
				name (str): The name of the control plane
				ipaddresses ([str]): A list of IP-addresses for the control plane
	"""

	controlplanes = []

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
	if status != 200:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": API-server returned ", "default"),
				ANSIThemeString(f"{status}", "errorvalue"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)
	if vlist is None:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": API-server did not return any data", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for node in vlist:
		name = deep_get(node, DictPath("metadata#name"))
		node_roles = kh.get_node_roles(cast(Dict, node))
		if "control-plane" in node_roles or "master" in node_roles:
			ipaddresses = []
			for address in deep_get(node, DictPath("status#addresses")):
				if deep_get(address, DictPath("type"), "") == "InternalIP":
					ipaddresses.append(deep_get(address, DictPath("address")))
			controlplanes.append((name, ipaddresses))

	return controlplanes

def show_configuration(hosts: List[str], cri: Optional[str] = None) -> None:
	"""
	Show cluster configuration

		Parameters:
			hosts (list[str]): The hosts that will be affected
	"""

	cluster_name = get_cluster_name()
	controlplanes = get_control_planes()

	http_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#http_proxy"), "")
	if http_proxy is not None and http_proxy == "":
		http_proxy = None
	http_proxy_env = os.getenv("http_proxy")
	if http_proxy_env is not None and http_proxy_env == "":
		http_proxy_env = None
	https_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#https_proxy"), "")
	if https_proxy is not None and https_proxy == "":
		https_proxy = None
	https_proxy_env = os.getenv("https_proxy")
	if https_proxy_env is not None and https_proxy_env == "":
		https_proxy_env = None
	no_proxy = deep_get(cmtlib.cmtconfig, DictPath("Network#no_proxy"), "")
	if no_proxy is not None and no_proxy == "":
		no_proxy = None
	no_proxy_env = os.getenv("no_proxy")
	if no_proxy_env is not None and no_proxy_env == "":
		no_proxy_env = None

	ansithemeprint([ANSIThemeString("\n[Summary]", "phase")])
	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Configuration:", "action")])
	ansithemeprint([ANSIThemeString("        Cluster Name: ", "action"),
			ANSIThemeString(f"{cluster_name}", "hostname")])
	if cri is not None:
		ansithemeprint([ANSIThemeString("                 CRI: ", "action"),
				ANSIThemeString(f"{cri}", "programname")])
	ansithemeprint([ANSIThemeString("          HTTP Proxy: ", "action"),
			__format_none(http_proxy, "url"),
			ANSIThemeString(" (", "default"),
			ANSIThemeString(f"{CMT_CONFIG_FILE}", "path"),
			ANSIThemeString(")", "default")])
	ansithemeprint([ANSIThemeString("          HTTP Proxy: ", "action"),
			__format_none(http_proxy_env, "url"),
			ANSIThemeString(" (Environment)", "default")])
	ansithemeprint([ANSIThemeString("         HTTPS Proxy: ", "action"),
			__format_none(https_proxy, "url"),
			ANSIThemeString(" (", "default"),
			ANSIThemeString(f"{CMT_CONFIG_FILE}", "path"),
			ANSIThemeString(")", "default")])
	ansithemeprint([ANSIThemeString("         HTTPS Proxy: ", "action"),
			__format_none(https_proxy_env, "url"),
			ANSIThemeString(" (Environment)", "default")])
	ansithemeprint([ANSIThemeString("            No Proxy: ", "action"),
			__format_none(no_proxy, "url"),
			ANSIThemeString(" (", "default"),
			ANSIThemeString(f"{CMT_CONFIG_FILE}", "path"),
			ANSIThemeString(")", "default")])
	ansithemeprint([ANSIThemeString("            No Proxy: ", "action"),
			__format_none(no_proxy_env, "url"),
			ANSIThemeString(" (Environment)", "default")])

	ansithemeprint([ANSIThemeString("", "default")])
	ansithemeprint([ANSIThemeString("• ", "separator"),
			ANSIThemeString("Control Planes:", "action")])

	for controlplane in controlplanes:
		ansithemeprint([ANSIThemeString("  • ", "separator"),
				ANSIThemeString(f"{controlplane[0]} ", "emphasis"),
				ANSIThemeString("(", "default")] +
			       ansithemestring_join_tuple_list(controlplane[1], formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
			       [ANSIThemeString(")", "default")])

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Target Hosts:", "action")])
	for host in hosts:
		ansithemeprint([ANSIThemeString("  • ", "separator"),
				ANSIThemeString(host, "hostname")])

def run_playbooks(playbooks: List[Tuple[List[ANSIThemeString], FilePath]], hosts: Optional[List[str]] = None, extra_values: Optional[Dict] = None, verbose: bool = False) -> bool:
	"""
	Run a set of playbooks

		Parameters:
			playbooks (list[(description, playbookpath)]): A list of playbooks
			hosts (str): The hosts to run the playbooks on
			extra_values (dict): Variables to set before running the playbooks
			verbose (bool): If the results are printed, should skipped tasks be printed too?
		Returns:
			True on success, False on failure
	"""

	if len(playbooks) == 0 or hosts is None:
		return True

	for string, playbookpath in playbooks:
		ansithemeprint(string)
		retval, _ansible_results = run_playbook(playbookpath, hosts = cast(List[str], hosts), extra_values = extra_values, verbose = verbose)

		# We do not want to continue executing playbooks if the first one failed
		if retval != 0:
			break

	return retval == 0

def get_selection(selection: List[str], kind: Optional[Tuple[str, str]] = None) -> Tuple[List[str], List[str], List[str]]:
	"""
	Based on input parameters, split the node list into nodes, non-existing nodes, and control planes

		Parameters:
			selection (list[str]): A list of nodes, or ALL to select all nodes
			kind (tuple): A Kubernetes kind; only supported for now is ("Node", "")
			_or_
			kind (str): For future use with playbooks, etc.
		Returns:
			(nodes, non_existing_nodes, controlplanes):
				nodes (list[str]): (str, str, str): The nodes
				non_existing_nodes (list[str]): The non-existing nodes
				controlplanes (list[str]): The control planes
	"""

	all_items = False
	items1 = []
	non_existing = []
	# Only used for controlplanes
	items2 = []

	if kind is None:
		raise ValueError("kind is None; this is a programming error")

	if selection is None:
		raise ValueError("selection is None; this is a programming error")

	if "ALL" in selection:
		if len(selection) > 1:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": “", "default"),
					ANSIThemeString("ALL", "argument"),
					ANSIThemeString("“ cannot be combined with other arguments; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		else:
			all_items = True

	# Kubernetes resources
	if isinstance(kind, tuple):
		from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
		kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

		vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
		if status != 200:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": API-server returned ", "default"),
					ANSIThemeString(f"{status}", "errorvalue"),
					ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		if vlist is None:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": API-server did not return any data", "default")], stderr = True)
			sys.exit(errno.EINVAL)

		for node in vlist:
			name = deep_get(node, DictPath("metadata#name"))
			if not all_items and name not in selection:
				continue

			node_roles = kh.get_node_roles(cast(Dict, node))
			if "control-plane" in node_roles or "master" in node_roles:
				items2.append(name)
				continue

			items1.append(name)
	# str kinds are things such as playbooks; for now cmt does not use them

	# Finally, generate a list of non-existing items
	if not all_items:
		for item in selection:
			if item not in items1 + items2:
				non_existing.append(item)

	return items1, non_existing, items2

def cordon_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Cordon nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	include_control_planes = False
	header = True

	for opt, _optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False

	selection = args[0].split(",")

	# It is OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes:
		nodes += controlplanes

	if len(non_existing) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +
			       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
			       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header:
		ansithemeprint([ANSIThemeString("\n[Cordoning nodes]", "phase")])

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for node in nodes:
		ansithemeprint([ANSIThemeString(f"{node}:", "hostname")])
		message, status = kh.cordon_node(node)
		if status in (200, 204):
			ansithemeprint([ANSIThemeString("  Cordoned", "success")])
			print(message)
		elif status == 42503:
			ansithemeprint([ANSIThemeString("", "default")])
			ansithemeprint([ANSIThemeString("Critical", "critical"),
					ANSIThemeString(": Cluster not available; aborting", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			ansithemeprint([ANSIThemeString("\nAPI call returned error:", "error")], stderr = True)
			ansithemeprint([ANSIThemeString(f"  {message}", "error")], stderr = True)
			sys.exit(errno.EINVAL)
	return 0

def drain_nodes(options: Sequence[Tuple[str, Optional[str]]], args: List[str]) -> int:
	"""
	Drain nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	include_control_planes = False
	header = True

	# Check kubectl version
	kubectl_major_version, kubectl_minor_version, _kubectl_git_version, _server_major_version, _server_minor_version, _server_git_version = kubectl_get_version()

	_args = ["/usr/bin/kubectl", "drain"]

	for opt, _optarg in options:
		if opt in ("--delete-emptydir-data", "--delete-local-data"):
			if kubectl_major_version >= 1 and kubectl_minor_version >= 20:
				_args.append("--delete-emptydir-data")
			else:
				_args.append("--delete-local-data")
		elif opt == "--disable-eviction":
			if kubectl_major_version >= 1 and kubectl_minor_version >= 18:
				_args.append(opt)
		elif opt == "--ignore-daemonsets":
			_args.append(opt)
		elif opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False

	selection = args[0].split(",")

	# It is OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes:
		nodes += controlplanes

	if len(non_existing) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +
			       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
			       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header:
		ansithemeprint([ANSIThemeString("\n[Draining nodes]", "phase")])
	_args += nodes
	execute_command(_args)
	return 0

def uncordon_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Uncordon nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	include_control_planes = False
	header = True

	for opt, _optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False

	selection = args[0].split(",")

	# It is OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes:
		nodes += controlplanes

	if len(non_existing) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +
			       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
			       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header:
		ansithemeprint([ANSIThemeString("\n[Uncordoning nodes]", "phase")])

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for node in nodes:
		ansithemeprint([ANSIThemeString(f"{node}:", "hostname")])
		message, status = kh.uncordon_node(node)
		if status in (200, 204):
			ansithemeprint([ANSIThemeString("  Uncordoned", "success")])
			print(message)
		elif status == 42503:
			ansithemeprint([ANSIThemeString("", "default")])
			ansithemeprint([ANSIThemeString("Critical", "critical"),
					ANSIThemeString(": Cluster not available; aborting", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			ansithemeprint([ANSIThemeString("\nAPI call returned error:", "error")], stderr = True)
			ansithemeprint([ANSIThemeString(f"  {message}", "error")], stderr = True)
			sys.exit(errno.EINVAL)
	return 0

def taint_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Taint nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	include_control_planes = False
	overwrite = False
	header = True

	for opt, _optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		elif opt == "--overwrite":
			overwrite = True

	selection = args[0].split(",")
	taint = args[1]

	if "=" not in taint:
		ansithemeprint([ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
				ANSIThemeString(": invalid syntax; the correct syntax is either “", "default"),
				ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" taint ", "command"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString("|", "separator"),
				ANSIThemeString("ALL ", "argument"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString("=", "separator"),
				ANSIThemeString("EFFECT", "argument"),
				ANSIThemeString("“ or “", "default"),
				ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" taint ", "command"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString("|", "separator"),
				ANSIThemeString("ALL ", "argument"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString(":", "separator"),
				ANSIThemeString("VALUE", "argument"),
				ANSIThemeString("=", "separator"),
				ANSIThemeString("EFFECT", "argument"),
				ANSIThemeString("“; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	taint, taint_new_effect = taint.split("=")
	if ":" in taint:
		taint_key, taint_value = taint.split(":")
	else:
		taint_key = taint
		taint_value = None

	if taint_new_effect not in ("NoSchedule", "PreferNoSchedule", "NoExecute"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Invalid effect; valid effects are: ", "default"),
				ANSIThemeString("NoSchedule", "argument"),
				ANSIThemeString(", ", "default"),
				ANSIThemeString("PreferNoSchedule", "argument"),
				ANSIThemeString(", and ", "default"),
				ANSIThemeString("NoExecute", "argument"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# It is OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes:
		nodes += controlplanes

	if len(non_existing) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +
			       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
			       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header:
		ansithemeprint([ANSIThemeString("\n[Tainting nodes]", "phase")])

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for node in nodes:
		node_info = kh.get_ref_by_kind_name_namespace(("Node", ""), node, "")
		node_status, _status_group, _taints, full_taints = get_node_status(node_info)
		if node_status == "Unknown":
			ansithemeprint([ANSIThemeString("Critical", "critical"),
					ANSIThemeString(": Failed to get node information; do you have a running cluster? Aborting.", "default")], stderr = True)
			sys.exit(errno.ENXIO)

		ansithemeprint([ANSIThemeString(node, "hostname")])
		_message, status = kh.taint_node(node, full_taints, (taint_key, taint_value, None, taint_new_effect), overwrite = overwrite)
		if status == 304:
			ansithemeprint([ANSIThemeString("  Not modified", "none")])
		elif status == 42304:
			ansithemeprint([ANSIThemeString("  Warning", "warning"),
					ANSIThemeString(": Ignoring request; node already has taint(s) with matching effect; use “", "default"),
					ANSIThemeString("--overwrite", "option"),
					ANSIThemeString("“ to override", "default")])
		elif status == 200:
			ansithemeprint([ANSIThemeString("  Tainted", "success")])
		else:
			ansithemeprint([ANSIThemeString("  Failed to modify taint", "error"),
					ANSIThemeString(f"; HTTP error {status}; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
	return 0

def untaint_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Untaint nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	include_control_planes = False
	header = True

	for opt, _optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False

	selection = args[0].split(",")
	taint = args[1]

	if "=" in taint:
		taint, taint_old_effect = taint.split("=")
	else:
		taint_old_effect = None
	if ":" in taint:
		taint_key, taint_value = taint.split(":")
	else:
		taint_key = taint
		taint_value = None

	if taint_old_effect is not None and taint_old_effect not in ("NoSchedule", "PreferNoSchedule", "NoExecute"):
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Invalid effect; valid effects are: ", "default"),
				ANSIThemeString("NoSchedule", "argument"),
				ANSIThemeString(", ", "default"),
				ANSIThemeString("PreferNoSchedule", "argument"),
				ANSIThemeString(", and ", "default"),
				ANSIThemeString("NoExecute", "argument"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# It is OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes:
		nodes += controlplanes

	if len(non_existing) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +
			       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
			       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header:
		ansithemeprint([ANSIThemeString("\n[Untainting nodes]", "phase")])

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for node in nodes:
		node_info = kh.get_ref_by_kind_name_namespace(("Node", ""), node, "")
		node_status, _status_group, _taints, full_taints = get_node_status(node_info)
		if node_status == "Unknown":
			ansithemeprint([ANSIThemeString("Critical", "critical"),
					ANSIThemeString(": Failed to get node information; do you have a running cluster? Aborting.", "default")], stderr = True)
			sys.exit(errno.ENXIO)

		ansithemeprint([ANSIThemeString(node, "hostname")])
		_message, status = kh.taint_node(node, full_taints, (taint_key, taint_value, taint_old_effect, None))
		if status == 304:
			ansithemeprint([ANSIThemeString("  Not modified", "none")])
		elif status == 200:
			ansithemeprint([ANSIThemeString("  Untainted", "success")])
		else:
			ansithemeprint([ANSIThemeString("  Failed to modify taint", "error"),
					ANSIThemeString(f"; HTTP error {status}; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
	return 0

def prepare_hosts(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Install and configure pre-requisites for use as a node

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	ignore_existing = False
	no_password = False
	from_file = False
	confirm = True
	verbose = False

	for opt, optarg in options:
		if opt == "--ignore-existing":
			ignore_existing = True
		elif opt == "--no-password":
			no_password = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--forks":
			ansible_configuration["ansible_forks"] = optarg
		elif opt == "--from-file":
			from_file = True
		elif opt == "--verbose":
			verbose = True
		elif opt == "-Y":
			confirm = False

	if from_file:
		hostfile = args[0]
		hostfile_path = Path(hostfile)
		if not hostfile_path.exists():
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default"),
					ANSIThemeString(f"{hostfile}", "path"),
					ANSIThemeString(" does not exist; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		if not hostfile_path.is_file():
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default"),
					ANSIThemeString(f"{hostfile}", "path"),
					ANSIThemeString(" is not a file; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)

		hosts_raw = secure_read_string(FilePath(hostfile))
		hosts_raw_split = cast(List[str], hosts_raw.splitlines())

		if len(hosts_raw_split) == 1 and "," in hosts_raw_split[0]:
			selection = hosts_raw_split[0].split(",")
		else:
			selection = hosts_raw_split
	else:
		selection = args[0].split(",")
		if "ALL" in selection:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default"),
					ANSIThemeString("ALL", "hostname"),
					ANSIThemeString(" cannot be used with ", "default"),
					ANSIThemeString("prepare", "command"),
					ANSIThemeString("; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)

	# Validate FQDN/hostname list
	retval = validate_fqdn(selection[0], message_on_error = True)
	if retval != HostNameStatus.OK:
		sys.exit(errno.EINVAL)

	# Correlate the list of hosts with the nodes in the cluster
	nodes, non_existing, controlplanes = get_selection(selection, kind = ("Node", ""))

	if len(nodes) > 0 or len(controlplanes) > 0:
		if not ignore_existing:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(nodes + controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are already part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(errno.EEXIST)
		else:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(nodes + controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are already part of the cluster; ignoring them since “", "description"),
					ANSIThemeString("--ignore-existing", "option"),
					ANSIThemeString("“ was specified.", "default")])

	if len(non_existing) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No valid hosts specified; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# Check if the hosts are part of the inventory
	inventory = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")
	not_in_inventory = []
	for host in non_existing:
		if host not in inventory:
			not_in_inventory.append(host)

	if len(not_in_inventory) > 0:
		if confirm:
			input_retval = ansithemeinput([ANSIThemeString("\nWarning", "warning"),
						       ANSIThemeString(": ", "default")] +
						      ansithemestring_join_tuple_list(not_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
						      [ANSIThemeString(" are not defined in the inventory; do you want to add them now? (No will abort the installation) [y/", "default"),
						       ANSIThemeString("N", "emphasis"), ANSIThemeString("]: ", "default")])
			if input_retval.lower() not in ("y", "yes"):
				ansithemeprint([ANSIThemeString("\nAborting", "error"),
						ANSIThemeString(": Nodes not added to the inventory.", "default")], stderr = True)
				sys.exit(errno.EINTR)
		else:
			ansithemeprint([ANSIThemeString("\nNote", "note"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(not_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are not defined in the inventory; adding them now.", "default")])

	show_configuration(non_existing)

	prepare_playbooks = [
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_passwordless_ansible.yaml"))),
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("prepare_node.yaml")))
	]
	playbooks = populate_playbooks_from_paths(prepare_playbooks)
	ansible_print_action_summary(playbooks)

	ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = not_in_inventory, skip_all = False)

	if confirm:
		input_retval = ansithemeinput([ANSIThemeString("\nStart host preparation? [y/", "default"),
					       ANSIThemeString("N", "emphasis"),
					       ANSIThemeString("]: ", "default")])
		if input_retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting", "error"),
					ANSIThemeString(": User stopped host preparation.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	ansithemeprint([ANSIThemeString("\n[Preparing host(s)]", "phase")])

	scan_and_add_ssh_keys(non_existing)

	# We most likely will not be able to connect to the remote host without a password
	if not no_password:
		request_ansible_password()

	extra_values = {
		"ansible_become_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
		"ansible_ssh_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
	}

	run_retval = run_playbooks(playbooks = playbooks, hosts = non_existing, extra_values = extra_values, verbose = verbose)
	if run_retval:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansithemeprint([ANSIThemeString("\nHosts successfully prepared", "success")])
	return 0

cri_data: Dict = {
	"containerd": {
		"socket": "unix:///run/containerd/containerd.sock",
	},
	"cri-o": {
		"socket": "unix:///run/crio/crio.sock",
	},
	"docker-shim": {
		"socket": "unix:///run/dockershim.sock",
	}
}

def add_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Add nodes to the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	os_distro = identify_distro()
	k8s_distro = "kubeadm"

	ignore_existing = False
	ignore_non_existing = False
	from_file = False
	ca_cert_path = ""
	cri = None
	confirm = True
	verbose = False

	for opt, optarg in options:
		if opt == "--ignore-existing":
			ignore_existing = True
		elif opt == "--ignore-non-existing":
			ignore_non_existing = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--ca-cert-path":
			ca_cert_path = optarg
		elif opt == "--forks":
			ansible_configuration["ansible_forks"] = optarg
		elif opt == "--cri":
			if optarg in ("docker-shim", "containerd", "cri-o"):
				cri = optarg
			else:
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": Unknown CRI “", "default"),
						ANSIThemeString(optarg, "argument"),
						ANSIThemeString("“ specified; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
		elif opt == "--from-file":
			from_file = True
		elif opt == "--verbose":
			verbose = True
		elif opt == "-Y":
			confirm = False
		elif opt == "--kubernetes-distro":
			k8s_distro = optarg

	if os_distro == "suse" and k8s_distro != "rke2":
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Currently ", "default"),
				ANSIThemeString("RKE2", "argument"),
				ANSIThemeString(" is the only supported Kubernetes distro for SUSE; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOTSUP)

	if from_file:
		hostfile = args[0]
		if not os.path.exists(hostfile):
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default"),
					ANSIThemeString(f"{hostfile}", "path"),
					ANSIThemeString(" does not exist; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		elif not os.path.isfile(hostfile):
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default"),
					ANSIThemeString(f"{hostfile}", "path"),
					ANSIThemeString(" is not a file; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			hosts_raw = None
			with open(hostfile, "r", encoding = "utf-8", errors = "replace") as f:
				hosts_raw = f.readlines()

			if hosts_raw is None:
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": Failed to read hostnames from ", "default"),
						ANSIThemeString(f"{hostfile}", "path"),
						ANSIThemeString("; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

			# strip newlines
			hosts_raw = [s.strip() for s in hosts_raw]

			if len(hosts_raw) == 1 and "," in hosts_raw[0]:
				selection = hosts_raw[0].split(",")
			else:
				selection = hosts_raw
	else:
		selection = args[0].split(",")

	if "ALL" in selection:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default"),
				ANSIThemeString("ALL", "hostname"),
				ANSIThemeString(" cannot be used with ", "default"),
				ANSIThemeString("add-node", "command"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# Correlate the list of hosts with the nodes in the cluster
	nodes, non_existing, controlplanes = get_selection(selection, kind = ("Node", ""))

	if len(nodes) > 0 or len(controlplanes) > 0:
		if not ignore_existing:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(nodes + controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are already part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(errno.EEXIST)
		else:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(nodes + controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are already part of the cluster; ignoring them since “", "description"),
					ANSIThemeString("--ignore-existing", "option"),
					ANSIThemeString("“ was specified.", "default")])

	if len(non_existing) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No valid hosts specified; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# Check if the hosts are part of the inventory
	inventory = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")
	inventory_control_planes = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "controlplane")
	inventory_nodes = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "nodes")
	not_in_inventory = []
	node_in_inventory = []
	control_plane_in_inventory = []
	for host in non_existing:
		if host not in inventory:
			not_in_inventory.append(host)
		if host in inventory_control_planes:
			control_plane_in_inventory.append(host)
		if host in inventory_nodes:
			node_in_inventory.append(host)

	if len(not_in_inventory) > 0:
		if not ignore_non_existing:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(not_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are not defined in the inventory; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(not_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are not defined in the invetory; ignoring them since “", "description"),
					ANSIThemeString("--ignore-non-existing", "option"),
					ANSIThemeString("“ was specified.", "default")])

	if len(node_in_inventory) > 0:
		if not ignore_existing:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(node_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are already listed as nodes in the inventory; aborting.", "default")], stderr = True)
			sys.exit(errno.EEXIST)
		else:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(node_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are already listed as nodes in the inventory; ignoring them since “", "description"),
					ANSIThemeString("--ignore-existing", "option"),
					ANSIThemeString("“ was specified.", "default")])

	if len(control_plane_in_inventory) > 0:
		if not ignore_existing:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(control_plane_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are already listed as control planes in the inventory; aborting.", "default")], stderr = True)
			sys.exit(errno.EEXIST)
		else:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(control_plane_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are already listed as control planes in the inventory; ignoring them since “", "description"),
					ANSIThemeString("--ignore-existing", "option"),
					ANSIThemeString("“ was specified.", "default")])

	show_configuration(non_existing, cri = cri)

	if confirm:
		input_retval = ansithemeinput([ANSIThemeString("\nStart node setup? [y/", "default"),
					       ANSIThemeString("N", "emphasis"),
					       ANSIThemeString("]: ", "default")])
		if input_retval.lower() not in ("y", "yes"):
			ansithemeprint([ANSIThemeString("\nAborting", "error"),
					ANSIThemeString(": User stopped node setup.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	# Time to setup and add the hosts to the cluster
	ansithemeprint([ANSIThemeString("\n[Adding nodes]", "phase")])

	# Get variables that need to be available when setting up nodes
	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	join_token = None
	ca_cert_hash = None

	if k8s_distro == "kubeadm":
		join_token = kh.get_join_token()
		if len(join_token) == 0:
			if confirm:
				input_retval = ansithemeinput([ANSIThemeString("Warning", "warning"),
							       ANSIThemeString(": No join token found; create one now? (No will abort the installation) [y/", "default"),
							       ANSIThemeString("N", "emphasis"),
							       ANSIThemeString("]: ", "default")])
				if input_retval.lower() not in ("y", "yes"):
					ansithemeprint([ANSIThemeString("\nAborting", "error"),
							ANSIThemeString(": No join token available.", "default")], stderr = True)
					sys.exit(errno.ENOENT)
			else:
				ansithemeprint([ANSIThemeString("Note", "note"),
						ANSIThemeString(": No join token found; creating one now.", "default")])

			create_join_token_playbooks = [
				FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_create_join_token.yaml")))
			]
			playbooks = populate_playbooks_from_paths(create_join_token_playbooks)
			retval = run_playbooks(playbooks = playbooks, hosts = controlplanes, verbose = verbose)
			join_token = kh.get_join_token()
			if len(join_token) == 0:
				ansithemeprint([ANSIThemeString("Critical", "critical"),
						ANSIThemeString(": Failed to create join token; aborting", "default")], stderr = True)
				sys.exit(errno.EINVAL)

		ca_cert_hash = ""
		if len(ca_cert_path) == 0:
			ca_cert_hash = kh.get_ca_cert_hash()
		if len(ca_cert_hash) == 0:
			if len(ca_cert_path) == 0:
				ca_cert_path = "/etc/kubernetes/pki/ca.crt"
			input_retval = ansithemeinput([ANSIThemeString("Warning", "warning"),
						       ANSIThemeString(": Could not find ", "default"),
						       ANSIThemeString("ca.crt", "path"),
						       ANSIThemeString(" or a certificate-controller-token secret; try to use ", "default"),
						       ANSIThemeString(ca_cert_path, "path"),
						       ANSIThemeString("? No will abort the installation) [y/", "default"),
						       ANSIThemeString("N", "emphasis"),
						       ANSIThemeString("]: ", "default")])
			if input_retval.lower() not in ("y", "yes"):
				ansithemeprint([ANSIThemeString("\nAborting", "error"),
						ANSIThemeString(": No CA certificate available.", "default")], stderr = True)
				sys.exit(errno.ENOENT)
			else:
				ca_cert = ""
				ca_cert_hash = ""

				try:
					ca_cert = secure_read_string(FilePath(ca_cert_path))
					if len(ca_cert) > 0:
						try:
							x509obj = x509.load_pem_x509_certificate(ca_cert.encode("utf-8"))
						except TypeError as e:
							if "load_pem_x509_certificate() missing 1 required positional argument: 'backend'" in str(e):
								# This is to handle systems that doesn't have the latest version of cryptography
								# pylint: disable-next=import-outside-toplevel,no-name-in-module
								from cryptography.hazmat.primitives import default_backend
								x509obj = x509.load_pem_x509_certificate(ca_cert.encode("utf-8"), backend = default_backend)
							else:
								raise
						pubkeyder = x509obj.public_key().public_bytes(encoding = serialization.Encoding.DER, format = serialization.PublicFormat.SubjectPublicKeyInfo)
						ca_cert_hash = hashlib.sha256(pubkeyder).hexdigest()
				except FileNotFoundError:
					pass

				if len(ca_cert_hash) == 0:
					ansithemeprint([ANSIThemeString("\nAborting", "error"),
							ANSIThemeString(": No CA certificate available.", "default")], stderr = True)
					sys.exit(errno.EINTR)

	control_plane_ip, control_plane_port, control_plane_path = kh.get_control_plane_address()
	if control_plane_ip is None:
		ansithemeprint([ANSIThemeString("\nAborting", "error"),
				ANSIThemeString(": Could not get the IP-address for the control plane.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# If this is a kubeadm cluster we need the package version for kubeadm;
	# if it's an RKE2 cluster we try to deduce the channel from the control plane
	# Kubernetes version
	if k8s_distro == "kubeadm":
		_retval, ansible_results = ansible_run_playbook_on_selection(FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("get_versions.yaml"))), selection = [control_plane_ip])
		if len(ansible_results) == 0:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(f": Failed to get package versions from control plane at {control_plane_ip} (retval: {retval}); aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)

		tmp = []

		for result in deep_get(ansible_results, DictPath(control_plane_ip), []):
			if deep_get(result, DictPath("task"), "") == "Package versions":
				tmp = deep_get(result, DictPath("msg_lines"), [])
				break

		if len(tmp) == 0:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(f": Failed to get package versions from control plane at {control_plane_ip} (playbook returned no valid data); aborting.", "default")], stderr = True)
			sys.exit(errno.EBADMSG)

		kubeadm_version = ""
		# Safe
		kubeadm_version_regex = re.compile(r"^(.*?): (.*)")

		for line in tmp:
			match_tmp = kubeadm_version_regex.match(line)
			if match_tmp is None:
				continue
			if match_tmp[1] == "kubeadm":
				kubeadm_version = match_tmp[2]
				break

		if len(kubeadm_version) == 0:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": Failed to get ", "default"),
					ANSIThemeString("kubeadm", "programname"),
					ANSIThemeString(f" package version from control plane at {control_plane_ip}; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)

		# First remove the distro revision
		major_minor_patchrev, _pkgrev = kubeadm_version.split("-")
		# Now split the version tuple
		version_major, version_minor, _rest = major_minor_patchrev.split(".")
	elif k8s_distro == "rke2":
		vlist = get_control_planes()
		first_control_plane = vlist[0][0]
		node_data = kh.get_ref_by_kind_name_namespace(("Node", ""), first_control_plane, "")
		kubelet_version = deep_get(node_data, DictPath("status#nodeInfo#kubeletVersion"), "")
		match_tmp = re.match(r"^(v\d+)\.(\d+).*", kubelet_version)
		if match_tmp is None:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": Failed to get kubelet version from control plane; aborting.", "default")], stderr = True)
			sys.exit(errno.EBADMSG)
		rke2_version = f"{match_tmp[1]}.{match_tmp[2]}"
		version_major = match_tmp[1][1:]
		version_minor = match_tmp[2]

	if cri is None:
		if int(version_minor) < 24 and k8s_distro != "rke2":
			cri = "docker-shim"
		else:
			cri = "containerd"
	else:
		if cri == "docker-shim":
			if k8s_distro == "rke2":
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": CRI cannot be “", "default"),
						ANSIThemeString("docker-shim", "argument"),
						ANSIThemeString("“ for ", "default"),
						ANSIThemeString("RKE2", "argument"),
						ANSIThemeString("; aborting.", "default")], stderr = True)
				sys.exit(errno.ENOTSUP)
			elif int(version_minor) >= 24:
				ansithemeprint([ANSIThemeString("Error", "error"),
						ANSIThemeString(": CRI cannot be “", "default"),
						ANSIThemeString("docker-shim", "argument"),
						ANSIThemeString("“ for ", "default"),
						ANSIThemeString("Kubernetes ", "programname"),
						ANSIThemeString(">= ", "default"),
						ANSIThemeString("1.24", "version"),
						ANSIThemeString("; aborting.", "default")], stderr = True)
				sys.exit(errno.ENOTSUP)

	# Add the CRI to the setup playbooks for the control plane;
	# the list is short enough that doing prepend isn't a performance issue
	if cri == "docker-shim":
		add_playbooks = [FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("setup_docker.io.yaml")))]
	elif cri == "containerd":
		add_playbooks = [FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("setup_containerd.yaml")))]
	elif cri == "cri-o":
		add_playbooks = [FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("setup_cri-o.yaml")))]
	cri_socket = deep_get(cri_data[cri], DictPath("socket"))

	cluster_name = get_cluster_name()
	if cluster_name is None:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Could not get the cluster name", "default"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if k8s_distro == "kubeadm":
		add_playbooks += [
			# cmt does not use run_before/run_after/add_to_groups/remove_from_groups,
			# so we have to do all of that explicitly
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("add_kubernetes_repo.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_setup_node.yaml")))
		]

		if int(version_minor) < 23:
			join_configuration_api_version = "kubeadm.k8s.io/v1beta2"
		else:
			join_configuration_api_version = "kubeadm.k8s.io/v1beta3"

		extra_values = {
			"control_plane_ip": control_plane_ip,
			"control_plane_port": control_plane_port,
			"control_plane_path": control_plane_path,
			"join_token": join_token,
			"ca_cert_hash": ca_cert_hash,
			"configuration_path": "templates/config/nodeconfig.yaml.j2",
			"control_plane_k8s_version": kubeadm_version,
			"cri_socket": cri_socket,
			"kubernetes_major_minor_version": f"{version_major}.{version_minor}",
			"join_configuration_api_version": join_configuration_api_version,
		}
	elif k8s_distro == "rke2":
		add_playbooks += [
			# cmt does not use run_before/run_after/add_to_groups/remove_from_groups,
			# so we have to do all of that explicitly
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("rke2_setup_node.yaml")))
		]
		extra_values = {
			"control_plane_ip": control_plane_ip,
			"control_plane_port": control_plane_port,
			"requested_version": rke2_version,
			"cri_socket": cri_socket,
			"cluster_name": cluster_name,
			"kubernetes_major_minor_version": f"{version_major}.{version_minor}",
		}
	playbooks = populate_playbooks_from_paths(add_playbooks)

	retval = run_playbooks(playbooks = playbooks, hosts = non_existing, extra_values = extra_values, verbose = verbose)
	if retval:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = non_existing, group = "nodes", skip_all = True)
	ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = non_existing, group = cluster_name, skip_all = True)
	ansithemeprint([ANSIThemeString("\nNodes successfully added", "success")])
	return 0

def remove_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Remove nodes from the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	os_distro = identify_distro()
	k8s_distro = "kubeadm"

	force = False
	purge = False
	verbose = False

	for opt, optarg in options:
		if opt == "--force":
			force = True
		elif opt == "--purge":
			purge = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--forks":
			ansible_configuration["ansible_forks"] = optarg
		elif opt == "--kubernetes-distro":
			k8s_distro = optarg
		elif opt == "--verbose":
			verbose = True

	if os_distro == "suse" and k8s_distro != "rke2":
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Currently ", "default"),
				ANSIThemeString("RKE2", "argument"),
				ANSIThemeString(" is the only supported Kubernetes distro for SUSE; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOTSUP)

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0 and args[0] != "ALL":
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +
			       ansithemestring_join_tuple_list(controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
			       [ANSIThemeString(" are control plane(s) and should be removed using ", "default"),
				ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(non_existing) > 0:
		if not force:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are not part of the cluster; attempting to purge them anyway since “", "description"),
					ANSIThemeString("--force", "option"),
					ANSIThemeString("“ was specified.", "default")])
			nodes += non_existing

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	ansithemeprint([ANSIThemeString("\n[Removing nodes]", "phase")])
	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Deleting nodes from the cluster", "action")])
	delete_playbooks = [
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("delete_node.yaml"))),
	]
	playbooks = populate_playbooks_from_paths(delete_playbooks)

	extra_values: Dict = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values, verbose = verbose)
	if retval:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	elif force:
		ansithemeprint([ANSIThemeString("NOT OK", "warning"),
				ANSIThemeString("; ignoring since “", "description"),
				ANSIThemeString("--force", "option"),
				ANSIThemeString("“ was specified.", "default")], stderr = True)
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Tearing down Kubernetes on the nodes", "action")])

	if k8s_distro == "kubeadm":
		teardown_playbooks = [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_teardown_node.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("teardown_cni.yaml"))),
		]
	elif k8s_distro == "rke2":
		teardown_playbooks = [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("rke2_teardown_node.yaml"))),
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("teardown_cni.yaml"))),
		]

	playbooks = populate_playbooks_from_paths(teardown_playbooks)

	extra_values = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values, verbose = verbose)
	if retval:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansithemeprint([ANSIThemeString("\nNodes successfully removed from cluster", "success")])

	if purge:
		purge_hosts(options = [("--ignore-non-existing", None)], args = [",".join(nodes)])

	cluster_name = get_cluster_name()

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Removing nodes from the inventory", "action")])
	ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = nodes, group = "nodes")
	ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = nodes, group = cluster_name)
	ansithemeprint([ANSIThemeString("\nNodes successfully removed", "success")])
	return 0

def purge_hosts(options: Sequence[Tuple[str, Optional[str]]], args: List[str]) -> int:
	"""
	Purge nodes from the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	os_distro = identify_distro()
	k8s_distro = "kubeadm"

	ignore_non_existing = False
	verbose = False

	selection = args[0].split(",")

	if "ALL" in selection:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default"),
				ANSIThemeString("ALL", "hostname"),
				ANSIThemeString(" cannot be used with ", "default"),
				ANSIThemeString("purge", "command"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for opt, optarg in options:
		if opt == "--ignore-non-existing":
			ignore_non_existing = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--forks":
			ansible_configuration["ansible_forks"] = optarg
		elif opt == "--verbose":
			verbose = True
		elif opt == "--kubernetes-distro":
			k8s_distro = cast(str, optarg)

	if os_distro == "suse" and k8s_distro != "rke2":
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Currently ", "default"),
				ANSIThemeString("RKE2", "argument"),
				ANSIThemeString(" is the only supported Kubernetes distro for SUSE; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOTSUP)

	nodes, _non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +
			       ansithemestring_join_tuple_list(controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
			       [ANSIThemeString(" are control plane(s) and should be removed using ", "default"),
				ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(nodes) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +
			       ansithemestring_join_tuple_list(nodes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
			       [ANSIThemeString(" are still node(s) in the cluster; please run ", "default"),
				ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
				ANSIThemeString(" remove-node", "command"),
				ANSIThemeString(" first to remove them from the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.EBUSY)

	hosts = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")

	not_in_inventory = []
	for host in selection:
		if host not in hosts:
			not_in_inventory.append(host)
			selection.remove(host)

	if len(not_in_inventory) > 0:
		if not ignore_non_existing:
			ansithemeprint([ANSIThemeString("Error", "error"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(not_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are not in the inventory; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			ansithemeprint([ANSIThemeString("Warning", "warning"),
					ANSIThemeString(": ", "default")] +
				       ansithemestring_join_tuple_list(not_in_inventory, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
				       [ANSIThemeString(" are not in the inventory; ignoring them since “", "description"),
					ANSIThemeString("--ignore-non-existing", "option"),
					ANSIThemeString("“ was specified.", "default")])

	if len(selection) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": None of the specified hosts are part of the inventory; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Purging Kubernetes from the hosts", "action")])

	if k8s_distro == "kubeadm":
		purge_playbooks = [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_purge.yaml"))),
		]
	elif k8s_distro == "rke2":
		purge_playbooks = [
			FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("rke2_purge.yaml"))),
		]
	playbooks = populate_playbooks_from_paths(purge_playbooks)

	hosts = selection

	extra_values = {
		"packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
			"kubernetes-cni",
		],
		"held_packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
		]
	}
	retval = run_playbooks(playbooks = playbooks, hosts = hosts, extra_values = extra_values, verbose = verbose)
	if retval:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansithemeprint([ANSIThemeString("\nHosts successfully purged", "success")])
	return 0

def upgrade_nodes(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Upgrade nodes in the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	verbose = False

	for opt, optarg in options:
		if opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--forks":
			ansible_configuration["ansible_forks"] = optarg
		elif opt == "--verbose":
			verbose = True

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0 and args[0] != "ALL":
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +
			       ansithemestring_join_tuple_list(controlplanes, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
			       [ANSIThemeString(" are control plane(s) and should be upgraded using ", "default"),
				ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(non_existing) > 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": ", "default")] +
			       ansithemestring_join_tuple_list(non_existing, formatting = "hostname", separator = ANSIThemeString(",", "separator")) +
			       [ANSIThemeString(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	ansithemeprint([ANSIThemeString("\n[Upgrading nodes]", "phase")])
	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Drain nodes", "action")])
	drain_options = [
		("--delete-emptydir-data", None),
		("--disable-eviction", None),
		("--ignore-daemonsets", None),
		("--no-header", None),
	]
	drain_nodes(options = drain_options, args = [",".join(nodes)])

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Run upgrade playbooks on nodes", "action")])
	upgrade_playbooks = [
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("add_kubernetes_repo.yaml"))),
		FilePath(str(PurePath(ANSIBLE_PLAYBOOK_DIR).joinpath("kubeadm_upgrade_node.yaml"))),
	]
	playbooks = populate_playbooks_from_paths(upgrade_playbooks)

	extra_values: Dict = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values, verbose = verbose)
	if retval:
		ansithemeprint([ANSIThemeString("OK", "ok")])
	else:
		ansithemeprint([ANSIThemeString("NOT OK", "notok"),
				ANSIThemeString("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansithemeprint([ANSIThemeString("\n• ", "separator"),
			ANSIThemeString("Uncordon nodes", "action")])
	uncordon_nodes(options = [], args = [",".join(nodes)])

	ansithemeprint([ANSIThemeString("\nNode upgrade successful", "success")])
	return 0

# pylint: disable-next=unused-argument
def get_contexts(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Get the list of available contexts

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	contexts = list_contexts()

	if contexts is None:
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Could not find any contexts", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	contexts = natsorted(contexts, key = itemgetter(3))

	index_header = "Index:"
	current_header = "Current:"
	name_header = "Name:"
	cluster_header = "Cluster:"
	authinfo_header = "Authinfo:"
	namespace_header = "Namespace:"
	server_header = "Server:"

	index_len = len(index_header)
	current_len = len(current_header)
	name_len =  len(name_header)
	cluster_len = len(cluster_header)
	authinfo_len = len(authinfo_header)
	namespace_len = len(namespace_header)
	server_len = len(server_header)

	for _current, name, cluster, authinfo, namespace, server in contexts:
		name_len = max(name_len, len(name))
		cluster_len = max(cluster_len, len(cluster))
		authinfo_len = max(authinfo_len, len(authinfo))
		namespace_len = max(namespace_len, len(namespace))
		server_len = max(server_len, len(server))

	ansithemeprint([ANSIThemeString(index_header, "header"),
			ANSIThemeString("".ljust(2), "default"),
			ANSIThemeString(current_header, "header"),
			ANSIThemeString("".ljust(2), "default"),
			ANSIThemeString(name_header, "header"),
			ANSIThemeString("".ljust(name_len - len(name_header) + 2), "default"),
			ANSIThemeString(cluster_header, "header"),
			ANSIThemeString("".ljust(cluster_len - len(cluster_header) + 2), "default"),
			ANSIThemeString(authinfo_header, "header"),
			ANSIThemeString("".ljust(authinfo_len - len(authinfo_header) + 2), "default"),
			ANSIThemeString(namespace_header, "header"),
			ANSIThemeString("".ljust(namespace_len - len(namespace_header) + 2), "default"),
			ANSIThemeString(server_header, "header")])

	i = 0

	for current, name, cluster, authinfo, namespace, server in contexts:
		if current:
			current_str = "✓"
		else:
			current_str = " "

		ansithemeprint([ANSIThemeString(f"{i}".rjust(index_len), "numerical"),
				ANSIThemeString("".ljust(2), "default"),
				ANSIThemeString(current_str.ljust(current_len + 2), "tag"),
				ANSIThemeString(name.ljust(name_len + 2), "default"),
				ANSIThemeString(cluster.ljust(cluster_len + 2), "default"),
				ANSIThemeString(authinfo.ljust(authinfo_len + 2), "default"),
				ANSIThemeString(namespace.ljust(namespace_len + 2), "namespace"),
				ANSIThemeString(server, "default")])

		i += 1

	return 0

# pylint: disable-next=unused-argument
def use_context(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	Get the list of available contexts

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	contexts = list_contexts()

	if contexts is None:
		ansithemeprint([ANSIThemeString("Critical", "critical"),
				ANSIThemeString(": Could not find any contexts", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	contexts = natsorted(contexts, key = itemgetter(3))

	context_index = None
	context_name = None

	try:
		context_index = int(args[0])
	except ValueError:
		context_name = args[0]

	i = 0

	current_context = None

	for current, name, _cluster, _authinfo, _namespace, _server in contexts:
		if context_index is not None and context_index == i:
			context_name = name
		i += 1
		if current is True:
			current_context = name

	if current_context is not None and current_context == context_name:
		ansithemeprint([ANSIThemeString("Context not modified", "default")])
		return 0

	result = set_context(name = context_name)

	if not result:
		ansithemeprint([ANSIThemeString("Error", "error"),
				ANSIThemeString(": Could not find a matching context", "default")], stderr = True)
		sys.exit(errno.ENOENT)
	else:
		ansithemeprint([ANSIThemeString("Context successfully changed to ", "default"),
				ANSIThemeString(f"{context_name}", "argument")])

	return 0

# pylint: disable-next=unused-argument
def list_api_resources(options: List[Tuple[str, str]], args: List[str]) -> int:
	"""
	List available API-resources

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
		Returns:
			0 on success, exits with errno on failure
	"""

	namespaced_only = None
	local_only = None
	verb_selector = []
	wide = False
	sortkey1 = 0
	sortkey2 = 2
	header = True
	api_version_selector = None
	has_data = False
	known_filter: Dict[str, Any] = {
		"known": None,
		"list": None,
		"info": None,
	}

	color = "auto"

	# Valid formats:
	# table = Normal output format (default)
	# csv = Comma-separated values
	# ssv = Space-separated values
	# tsv = Tab-separated values
	# entry = Used when adding API support to CMT
	output_format = "table"

	for opt, optarg in options:
		if opt == "--api-group":
			api_version_selector = optarg
		elif opt == "--color":
			color = optarg
		elif opt == "--format":
			output_format = optarg
		elif opt == "--known":
			optarg_list = optarg.split(",")
			for optarg in optarg_list:
				if optarg == "known":
					known_filter["known"] = True
				elif optarg in ("!known", "not-known", "unknown"):
					known_filter["known"] = False
				elif optarg == "list":
					known_filter["list"] = True
				elif optarg in ("!list", "not-list"):
					known_filter["list"] = False
				elif optarg == "info":
					known_filter["info"] = True
				elif optarg in ("!info", "not-info"):
					known_filter["info"] = False
		elif opt == "--has-data":
			has_data = True
		elif opt == "--local":
			_result, local_only = commandparser.validator_bool(optarg)
		elif opt == "--namespaced":
			_isbool, namespaced_only = commandparser.validator_bool(optarg)
		elif opt == "--no-header":
			header = False
		elif opt == "--sort-by":
			if optarg == "name":
				sortkey1 = 2
				sortkey2 = 0
			elif optarg in ("apiversion", "api_version"):
				sortkey1 = 4
				sortkey2 = 2
			elif optarg == "namespaced":
				sortkey1 = 3
				sortkey2 = 3
			elif optarg == "kind":
				sortkey1 = 2
				sortkey2 = 4
		elif opt == "--verbs":
			verb_selector = optarg.split(",")
		elif opt == "--wide":
			wide = True

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	result, api_resources = kh.get_api_resources()
	kubernetes_resources = None
	if wide or \
	   known_filter["known"] is not None or \
	   known_filter["list"] is not None or \
	   known_filter["info"] is not None:
		kubernetes_resources, _result2, _modified = kh.get_available_kinds()

	name_header = ""
	shortnames_header = ""
	api_version_header = ""
	namespaced_header = ""
	kind_header = ""
	verbs_header = ""

	if header:
		name_header = "Name:"
		shortnames_header = "Shortnames:"
		api_version_header = "API-Version:"
		namespaced_header = "Namespaced:"
		kind_header = "Kind:"
		verbs_header = "Verbs:"
		cmt_support_header = "CMT-support:"
		local_view_header = "Local view:"

	name_len = len(name_header)
	shortnames_len = len(shortnames_header)
	api_version_len = len(api_version_header)
	namespaced_len = len(namespaced_header)
	kind_len = len(kind_header)
	verbs_len = len(verbs_header)
	cmt_support_len = len(cmt_support_header)
	local_view_len = len(local_view_header)

	viewdir = os.path.join(VIEW_DIR)
	if not os.path.isdir(viewdir):
		sys.exit(f"{viewdir} does not exist; please re-run {about.INSTALL_PROGRAM_NAME}")

	# Get a full list of views from all view directories
	# Start by adding files from the views directory
	view_dirs = []
	if local_only is None or local_only is not None and local_only:
		view_dirs += deep_get(cmtlib.cmtconfig, DictPath("General#local_views"), [])
	if local_only is None or local_only is not None and not local_only:
		view_dirs.append(viewdir)

	filtered_api_resources = []

	sorted_list = sorted(api_resources, key = itemgetter(sortkey1))
	sorted_list = sorted(sorted_list, key = itemgetter(sortkey2))

	for name, shortnames, api_version, namespaced, kind, verbs in sorted_list:
		if kubernetes_resources is not None:
			try:
				api_group = ""
				if "/" in api_version:
					api_group = api_version.split("/")[0]
				kind_tuple = kh.guess_kind((name, api_group))

				# OK, this is a kind known by CMT that is available in the cluster;
				# now check whether there's a view file and where it has list/info views
				if kind_tuple == ("Event", ""):
					filename = "Event.events.k8s.io.yaml"
				elif len(kind_tuple[1]) == 0:
					filename = f"{kind}.yaml"
				else:
					filename = f"{kind}.{api_group}.yaml"
				for view_dir in view_dirs:
					view_file = FilePath(os.path.join(view_dir, filename))
					try:
						d = secure_read_yaml(view_file, directory_is_symlink = True)
						has_list_view = "listview" in d
						has_info_view = "infoview" in d
						is_local = view_dir != viewdir
						kh_update_api_status(kind_tuple, listview = has_list_view, infoview = has_info_view, local = is_local)
						# This won't do any updates except get the updated list & info view flags
						kubernetes_resources, _result2, _modified = kh.get_available_kinds()
					except FilePathAuditError as e:
						if "SecurityStatus.DOES_NOT_EXIST" in str(e):
							continue
					except yaml.parser.ParserError:
						sys.exit(f"View-file {view_file} is invalid; aborting.")
			except NameError:
				kind_tuple = None

		if namespaced_only is not None and namespaced != namespaced_only:
			continue

		if "/" in name:
			continue

		if set(verb_selector) & set(verbs) != set(verb_selector):
			continue

		cmt_support = []
		local_view = ""

		if kubernetes_resources is not None:
			list_support = False
			info_support = False
			if kind_tuple in kubernetes_resources:
				if "list" in kubernetes_resources[kind_tuple] and deep_get(kubernetes_resources[kind_tuple], DictPath("list")):
					list_support = True
					cmt_support.append("List")
				if "info" in kubernetes_resources[kind_tuple] and deep_get(kubernetes_resources[kind_tuple], DictPath("info")):
					info_support = True
					cmt_support.append("Info")
				if "local" in kubernetes_resources[kind_tuple]:
					if deep_get(kubernetes_resources[kind_tuple], DictPath("local")):
						local_view = "True"
					else:
						local_view = "False"

				if has_data:
					vlist, _status = kh.get_list_by_kind_namespace(kind = (kind, api_group), namespace = "")
					if vlist is None or len(vlist) == 0:
						continue

			if known_filter["known"] is not None:
				if "list" not in verbs:
					continue

				if not known_filter["known"] and kind_tuple in kubernetes_resources:
					continue

				if known_filter["known"]:
					if kind_tuple not in kubernetes_resources:
						continue

					if known_filter["list"] is not None:
						if known_filter["list"] and \
								("list" not in kubernetes_resources[kind_tuple] or not list_support):
							continue

						if not known_filter["list"] and \
								"list" in kubernetes_resources[kind_tuple] and list_support:
							continue

					if known_filter["info"] is not None:
						if known_filter["info"] and \
								("info" not in kubernetes_resources[kind_tuple] or not info_support):
							continue

						if not known_filter["info"] and \
								"info" in kubernetes_resources[kind_tuple] and info_support:
							continue

		if api_version_selector is not None:
			if len(api_version_selector) == 0:
				if "/" in api_version:
					continue
			else:
				if "/" in api_version_selector and api_version_selector != api_version:
					continue
				if api_version_selector != api_version.split("/")[0]:
					continue

		filtered_api_resources.append((name, shortnames, api_version, namespaced, kind, verbs))

		if output_format != "table":
			continue

		name_len = max(name_len, len(name))
		shortnames_len_tmp = 0
		shortnames_formatted = ansithemestring_join_tuple_list(shortnames, formatting = "default", separator = ANSIThemeString(",", "separator"))
		for item in shortnames_formatted:
			shortnames_len_tmp += len(item)
		shortnames_len = max(shortnames_len, shortnames_len_tmp)
		api_version_len = max(api_version_len, len(api_version))
		namespaced_len = max(namespaced_len, len(f"{namespaced}"))
		kind_len = max(kind_len, len(kind))
		verbs_len_tmp = 0
		verbs_formatted = ansithemestring_join_tuple_list(verbs, formatting = "default", separator = ANSIThemeString(",", "separator"))
		for item in verbs_formatted:
			verbs_len_tmp += len(item)
		verbs_len = max(verbs_len, verbs_len_tmp)
		cmt_support_len_tmp = 0
		cmt_support_formatted = ansithemestring_join_tuple_list(cmt_support, formatting = "default", separator = ANSIThemeString(",", "separator"))
		for item in cmt_support_formatted:
			cmt_support_len_tmp += len(item)
		cmt_support_len = max(cmt_support_len, cmt_support_len_tmp)
		local_view_len = max(local_view_len, len(local_view))

	if len(filtered_api_resources) == 0:
		ansithemeprint([ANSIThemeString("Note", "note"),
				ANSIThemeString(": No matching APIs found.", "default")])
		return 0

	if output_format != "table":
		separator = ""
		if output_format == "csv":
			separator = ","
		elif output_format == "ssv":
			separator = " "
		elif output_format == "tsv":
			separator = "\t"

		output = ""

		current_api_group = ""
		for name, shortnames, api_version, namespaced, kind, verbs in filtered_api_resources:
			api_group = ""
			api_path = f"api/{api_version}/"
			kind_string = kind
			if "/" in api_version:
				api_group = api_version.split("/")[0]
				api_path = f"apis/{api_version}/"
				kind_string += f".{api_group}"

			if output_format == "entry":
				entry = ""
				if current_api_group != api_group:
					entry += f"\t# {api_group}\n"
				entry += f"\t(\"{kind}\", \"{api_group}\"): "
				entry += "{\n"
				entry += f"\t\t\"api_paths\": [\"{api_path}\"],\n"
				entry += f"\t\t\"api\": \"{name}\",\n"
				if not namespaced:
					entry += "\t\t\"namespaced\": False,\n"
				entry += "\t},"
				print(entry)
			else:
				if len(output) > 0:
					output += f"{separator}"
				output += f"{kind_string}"
			current_api_group = api_group

		if len(output) > 0:
			print(output)
		return 0

	if header:
		tmp_header = [ANSIThemeString(name_header, "header"),
			      ANSIThemeString("".ljust(name_len - len(name_header) + 2), "default"),
			      ANSIThemeString(shortnames_header, "header"),
			      ANSIThemeString("".ljust(shortnames_len - len(shortnames_header) + 2), "default"),
			      ANSIThemeString(api_version_header, "header"),
			      ANSIThemeString("".ljust(api_version_len - len(api_version_header) + 2), "default"),
			      ANSIThemeString(namespaced_header, "header"),
			      ANSIThemeString("".ljust(namespaced_len - len(namespaced_header) + 2), "default"),
			      ANSIThemeString(kind_header, "header"),
			      ANSIThemeString("".ljust(kind_len - len(kind_header) + 2), "default")]

		if wide:
			tmp_header += [ANSIThemeString(verbs_header, "header"),
				       ANSIThemeString("".ljust(verbs_len - len(verbs_header) + 2), "default"),
				       ANSIThemeString(cmt_support_header, "header"),
				       ANSIThemeString("".ljust(cmt_support_len - len(cmt_support_header) + 2), "default"),
				       ANSIThemeString(local_view_header, "header"),
				       ANSIThemeString("".ljust(local_view_len - len(local_view_header) + 2), "default")]
		if color == "never" or color == "auto" and not sys.stdout.isatty():
			tmp_header = [item.upper() for item in tmp_header]
		ansithemeprint(tmp_header, color = color)

	for name, shortnames, api_version, namespaced, kind, verbs in filtered_api_resources:
		if kubernetes_resources is not None:
			try:
				api_group = ""
				if "/" in api_version:
					api_group = api_version.split("/")[0]
				kind_tuple = kh.guess_kind((name, api_group))
			except NameError:
				kind_tuple = None

		if namespaced_only is not None and namespaced != namespaced_only:
			continue

		if "/" in name:
			continue

		if set(verb_selector) & set(verbs) != set(verb_selector):
			continue

		cmt_support = []
		local_view = ""

		if kubernetes_resources is not None:
			list_support = False
			info_support = False

			if kind_tuple in kubernetes_resources:
				if "list" in kubernetes_resources[kind_tuple] and deep_get(kubernetes_resources[kind_tuple], DictPath("list")):
					list_support = True
					cmt_support.append("List")
				if "info" in kubernetes_resources[kind_tuple] and deep_get(kubernetes_resources[kind_tuple], DictPath("info")):
					info_support = True
					cmt_support.append("Info")
				if "local" in kubernetes_resources[kind_tuple]:
					if deep_get(kubernetes_resources[kind_tuple], DictPath("local")):
						local_view = "True"
					else:
						local_view = "False"

			if known_filter["known"] is not None:
				if "list" not in verbs:
					continue

				if not known_filter["known"] and kind_tuple in kubernetes_resources:
					continue

				if known_filter["known"]:
					if kind_tuple not in kubernetes_resources:
						continue

					if known_filter["list"] is not None:
						if known_filter["list"] and \
								("list" not in kubernetes_resources[kind_tuple] or not list_support):
							continue

						if not known_filter["list"] and \
								"list" in kubernetes_resources[kind_tuple] and list_support:
							continue

					if known_filter["info"] is not None:
						if known_filter["info"] and \
								("info" not in kubernetes_resources[kind_tuple] or not info_support):
							continue

						if not known_filter["info"] and \
								"info" in kubernetes_resources[kind_tuple] and info_support:
							continue

		if api_version_selector is not None:
			if len(api_version_selector) == 0:
				if "/" in api_version:
					continue
			else:
				if "/" in api_version_selector and api_version_selector != api_version:
					continue
				if api_version_selector != api_version.split("/")[0]:
					continue

		shortnames_len_tmp = 0
		shortnames_formatted = ansithemestring_join_tuple_list(shortnames, formatting = "default", separator = ANSIThemeString(",", "separator"))
		for item in shortnames_formatted:
			shortnames_len_tmp += len(item)
		if len(shortnames_formatted) == 0:
			shortnames_formatted = [ANSIThemeString("", "default")]

		verbs_len_tmp = 0
		verbs_formatted = ansithemestring_join_tuple_list(verbs, formatting = "default", separator = ANSIThemeString(",", "separator"))
		for item in verbs_formatted:
			verbs_len_tmp += len(item)
		if len(verbs_formatted) == 0:
			verbs_formatted = [ANSIThemeString("", "default")]

		cmt_support_len_tmp = 0
		cmt_support_formatted = ansithemestring_join_tuple_list(cmt_support, formatting = "default", separator = ANSIThemeString(",", "separator"))
		for item in cmt_support_formatted:
			cmt_support_len_tmp += len(item)
		if len(cmt_support_formatted) == 0:
			cmt_support_formatted = [ANSIThemeString("", "default")]

		tmp_str = [ANSIThemeString(f"{name}".ljust(name_len + 2), "default")] + \
			  shortnames_formatted + \
			  [ANSIThemeString("".ljust(shortnames_len - shortnames_len_tmp + 2), "default"),
			   ANSIThemeString(f"{api_version}".ljust(api_version_len + 2), "version"),
			   ANSIThemeString(f"{namespaced}".ljust(namespaced_len + 2), "default"),
			   ANSIThemeString(f"{kind}".ljust(kind_len + 2), "default")]

		if wide:
			tmp_str += verbs_formatted + \
				   [ANSIThemeString("".ljust(verbs_len - verbs_len_tmp + 2), "default")] + \
				   cmt_support_formatted + \
				   [ANSIThemeString("".ljust(cmt_support_len - cmt_support_len_tmp + 2), "default"),
				    ANSIThemeString(f"{local_view}".ljust(local_view_len + 2), "default")]

		ansithemeprint(tmp_str, color = color)

	return result

# pylint: disable-next=pointless-string-statement
"""
def get_resource(options: List[Tuple[str, str]], args: List[str]) -> None:
	namespaces = ["default"]

	for opt, optarg in options:
		# This is a tuple option, so the easiest way is to check this way
		if "--all-namespaces" in opt:
			namespaces = None
		elif "--namespace" in opt:
			namespaces = optarg.split(",")

	# We might have to get the resources across multiple namespaces, so we need to do multiple requests
	return
"""

CMT_COMMANDLINE = {
	"Cordon Node": {
		"command": ["cordon"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL", "argument")],
		"description": [ANSIThemeString("Cordon ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"options": {
			"--include-control-planes": {
				"description": [ANSIThemeString("Include control planes when ALL is used", "description")],
			},
		},
		"required_args": [
			{
				"name": "node",
				"string": [ANSIThemeString("NODE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("ALL", "argument")],
				"validation": {
					"validator": "hostname",
					"list_separator": ",",
				},
			},
		],
		"callback": cordon_nodes,
	},
	"Drain Node": {
		"command": ["drain"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL", "argument")],
		"description": [ANSIThemeString("Drain ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"options": {
			"--delete-emptydir-data": {
				"description": [ANSIThemeString("Delete emptydir data", "description")],
				"extended_description": [
					[ANSIThemeString("Drain nodes even if this would cause ", "description"),
					 ANSIThemeString("emptyDir", "emphasis")],
				        [ANSIThemeString("data to be deleted", "description")],
				],
			},
			"--delete-local-data": {
				"description": [ANSIThemeString("This is an alias for “", "description"),
						ANSIThemeString("--delete-emptydir-data", "option"),
						ANSIThemeString("“", "description")],
			},
			"--disable-eviction": {
				"description": [ANSIThemeString("Delete pods instead of using evict", "description")],
				"extended_description": [
					[ANSIThemeString("This bypasses ", "description"),
					 ANSIThemeString("PodDisruptionBudget", "emphasis")],
				],
			},
			"--ignore-daemonsets": {
				"description": [ANSIThemeString("Ignore pods managed by daemonsets", "description")],
				"extended_description": [
					[ANSIThemeString("By default ", "description"),
					 ANSIThemeString("drain ", "command"),
					 ANSIThemeString("will abort if there are", "description")],
					[ANSIThemeString("such pods running on the node", "description")],
				],
			},
			"--include-control-planes": {
				"description": [ANSIThemeString("Include control planes when ALL is used", "description")],
			},
		},
		"required_args": [
			{
				"name": "node",
				"string": [ANSIThemeString("NODE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("ALL", "argument")],
				"validation": {
					"validator": "hostname",
					"list_separator": ",",
				},
			},
		],
		"callback": drain_nodes,
	},
	"Drain Node (Force)": {
		"command": ["force-drain"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL", "argument")],
		"description": [ANSIThemeString("Force-drain ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"extended_description": [
			[ANSIThemeString("When a node is force-drained, pods belonging to", "description")],
			[ANSIThemeString("daemonsets are ignored, and ", "description"),
			 ANSIThemeString("emptyDir", "emphasis"),
			 ANSIThemeString(" data", "description")],
			[ANSIThemeString("is deleted", "description")],
		],
		"options": {
			"--disable-eviction": {
				"description": [ANSIThemeString("Delete pods instead of using evict", "description")],
				"extended_description": [
					[ANSIThemeString("This bypasses ", "description"),
					 ANSIThemeString("PodDisruptionBudget", "emphasis")],
				],
			},
			"--include-control-planes": {
				"description": [ANSIThemeString("Include control planes when ALL is used", "description")],
			},
		},
		"implicit_options": [
			("--delete-emptydir-data", None),
			("--ignore-daemonsets", None),
		],
		"required_args": [
			{
				"name": "node",
				"string": [ANSIThemeString("NODE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("ALL", "argument")],
				"validation": {
					"validator": "hostname",
					"list_separator": ",",
				},
			},
		],
		"callback": drain_nodes,
	},
	"Uncordon Node": {
		"command": ["uncordon"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL", "argument")],
		"description": [ANSIThemeString("Uncordon ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"options": {
			"--include-control-planes": {
				"description": [ANSIThemeString("Include control planes when ALL is used", "description")],
			},
		},
		"required_args": [
			{
				"name": "node",
				"string": [ANSIThemeString("NODE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("ALL", "argument")],
				"validation": {
					"validator": "hostname",
					"list_separator": ",",
				},
			},
		],
		"callback": uncordon_nodes,
	},
	"Taint Node": {
		"command": ["taint"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL ", "argument"),
			   ANSIThemeString("KEY", "argument"),
			   ANSIThemeString("[:", "separator"),
			   ANSIThemeString("VALUE", "argument"),
			   ANSIThemeString("]=", "separator"),
			   ANSIThemeString("EFFECT", "argument")],
		"description": [ANSIThemeString("Add taint ", "description"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString("[:", "separator"),
				ANSIThemeString("VALUE", "argument"),
				ANSIThemeString("]", "separator"),
				ANSIThemeString(" with ", "description"),
				ANSIThemeString("EFFECT", "argument"),
				ANSIThemeString(" to ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"extended_description": [
			[ANSIThemeString("Valid values for ", "description"),
			 ANSIThemeString("EFFECT", "argument"),
			 ANSIThemeString(" are:", "description")],
			[ANSIThemeString("NoSchedule", "argument"),
			 ANSIThemeString(", ", "separator"),
			 ANSIThemeString("PreferNoSchedule", "argument"),
			 ANSIThemeString(",", "separator"),
			 ANSIThemeString(" and ", "description"),
			 ANSIThemeString("NoExecute", "argument")],
		],
		"options": {
			"--include-control-planes": {
				"description": [ANSIThemeString("Include control planes when ALL is used", "description")],
			},
			"--overwrite": {
				"description": [ANSIThemeString("Allow taints to be overwritten", "description")],
				"extended_description": [
					[ANSIThemeString("(by default conflicting taints are ignored)", "description")],
				],
			}
		},
		"required_args": [
			{
				"name": "node",
				"string": [ANSIThemeString("NODE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("ALL", "argument")],
				"validation": {
					"validator": "hostname",
					"list_separator": ",",
				},
			}, {
				"name": "taint",
				"string": [ANSIThemeString("KEY", "argument"),
					   ANSIThemeString("[:", "separator"),
					   ANSIThemeString("VALUE", "argument"),
					   ANSIThemeString("]=", "separator"),
					   ANSIThemeString("EFFECT", "argument")],
				"validation": {
					"validator": "taint",
				},
			},
		],
		"callback": taint_nodes,
	},
	"Untaint Node": {
		"command": ["untaint"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL ", "argument"),
			   ANSIThemeString("KEY", "argument"),
			   ANSIThemeString("[:", "separator"),
			   ANSIThemeString("VALUE", "argument"),
			   ANSIThemeString("][=", "separator"),
			   ANSIThemeString("EFFECT", "argument"),
			   ANSIThemeString("]", "separator")],
		"description": [ANSIThemeString("Remove taint ", "description"),
				ANSIThemeString("KEY", "argument"),
				ANSIThemeString("[:", "separator"),
				ANSIThemeString("VALUE", "argument"),
				ANSIThemeString("]", "separator"),
				ANSIThemeString(" with ", "description"),
				ANSIThemeString("EFFECT", "argument"),
				ANSIThemeString(" from ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"extended_description": [
			[ANSIThemeString("If ", "description"),
			 ANSIThemeString("EFFECT", "argument"),
			 ANSIThemeString(" is not specified,", "description")],
			[ANSIThemeString("all taints matching ", "description"),
			 ANSIThemeString("KEY", "argument"),
			 ANSIThemeString("[:", "separator"),
			 ANSIThemeString("VALUE", "argument"),
			 ANSIThemeString("]", "separator"),
			 ANSIThemeString(" will be removed", "description")],
		],
		"options": {
			"--include-control-planes": {
				"description": [ANSIThemeString("Include control planes when ALL is used", "description")],
			},
		},
		"required_args": [
			{
				"name": "node",
				"string": [ANSIThemeString("NODE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("ALL", "argument")],
				"validation": {
					"validator": "hostname",
					"list_separator": ",",
				},
			}, {
				"name": "taint",
				"string": [ANSIThemeString("KEY", "argument"),
					   ANSIThemeString("[:", "separator"),
					   ANSIThemeString("VALUE", "argument"),
					   ANSIThemeString("]=[", "separator"),
					   ANSIThemeString("EFFECT", "argument"),
					   ANSIThemeString("]", "separator")],
				"validation": {
					"validator": "untaint",
				},
			},
		],
		"callback": untaint_nodes,
	},
	"Prepare Host": {
		"command": ["prepare"],
		"values": [ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("PATH", "argument")],
		"description": [ANSIThemeString("Prepare ", "description"),
				ANSIThemeString("HOST", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" for use as cluster node(s)", "description")],
		"extended_description": [
			[ANSIThemeString("Note", "note"),
			 ANSIThemeString(": If possible ", "description"),
			 ANSIThemeString("HOST", "argument"),
			 ANSIThemeString(" should be a resolvable", "description")],
			[ANSIThemeString("hostname; using an IP-address may cause issues", "description")],
		],
		"options": {
			"--ignore-existing": {
				"description": [ANSIThemeString("Ignore hosts that are already part of the cluster", "description")],
			},
			"--forks": {
				"values": [ANSIThemeString("FORKS", "argument")],
				"description": [ANSIThemeString("Max number of parallel Ansible connections", "description")],
				"extended_description": [
					[ANSIThemeString("This sets the max number of parallel connections", "description")],
					[ANSIThemeString("when running Ansible playbooks", "description")],
					[ANSIThemeString("(this overrides ", "description"),
					 ANSIThemeString(f"{CMT_CONFIG_FILENAME}", "argument"),
					 ANSIThemeString("; default: ", "description"),
					 ANSIThemeString("5", "argument"),
					 ANSIThemeString(")", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (5, 256),
				},
			},
			"--from-file": {
				"description": [ANSIThemeString("Treat the argument to ", "description"),
						ANSIThemeString("prepare", "command"),
						ANSIThemeString(" as a path", "description")],
				"extended_description": [
					[ANSIThemeString("When using this option the HOST", "description")],
					[ANSIThemeString("argument will be treated as a path to a file", "description")],
					[ANSIThemeString("with hostnames instead of a list of hostnames", "description")],
				],
			},
			"--no-password": {
				"description": [ANSIThemeString("Do not prompt for a password", "description")],
				"extended_description": [
					[ANSIThemeString("Use this if the hosts you are preparing", "description")],
					[ANSIThemeString("are already configured for login using an SSH key", "description")],
				],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs", "description")],
				"extended_description": [
					       [ANSIThemeString("The logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
				],
			},
			"--verbose": {
				"description": [ANSIThemeString("Be more verbose", "description")],
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation", "description")],
			},
		},
		"required_args": [
			{
				"name": "hosts_or_hostfile_path",
				"string": [ANSIThemeString("HOST", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("PATH", "argument")],
				"validation": {
					"validator": "hostname_or_path",
					"list_separator": ",",
				},
			},
		],
		"callback": prepare_hosts,
	},
	"Add Node": {
		"command": ["add-node", "add-nodes"],
		"values": [ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("PATH", "argument")],
		"description": [ANSIThemeString("Add ", "description"),
				ANSIThemeString("HOST", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" as Kubernetes nodes to a cluster", "description")],
		"extended_description": [
			[ANSIThemeString("Note", "note"),
			 ANSIThemeString(": If possible ", "description"),
			 ANSIThemeString("HOST", "argument"),
			 ANSIThemeString(" should be a resolvable", "description")],
			[ANSIThemeString("hostname; using an IP-address may cause issues", "description")],
		],
		"options": {
			"--ca-cert-file": {
				"values": [ANSIThemeString("PATH", "argument")],
				"description": [ANSIThemeString("Use ", "description"),
						ANSIThemeString("PATH", "argument"),
						ANSIThemeString(" as token CA certificate", "description")],
				"requires_arg": True,
				"validation": {
					"validator": "path",
				},
			},
			"--cri": {
				"values": [ANSIThemeString("CRI", "argument")],
				"description": [ANSIThemeString("Use ", "description"),
						ANSIThemeString("CRI", "argument"),
						ANSIThemeString(" instead of the default CRI", "description")],
				"extended_description": [
					[ANSIThemeString("Valid options for CRI", "description")],
					[ANSIThemeString("(Container Runtime Interface) are:", "description")],
					[ANSIThemeString("docker-shim", "argument"),
					 ANSIThemeString(" (", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" < ", "description"),
					 ANSIThemeString("1.24", "version"),
					 ANSIThemeString(")", "description"),
					 ANSIThemeString(",", "separator")],
					[ANSIThemeString("containerd", "argument"),
					 ANSIThemeString(", ", "separator"),
					 ANSIThemeString("cri-o", "argument"),
					],
					[ANSIThemeString("Default CRI:", "description")],
					[ANSIThemeString("docker-shim", "argument"),
					 ANSIThemeString(" (", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" < ", "description"),
					 ANSIThemeString("1.24", "version"),
					 ANSIThemeString(")", "description"),
					 ANSIThemeString(", ", "separator")],
					[ANSIThemeString("containerd", "argument"),
					 ANSIThemeString(" (", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.24", "version"),
					 ANSIThemeString(")", "description"),
					 ANSIThemeString(", ", "separator")],
					[ANSIThemeString("Note", "note"),
					 ANSIThemeString(": ", "description"),
					 ANSIThemeString("Kubernetes", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.26", "version"),
					 ANSIThemeString(" requires", "description")],
					[ANSIThemeString("containerd", "programname"),
					 ANSIThemeString(" >= ", "description"),
					 ANSIThemeString("1.6", "version"),
					 ANSIThemeString(" or ", "description"),
					 ANSIThemeString("cri-o", "programname"),
					 ANSIThemeString(".", "description")],
					[ANSIThemeString("If you intend to use DRA you should use ", "description"),
					 ANSIThemeString("cri-o", "programname")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": ["containerd", "cri-o", "docker-shim"],
				},
			},
			"--forks": {
				"values": [ANSIThemeString("FORKS", "argument")],
				"description": [ANSIThemeString("Max number of parallel Ansible connections", "description")],
				"extended_description": [
					[ANSIThemeString("This sets the max number of parallel connections", "description")],
					[ANSIThemeString("when running Ansible playbooks", "description")],
					[ANSIThemeString("(this overrides ", "description"),
					 ANSIThemeString(f"{CMT_CONFIG_FILENAME}", "argument"),
					 ANSIThemeString("; default: ", "description"),
					 ANSIThemeString("5", "argument"),
					 ANSIThemeString(")", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (5, 256),
				},
			},
			"--from-file": {
				"description": [ANSIThemeString("Treat the argument to ", "description"),
						ANSIThemeString("prepare", "command"),
						ANSIThemeString(" as a path", "description")],
				"extended_description": [
					[ANSIThemeString("When using this option the HOST", "description")],
					[ANSIThemeString("argument will be treated as a path to a file", "description")],
					[ANSIThemeString("with hostnames instead of a list of hostnames", "description")],
				],
			},
			"--ignore-existing": {
				"description": [ANSIThemeString("Ignore hosts that are already part of the cluster", "description")],
			},
			"--ignore-non-existing": {
				"description": [ANSIThemeString("Ignore hosts that are not part of the inventory", "description")],
			},
			"--kubernetes-distro": {
				"values": [ANSIThemeString("DISTRO", "argument")],
				"description": [ANSIThemeString("The Kubernetes distro of the control plane", "description")],
				"extended_description": [
					[ANSIThemeString("Depending on the Kubernetes distro in use a lot", "description")],
					[ANSIThemeString("of things during node setup has to be done", "description")],
					[ANSIThemeString("differently. If this option is not specified ", "description")],
					[ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
					 ANSIThemeString(" will assume that ", "description"),
					 ANSIThemeString("kubeadm ", "argument"),
					 ANSIThemeString("is used.", "description")],
					[ANSIThemeString("Supported options:", "description")],
					[ANSIThemeString("kubeadm", "argument"),
					 ANSIThemeString(" (default)", "description")],
					[ANSIThemeString("rke2", "argument"),
					 ANSIThemeString(" (default on SUSE)", "description")],
					[ANSIThemeString("Note", "note"),
					 ANSIThemeString(": currently ", "description"),
					 ANSIThemeString("rke2", "argument"),
					 ANSIThemeString(" is the only supported", "description")],
					[ANSIThemeString("option on ", "description"),
					 ANSIThemeString("SUSE", "programname")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "regex",
					"regex": r"^(kubeadm|rke2)$",
				},
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs", "description")],
				"extended_description": [
					       [ANSIThemeString("The logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
				],
			},
			"--verbose": {
				"description": [ANSIThemeString("Be more verbose", "description")],
			},
			"-Y": {
				"description": [ANSIThemeString("Do not ask for confirmation", "description")],
			},
		},
		"required_args": [
			{
				"name": "hosts_or_hostfile_path",
				"string": [ANSIThemeString("HOST", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("PATH", "argument")],
				"validation": {
					"validator": "hostname_or_path",
					"list_separator": ",",
				},
			},
		],
		"callback": add_nodes,
	},
	"Remove Node": {
		"command": ["remove-node", "remove-nodes"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL", "argument")],
		"description": [ANSIThemeString("Remove ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument"),
				ANSIThemeString(" from a Kubernetes cluster", "description")],
		"options": {
			"--force": {
				"description": [ANSIThemeString("Force teardown of non-nodes", "description")],
				"extended_description": [
					[ANSIThemeString("Attempt to teardown Kubernetes nodes", "description")],
					[ANSIThemeString("that are no longer part of the cluster", "description")],
				],
			},
			"--forks": {
				"values": [ANSIThemeString("FORKS", "argument")],
				"description": [ANSIThemeString("Max number of parallel Ansible connections", "description")],
				"extended_description": [
					[ANSIThemeString("This sets the max number of parallel connections", "description")],
					[ANSIThemeString("when running Ansible playbooks", "description")],
					[ANSIThemeString("(this overrides ", "description"),
					 ANSIThemeString(f"{CMT_CONFIG_FILENAME}", "argument"),
					 ANSIThemeString("; default: ", "description"),
					 ANSIThemeString("5", "argument"),
					 ANSIThemeString(")", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (5, 256),
				},
			},
			"--kubernetes-distro": {
				"values": [ANSIThemeString("DISTRO", "argument")],
				"description": [ANSIThemeString("The Kubernetes distro of the control plane", "description")],
				"extended_description": [
					[ANSIThemeString("Depending on the Kubernetes distro in use a lot", "description")],
					[ANSIThemeString("of things during node teardown has to be done", "description")],
					[ANSIThemeString("differently. If this option is not specified ", "description")],
					[ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
					 ANSIThemeString(" will assume that ", "description"),
					 ANSIThemeString("kubeadm ", "argument"),
					 ANSIThemeString("is used.", "description")],
					[ANSIThemeString("Supported options:", "description")],
					[ANSIThemeString("kubeadm", "argument"),
					 ANSIThemeString(" (default)", "description")],
					[ANSIThemeString("rke2", "argument"),
					 ANSIThemeString(" (default on SUSE)", "description")],
					[ANSIThemeString("Note", "note"),
					 ANSIThemeString(": currently ", "description"),
					 ANSIThemeString("rke2", "argument"),
					 ANSIThemeString(" is the only supported", "description")],
					[ANSIThemeString("option on ", "description"),
					 ANSIThemeString("SUSE", "programname")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "regex",
					"regex": r"^(kubeadm|rke2)$",
				},
			},
			"--purge": {
				"description": [ANSIThemeString("Purge hosts if teardown completes successfully", "description")],
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs", "description")],
				"extended_description": [
					       [ANSIThemeString("The logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
				],
			},
			"--verbose": {
				"description": [ANSIThemeString("Be more verbose", "description")],
			},
		},
		"required_args": [
			{
				"name": "node",
				"string": [ANSIThemeString("NODE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("ALL", "argument")],
				"validation": {
					"validator": "hostname",
					"list_separator": ",",
				},
			},
		],
		"callback": remove_nodes,
	},
	"Purge": {
		"command": ["purge"],
		"values": [ANSIThemeString("HOST", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument")],
		"description": [ANSIThemeString("Purge configuration and packages from ", "description"),
				ANSIThemeString("HOST", "argument")],
		"extended_description": [
			[ANSIThemeString("purge", "command"),
			 ANSIThemeString(" will run ", "description"),
			 ANSIThemeString("remove-node", "command"),
			 ANSIThemeString(" first if necessary", "description")],
		],
		"options": {
			"--ignore-non-existing": {
				"description": [ANSIThemeString("Ignore non-existing hosts", "description")],
				"extended_description": [
					[ANSIThemeString("Silently ignore hosts that cannot be found", "description")],
					[ANSIThemeString("in the inventory", "description")],
				],
			},
			"--forks": {
				"values": [ANSIThemeString("FORKS", "argument")],
				"description": [ANSIThemeString("Max number of parallel Ansible connections", "description")],
				"extended_description": [
					[ANSIThemeString("This sets the max number of parallel connections", "description")],
					[ANSIThemeString("when running Ansible playbooks", "description")],
					[ANSIThemeString("(this overrides ", "description"),
					 ANSIThemeString(f"{CMT_CONFIG_FILENAME}", "argument"),
					 ANSIThemeString("; default: ", "description"),
					 ANSIThemeString("5", "argument"),
					 ANSIThemeString(")", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (5, 256),
				},
			},
			"--kubernetes-distro": {
				"values": [ANSIThemeString("DISTRO", "argument")],
				"description": [ANSIThemeString("The Kubernetes distro of the control plane", "description")],
				"extended_description": [
					[ANSIThemeString("Depending on the Kubernetes distro in use a lot", "description")],
					[ANSIThemeString("of things during node teardown has to be done", "description")],
					[ANSIThemeString("differently. If this option is not specified ", "description")],
					[ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
					 ANSIThemeString(" will assume that ", "description"),
					 ANSIThemeString("kubeadm ", "argument"),
					 ANSIThemeString("is used.", "description")],
					[ANSIThemeString("Supported options:", "description")],
					[ANSIThemeString("kubeadm", "argument"),
					 ANSIThemeString(" (default)", "description")],
					[ANSIThemeString("rke2", "argument"),
					 ANSIThemeString(" (default on SUSE)", "description")],
					[ANSIThemeString("Note", "note"),
					 ANSIThemeString(": currently ", "description"),
					 ANSIThemeString("rke2", "argument"),
					 ANSIThemeString(" is the only supported", "description")],
					[ANSIThemeString("option on ", "description"),
					 ANSIThemeString("SUSE", "programname")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "regex",
					"regex": r"^(kubeadm|rke2)$",
				},
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs", "description")],
				"extended_description": [
					       [ANSIThemeString("The logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
				],
			},
			"--verbose": {
				"description": [ANSIThemeString("Be more verbose", "description")],
			},
		},
		"required_args": [
			{
				"name": "hosts",
				"string": [ANSIThemeString("HOST", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("ALL", "argument")],
				"validation": {
					"validator": "hostname",
					"list_separator": ",",
				},
			},
		],
		"callback": purge_hosts,
	},
	"Upgrade Node": {
		"command": ["upgrade-node", "upgrade-nodes"],
		"values": [ANSIThemeString("NODE", "argument"),
			   ANSIThemeString(",", "separator"),
			   ANSIThemeString("...", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("ALL", "argument")],
		"description": [ANSIThemeString("Upgrade Kubernetes on ", "description"),
				ANSIThemeString("NODE", "argument"),
				ANSIThemeString(",", "separator"),
				ANSIThemeString("...", "argument")],
		"extended_description": [
			[ANSIThemeString("This command upgrades Kubernetes on ", "description"),
			 ANSIThemeString("NODE", "argument"),
			 ANSIThemeString(",", "separator"),
			 ANSIThemeString("...", "argument")],
			[ANSIThemeString("to the version on the control plane(s);", "description")],
			[ANSIThemeString("run this on all nodes after running", "description")],
			[ANSIThemeString("“", "description"),
			 ANSIThemeString(f"{about.ADMIN_PROGRAM_NAME}", "programname"),
			 ANSIThemeString(" upgrade-control-plane", "command"),
			 ANSIThemeString("“", "description")],
			[ANSIThemeString("Note", "note"),
			 ANSIThemeString(": ", "description"),
			 ANSIThemeString("upgrade-node", "command"),
			 ANSIThemeString(" is currently not", "description")],
			[ANSIThemeString("implemented for ", "description"),
			 ANSIThemeString("rke2", "argument")],
		],
		"options": {
			"--forks": {
				"values": [ANSIThemeString("FORKS", "argument")],
				"description": [ANSIThemeString("Max number of parallel Ansible connections", "description")],
				"extended_description": [
					[ANSIThemeString("This sets the max number of parallel connections", "description")],
					[ANSIThemeString("when running Ansible playbooks", "description")],
					[ANSIThemeString("(this overrides ", "description"),
					 ANSIThemeString(f"{CMT_CONFIG_FILENAME}", "argument"),
					 ANSIThemeString("; default: ", "description"),
					 ANSIThemeString("5", "argument"),
					 ANSIThemeString(")", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "int",
					"valid_range": (5, 256),
				},
			},
			"--save-ansible-logs": {
				"description": [ANSIThemeString("Save logs from Ansible runs", "description")],
				"extended_description": [
					       [ANSIThemeString("The logs can be viewed using “", "description"),
						ANSIThemeString("cmu", "programname"),
						ANSIThemeString(" logs", "command"),
						ANSIThemeString("“", "description")]
				],
			},
			"--verbose": {
				"description": [ANSIThemeString("Be more verbose", "description")],
			},
		},
		"required_args": [
			{
				"name": "node",
				"string": [ANSIThemeString("NODE", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("ALL", "argument")],
				"validation": {
					"validator": "hostname",
					"list_separator": ",",
				},
			},
		],
		"callback": upgrade_nodes,
	},
	"Get Contexts": {
		"command": ["get-contexts", "get-ctx"],
		"description": [ANSIThemeString("Get the list of available contexts", "description")],
		"callback": get_contexts,
	},
	"Use Context": {
		"command": ["use-context", "use-ctx"],
		"description": [ANSIThemeString("Set current context", "description")],
		"callback": use_context,
		"values": [ANSIThemeString("NAME", "argument"),
			   ANSIThemeString("|", "separator"),
			   ANSIThemeString("INDEX", "argument")],
		"extended_description": [
			[ANSIThemeString("Set current context, either by specifying", "description")],
			[ANSIThemeString("context ", "description"),
			 ANSIThemeString("NAME", "argument"),
			 ANSIThemeString(" or by specifying context ", "description"),
			 ANSIThemeString("INDEX", "argument")],
		],
		"required_args": [
			{
				"name": "context",
				"string": [ANSIThemeString("NAME", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("INDEX", "argument")],
				"validation": {
					"validator": "regex",
					"regex": r"^(\d+|[a-z][a-z+@\d-]*)$",
				},
			},
		],
	},
	"List API-resources": {
		"command": ["api-resources"],
		"description": [ANSIThemeString("Display available API-resources", "description")],
		"options": {
			"--api-group": {
				"values": [ANSIThemeString("API_GROUP", "argument")],
				"description": [ANSIThemeString("Limit output to ", "description"),
						ANSIThemeString("API_GROUP", "argument")],
				"extended_description": [
					[ANSIThemeString("If the version part of ", "description"),
					 ANSIThemeString("API_GROUP", "argument"),
					 ANSIThemeString(" is omitted,", "description")],
					[ANSIThemeString("all versions of the API-GROUP are included.", "description")],
					[ANSIThemeString("To only show core APIs, use ", "description"),
					 ANSIThemeString("\"\"", "argument"),
					 ANSIThemeString(".", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "regex",
					"regex": r"^([a-z][a-z0-9.-]*[a-z0-9]?)?",
				},
			},
			"--color": {
				"values": [ANSIThemeString("WHEN", "argument")],
				"description": [ANSIThemeString("WHEN should the output use ANSI-colors", "description")],
				"extended_description": [
					[ANSIThemeString("Valid arguments are: ", "description")],
					[ANSIThemeString("always", "argument"),
					 ANSIThemeString(" (always color the output)", "description")],
					[ANSIThemeString("auto", "argument"),
					 ANSIThemeString(" (color the output when outputting", "description")],
					[ANSIThemeString("to a terminal)", "description")],
					[ANSIThemeString("never", "argument"),
					 ANSIThemeString(" (never color the output)", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": [
						"always",
						"auto",
						"never",
					],
				},
			},
			"--has-data": {
				"description": [ANSIThemeString("Only list APIs that have resources", "description")],
				"extended_description": [
					[ANSIThemeString("This option will only list APIs that have data.", "description")],
					[ANSIThemeString("Note", "note"),
					 ANSIThemeString(": this can be very slow.", "description")],
				],
			},
			"--known": {
				"values": [ANSIThemeString("FILTER", "argument")],
				"description": [ANSIThemeString("Limit output to ", "description"),
						ANSIThemeString("FILTER", "argument")],
				"extended_description": [
					[ANSIThemeString("Valid values are:", "description")],
					[ANSIThemeString("unknown", "argument"),
					 ANSIThemeString("/", "separator"),
					 ANSIThemeString("not-known", "argument")],
					[ANSIThemeString("or a combination of:", "description")],
					[ANSIThemeString("known", "argument"),
					 ANSIThemeString(", ", "separator"),
					 ANSIThemeString("list", "argument"),
					 ANSIThemeString("/", "separator"),
					 ANSIThemeString("not-list", "argument"),
					 ANSIThemeString(" and ", "description"),
					 ANSIThemeString("info", "argument"),
					 ANSIThemeString("/", "separator"),
					 ANSIThemeString("not-info", "argument"),
					 ANSIThemeString(".", "description")],
					[ANSIThemeString("unknown", "argument"),
					 ANSIThemeString("/", "separator"),
					 ANSIThemeString("not-known", "argument"),
					 ANSIThemeString(" limits the output to APIs that", "description")],
					[ANSIThemeString("are unknown to ", "description"),
					 ANSIThemeString("CMT", "programname"),
					 ANSIThemeString(".", "description")],
					[ANSIThemeString("known", "argument"),
					 ANSIThemeString(" limits the output to APIs that are", "description")],
					[ANSIThemeString("known by ", "description"),
					 ANSIThemeString("CMT", "programname"),
					 ANSIThemeString("; augment this with ", "description")],
					[ANSIThemeString("list", "argument"),
					 ANSIThemeString("/", "separator"),
					 ANSIThemeString("not-list", "argument"),
					 ANSIThemeString(" and ", "description"),
					 ANSIThemeString("info", "argument"),
					 ANSIThemeString("/", "separator"),
					 ANSIThemeString("not-info", "argument")],
					[ANSIThemeString("to limit the output based on whether ", "description"),
					 ANSIThemeString("CMT", "programname")],
					[ANSIThemeString("has ", "description"),
					 ANSIThemeString("list", "emphasis"),
					 ANSIThemeString(" and ", "description"),
					 ANSIThemeString("info", "emphasis"),
					 ANSIThemeString(" views available.", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": [
						"known",
						"!known", "not-known", "unknown",
						"list",
						"!list", "not-list",
						"info",
						"!info", "not-info"
					],
					"list_separator": ",",
				},
			},
			"--local": {
				"values": [ANSIThemeString("true", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("false", "argument")],
				"description": [ANSIThemeString("Limit output to only local or upstream view-files", "description")],
				"extended_description": [
					[ANSIThemeString("If ", "description"),
					 ANSIThemeString("true", "argument"),
					 ANSIThemeString(" only locally added view-files are", "description")],
					[ANSIThemeString("considered when determining API-support level.", "description")],
					[ANSIThemeString("If ", "description"),
					 ANSIThemeString("false", "argument"),
					 ANSIThemeString(" only upstream view-files are considered", "description")],
					[ANSIThemeString("when determining API-support level.", "description")],
					[ANSIThemeString("By default both local and upstream view-files", "description")],
					[ANSIThemeString("are considered.", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "bool",
				},
			},
			"--namespaced": {
				"values": [ANSIThemeString("true", "argument"),
					   ANSIThemeString("|", "separator"),
					   ANSIThemeString("false", "argument")],
				"description": [ANSIThemeString("Limit output to namespaced or cluster-wide", "description")],
				"extended_description": [
					[ANSIThemeString("If ", "description"),
					 ANSIThemeString("true", "argument"),
					 ANSIThemeString(" only namespaced resources will be listed.", "description")],
					[ANSIThemeString("If ", "description"),
					 ANSIThemeString("false", "argument"),
					 ANSIThemeString(" only cluster-wide resources will be", "description")],
					[ANSIThemeString("listed. By default all resources are listed.", "description")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "bool",
				},
			},
			"--no-header": {
				"description": [ANSIThemeString("Do not output list headers", "description")],
			},
			"--format": {
				"values": [ANSIThemeString("FORMAT", "argument")],
				"description": [ANSIThemeString("Format the output as ", "description"),
						ANSIThemeString("FORMAT", "description")],
				"extended_description": [
					[ANSIThemeString("Valid formats are: ", "description")],
					[ANSIThemeString("table", "argument"),
					 ANSIThemeString(" (table with information)", "description")],
					[ANSIThemeString("csv", "argument"),
					 ANSIThemeString(" (comma-separated values)", "description")],
					[ANSIThemeString("ssv", "argument"),
					 ANSIThemeString(" (space-separated values)", "description")],
					[ANSIThemeString("tsv", "argument"),
					 ANSIThemeString(" (tab-separated values)", "description")],
					[ANSIThemeString("entry", "argument"),
					 ANSIThemeString(" (used when adding API support to CMT)", "description")]
				],
				"requires_arg": True,
				"validation": {
					"validator": "allowlist",
					"allowlist": [
						"table",
						"csv",
						"ssv",
						"tsv",
						"entry"
					],
				},
			},
			"--sort-by": {
				"values": [ANSIThemeString("SORTKEY", "argument")],
				"description": [ANSIThemeString("Sort the output by ", "description"),
						ANSIThemeString("SORTKEY", "description")],
				"extended_description": [
					[ANSIThemeString("Valid sortkeys are: ", "description")],
					[ANSIThemeString("name", "argument")],
					[ANSIThemeString("apiversion", "argument")],
					[ANSIThemeString("namespaced", "argument")],
					[ANSIThemeString("kind", "argument")],
				],
				"requires_arg": True,
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z]+",
					"list_separator": ",",
				},
			},
			"--verbs": {
				"values": [ANSIThemeString("VERB", "argument"),
					   ANSIThemeString(",", "separator"),
					   ANSIThemeString("...", "argument")],
				"description": [ANSIThemeString("Limit output by supported verbs", "description")],
				"requires_arg": True,
				"validation": {
					"validator": "regex",
					"regex": r"^[a-z]+",
					"list_separator": ",",
				},
			},
			"--wide": {
				"description": [ANSIThemeString("Wide output format", "description")],
			},
		},
		"callback": list_api_resources,
	},
	"spacer1": {
		"command": [""],
		"description": [ANSIThemeString("", "default")],
	},
#	"Get": {
#		"command": ["get", "l", "list"],
#		"values": [ANSIThemeString("RESOURCE", "argument"),
#			   ANSIThemeString(",", "separator"),
#			   ANSIThemeString("...", "argument")],
#		"description": [ANSIThemeString("List information about ", "description"),
#				ANSIThemeString("RESOURCE", "argument"),
#				ANSIThemeString(",", "separator"),
#				ANSIThemeString("...", "argument")],
#		"options": {
#			("-N", "--namespace"): {
#				"values": [ANSIThemeString("NAMESPACE", "argument"),
#					   ANSIThemeString(",", "separator"),
#					   ANSIThemeString("...", "argument")],
#				"description": [ANSIThemeString("Only show resources belonging to ", "description"),
#						ANSIThemeString("NAMESPACE", "argument"),
#						ANSIThemeString(",", "separator"),
#						ANSIThemeString("...", "argument")],
#				"requires_arg": True,
#			},
#			("-A", "--all-namespaces"): {
#				"description": [ANSIThemeString("Show resources across all namespaces", "description")],
#			},
#		},
#		"min_args": 1,
#		"max_args": 1,
#		"callback": get_resource,
#	},
	"extended_description": [
		[ANSIThemeString("You can use “", "description"),
		 ANSIThemeString("ALL", "emphasis"),
		 ANSIThemeString("“ as a substitute for all resources in most cases;", "description")],
		[ANSIThemeString("for instance “", "description"),
		 ANSIThemeString(f"{about.TOOL_PROGRAM_NAME}", "programname"),
		 ANSIThemeString(" upgrade-node ", "command"),
		 ANSIThemeString("ALL", "emphasis"),
		 ANSIThemeString("“ will upgrade Kubernetes on all nodes", "description")],
		[ANSIThemeString("", "default")],
		[ANSIThemeString("Note that “", "description"),
		 ANSIThemeString("ALL", "emphasis"),
		 ANSIThemeString("“ excludes control planes; to include", "description")],
		[ANSIThemeString("control planes you need to use “", "description"),
		 ANSIThemeString("--include-control-planes", "option"),
		 ANSIThemeString("“ (where applicable)", "description")],
	]
}

def get_programname(callname: str) -> Tuple[str, Dict]:
	"""
	Return the name that the program was called with;
	the eventual intention here is that the behaviour can be different
	depending on by what name the program was invoked

		Parameters:
			callname (str): The name that the program was invoked with
		Returns:
			(callname (str), commandline (List[str]))
	"""

	callnames = {
		"cmt": CMT_COMMANDLINE,		# main name
		#"cmtdep": DEP_COMMANDLINE,	# deployment shortcut
		#"cmtds": DS_COMMANDLINE,	# daemon set shortcut
		#"cmtrs": RS_COMMANDLINE,	# replica set shortcut
		#"cmtjob": JOB_COMMANDLINE,	# job shortcut
		#"cmtnode": NODE_COMMANDLINE,	# node shortcut
		#"cmtpod": POD_COMMANDLINE,	# pod shortcut
	}

	if callname not in callnames:
		sys.exit(f"{about.TOOL_PROGRAM_NAME} called with unknown name {callname}; aborting.")

	return callname, callnames[callname]

def main() -> int:
	"""
	Main function for the program
	"""

	# Before doing anything else, make sure that the user is not running as root
	if os.geteuid() == 0:
		sys.exit("CRITICAL: This program should not be run as the root user; aborting.")

	# Then initialise the configuration file
	read_cmtconfig()

	programname, commandline = get_programname(os.path.basename(sys.argv[0]))

	command, options, args = parse_commandline(programname, about.TOOL_PROGRAM_VERSION, PROGRAMDESCRIPTION, PROGRAMAUTHORS, sys.argv,
						   commandline, theme = DEFAULT_THEME_FILE)

	# Used by the ansible module
	ansible_configuration["ansible_forks"] = deep_get(cmtlib.cmtconfig, DictPath("Ansible#forks"), 10)
	ansible_user = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_user"))
	if ansible_user is None or len(ansible_user) == 0:
		ansible_user = getuser()
	ansible_configuration["ansible_user"] = ansible_user
	ansible_password = deep_get(cmtlib.cmtconfig, DictPath("Ansible#ansible_password"))
	if ansible_password is not None and len(ansible_password) > 0:
		ansible_configuration["ansible_password"] = ansible_password
	ansible_configuration["disable_strict_host_key_checking"] = deep_get(cmtlib.cmtconfig, DictPath("Nodes#disablestricthostkeychecking"), False)
	ansible_configuration["save_logs"] = deep_get(cmtlib.cmtconfig, DictPath("Ansible#save_logs"), False)

	return command(options, args)

if __name__ == "__main__":
	main()
