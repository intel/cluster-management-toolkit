#! /usr/bin/env python3
# Requires: ansible
# Requires: python3 (>= 3.6)
# Requires: python3-natsort
# Requires: python3-openssl
# Recommends: python3-ujson

import errno
from functools import reduce
from getpass import getuser
import hashlib
import os
from pathlib import Path
import re
import socket
import subprocess
from subprocess import PIPE, STDOUT
import sys
import yaml

import paramiko

try:
	from natsort import natsorted
except ModuleNotFoundError:
	sys.exit("ModuleNotFoundError: you probably need to install python3-natsort")

try:
	import OpenSSL
except ModuleNotFoundError:
	sys.exit("ModuleNotFoundError: you probably need to install python3-openssl")

from commandparser import parse_commandline

from ansible_helper import ansible_configuration, ansible_set_vars, ansible_run_playbook_on_host_list, ansible_run_playbook_on_selection, ansible_get_hosts_by_group, ansible_add_hosts, ansible_remove_hosts
from ansible_helper import ANSIBLE_PLAYBOOK_DIR, ANSIBLE_INVENTORY

import iktlib
from iktlib import deep_get, join_tuple_list

HOMEDIR = str(Path.home())
IKTDIR = f"{HOMEDIR}/.ikt"
IKT_CONFIG_FILENAME = "ikt.yaml"
IKT_CONFIG_FILE = f"{IKTDIR}/{IKT_CONFIG_FILENAME}"

THEME_DIRNAME = "themes"
THEMEDIR = f"{IKTDIR}/{THEME_DIRNAME}"
THEME_PATH = f"{THEMEDIR}/default.yaml"

from iktprint import iktprint, iktinput, iktinput_password, init_iktprint

import about
PROGRAMDESCRIPTION = "Commandline tool for managing Kubernetes clusters"
PROGRAMAUTHORS = "Written by David Weinehall."

iktconfig = None

def scan_and_add_ssh_keys(hosts):
	for host in hosts:
		try:
			transport = paramiko.Transport(host)
		except socket.gaierror as e:
			if str(e) in ["[Errno -3] Temporary failure in name resolution", "[Errno -2] Name or service not known"]:
				continue
			else:
				raise socket.gaierror(f"{str(e)}\nhost: {host}")
		transport.connect()
		key = transport.get_remote_server_key()
		transport.close()
		known_hosts = f"{HOMEDIR}/.ssh/known_hosts"

		# Note: Paramiko seems to have issues if .ssh/known_hosts doesn't exist,
		# so "touch" the file just in case.
		open(known_hosts, 'a').close()

		hostfile = paramiko.HostKeys(filename = known_hosts)
		hostfile.add(hostname = host, key = key, keytype = key.get_name())
		hostfile.save(filename = known_hosts)

def request_ansible_password():
	# Check whether ansible_password is defined or not
	if ansible_configuration.ansible_password == None:
		iktprint([("Attention: ", "warning"), ("To be able to run playbooks you need to provide the ansible/ssh password.", "default")])
		iktprint([("Since the system will be reconfigured to use passwordless sudo and ssh keys this is a one-time thing when preparing systems.", "default")])
		ansible_password = iktinput_password([("\nPassword: ", "default")])
		if len(ansible_password) == 0:
			iktprint([("\nError: ", "Error"), ("Empty password; aborting.")], stderr = True)
			sys.exit(errno.EINVAL)
		else:
			ansible_configuration.ansible_password = ansible_password

def run_playbook(playbookpath, hosts = None, extra_values = {}, quiet = False):
	# Set necessary Ansible keys before running playbooks
	http_proxy = deep_get(iktconfig, "Network#http_proxy", "")
	if http_proxy is None:
		http_proxy = ""
	https_proxy = deep_get(iktconfig, "Network#https_proxy", "")
	if https_proxy is None:
		https_proxy = ""
	no_proxy = deep_get(iktconfig, "Network#no_proxy", "")
	if no_proxy is None:
		no_proxy = ""
	insecure_registries = deep_get(iktconfig, "Docker#insecure_registries", [])
	registry_mirrors = deep_get(iktconfig, "Containerd#registry_mirrors", [])
	retval = 0

	use_proxy = "no"
	if len(http_proxy) > 0 or len(https_proxy) > 0:
		use_proxy = "yes"

	values = {
		"http_proxy": http_proxy,
		"https_proxy": https_proxy,
		"no_proxy": no_proxy,
		"insecure_registries": insecure_registries,
		"registry_mirrors": registry_mirrors,
		"use_proxy": use_proxy,
	}
	merged_values = { **values, **extra_values }

	if hosts is None:
		retval, ansible_results = ansible_run_playbook(playbookpath, values = merged_values)
	else:
		retval, ansible_results = ansible_run_playbook_on_selection(playbookpath, selection = hosts, values = merged_values)

	for host in ansible_results:
		data = ansible_results[host]
		if retval == 0 and quiet == True:
			break

		# RUN_ERROR = 1
		# RUN_FAILED_HOSTS = 2
		# RUN_UNREACHABLE_HOSTS = 4
		# RUN_FAILED_BREAK_PLAY = 8
		extra_status = ""
		if retval & 1 == 1:
			extra_status += " Error,"
		if retval & 2 == 2:
			extra_status += " Failed hosts,"
		if retval & 4 == 4:
			extra_status += " host unreachable,"
		if retval & 8 == 8:
			extra_status += " Failed break play,"

		extra_status = extra_status.rstrip(",")

		if retval == 0:
			iktprint([(f"    [{host}]", "success")])
		else:
			iktprint([(f"    [{host}]", "error"), (extra_status, "errorvalue")])

		for task in ansible_results[host]:
			taskname = task[len("TASK: "):]
			iktprint([(f"      {taskname}:", "default")])
			msg = data[task].get("msg", "").splitlines()
			if len(msg) > 0:
				iktprint([(f"        ", "default"), ("msg:", "header")])
				for line in msg:
					iktprint([(f"        {line}", "default")])
				iktprint([("", "default")])
			stdout_lines = data[task].get("stdout_lines", [])
			if len(stdout_lines) > 0:
				iktprint([(f"        ", "default"), ("stdout:", "header")])
				for line in data[task]["stdout_lines"]:
					iktprint([(f"        {line}", "default")])
				iktprint([("", "default")])
			stderr_lines = data[task].get("stderr_lines", [])
			if len(stderr_lines) > 0:
				iktprint([(f"        ", "default"), ("stderr:", "header")])
				for line in data[task]["stderr_lines"]:
					iktprint([(f"        {line}", "default")])
				iktprint([("", "default")])
			if len(msg) == 0 and len(stdout_lines) == 0 and len(stderr_lines) == 0:
				iktprint([(f"        <no output>", "none")])
				iktprint([("", "default")])

	return retval, ansible_results

def __format_none(string, fmt):
	if string is None or string == "<none>":
		__string = ("<none>", "none")
	else:
		__string = (string, fmt)
	return __string

def show_configuration(hosts):
	# cluster_name = 
	http_proxy = deep_get(iktconfig, "Network#http_proxy", "")
	if http_proxy is not None and http_proxy == "":
		http_proxy = None
	http_proxy_env = os.getenv("http_proxy")
	if http_proxy_env is not None and http_proxy_env == "":
		http_proxy_env = None
	https_proxy = deep_get(iktconfig, "Network#https_proxy", "")
	if https_proxy is not None and https_proxy == "":
		https_proxy = None
	https_proxy_env = os.getenv("https_proxy")
	if https_proxy_env is not None and https_proxy_env == "":
		https_proxy_env = None
	no_proxy = deep_get(iktconfig, "Network#no_proxy", "")
	if no_proxy is not None and no_proxy == "":
		no_proxy = None
	no_proxy_env = os.getenv("no_proxy")
	if no_proxy_env is not None and no_proxy_env == "":
		no_proxy_env = None

	iktprint([("\n[Summary]", "phase")])
	iktprint([("\n• ", "separator"), ("Configuration:", "action")])
	iktprint([("          HTTP Proxy: ", "action"), __format_none(http_proxy, "url"), (" (", "default"), (f"{IKT_CONFIG_FILE}", "path"), (")", "default")])
	iktprint([("          HTTP Proxy: ", "action"), __format_none(http_proxy_env, "url"), (" (Environment)", "default")])
	iktprint([("         HTTPS Proxy: ", "action"), __format_none(https_proxy, "url"), (" (", "default"), (f"{IKT_CONFIG_FILE}", "path"), (")", "default")])
	iktprint([("         HTTPS Proxy: ", "action"), __format_none(https_proxy_env, "url"), (" (Environment)", "default")])
	iktprint([("            No Proxy: ", "action"), __format_none(no_proxy, "url"), (" (", "default"), (f"{IKT_CONFIG_FILE}", "path"), (")", "default")])
	iktprint([("            No Proxy: ", "action"), __format_none(no_proxy_env, "url"), (" (Environment)", "default")])
	iktprint([("", "default")])
	iktprint([("Target hosts:", "header")])
	for host in hosts:
		iktprint([("  • ", "separator"), (host, "hostname")])

def run_playbooks(playbooks, hosts = None, extra_values = {}):
	for string, playbookpath in playbooks:
		iktprint(string)
		retval, ansible_results = run_playbook(playbookpath, hosts = hosts, extra_values = extra_values)

		# We don't want to continue executing playbooks if the first one failed
		if retval != 0:
			break

	return retval == 0

# Add all playbooks in the array
def populate_playbooks_from_paths(paths):
	playbooks = []

	for playbookpath in paths:
		# Only process playbooks
		tmp = re.match(r"(.*)\.ya?ml$", os.path.basename(playbookpath))
		if tmp is None:
			raise Exception(f"The playbook filename “{os.path.basename(playbookpath)}“ does not end with .yaml or .yml; this is most likely a programming error.")

		playbookname = tmp[1]
		description = None
		with open(playbookpath) as f:
			d = yaml.safe_load(f)
			description = [(deep_get(d[0], "vars#metadata#description"), "play")]

		if description is None or len(description) == 0:
			description = [("Running “", "play"), (playbookname, "programname"), ("“", "play")]

		# If there's no description we fallback to just using the filename
		playbooks.append(([("  • ", "separator")] + description, playbookpath))

	return playbooks

# This executes a command without capturing the output
def execute_command(args, env = None):
	if env is None:
		retval = subprocess.run(args)
	else:
		retval = subprocess.run(args, env = env)
	return retval.returncode == 0

# This executes a command with the output captured
def execute_command_with_response(args):
	result = subprocess.run(args, stdout = PIPE, stderr = STDOUT, check = False)
	return result.stdout.decode("utf-8")

def get_selection(selection, kind = None, default = None, skip_control_planes = True):
	all_items = False
	items1 = []
	non_existing = []
	# Only used for controlplanes
	items2 = []

	if kind is None:
		raise Exception("Kind is None; this is a programming error")

	if selection is None:
		if default is None:
			raise Exception("Both selection and default is None; this is a programming error")
		selection = default

	if "ALL" in selection:
		if len(selection) > 1:
			iktprint([("Error: ", "error"), ("“", "default"), ("ALL", "argument"), ("“ cannot be combined with other arguments; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		else:
			all_items = True

	# Kubernetes resources
	if type(kind) == tuple:
		from kubernetes_helper import KubernetesHelper
		kh = KubernetesHelper(about.program_suite_name, about.program_suite_version, None)

		vlist, status = kh.get_list_by_kind_namespace(("Node", ""), "")
		for node in vlist:
			name = deep_get(node, "metadata#name")
			if all_items == False and name not in selection:
				continue

			if kind == ("Node", "") and skip_control_planes == True:
				node_roles = kh.get_node_roles(node)
				if "control-plane" in node_roles:
					items2.append(name)
					continue

			items1.append(name)
	# str kinds are things such as playbooks; for now ikt doesn't use them

	# Finally, generate a list of non-existing items
	if all_items == False:
		for item in selection:
			if item not in items1 + items2:
				non_existing.append(item)

	return items1, non_existing, items2

def cordon_nodes(options = [], args = None):
	include_control_planes = False
	header = True

	_args = ["kubectl", "cordon"]

	for opt, optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")

	# It's OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(non_existing) > 0:
		iktprint([(f"Error: ", "error"), join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")), (" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		iktprint([("\n[Cordoning nodes]", "phase")])
	_args += nodes
	execute_command(_args)

def drain_nodes(options = [], args = None):
	include_control_planes = False
	header = True

	# Check kubectl version
	_args = ["kubectl", "version", "-oyaml"]
	response = execute_command_with_response(_args)
	version_data = yaml.safe_load(response)
	major_version = deep_get(version_data, "clientVersion#major")
	minor_version = deep_get(version_data, "clientVersion#minor")

	_args = ["kubectl", "drain"]

	for opt, optarg in options:
		if opt in ["--delete-emptydir-data", "--delete-local-data"]:
			if int(major_version) >= 1 and int(minor_version) >= 20:
				_args.append("--delete-emptydir-data")
			else:
				_args.append("--delete-local-data")
		elif opt == "--disable-eviction":
			if int(major_version) >= 1 and int(minor_version) >= 18:
				_args.append(opt)
		elif opt == "--ignore-daemonsets":
			_args.append(opt)
		elif opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")

	# It's OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(non_existing) > 0:
		iktprint([(f"Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		iktprint([("\n[Draining nodes]", "phase")])
	_args += nodes
	execute_command(_args)

def uncordon_nodes(options = [], args = None):
	include_control_planes = False
	header = True

	_args = ["kubectl", "uncordon"]

	for opt, optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")

	# It's OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(non_existing) > 0:
		iktprint([(f"Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		iktprint([("\n[Uncordoning nodes]", "phase")])
	_args += nodes
	execute_command(_args)

def setup_nodes(options = [], args = None):
	return 0

def prepare_hosts(options = [], args = None):
	ignore_existing = False
	no_password = False

	selection = args[0].split(",")

	if "ALL" in selection:
		iktprint([("Error: ", "error"), ("ALL", "hostname"), (" cannot be used with ", "default"), ("prepare", "command"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for opt, optarg in options:
		if opt == "--ignore-existing":
			ignore_existing = True
		elif opt == "--no-password":
			no_password = True
		elif opt == "--save-ansible-logs":
			ansible_configuration.save_logs = True
		elif opt == "--forks":
			ansible_configuration.forks = optarg
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	# Correlate the list of hosts with the nodes in the cluster
	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(nodes) > 0 or len(controlplanes) > 0:
		if ignore_existing == False:
			iktprint([(f"Error: ", "error")] + join_tuple_list(nodes + controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are already part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(errno.EEXIST)
		else:
			iktprint([(f"Warning: ", "warning")] + join_tuple_list(nodes + controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are already part of the cluster; ignoring them since “", "description"), ("--ignore-existing", "argument"), ("“ was specified.", "default")], stderr = True)

	if len(non_existing) == 0:
		iktprint([(f"Error: ", "error"), (" no valid hosts specified; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# Check if the hosts are part of the inventory
	inventory = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")
	not_in_inventory = []
	for host in non_existing:
		if host not in inventory:
			not_in_inventory.append(host)

	if len(not_in_inventory) > 0:
		retval = iktinput([("\nWarning: ", "warning")] + join_tuple_list(not_in_inventory, _tuple = "hostname", separator = (",", "separator")) + [(" are not defined in the inventory; do you want to add them now? (No will abort the installation) [y/", "default"), ("N", "emphasis"), ("]: ", "default")])
		if retval.lower() not in ["y", "yes"]:
			iktprint([("\nAborting: ", "error"), ("Nodes not added to the inventory.", "default")], stderr = True)
			sys.exit(errno.EINTR)
		else:
			ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = not_in_inventory, skip_all = False)

	show_configuration(non_existing)

	confirm = True
	if confirm == True:
		retval = iktinput([("\nStart host preparation? [y/", "default"), ("N", "emphasis"), ("]: ", "default")])
		if retval.lower() not in ["y", "yes"]:
			iktprint([("\nAborting: ", "error"), ("User stopped host preparation.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	iktprint([(f"\n[Preparing host(s)]", "phase")])

	scan_and_add_ssh_keys(non_existing)

	# We most likely won't be able to connect to the remote host without a password
	if no_password == False:
		request_ansible_password()

	prepare_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/prepare_node.yaml",
	]
	playbooks = populate_playbooks_from_paths(prepare_playbooks)

	extra_values = {
		"ansible_become_pass": ansible_configuration.ansible_password,
		"ansible_ssh_pass": ansible_configuration.ansible_password,
	}

	retval = run_playbooks(playbooks = playbooks, hosts = non_existing, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	iktprint([("\nHosts successfully prepared", "success")])

def add_nodes(options = [], args = None):
	ignore_existing = False
	ignore_non_existing = False
	ca_cert_path = ""
	cri = None

	selection = args[0].split(",")

	if "ALL" in selection:
		iktprint([("Error: ", "error"), ("ALL", "hostname"), (" cannot be used with ", "default"), ("add-node", "command"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for opt, optarg in options:
		if opt == "--ignore-existing":
			ignore_existing = True
		elif opt == "--ignore-non-existing":
			ignore_non_existing = True
		elif opt == "--save-ansible-logs":
			ansible_configuration.save_logs = True
		elif opt == "--ca-cert-path":
			ca_cert_path = optarg
		elif opt == "--forks":
			ansible_configuration.forks = optarg
		elif opt == "--cri":
			if optarg in ["dockershim", "containerd", "manual"]:
				cri = optarg
			else:
				iktprint([("Error: ", "error"), ("Unknown CRI “", "default"), (optarg, "argument"), ("“ specified; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	# Correlate the list of hosts with the nodes in the cluster
	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(nodes) > 0 or len(controlplanes) > 0:
		if ignore_existing == False:
			iktprint([(f"Error: ", "error")] + join_tuple_list(controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are already part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(errno.EEXIST)
		else:
			iktprint([(f"Warning: ", "warning")] + join_tuple_list(nodes + controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are already part of the cluster; ignoring them since “", "description"), ("--ignore-existing", "argument"), ("“ was specified.", "default")], stderr = True)

	if len(non_existing) == 0:
		iktprint([(f"Error: ", "error"), (" no valid hosts specified; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# Check if the hosts are part of the inventory
	inventory = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")
	not_in_inventory = []
	for host in non_existing:
		if host not in inventory:
			not_in_inventory.append(host)

	if len(not_in_inventory) > 0:
		if ignore_non_existing == False:
			iktprint([(f"Error: ", "error")] + join_tuple_list(not_in_inventory, _tuple = "hostname", separator = (",", "separator")) + [(" are not defined in the inventory; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			iktprint([(f"Warning: ", "warning")] + join_tuple_list(not_in_inventory, _tuple = "hostname", separator = (",", "separator")) + [(" are not defined in the invetory; ignoring them since “", "description"), ("--ignore-non-existing", "argument"), ("“ was specified.", "default")], stderr = True)

	show_configuration(non_existing)

	confirm = True
	if confirm == True:
		retval = iktinput([("\nStart node setup? [y/", "default"), ("N", "emphasis"), ("]: ", "default")])
		if retval.lower() not in ["y", "yes"]:
			iktprint([("\nAborting: ", "error"), ("User stopped node setup.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	# Time to setup and add the hosts to the cluster
	iktprint([("\n[Adding nodes]", "phase")])

	# Get variables that need to be available when setting up nodes
	from kubernetes_helper import KubernetesHelper
	kh = KubernetesHelper(about.program_suite_name, about.program_suite_version, None)

	join_token = kh.get_join_token()
	if len(join_token) == 0:
		retval = iktinput([("Error: ", "error"), ("No join token found; create a one now? (No will abort the installation) [y/", "default"), ("N", "emphasis"), ("]: ", "default")])
		if retval.lower() not in ["y", "yes"]:
			iktprint([("\nAborting: ", "error"), ("No join token available.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			create_join_token_playbooks = [
				f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_create_join_token.yaml",
			]
			playbooks = populate_playbooks_from_paths(create_join_token_playbooks)
			retval = run_playbooks(playbooks = playbooks, hosts = controlplanes)
			join_token = kh.get_join_token()
			if len(join_token) == 0:
				iktprint([("Critical: ", "critical"), ("failed to create join token; aborting", "default")], stderr = True)
				sys.exit(errno.EINVAL)

	ca_cert_hash = ""
	if len(ca_cert_path) == 0:
		ca_cert_hash = kh.get_ca_cert_hash()
	if len(ca_cert_hash) == 0:
		if len(ca_cert_path) == 0:
			ca_cert_path = "/etc/kubernetes/pki/ca.crt"
		retval = iktinput([("Warning: ", "warning"), ("Could not find ", "default"), ("ca.crt", "path"), (" or a certificate-controller-token secret; try to use ", "default"), (ca_cert_path, "path"), ("? No will abort the installation) [y/", "default"), ("N", "emphasis"), ("]: ", "default")])
		if retval.lower() not in ["y", "yes"]:
			iktprint([("\nAborting: ", "error"), ("No CA certificate available.", "default")], stderr = True)
			sys.exit(errno.EINTR)
		else:
			ca_cert = ""
			with open(ca_cert_path) as f:
				ca_cert = f.read()
			ca_cert_hash = ""
			if len(ca_cert) > 0:
				x509obj = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, ca_cert)
				pubkey = x509obj.get_pubkey()
				pubkeyasn1 = OpenSSL.crypto.dump_publickey(OpenSSL.crypto.FILETYPE_ASN1, pubkey)
				ca_cert_hash = hashlib.sha256(pubkeyasn1).hexdigest()

			if len(ca_cert_hash) == 0:
				iktprint([("\nAborting: ", "error"), ("No CA certificate available.", "default")], stderr = True)
				sys.exit(errno.EINTR)

	control_plane_ip, control_plane_port = kh.get_control_plane_address()
	# Now that we have the IP address of the API-server we can use that to get the package
	# version for kubeadm
	retval, ansible_results = ansible_run_playbook_on_host_list(f"{ANSIBLE_PLAYBOOK_DIR}/get_versions.yaml", hosts = [control_plane_ip])
	if len(ansible_results) == 0:
		iktprint([("Error: ", "error"), ("Failed to get package versions from control-plane at {control_plane_ip} (retval: {retval}); aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	for host in ansible_results:
		data = ansible_results[host]

		for task in data:
			if "package versions" in task.replace("_", " "):
				tmp = str(data[task].get("msg", "")).split("\n")

	if len(tmp) == 0:
		iktprint([("Error: ", "error"), ("Failed to get package versions from control-plane at {control_plane_ip} (playbook returned no valid data); aborting.", "default")], stderr = True)
		sys.exit(errno.BADMSG)

	kubeadm_version = ""
	for line in tmp:
		tmp = re.match(r"^(.*?): (.*)", line)
		if tmp is None:
			continue
		if tmp[1] == "kubeadm":
			kubeadm_version = tmp[2]
			break

	if len(kubeadm_version) == 0:
		iktprint([("Error: ", "error"), ("Failed to get ", "default"), ("kubeadm", "programname"), (" package version from control-plane at {control_plane_ip}; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# 1.24.2-00
	_version = kubeadm_version.split(".")
	if int(_version[1]) >= 24:
		if cri == "dockershim":
			iktprint([("Error: ", "error"), ("CRI cannot be “", "default"), ("dockershim", "argument"), ("“ for ", "default"), ("Kubernetes ", "programname"), (">= ", "default"), ("1.24", "version"), ("; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		elif cri is None:
			cri = "containerd"
	else:
		if cri is None:
			cri = "dockershim"

	add_playbooks = [
		# ikt doesn't use run_before/run_after/add_to_groups/remove_from_groups,
		# so we have to do all of that explicitly
		f"{ANSIBLE_PLAYBOOK_DIR}/add_kubernetes_repo.yaml",
		f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_setup_node.yaml",
	]
	playbooks = populate_playbooks_from_paths(add_playbooks)

	extra_values = {
		"control_plane_ip": control_plane_ip,
		"control_plane_port": control_plane_port,
		"join_token": join_token,
		"ca_cert_hash": ca_cert_hash,
		"control_plane_k8s_version": kubeadm_version,
		"cri": cri,
	}
	retval = run_playbooks(playbooks = playbooks, hosts = non_existing, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = non_existing, group = "nodes", skip_all = True)
	# XXX: We need to get the cluster name to do this
	#ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = non_existing, group = cluster_name, skip_all = True)
	iktprint([("\nNodes successfully added", "success")])

def remove_nodes(options = [], args = None):
	force = False
	purge = False

	selection = args[0].split(",")

	for opt, optarg in options:
		if opt == "--force":
			force = True
		elif opt == "--purge":
			purge = True
		elif opt == "--save-ansible-logs":
			ansible_configuration.save_logs = True
		elif opt == "--forks":
			ansible_configuration.forks = optarg
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0 and args[0] != "ALL":
		iktprint([(f"Error: ", "error")] + join_tuple_list(controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are control-plane(s) and should be removed using ", "default"), (f"{about.admin_program_name}", "programname"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(non_existing) > 0:
		if force == False:
			iktprint([(f"Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			iktprint([(f"Warning: ", "warning")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; attempting to purge them anyway since “", "description"), ("--force", "argument"), ("“ was specified.", "default")], stderr = True)
			nodes += non_existing

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	iktprint([("\n[Removing nodes]", "phase")])
	iktprint([("\n• ", "separator"), ("Deleting nodes from the cluster", "action")])
	delete_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/delete_node.yaml",
	]
	playbooks = populate_playbooks_from_paths(delete_playbooks)

	extra_values = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	elif force == True:
		iktprint([("NOT OK", "warning"), ("; ignoring since “", "description"), ("--force", "argument"), ("“ was specified.", "default")], stderr = True)
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	iktprint([("\n• ", "separator"), ("Tearing down Kubernetes on the nodes", "action")])
	teardown_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_teardown_node.yaml",
		f"{ANSIBLE_PLAYBOOK_DIR}/teardown_cni.yaml",
	]
	playbooks = populate_playbooks_from_paths(teardown_playbooks)

	extra_values = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	iktprint([("\nNodes successfully removed from cluster", "success")])

	if purge == True:
		purge_hosts(options = [("--ignore-non-existing", None)], args = [",".join(nodes)])

	iktprint([("\n• ", "separator"), ("Removing nodes from the inventory", "action")])
	ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = nodes, group = "nodes")
	# XXX: We need to get the cluster name to do this
	#ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = nodes, group = cluster_name)

def purge_hosts(options = [], args = None):
	ignore_non_existing = False

	selection = args[0].split(",")

	if "ALL" in selection:
		iktprint([("Error: ", "error"), ("ALL", "hostname"), (" cannot be used with ", "default"), ("purge", "command"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for opt, optarg in options:
		if opt == "--ignore-non-existing":
			ignore_non_existing = True
		elif opt == "--save-ansible-logs":
			ansible_configuration.save_logs = True
		elif opt == "--forks":
			ansible_configuration.forks = optarg
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0:
		iktprint([(f"Error: ", "error")] + join_tuple_list(controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are control-plane(s) and should be removed using ", "default"), (f"{about.admin_program_name}", "programname"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(nodes) > 0:
		iktprint([(f"Error: ", "error")] + join_tuple_list(nodes, _tuple = "hostname", separator = (",", "separator")) + [(" are still node(s) in the cluster; please run ", "default"), (f"{about.tool_program_name}", "programname"), (" remove-node", "command"), (" first to remove them from the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.EBUSY)

	hosts = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")

	not_in_inventory = []
	for host in selection:
		if host not in hosts:
			not_in_inventory.append(host)
			selection.remove(host)

	if len(not_in_inventory) > 0:
		if ignore_non_existing == False:
			iktprint([(f"Error: ", "error")] + join_tuple_list(not_in_inventory, _tuple = "hostname", separator = (",", "separator")) + [(" are not in the inventory; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			iktprint([(f"Warning: ", "warning")] + join_tuple_list(not_in_inventory, _tuple = "hostname", separator = (",", "separator")) + [(" are not in the inventory; ignoring them since “", "description"), ("--ignore-non-existing", "argument"), ("“ was specified.", "default")], stderr = True)

	if len(selection) == 0:
		iktprint([(f"Error: ", "error"), (" none of the specified hosts are part of the inventory; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	iktprint([("\n• ", "separator"), ("Purging Kubernetes from the hosts", "action")])
	purge_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_purge.yaml",
	]
	playbooks = populate_playbooks_from_paths(purge_playbooks)

	hosts = selection

	extra_values = {
		"packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
			"kubernetes-cni",
		],
		"held_packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
		]
	}
	retval = run_playbooks(playbooks = playbooks, hosts = hosts, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	iktprint([("\nHosts successfully purged", "success")])

def upgrade_nodes(options = [], args = None):
	selection = args[0].split(",")

	for opt, optarg in options:
		if opt == "--save-ansible-logs":
			ansible_configuration.save_logs = True
		elif opt == "--forks":
			ansible_configuration.forks = optarg
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0 and args[0] != "ALL":
		iktprint([(f"Error: ", "error")] + join_tuple_list(controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are control-plane(s) and should be upgraded using ", "default"), (f"{about.admin_program_name}", "programname"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(non_existing) > 0:
		iktprint([(f"Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	iktprint([("\n[Upgrading nodes]", "phase")])
	iktprint([("\n• ", "separator"), ("Drain nodes", "action")])
	drain_options = {
		("--delete-emptydir-data", None),
		("--disable-eviction", None),
		("--ignore-daemonsets", None),
		("--no-header", None),
	}
	drain_nodes(options = drain_options, args = [",".join(nodes)])

	iktprint([("\n• ", "separator"), ("Run upgrade playbooks on nodes", "action")])
	upgrade_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_upgrade_node.yaml",
	]
	playbooks = populate_playbooks_from_paths(upgrade_playbooks)

	extra_values = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	iktprint([("\n• ", "separator"), ("Uncordon nodes", "action")])
	uncordon_nodes(args = [",".join(nodes)])

	iktprint([("\nNode upgrade successful", "success")])

def get_resource(options = [], args = None):
	namespaces = ["default"]

	for opt, optarg in options:
		# This is a tuple option, so the easiest way is to check this way
		if "--all-namespaces" in opt:
			namespaces = None
		elif "--namespace" in opt:
			namespaces = optarg.split(",")
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	# We might have to get the resources across multiple namespaces, so we need to do multiple requests
	return

ikt_commandline = {
	"Cordon Node": {
		"command": ["cordon"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Cordon ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"min_args": 1,
		"max_args": 1,
		"callback": cordon_nodes,
		"options": {
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
	},
	"Drain Node": {
		"command": ["drain"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Drain ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"min_args": 1,
		"max_args": 1,
		"options": {
			"--delete-emptydir-data": {
				"description": [("Drain nodes even if this would cause ", "description"), ("emptyDir", "emphasis"), (" data to be deleted", "description")],
			},
			"--delete-local-data": {
				"description": [("This is an alias for “", "description"), ("--delete-emptydir-data", "option"), ("“", "description")],
			},
			"--disable-eviction": {
				"description": [("Delete pods instead of using evict; this bypasses ", "description"), ("PodDisruptionBudget", "emphasis")],
			},
			"--ignore-daemonsets": {
				"description": [("Ignore pods managed by daemonsets; by default ", "description"), ("drain ", "command"), ("will abort if there are such pods running on the node", "description")],
			},
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
		"callback": drain_nodes,
	},
	"Drain Node (Force)": {
		"command": ["force-drain"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Force-drain ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"extended_description": [
			[("When a node is force-drained, pods belonging to daemonsets are ignored, and ", "description"), ("emptyDir", "emphasis"), (" data is deleted", "description")],
		],
		"min_args": 1,
		"max_args": 1,
		"options": {
			"--disable-eviction": {
				"description": [("Delete pods instead of using evict; this bypasses ", "description"), ("PodDisruptionBudget", "emphasis")],
			},
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
		"implicit_options": [
			("--delete-emptydir-data", None),
			("--ignore-daemonsets", None),
		],
		"callback": drain_nodes,
	},
	"Uncordon Node": {
		"command": ["uncordon"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Uncordon ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"min_args": 1,
		"max_args": 1,
		"callback": uncordon_nodes,
		"options": {
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
	},
	"Prepare Host": {
		"command": ["prepare"],
		"values": [("HOST", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Prepare ", "description"), ("HOST", "argument"), (",", "separator"), ("...", "argument"), (" for use as a node in a Kubernetes cluster", "description")],
		"min_args": 1,
		"max_args": 1,
		"callback": prepare_hosts,
		"options": {
			"--ignore-existing": {
				"description": [("Ignore hosts that are already part of the cluster", "description")],
			},
			"--forks": {
				"values": [("FORKS", "argument")],
				"description": [("Max number of parallel connections when running Ansible playbooks (overrides ", "description"), ("ikt.yaml", "argument"), ("; default: ", "description"), ("5", "argument"), (")", "description")],
				"requires_arg": True,
			},
			"--no-password": {
				"description": [("Do not prompt for a password; use this if the hosts you're preparing are already configured for login using an SSH key", "description")],
			},
			"--save-ansible-logs": {
				"description": [("Save logs from Ansible runs; the logs can be viewed using “", "description"), ("iku", "programname"), (" logs", "command"), ("“", "description")]
			},
		},
	},
	"Add Node": {
		"command": ["add-node", "add-nodes"],
		"values": [("HOST", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Add ", "description"), ("HOST", "argument"), (",", "separator"), ("...", "argument"), (" as Kubernetes nodes to a cluster", "description")],
		"min_args": 1,
		"max_args": 1,
		"callback": add_nodes,
		"options": {
			"--ca-cert-file": {
				"values": [("PATH", "argument")],
				"description": [("Use ", "description"), ("PATH", "argument"), (" as token CA certificate", "description")],
				"requires_arg": True,
			},
			"--cri": {
				"values": [("CRI", "argument")],
				"description": [("Use ", "description"), ("CRI", "argument"), (" instead of the default CRI", "description")],
				"extended_description": [
					[("Valid options for CRI (Container Runtime Interface) are:", "description")],
					[
						("dockershim", "argument"), (" (", "description"), ("Kubernetes", "programname"), (" < ", "description"), ("1.24", "version"), (")", "description"), (", ", "separator"),
						("containerd", "argument"), (", ", "separator"),
					],
					[
						("manual", "argument"), (" (do not install a CRI; this requires you to manually install and configure the CRI)", "description"),
					],
					[("The default CRI is ", "description"), ("dockershim", "argument"), (" for ", "description"), ("Kubernetes", "programname"), (" < ", "description"), ("1.24", "version")],
					[("and ", "description"), ("containerd", "argument"), (" for ", "description"), ("Kubernetes", "programname"), (" >= ", "description"), ("1.24", "version")],
				],
				"requires_arg": True,
			},
			"--forks": {
				"values": [("FORKS", "argument")],
				"description": [("Max number of parallel connections when running Ansible playbooks (overrides ", "description"), ("ikt.yaml", "argument"), ("; default: ", "description"), ("5", "argument"), (")", "description")],
				"requires_arg": True,
			},
			"--ignore-existing": {
				"description": [("Ignore hosts that are already part of the cluster", "description")],
			},
			"--ignore-non-existing": {
				"description": [("Ignore hosts that are not part of the inventory", "description")],
			},
			"--save-ansible-logs": {
				"description": [("Save logs from Ansible runs; the logs can be viewed using “", "description"), ("iku", "programname"), (" logs", "command"), ("“", "description")]
			},
		},
	},
	"Remove Node": {
		"command": ["remove-node", "remove-nodes"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Remove ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument"), (" from a Kubernetes cluster", "description")],
		"min_args": 1,
		"max_args": 1,
		"callback": remove_nodes,
		"options": {
			"--force": {
				"description": [("Attempt to teardown Kubernetes nodes that are no longer in the cluster", "description")],
			},
			"--forks": {
				"values": [("FORKS", "argument")],
				"description": [("Max number of parallel connections when running Ansible playbooks (overrides ", "description"), ("ikt.yaml", "argument"), ("; default: ", "description"), ("5", "argument"), (")", "description")],
				"requires_arg": True,
			},
			"--purge": {
				"description": [("Purge hosts if teardown completes successfully", "description")],
			},
			"--save-ansible-logs": {
				"description": [("Save logs from Ansible runs; the logs can be viewed using “", "description"), ("iku", "programname"), (" logs", "command"), ("“", "description")]
			},
		},
	},
	"Purge": {
		"command": ["purge"],
		"values": [("HOST", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Remove Kubernetes configuration and packages from ", "description"), ("HOST", "argument")],
		"min_args": 1,
		"max_args": 1,
		"callback": purge_hosts,
		"options": {
			"--ignore-non-existing": {
				"description": [("Ignore hosts that cannot be found in the inventory", "description")],
			},
			"--forks": {
				"values": [("FORKS", "argument")],
				"description": [("Max number of parallel connections when running Ansible playbooks (overrides ", "description"), ("ikt.yaml", "argument"), ("; default: ", "description"), ("5", "argument"), (")", "description")],
				"requires_arg": True,
			},
			"--save-ansible-logs": {
				"description": [("Save logs from Ansible runs; the logs can be viewed using “", "description"), ("iku", "programname"), (" logs", "command"), ("“", "description")]
			},
		},
	},
	"Upgrade Node": {
		"command": ["upgrade-node", "upgrade-nodes"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Upgrade Kubernetes on ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"extended_description": [
			[("Upgrade Kubernetes on ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument"), (" to the version in use on the control-plane(s);", "description")],
			[("run this on all nodes after running “", "description"), (f"{about.admin_program_name}", "programname"), (" upgrade-control-plane", "command"), ("“", "description")],
		],
		"min_args": 1,
		"max_args": 1,
		"callback": upgrade_nodes,
		"options": {
			"--forks": {
				"values": [("FORKS", "argument")],
				"description": [("Max number of parallel connections when running Ansible playbooks (overrides ", "description"), ("ikt.yaml", "argument"), ("; default: ", "description"), ("5", "argument"), (")", "description")],
				"requires_arg": True,
			},
			"--save-ansible-logs": {
				"description": [("Save logs from Ansible runs; the logs can be viewed using “", "description"), ("iku", "programname"), (" logs", "command"), ("“", "description")]
			},
		},
	},
#	"Get": {
#		"command": ["get", "l", "list"],
#		"values": [("RESOURCE", "argument"), (",", "separator"), ("...", "argument")],
#		"description": [("List information about ", "description"), ("RESOURCE", "argument"), (",", "separator"), ("...", "argument")],
#		"min_args": 1,
#		"max_args": 1,
#		"options": {
#			("-N", "--namespace"): {
#				"values": [("NAMESPACE", "argument"), (",", "separator"), ("...", "argument")],
#				"description": [("Only show resources belonging to ", "description"), ("NAMESPACE", "argument"), (",", "separator"), ("...", "argument")],
#				"requires_arg": True,
#			},
#			("-A", "--all-namespaces"): {
#				"description": [("Show resources across all namespaces", "description")],
#			},
#		},
#		"callback": get_resource,
#	},
	"extended_description": [
		[("You can use “", "description"), ("ALL", "emphasis"), ("“ as a substitute for all resources in most cases;", "description")],
		[("for instance “", "description"), (f"{about.tool_program_name}", "programname"), (" upgrade-node ", "command"), ("ALL", "emphasis"), ("“ will upgrade Kubernetes on all nodes", "description")],
		[("", "default")],
		[("Note that “", "description"), ("ALL", "emphasis"), ("“ excludes control planes when used on nodes; to include control planes", "description")],
		[("you need to pass the “", "description"), ("--include-control-planes", "option"), ("“ option (where available)", "description")],
	]
}

def get_programname(callname):
	callnames = {
		"ikt": ikt_commandline,		# main name
		#"iktdep": dep_commandline,	# deployment shortcut
		#"iktds": ds_commandline,	# daemon set shortcut
		#"iktrs": rs_commandline,	# replica set shortcut
		#"iktjob": job_commandline,	# job shortcut
		#"iktnode": node_commandline,	# node shortcut
		#"iktpod": pod_commandline,	# pod shortcut
	}

	if callname not in callnames:
		sys.exit(f"{about.tool_program_name} called with unknown name {callname}; aborting.")

	return callname, callnames[callname]

def main():
	global iktconfig
	global programname
	argv = sys.argv

	init_iktprint(THEME_PATH)
	programname, commandline = get_programname(os.path.basename(argv[0]))

	command, options, args = parse_commandline(programname, about.tool_program_version, PROGRAMDESCRIPTION, PROGRAMAUTHORS, argv, commandline)
	iktconfig = iktlib.read_iktconfig()

	# Used by the ansible module
	ansible_configuration.ansible_forks = deep_get(iktconfig, "Ansible#forks", 5)
	ansible_user = deep_get(iktconfig, "Ansible#ansible_user")
	if ansible_user is None or len(ansible_user) == 0:
		ansible_user = getuser()
	ansible_configuration.ansible_user = ansible_user
	ansible_password = deep_get(iktconfig, "Ansible#ansible_password")
	if ansible_password is not None and len(ansible_password) > 0:
		ansible_configuration.ansible_password = ansible_password
	ansible_configuration.disable_strict_host_key_checking = deep_get(iktconfig, "Nodes#disablestricthostkeychecking", False)
	ansible_configuration.save_logs = deep_get(iktconfig, "Ansible#save_logs", False)

	return command(options, args)

if __name__ == "__main__":
	main()
