#! /usr/bin/env python3
# Requires: ansible
# Requires: python3 (>= 3.6)
# Requires: python3-natsort
# Requires: python3-openssl
# Recommends: python3-ujson

from functools import reduce
from getpass import getuser
import os
from pathlib import Path
import re
import subprocess
from subprocess import PIPE, STDOUT
import sys
import yaml

try:
	from natsort import natsorted
except ModuleNotFoundError:
	sys.exit("ModuleNotFoundError: you probably need to install python3-natsort")

try:
	import OpenSSL
except ModuleNotFoundError:
	sys.exit("ModuleNotFoundError: you probably need to install python3-openssl")

from commandparser import parse_commandline

from ansible_helper import ansible_configuration, ansible_set_vars, ansible_run_playbook_on_selection, ansible_get_hosts_by_group, ansible_remove_hosts
from ansible_helper import ANSIBLE_PLAYBOOK_DIR, ANSIBLE_INVENTORY

import iktlib
from iktlib import deep_get, join_tuple_list

HOMEDIR = str(Path.home())
IKTDIR = f"{HOMEDIR}/.ikt"

THEME_DIRNAME = "themes"
THEMEDIR = f"{IKTDIR}/{THEME_DIRNAME}"
THEME_PATH = f"{THEMEDIR}/default.yaml"

from iktprint import iktprint, init_iktprint

import about
PROGRAMDESCRIPTION = "Commandline tool for managing Kubernetes clusters"
PROGRAMAUTHORS = "Written by David Weinehall."

iktconfig = None

def run_playbook(playbookpath, hosts = None, extra_values = {}, quiet = False):
	# Set necessary Ansible keys before running playbooks
	http_proxy = deep_get(iktconfig, "Network#http_proxy", "")
	if http_proxy is None:
		http_proxy = ""
	https_proxy = deep_get(iktconfig, "Network#https_proxy", "")
	if https_proxy is None:
		https_proxy = ""
	no_proxy = deep_get(iktconfig, "Network#no_proxy", "")
	if no_proxy is None:
		no_proxy = ""
	insecure_registries = deep_get(iktconfig, "Docker#insecure_registries", [])
	registry_mirrors = deep_get(iktconfig, "Containerd#registry_mirrors", [])
	retval = 0

	use_proxy = "no"
	if len(http_proxy) > 0 or len(https_proxy) > 0:
		use_proxy = "yes"

	values = {
		"http_proxy": http_proxy,
		"https_proxy": https_proxy,
		"no_proxy": no_proxy,
		"insecure_registries": insecure_registries,
		"registry_mirrors": registry_mirrors,
		"use_proxy": use_proxy,
	}
	merged_values = { **values, **extra_values }

	if hosts is None:
		retval, ansible_results = ansible_run_playbook(playbookpath, values = merged_values)
	else:
		retval, ansible_results = ansible_run_playbook_on_selection(playbookpath, selection = hosts, values = merged_values)

	for host in ansible_results:
		data = ansible_results[host]
		if retval == 0 and quiet == True:
			break

		# RUN_ERROR = 1
		# RUN_FAILED_HOSTS = 2
		# RUN_UNREACHABLE_HOSTS = 4
		# RUN_FAILED_BREAK_PLAY = 8
		extra_status = ""
		if retval & 1 == 1:
			extra_status += " Error,"
		if retval & 2 == 2:
			extra_status += " Failed hosts,"
		if retval & 4 == 4:
			extra_status += " host unreachable,"
		if retval & 8 == 8:
			extra_status += " Failed break play,"

		extra_status = extra_status.rstrip(",")

		if retval == 0:
			iktprint([(f"    [{host}]", "success")])
		else:
			iktprint([(f"    [{host}]", "error"), (extra_status, "errorvalue")])

		for task in ansible_results[host]:
			taskname = task[len("TASK: "):]
			iktprint([(f"      {taskname}:", "default")])
			msg = data[task].get("msg", "").splitlines()
			if len(msg) > 0:
				iktprint([(f"        ", "default"), ("msg:", "header")])
				for line in msg:
					iktprint([(f"        {line}", "default")])
				iktprint([("", "default")])
			stdout_lines = data[task].get("stdout_lines", [])
			if len(stdout_lines) > 0:
				iktprint([(f"        ", "default"), ("stdout:", "header")])
				for line in data[task]["stdout_lines"]:
					iktprint([(f"        {line}", "default")])
				iktprint([("", "default")])
			stderr_lines = data[task].get("stderr_lines", [])
			if len(stderr_lines) > 0:
				iktprint([(f"        ", "default"), ("stderr:", "header")])
				for line in data[task]["stderr_lines"]:
					iktprint([(f"        {line}", "default")])
				iktprint([("", "default")])
			if len(msg) == 0 and len(stdout_lines) == 0 and len(stderr_lines) == 0:
				iktprint([(f"        <no output>", "none")])
				iktprint([("", "default")])

	return retval, ansible_results

def run_playbooks(playbooks, hosts = None, extra_values = {}):
	for string, playbookpath in playbooks:
		iktprint(string)
		retval, ansible_results = run_playbook(playbookpath, hosts = hosts, extra_values = extra_values)

		# We don't want to continue executing playbooks if the first one failed
		if retval != 0:
			break

	return retval == 0

# Add all playbooks in the array
def populate_playbooks_from_paths(paths):
	playbooks = []

	for playbookpath in paths:
		# Only process playbooks
		tmp = re.match(r"(.*)\.ya?ml$", os.path.basename(playbookpath))
		if tmp is None:
			raise Exception(f"The playbook filename “{os.path.basename(playbookpath)}“ does not end with .yaml or .yml; this is most likely a programming error.")

		playbookname = tmp[1]
		description = None
		with open(playbookpath) as f:
			d = yaml.safe_load(f)
			description = [(deep_get(d[0], "vars#metadata#description"), "play")]

		if description is None or len(description) == 0:
			description = [("Running “", "play"), (playbookname, "programname"), ("“", "play")]

		# If there's no description we fallback to just using the filename
		playbooks.append(([("  • ", "separator")] + description, playbookpath))

	return playbooks

# This executes a command without capturing the output
def execute_command(args, env = None):
	if env is None:
		retval = subprocess.run(args)
	else:
		retval = subprocess.run(args, env = env)
	return retval.returncode == 0

# This executes a command with the output captured
def execute_command_with_response(args):
	result = subprocess.run(args, stdout = PIPE, stderr = STDOUT, check = False)
	return result.stdout.decode("utf-8")

def get_selection(selection, kind = None, default = None, skip_control_planes = True):
	all_items = False
	items1 = []
	non_existing = []
	# Only used for controlplanes
	items2 = []

	if kind is None:
		raise Exception("Kind is None; this is a programming error")

	if selection is None:
		if default is None:
			raise Exception("Both selection and default is None; this is a programming error")
		selection = default

	if "ALL" in selection:
		if len(selection) > 1:
			iktprint([("Error: ", "error"), ("“", "default"), ("ALL", "argument"), ("“ cannot be combined with other arguments; aborting.", "default")], stderr = True)
			sys.exit(2)
		else:
			all_items = True

	# Kubernetes resources
	if type(kind) == tuple:
		from kubernetes_helper import KubernetesHelper
		kh = KubernetesHelper(about.program_suite_name, about.program_suite_version, None)

		vlist = kh.get_list_by_kind_namespace(("Node", ""), "")
		if vlist is not None:
			for node in vlist:
				name = deep_get(node, "metadata#name")
				if all_items == False and name not in selection:
					continue

				if kind == ("Node", "") and skip_control_planes == True:
					node_roles = kh.get_node_roles(node)
					if "control-plane" in node_roles:
						items2.append(name)
						continue

				items1.append(name)
	# str kinds are things such as playbooks; for now iKT doesn't use them

	# Finally, generate a list of non-existing items
	if all_items == False:
		for item in selection:
			if item not in items1 + items2:
				non_existing.append(item)

	return items1, non_existing, items2

def cordon_nodes(options = None, args = None):
	include_control_planes = False
	header = True

	_args = ["kubectl", "cordon"]

	for opt, optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")

	# It's OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(non_existing) > 0:
		iktprint([(f"Error: ", "error"), join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")), (" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(2)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(2)

	if header == True:
		iktprint([("\n[Cordoning nodes]", "phase")])
	_args += nodes
	execute_command(_args)

def drain_nodes(options = None, args = None):
	include_control_planes = False
	header = True

	# Check kubectl version
	_args = ["kubectl", "version"]
	response = execute_command_with_response(_args).splitlines()
	tmp = re.match(r"^Client Version: version.Info{Major:\"(.)\", Minor:\"(.+?)\"", response[0])

	_args = ["kubectl", "drain"]

	for opt, optarg in options:
		if opt in ["--delete-emptydir-data", "--delete-local-data"]:
			if int(tmp[1]) >= 1 and int(tmp[2]) >= 20:
				_args.append("--delete-emptydir-data")
			else:
				_args.append("--delete-local-data")
		elif opt == "--disable-eviction":
			if int(tmp[1]) >= 1 and int(tmp[2]) >= 18:
				_args.append(opt)
		elif opt == "--ignore-daemonsets":
			_args.append(opt)
		elif opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")

	# It's OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(non_existing) > 0:
		iktprint([(f"Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(2)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(2)

	if header == True:
		iktprint([("\n[Draining nodes]", "phase")])
	_args += nodes
	execute_command(_args)

def uncordon_nodes(options = None, args = None):
	include_control_planes = False
	header = True

	_args = ["kubectl", "uncordon"]

	for opt, optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")

	# It's OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(non_existing) > 0:
		iktprint([(f"Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(2)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(2)

	if header == True:
		iktprint([("\n[Uncordoning nodes]", "phase")])
	_args += nodes
	execute_command(_args)

def setup_nodes(options = None, args = None):
	return 0

def remove_nodes(options = None, args = None):
	force = False

	selection = args[0].split(",")

	for opt, optarg in options:
		if opt == "--force":
			force = True
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0 and args[0] != "ALL":
		iktprint([(f"Error: ", "error")] + join_tuple_list(controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are control-plane(s) and should be removed using ", "default"), (f"{about.admin_program_name}", "programname"), ("; aborting.", "default")], stderr = True)
		sys.exit(2)

	if len(non_existing) > 0:
		if force == False:
			iktprint([(f"Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(2)
		else:
			iktprint([(f"Warning: ", "warning")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; attempting to purge them anyway since “", "description"), ("--force", "argument"), ("“ was specified.", "default")], stderr = True)
			nodes += non_existing

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(2)

	iktprint([("\n[Removing nodes]", "phase")])
	iktprint([("\n• ", "separator"), ("Deleting nodes from the cluster", "action")])
	delete_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/delete_node.yaml",
	]
	playbooks = populate_playbooks_from_paths(delete_playbooks)

	extra_values = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	elif force == True:
		iktprint([("NOT OK", "notok"), ("; ignoring since “", "description"), ("--force", "argument"), ("“ was specified.", "default")], stderr = True)
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(2)

	iktprint([("\n• ", "separator"), ("Tearing down Kubernetes on the nodes", "action")])
	teardown_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_teardown_node.yaml",
		f"{ANSIBLE_PLAYBOOK_DIR}/teardown_cni.yaml",
	]
	playbooks = populate_playbooks_from_paths(teardown_playbooks)

	extra_values = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(2)

	iktprint([("\n• ", "separator"), ("Removing nodes from the inventory", "action")])
	ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = nodes, group = "nodes")
	# XXX: We need to get the cluster name to do this
	#ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = nodes, group = cluster_name)

	iktprint([("\nNode removal successful", "success")])

def purge_hosts(options = None, args = None):
	ignore_non_existing = False

	selection = args[0].split(",")

	if "ALL" in selection:
		iktprint([("Error: ", "error"), ("ALL", "hostname"), (" cannot be used with ", "default"), ("purge", "command"), ("; aborting.", "default")], stderr = True)
		sys.exit(2)

	for opt, optarg in options:
		if opt == "--ignore-non-existing":
			ignore_non_existing = True
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0:
		iktprint([(f"Error: ", "error")] + join_tuple_list(controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are control-plane(s) and should be removed using ", "default"), (f"{about.admin_program_name}", "programname"), ("; aborting.", "default")], stderr = True)
		sys.exit(2)

	if len(nodes) > 0:
		iktprint([(f"Error: ", "error")] + join_tuple_list(nodes, _tuple = "hostname", separator = (",", "separator")) + [(" are still node(s) in the cluster; please run ", "default"), (f"{about.tool_program_name}", "programname"), (" remove-node", "command"), (" first to remove them from the cluster; aborting.", "default")], stderr = True)
		sys.exit(2)

	hosts = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")

	not_in_inventory = []
	for host in selection:
		if host not in hosts:
			not_in_inventory.append(host)
			selection.remove(host)

	if len(not_in_inventory) > 0:
		if ignore_non_existing == False:
			iktprint([(f"Error: ", "error")] + join_tuple_list(not_in_inventory, _tuple = "hostname", separator = (",", "separator")) + [(" are not in the inventory; aborting.", "default")], stderr = True)
			sys.exit(2)
		else:
			iktprint([(f"Warning: ", "warning")] + join_tuple_list(not_in_inventory, _tuple = "hostname", separator = (",", "separator")) + [(" are not in the inventory; ignoring them since “", "description"), ("--ignore-non-existing", "argument"), ("“ was specified.", "default")], stderr = True)

	if len(selection) == 0:
		iktprint([(f"Error: ", "error"), (" none of the specified hosts are part of the inventory; aborting.", "default")], stderr = True)
		sys.exit(2)

	iktprint([("\n• ", "separator"), ("Purging Kubernetes from the hosts", "action")])
	purge_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_purge.yaml",
	]
	playbooks = populate_playbooks_from_paths(purge_playbooks)

	hosts = selection

	extra_values = {
		"packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
			"kubernetes-cni",
		],
		"held_packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
		]
	}
	retval = run_playbooks(playbooks = playbooks, hosts = hosts, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(2)

	iktprint([("\nHost purge successful", "success")])

def upgrade_nodes(options = None, args = None):
	selection = args[0].split(",")

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0 and args[0] != "ALL":
		iktprint([(f"Error: ", "error")] + join_tuple_list(controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are control-plane(s) and should be upgraded using ", "default"), (f"{about.admin_program_name}", "programname"), ("; aborting.", "default")], stderr = True)
		sys.exit(2)

	if len(non_existing) > 0:
		iktprint([(f"Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(2)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(2)

	iktprint([("\n[Upgrading nodes]", "phase")])
	iktprint([("\n• ", "separator"), ("Drain nodes", "action")])
	drain_options = {
		("--delete-emptydir-data", None),
		("--disable-eviction", None),
		("--ignore-daemonsets", None),
		("--no-header", None),
	}
	drain_nodes(options = drain_options, args = nodes.join(","))

	iktprint([("\n• ", "separator"), ("Run upgrade playbooks on nodes", "action")])
	upgrade_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_upgrade_node.yaml",
	]
	playbooks = populate_playbooks_from_paths(upgrade_playbooks)

	extra_values = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(2)

	iktprint([("\n• ", "separator"), ("Uncordon nodes", "action")])
	uncordon_nodes(args = nodes.join(","))

	iktprint([("\nNode upgrade successful", "success")])

def get_resource(options = None, args = None):
	namespaces = ["default"]

	if options is not None:
		for opt, optarg in options:
			# This is a tuple option, so the easiest way is to check this way
			if "--all-namespaces" in opt:
				namespaces = None
			elif "--namespace" in opt:
				namespaces = optarg.split(",")
			else:
				raise Exception(f"Programming error; invalid option {opt}")

	# We might have to get the resources across multiple namespaces, so we need to do multiple requests
	return

ikt_commandline = {
	"Cordon Node": {
		"command": ["cordon"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Cordon ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"min_args": 1,
		"max_args": 1,
		"callback": cordon_nodes,
		"options": {
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
	},
	"Drain Node": {
		"command": ["drain"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Drain ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"min_args": 1,
		"max_args": 1,
		"options": {
			"--delete-emptydir-data": {
				"description": [("Drain nodes even if this would cause ", "description"), ("emptyDir", "emphasis"), (" data to be deleted", "description")],
			},
			"--delete-local-data": {
				"description": [("This is an alias for “", "description"), ("--delete-emptydir-data", "option"), ("“", "description")],
			},
			"--disable-eviction": {
				"description": [("Delete pods instead of using evict; this bypasses ", "description"), ("PodDisruptionBudget", "emphasis")],
			},
			"--ignore-daemonsets": {
				"description": [("Ignore pods managed by daemonsets; by default ", "description"), ("drain ", "command"), ("will abort if there are such pods running on the node", "description")],
			},
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
		"callback": drain_nodes,
	},
	"Drain Node (Force)": {
		"command": ["force-drain"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Force-drain ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"extended_description": [
			[("When a node is force-drained, pods belonging to daemonsets are ignored, and ", "description"), ("emptyDir", "emphasis"), (" data is deleted", "description")],
		],
		"min_args": 1,
		"max_args": 1,
		"options": {
			"--disable-eviction": {
				"description": [("Delete pods instead of using evict; this bypasses ", "description"), ("PodDisruptionBudget", "emphasis")],
			},
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
		"implicit_options": [
			("--delete-emptydir-data", None),
			("--ignore-daemonsets", None),
		],
		"callback": drain_nodes,
	},
	"Uncordon Node": {
		"command": ["uncordon"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Uncordon ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"min_args": 1,
		"max_args": 1,
		"callback": uncordon_nodes,
		"options": {
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
	},
	"Remove Node": {
		"command": ["remove-node"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Remove ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument"), (" from a Kubernetes cluster", "description")],
		"min_args": 1,
		"max_args": 1,
		"callback": remove_nodes,
		"options": {
			"--force": {
				"description": [("Attempt to teardown Kubernetes nodes that are no longer in the cluster", "description")],
			},
		},
	},
	"Purge": {
		"command": ["purge"],
		"values": [("HOST", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Remove Kubernetes configuration and packages from ", "description"), ("HOST", "argument")],
		"min_args": 1,
		"max_args": 1,
		"callback": purge_hosts,
		"options": {
			"--ignore-non-existing": {
				"description": [("Ignore hosts that cannot be found in the inventory", "description")],
			},
		},
	},
	"Upgrade Node": {
		"command": ["upgrade-node"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Upgrade Kubernetes on ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"extended_description": [
			[("Upgrade Kubernetes on ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument"), (" to the version in use on the control-plane(s);", "description")],
			[("run this on all nodes after running “", "description"), (f"{about.admin_program_name}", "programname"), (" upgrade-control-plane", "command"), ("“", "description")],
		],
		"min_args": 1,
		"max_args": 1,
		"callback": upgrade_nodes,
	},
#	"Get": {
#		"command": ["get", "l", "list"],
#		"values": [("RESOURCE", "argument"), (",", "separator"), ("...", "argument")],
#		"description": [("List information about ", "description"), ("RESOURCE", "argument"), (",", "separator"), ("...", "argument")],
#		"min_args": 1,
#		"max_args": 1,
#		"options": {
#			("-N", "--namespace"): {
#				"values": [("NAMESPACE", "argument"), (",", "separator"), ("...", "argument")],
#				"description": [("Only show resources belonging to ", "description"), ("NAMESPACE", "argument"), (",", "separator"), ("...", "argument")],
#				"requires_arg": True,
#			},
#			("-A", "--all-namespaces"): {
#				"description": [("Show resources across all namespaces", "description")],
#			},
#		},
#		"callback": get_resource,
#	},
	"extended_description": [
		[("You can use “", "description"), ("ALL", "emphasis"), ("“ as a substitute for all resources in most cases;", "description")],
		[("for instance “", "description"), (f"{about.tool_program_name}", "programname"), (" upgrade-node ", "command"), ("ALL", "emphasis"), ("“ will upgrade Kubernetes on all nodes", "description")],
		[("", "default")],
		[("Note that “", "description"), ("ALL", "emphasis"), ("“ excludes control planes when used on nodes; to include control planes", "description")],
		[("you need to pass the “", "description"), ("--include-control-planes", "option"), ("“ option (where available)", "description")],
	]
}

def get_programname(callname):
	callnames = {
		"ikt": ikt_commandline,		# main name
		#"iktdep": dep_commandline,	# deployment shortcut
		#"iktds": ds_commandline,	# daemon set shortcut
		#"iktrs": rs_commandline,	# replica set shortcut
		#"iktjob": job_commandline,	# job shortcut
		#"iktnode": node_commandline,	# node shortcut
		#"iktpod": pod_commandline,	# pod shortcut
	}

	if callname not in callnames:
		sys.exit(f"{about.tool_program_name} called with unknown name {callname}; aborting.")

	return callname, callnames[callname]

def main():
	global iktconfig
	global programname
	argv = sys.argv

	init_iktprint(THEME_PATH)
	programname, commandline = get_programname(os.path.basename(argv[0]))

	command, options, args = parse_commandline(programname, about.tool_program_version, PROGRAMDESCRIPTION, PROGRAMAUTHORS, argv, commandline)
	iktconfig = iktlib.read_iktconfig()

	# Used by the ansible module
	ansible_configuration.ansible_forks = deep_get(iktconfig, "Ansible#forks", 5)
	ansible_user = deep_get(iktconfig, "Ansible#ansible_user")
	if ansible_user is None or len(ansible_user) == 0:
		ansible_user = getuser()
	ansible_configuration.ansible_user = ansible_user
	ansible_password = deep_get(iktconfig, "Ansible#ansible_password")
	if ansible_password is not None and len(ansible_password) > 0:
		ansible_configuration.ansible_password = ansible_password
	ansible_configuration.disable_strict_host_key_checking = deep_get(iktconfig, "Nodes#disablestricthostkeychecking", False)
	ansible_configuration.save_logs = deep_get(iktconfig, "Ansible#save_logs", False)

	return command(options, args)

if __name__ == "__main__":
	main()
