#! /usr/bin/env python3
# Requires: ansible
# Requires: python3 (>= 3.6)
# Requires: python3-natsort
# Requires: python3-openssl
# Recommends: python3-ujson

from functools import reduce
from getpass import getuser
import os
from pathlib import Path
import re
import subprocess
from subprocess import PIPE, STDOUT
import sys
import yaml

try:
	from natsort import natsorted
except ModuleNotFoundError:
	sys.exit("ModuleNotFoundError: you probably need to install python3-natsort")

try:
	import OpenSSL
except ModuleNotFoundError:
	sys.exit("ModuleNotFoundError: you probably need to install python3-openssl")

from commandparser import parse_commandline

from ansible_helper import ansible_configuration, ansible_set_vars, ansible_run_playbook_on_selection, ansible_get_hosts_by_group
from ansible_helper import ANSIBLE_PLAYBOOK_DIR, ANSIBLE_INVENTORY

import iktlib
from iktlib import deep_get

HOMEDIR = str(Path.home())
IKTDIR = f"{HOMEDIR}/.ikt"

THEME_DIRNAME = "themes"
THEMEDIR = f"{IKTDIR}/{THEME_DIRNAME}"
THEME_PATH = f"{THEMEDIR}/default.yaml"

from iktprint import iktprint, init_iktprint

import about
PROGRAMNAME = "ikt"
PROGRAMVERSION = "0.1"
PROGRAMDESCRIPTION = "Commandline tool for managing Kubernetes clusters"
PROGRAMAUTHORS = "Written by David Weinehall."

iktconfig = None

def run_playbook(playbookpath, hosts = None, extra_values = {}, quiet = False):
	# Set necessary Ansible keys before running playbooks
	http_proxy = deep_get(iktconfig, "Network#http_proxy", "")
	if http_proxy is None:
		http_proxy = ""
	https_proxy = deep_get(iktconfig, "Network#https_proxy", "")
	if https_proxy is None:
		https_proxy = ""
	no_proxy = deep_get(iktconfig, "Network#no_proxy", "")
	if no_proxy is None:
		no_proxy = ""
	insecure_registries = deep_get(iktconfig, "Docker#insecure_registries", [])
	registry_mirrors = deep_get(iktconfig, "Containerd#registry_mirrors", [])
	retval = 0

	use_proxy = "no"
	if len(http_proxy) > 0 or len(https_proxy) > 0:
		use_proxy = "yes"

	values = {
		"http_proxy": http_proxy,
		"https_proxy": https_proxy,
		"no_proxy": no_proxy,
		"insecure_registries": insecure_registries,
		"registry_mirrors": registry_mirrors,
		"use_proxy": use_proxy,
	}
	merged_values = { **values, **extra_values }

	if hosts is None:
		retval, ansible_results = ansible_run_playbook(playbookpath, values = merged_values)
	else:
		retval, ansible_results = ansible_run_playbook_on_selection(playbookpath, selection = hosts, values = merged_values)

	for host in ansible_results:
		data = ansible_results[host]
		if retval == 0 and quiet == True:
			break

		# RUN_ERROR = 1
		# RUN_FAILED_HOSTS = 2
		# RUN_UNREACHABLE_HOSTS = 4
		# RUN_FAILED_BREAK_PLAY = 8
		extra_status = ""
		if retval & 1 == 1:
			extra_status += " Error,"
		if retval & 2 == 2:
			extra_status += " Failed hosts,"
		if retval & 4 == 4:
			extra_status += " host unreachable,"
		if retval & 8 == 8:
			extra_status += " Failed break play,"

		extra_status = extra_status.rstrip(",")

		if retval == 0:
			iktprint([(f"    [{host}]", "success")])
		else:
			iktprint([(f"    [{host}]", "error"), (extra_status, "errorvalue")])

		for task in ansible_results[host]:
			taskname = task[len("TASK: "):]
			iktprint([(f"      {taskname}:", "default")])
			msg = data[task].get("msg", "").splitlines()
			if len(msg) > 0:
				iktprint([(f"        ", "default"), ("msg:", "header")])
				for line in msg:
					iktprint([(f"        {line}", "default")])
				iktprint([("", "default")])
			stdout_lines = data[task].get("stdout_lines", [])
			if len(stdout_lines) > 0:
				iktprint([(f"        ", "default"), ("stdout:", "header")])
				for line in data[task]["stdout_lines"]:
					iktprint([(f"        {line}", "default")])
				iktprint([("", "default")])
			stderr_lines = data[task].get("stderr_lines", [])
			if len(stderr_lines) > 0:
				iktprint([(f"        ", "default"), ("stderr:", "header")])
				for line in data[task]["stderr_lines"]:
					iktprint([(f"        {line}", "default")])
				iktprint([("", "default")])
			if len(msg) == 0 and len(stdout_lines) == 0 and len(stderr_lines) == 0:
				iktprint([(f"        <no output>", "none")])
				iktprint([("", "default")])

	return retval, ansible_results

def run_playbooks(playbooks, hosts = None, extra_values = {}):
	for string, playbookpath in playbooks:
		iktprint(string)
		retval, ansible_results = run_playbook(playbookpath, hosts = hosts, extra_values = extra_values)

		# We don't want to continue executing playbooks if the first one failed
		if retval != 0:
			break

	return retval == 0

# Add all playbooks in the array
def populate_playbooks_from_paths(paths):
	playbooks = []

	for playbookpath in paths:
		# Only process playbooks
		tmp = re.match(r"(.*)\.ya?ml", os.path.basename(playbookpath))
		if tmp is None:
			raise Exception(f"The playbook filename “{os.path.basename(playbookpath)}“ does not end with .yaml or .yml; this is most likely a programming error.")

		playbookname = tmp[1]
		description = None
		with open(playbookpath) as f:
			d = yaml.safe_load(f)
			description = [(deep_get(d[0], "vars#metadata#description"), "play")]

		if description is None or len(description) == 0:
			description = [("Running “", "play"), (playbookname, "programname"), ("“", "play")]

		# If there's no description we fallback to just using the filename
		playbooks.append(([("  • ", "separator")] + description, playbookpath))

	return playbooks

# This executes a command without capturing the output
def execute_command(args, env = None):
	if env is None:
		retval = subprocess.run(args)
	else:
		retval = subprocess.run(args, env = env)
	return retval.returncode == 0

# This executes a command with the output captured
def execute_command_with_response(args):
	result = subprocess.run(args, stdout = PIPE, stderr = STDOUT, check = False)
	return result.stdout.decode("utf-8")

def cordon_nodes(options = None, args = None):
	_args = ["kubectl", "cordon"]
	_args += args
	execute_command(_args)

def drain_nodes(options = None, args = None):
	# Check kubectl version
	_args = ["kubectl", "version"]
	response = execute_command_with_response(_args).splitlines()
	tmp = re.match(r"^Client Version: version.Info{Major:\"(.)\", Minor:\"(.+?)\"", response[0])
	_args = ["kubectl", "drain"]

	for opt, optarg in options:
		if opt in ["--delete-emptydir-data", "--delete-local-data"]:
			if int(tmp[1]) >= 1 and int(tmp[2]) >= 20:
				_args.append("--delete-emptydir-data")
			else:
				_args.append("--delete-local-data")
		elif opt == "--disable-eviction":
			if int(tmp[1]) >= 1 and int(tmp[2]) >= 18:
				_args.append(opt)
		elif opt == "--ignore-daemonsets":
			_args.append(opt)

	_args += args
	execute_command(_args)

def uncordon_nodes(options = None, args = None):
	_args = ["kubectl", "uncordon"]
	_args += args
	execute_command(_args)

def setup_nodes(options = None, args = None):
	return 0

def upgrade_nodes(options = None, args = None):
	selection = []
	nodes = []
	controlplanes = []

	from kubernetes_helper import KubernetesHelper
	kh = KubernetesHelper(about.program_suite_name, about.program_suite_version, None)

	vlist = kh.get_list_by_kind_namespace(("Node", ""), "")
	if vlist is not None:
		for node in vlist:
			node_name = deep_get(node, "metadata#name")
			node_roles = kh.get_node_roles(node)
			if "control-plane" in node_roles:
				controlplanes = node_name
				continue
			nodes.append(node_name)

	if len(args) == 1 and args[0] == "ALL":
		selection = nodes
	else:
		for arg in args:
			if arg in controlplanes:
				iktprint([(f"Error: ", "error"), ("“", "default"), (arg, "hostname"), ("“ is a control-plane and should be upgraded using ", "default"), (f"{about.admin_program_name}", "programname"), ("; aborting.", "default")], stderr = True)
				sys.exit(2)
			if arg not in nodes:
				iktprint([(f"Error: ", "error"), ("“", "default"), (arg, "hostname"), ("“ is not a part of the cluster; aborting.", "default")], stderr = True)
				sys.exit(2)
		selection = args

	if len(selection) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(2)

	iktprint([("\n[Upgrading nodes]", "phase")])
	iktprint([("\n• ", "separator"), ("Drain nodes", "action")])
	drain_options = {
		("--delete-emptydir-data", None),
		("--disable-eviction", None),
		("--ignore-daemonsets", None),
	}
	drain_nodes(options = drain_options, args = selection)

	iktprint([("\n• ", "separator"), ("Run upgrade playbooks on nodes", "action")])
	upgrade_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_upgrade_node.yaml",
	]
	playbooks = populate_playbooks_from_paths(upgrade_playbooks)

	extra_values = {}
	retval = run_playbooks(playbooks = playbooks, hosts = selection, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")])
		sys.exit(2)

	iktprint([("\n• ", "separator"), ("Uncordon nodes", "action")])
	uncordon_nodes(args = selection)

	iktprint([("\nNode upgrade successful", "success")])

def get_resource(options = None, args = None):
	namespaces = ["default"]

	if options is not None:
		for opt, optarg in options:
			# This is a tuple option, so the easiest way is to check this way
			if "--all-namespaces" in opt:
				namespaces = None
			elif "--namespace" in opt:
				namespaces = optarg.split(",")
			else:
				raise Exception(f"Programming error; invalid option {opt}")

	# We might have to get the resources across multiple namespaces, so we need to do multiple requests
	return

ikt_commandline = {
	"Cordon Node": {
		"command": ["cordon"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Cordon ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"min_args": 1,
		"max_args": 1,
		"callback": cordon_nodes,
	},
	"Drain Node": {
		"command": ["drain"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Drain ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"min_args": 1,
		"max_args": 1,
		"options": {
			"--delete-emptydir-data": {
				"description": [("Drain nodes even if this would cause ", "description"), ("emptyDir", "emphasis"), (" data to be deleted", "description")],
			},
			"--delete-local-data": {
				"description": [("This is an alias for “", "description"), ("--delete-emptydir-data", "option"), ("“", "description")],
			},
			"--disable-eviction": {
				"description": [("Delete pods instead of using evict; this bypasses ", "description"), ("PodDisruptionBudget", "emphasis")],
			},
			"--ignore-daemonsets": {
				"description": [("Ignore pods managed by daemonsets; by default ", "description"), ("drain ", "command"), ("will abort if there are such pods running on the node", "description")],
			},
		},
		"callback": drain_nodes,
	},
	"Drain Node (Force)": {
		"command": ["force-drain"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Force-drain ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"extended_description": [
			[("When a node is force-drained, pods belonging to daemonsets are ignored, and ", "description"), ("emptyDir", "emphasis"), (" data is deleted", "description")],
		],
		"min_args": 1,
		"max_args": 1,
		"options": {
			"--disable-eviction": {
				"description": [("Delete pods instead of using evict; this bypasses ", "description"), ("PodDisruptionBudget", "emphasis")],
			},
		},
		"implicit_options": [
			("--delete-emptydir-data", None),
			("--ignore-daemonsets", None),
		],
		"callback": drain_nodes,
	},
	"Uncordon Node": {
		"command": ["uncordon"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Uncordon ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"min_args": 1,
		"max_args": 1,
		"callback": uncordon_nodes,
	},
	"Upgrade Node": {
		"command": ["upgrade-node"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Upgrade Kubernetes on ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"extended_description": [
			[("Upgrade Kubernetes on ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument"), (" to the version in use on the control-plane(s);", "description")],
			[("run this on all nodes after running “", "description"), (f"{about.admin_program_name}", "programname"), (" upgrade-control-plane", "command"), ("“", "description")],
		],
		"min_args": 1,
		"max_args": 1,
		"callback": upgrade_nodes,
	},
#	"Get": {
#		"command": ["get", "l", "list"],
#		"values": [("RESOURCE", "argument"), (",", "separator"), ("...", "argument")],
#		"description": [("List information about ", "description"), ("RESOURCE", "argument"), (",", "separator"), ("...", "argument")],
#		"min_args": 1,
#		"max_args": 1,
#		"options": {
#			("-N", "--namespace"): {
#				"values": [("NAMESPACE", "argument"), (",", "separator"), ("...", "argument")],
#				"description": [("Only show resources belonging to ", "description"), ("NAMESPACE", "argument"), (",", "separator"), ("...", "argument")],
#				"requires_arg": True,
#			},
#			("-A", "--all-namespaces"): {
#				"description": [("Show resources across all namespaces", "description")],
#			},
#		},
#		"callback": get_resource,
#	},
	"extended_description": [
		[("You can use “", "description"), ("ALL", "emphasis"), ("“ as a substitute for all resources in most cases;", "description")],
		[("for instance “", "description"), (f"{about.tool_program_name}", "programname"), (" upgrade-node ", "command"), ("ALL", "emphasis"), ("“ will upgrade Kubernetes on all nodes", "description")],
	]
}

def get_programname(callname):
	callnames = {
		"ikt": ikt_commandline,		# main name
		#"iktdep": dep_commandline,	# deployment shortcut
		#"iktds": ds_commandline,	# daemon set shortcut
		#"iktrs": rs_commandline,	# replica set shortcut
		#"iktjob": job_commandline,	# job shortcut
		#"iktnode": node_commandline,	# node shortcut
		#"iktpod": pod_commandline,	# pod shortcut
	}

	if callname not in callnames:
		sys.exit(f"{PROGRAMNAME} called with unknown name {callname}; aborting.")

	return callname, callnames[callname]

def main():
	global iktconfig
	global programname
	argv = sys.argv

	init_iktprint(THEME_PATH)
	programname, commandline = get_programname(os.path.basename(argv[0]))

	command, options, args = parse_commandline(programname, PROGRAMVERSION, PROGRAMDESCRIPTION, PROGRAMAUTHORS, argv, commandline)
	iktconfig = iktlib.read_iktconfig()

	# Used by the ansible module
	ansible_configuration.ansible_forks = deep_get(iktconfig, "Ansible#forks", 5)
	ansible_user = deep_get(iktconfig, "Ansible#ansible_user")
	if ansible_user is None or len(ansible_user) == 0:
		ansible_user = getuser()
	ansible_configuration.ansible_user = ansible_user
	ansible_password = deep_get(iktconfig, "Ansible#ansible_password")
	if ansible_password is not None and len(ansible_password) > 0:
		ansible_configuration.ansible_password = ansible_password
	ansible_configuration.disable_strict_host_key_checking = deep_get(iktconfig, "Nodes#disablestricthostkeychecking", False)
	ansible_configuration.save_logs = deep_get(iktconfig, "Ansible#save_logs", False)

	return command(options, args)

if __name__ == "__main__":
	main()
