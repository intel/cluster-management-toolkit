#! /usr/bin/env python3
# Requires: ansible
# Requires: python3 (>= 3.6)
# Requires: python3-natsort
# Requires: python3-openssl
# Recommends: python3-ujson

# pylint: disable=line-too-long

"""
This program is used to install, upgrade and uninstall nodes for Kubernetes clusters,
and to perform various other tasks; eventually this is meant to have most of the
features available in iku

For usage, see:
	ikt help
"""

import errno
from getpass import getuser
import hashlib
import os
import re
import sys
import yaml

try:
	import OpenSSL
except ModuleNotFoundError:
	sys.exit("ModuleNotFoundError: you probably need to install python3-openssl")

from ikttypes import DictPath
from iktpaths import IKT_CONFIG_FILE, DEFAULT_THEME_FILE

from commandparser import parse_commandline

from ansible_helper import ansible_configuration, ansible_run_playbook_on_selection, ansible_get_hosts_by_group, ansible_add_hosts, ansible_remove_hosts, ansible_print_play_results
from ansible_helper import ANSIBLE_PLAYBOOK_DIR, ANSIBLE_INVENTORY

import iktlib # pylint: disable=unused-import
from iktlib import deep_get, iktconfig, join_tuple_list, execute_command

from kubernetes_helper import get_node_status, kubectl_get_version

from iktio import scan_and_add_ssh_keys
from iktprint import iktprint, iktinput, iktinput_password

import about
PROGRAMDESCRIPTION = "Commandline tool for managing Kubernetes clusters"
PROGRAMAUTHORS = "Written by David Weinehall."

def request_ansible_password():
	"""
	Requests the ansible password
	"""

	# Check whether ansible_password is defined or not
	if ansible_configuration["ansible_password"] == None:
		iktprint([("Attention: ", "warning"), ("To be able to run playbooks you need to provide the ansible/ssh password.", "default")])
		iktprint([("Since the systems will be reconfigured to use passwordless sudo and ssh keys this is a one-time thing.", "default")])
		ansible_password = iktinput_password([("\nPassword: ", "default")])
		if len(ansible_password) == 0:
			iktprint([("\nError: ", "Error"), ("Empty password; aborting.")], stderr = True)
			sys.exit(errno.EINVAL)
		else:
			ansible_configuration["ansible_password"] = ansible_password

def run_playbook(playbookpath, hosts = None, extra_values = None, quiet = False):
	"""
	Run a playbook

		Parameters:
			playbookpath (str): A path to the playbook to run
			hosts (list[str]): A list of hosts to run the playbook on
			extra_values (dict): A dict of values to set before running the playbook
			quiet (bool): Unused
		Returns:
			retval (int): The return value from ansible_run_playbook_on_selection()
			ansible_results (dict): A dict with the results from the run
	"""

	# Eventually we should be using this
	del quiet

	# Set necessary Ansible keys before running playbooks
	http_proxy = deep_get(iktconfig, DictPath("Network#http_proxy"), "")
	if http_proxy is None:
		http_proxy = ""
	https_proxy = deep_get(iktconfig, DictPath("Network#https_proxy"), "")
	if https_proxy is None:
		https_proxy = ""
	no_proxy = deep_get(iktconfig, DictPath("Network#no_proxy"), "")
	if no_proxy is None:
		no_proxy = ""
	insecure_registries = deep_get(iktconfig, DictPath("Docker#insecure_registries"), [])
	registry_mirrors = deep_get(iktconfig, DictPath("Containerd#registry_mirrors"), [])
	retval = 0

	use_proxy = "no"
	if len(http_proxy) > 0 or len(https_proxy) > 0:
		use_proxy = "yes"

	if extra_values is None:
		extra_values = {}

	values = {
		"http_proxy": http_proxy,
		"https_proxy": https_proxy,
		"no_proxy": no_proxy,
		"insecure_registries": insecure_registries,
		"registry_mirrors": registry_mirrors,
		"use_proxy": use_proxy,
	}
	merged_values = { **values, **extra_values }

	retval, ansible_results = ansible_run_playbook_on_selection(playbookpath, selection = hosts, values = merged_values)

	ansible_print_play_results(retval, ansible_results)

	return retval, ansible_results

def __format_none(string, fmt):
	if string is None or string == "<none>":
		__string = ("<none>", "none")
	else:
		__string = (string, fmt)
	return __string

def show_configuration(hosts):
	"""
	Show cluster configuration

		Parameters:
			hosts (list[str]): The hosts that will be affected
	"""

	# cluster_name =
	http_proxy = deep_get(iktconfig, DictPath("Network#http_proxy"), "")
	if http_proxy is not None and http_proxy == "":
		http_proxy = None
	http_proxy_env = os.getenv("http_proxy")
	if http_proxy_env is not None and http_proxy_env == "":
		http_proxy_env = None
	https_proxy = deep_get(iktconfig, DictPath("Network#https_proxy"), "")
	if https_proxy is not None and https_proxy == "":
		https_proxy = None
	https_proxy_env = os.getenv("https_proxy")
	if https_proxy_env is not None and https_proxy_env == "":
		https_proxy_env = None
	no_proxy = deep_get(iktconfig, DictPath("Network#no_proxy"), "")
	if no_proxy is not None and no_proxy == "":
		no_proxy = None
	no_proxy_env = os.getenv("no_proxy")
	if no_proxy_env is not None and no_proxy_env == "":
		no_proxy_env = None

	iktprint([("\n[Summary]", "phase")])
	iktprint([("\n• ", "separator"), ("Configuration:", "action")])
	iktprint([("          HTTP Proxy: ", "action"), __format_none(http_proxy, "url"), (" (", "default"), (f"{IKT_CONFIG_FILE}", "path"), (")", "default")])
	iktprint([("          HTTP Proxy: ", "action"), __format_none(http_proxy_env, "url"), (" (Environment)", "default")])
	iktprint([("         HTTPS Proxy: ", "action"), __format_none(https_proxy, "url"), (" (", "default"), (f"{IKT_CONFIG_FILE}", "path"), (")", "default")])
	iktprint([("         HTTPS Proxy: ", "action"), __format_none(https_proxy_env, "url"), (" (Environment)", "default")])
	iktprint([("            No Proxy: ", "action"), __format_none(no_proxy, "url"), (" (", "default"), (f"{IKT_CONFIG_FILE}", "path"), (")", "default")])
	iktprint([("            No Proxy: ", "action"), __format_none(no_proxy_env, "url"), (" (Environment)", "default")])
	iktprint([("", "default")])
	iktprint([("Target hosts:", "header")])
	for host in hosts:
		iktprint([("  • ", "separator"), (host, "hostname")])

def run_playbooks(playbooks, hosts = None, extra_values = None):
	"""
	Run a set of playbooks

		Parameters:
			playbooks (list[(description, playbookpath)]): A list of playbooks
			hosts (str): The hosts to run the playbooks on
			extra_values (dict): Variables to set before running the playbooks
		Returns:
			True on success, False on failure
	"""

	if len(playbooks) == 0 or hosts == None:
		return True

	for string, playbookpath in playbooks:
		iktprint(string)
		retval, _ansible_results = run_playbook(playbookpath, hosts = hosts, extra_values = extra_values)

		# We don't want to continue executing playbooks if the first one failed
		if retval != 0:
			break

	return retval == 0

# Add all playbooks in the array
def populate_playbooks_from_paths(paths):
	"""
	Populate a playbook list

		Parameters:
			paths (list[str]): A list of paths to playbooks
		Returns:
			list[(description, playbookpath)]: A playbook list for use with run_playbooks()
	"""

	playbooks = []

	# Safe
	yaml_regex = re.compile(r"^(.*)\.ya?ml$")

	for playbookpath in paths:
		# Don't process backups, etc.
		if os.path.basename(playbookpath).startswith(("~", ".")):
			continue

		# Only process playbooks
		tmp = yaml_regex.match(os.path.basename(playbookpath))
		if tmp is None:
			raise Exception(f"The playbook filename “{os.path.basename(playbookpath)}“ does not end with .yaml or .yml; this is most likely a programming error.")

		playbookname = tmp[1]
		description = None
		with open(playbookpath, encoding = "utf-8") as f:
			d = yaml.safe_load(f)
			description = [(deep_get(d[0], DictPath("vars#metadata#description")), "play")]

		if description is None or len(description) == 0:
			description = [("Running “", "play"), (playbookname, "programname"), ("“", "play")]

		# If there's no description we fallback to just using the filename
		playbooks.append(([("  • ", "separator")] + description, playbookpath))

	return playbooks

def get_selection(selection, kind = None):
	"""
	Based on input parameters, split the node list into nodes, non-existing nodes, and control planes

		Parameters:
			selection (list[str]): A list of nodes, or ALL to select all nodes
			kind (tuple): A Kubernetes kind; only supported for now is ("Node", "")
			_or_
			kind (str): For future use with playbooks, etc.
		Returns:
			(nodes, non_existing_nodes, controlplanes) (str, str, str): The nodes, non-existing nodes, and control planes
	"""

	all_items = False
	items1 = []
	non_existing = []
	# Only used for controlplanes
	items2 = []

	if kind is None:
		raise Exception("kind is None; this is a programming error")

	if selection is None:
		raise ValueError("selection is None; this is a programming error")

	if "ALL" in selection:
		if len(selection) > 1:
			iktprint([("Error: ", "error"), ("“", "default"), ("ALL", "argument"), ("“ cannot be combined with other arguments; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		else:
			all_items = True

	# Kubernetes resources
	if isinstance(kind, tuple):
		from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
		kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

		vlist, _status = kh.get_list_by_kind_namespace(("Node", ""), "")
		for node in vlist:
			name = deep_get(node, DictPath("metadata#name"))
			if all_items == False and name not in selection:
				continue

			node_roles = kh.get_node_roles(node)
			if "control-plane" in node_roles or "master" in node_roles:
				items2.append(name)
				continue

			items1.append(name)
	# str kinds are things such as playbooks; for now ikt doesn't use them

	# Finally, generate a list of non-existing items
	if all_items == False:
		for item in selection:
			if item not in items1 + items2:
				non_existing.append(item)

	return items1, non_existing, items2

def cordon_nodes(options, args):
	"""
	Cordon nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	include_control_planes = False
	header = True

	for opt, _optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")

	# It's OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes == True:
		nodes += controlplanes

	if len(non_existing) > 0:
		iktprint([("Error: ", "error"), join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")), (" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		iktprint([("\n[Cordoning nodes]", "phase")])

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for node in nodes:
		iktprint([(f"{node}:", "hostname")])
		message, status = kh.cordon_node(node)
		if status in (200, 204):
			iktprint([("  Cordoned", "success")])
			print(message)
		elif status == 42503:
			iktprint([("\nCritical: ", "critical"), ("Cluster not available; aborting", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			iktprint([("\nAPI call returned error:", "error")], stderr = True)
			iktprint([(f"  {message}", "error")], stderr = True)
			sys.exit(errno.EINVAL)

def drain_nodes(options, args):
	"""
	Drain nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	include_control_planes = False
	header = True

	# Check kubectl version
	kubectl_major_version, kubectl_minor_version, _kubectl_git_version, _server_major_version, _server_minor_version, _server_git_version = kubectl_get_version()

	_args = ["/usr/bin/kubectl", "drain"]

	for opt, _optarg in options:
		if opt in ("--delete-emptydir-data", "--delete-local-data"):
			if kubectl_major_version >= 1 and kubectl_minor_version >= 20:
				_args.append("--delete-emptydir-data")
			else:
				_args.append("--delete-local-data")
		elif opt == "--disable-eviction":
			if kubectl_major_version >= 1 and kubectl_minor_version >= 18:
				_args.append(opt)
		elif opt == "--ignore-daemonsets":
			_args.append(opt)
		elif opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")

	# It's OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes == True:
		nodes += controlplanes

	if len(non_existing) > 0:
		iktprint([("Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		iktprint([("\n[Draining nodes]", "phase")])
	_args += nodes
	execute_command(_args)

def uncordon_nodes(options, args):
	"""
	Uncordon nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	include_control_planes = False
	header = True

	for opt, _optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")

	# It's OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes == True:
		nodes += controlplanes

	if len(non_existing) > 0:
		iktprint([("Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		iktprint([("\n[Uncordoning nodes]", "phase")])

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for node in nodes:
		iktprint([(f"{node}:", "hostname")])
		message, status = kh.uncordon_node(node)
		if status in (200, 204):
			iktprint([("  Uncordoned", "success")])
			print(message)
		elif status == 42503:
			iktprint([("\nCritical: ", "critical"), ("Cluster not available; aborting", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			iktprint([("\nAPI call returned error:", "error")], stderr = True)
			iktprint([(f"  {message}", "error")], stderr = True)
			sys.exit(errno.EINVAL)

def taint_nodes(options, args):
	"""
	Taint nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	include_control_planes = False
	overwrite = False
	header = True

	for opt, _optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		elif opt == "--overwrite":
			overwrite = True
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")
	taint = args[1]

	if "=" not in taint:
		iktprint([(f"{about.TOOL_PROGRAM_NAME}", "programname"), (": invalid syntax; the correct syntax is either “", "default"),
			  (f"{about.TOOL_PROGRAM_NAME}", "programname"), (" taint ", "command"),
			  ("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL ", "argument"),
			  ("KEY", "argument"), ("=", "separator"), ("EFFECT", "argument"),
			  ("“ or “", "default"),
			  (f"{about.TOOL_PROGRAM_NAME}", "programname"), (" taint ", "command"),
			  ("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL ", "argument"),
			  ("KEY", "argument"), (":", "separator"), ("VALUE", "argument"), ("=", "separator"), ("EFFECT", "argument"), ("“; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	taint, taint_new_effect = taint.split("=")
	if ":" in taint:
		taint_key, taint_value = taint.split(":")
	else:
		taint_key = taint
		taint_value = None

	if taint_new_effect not in ("NoSchedule", "PreferNoSchedule", "NoExecute"):
		iktprint([("Error: ", "error"), ("invalid effect; valid effects are: ", "default"), ("NoSchedule", "argument"), (", ", "default"), ("PreferNoSchedule", "argument"), (", and ", "default"), ("NoExecute", "argument"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# It's OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes == True:
		nodes += controlplanes

	if len(non_existing) > 0:
		iktprint([("Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		iktprint([("\n[Tainting nodes]", "phase")])

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for node in nodes:
		node_info = kh.get_ref_by_kind_name_namespace(("Node", ""), node, "")
		status, _status_group, _taints, full_taints = get_node_status(node_info)
		if status == "Unknown":
			iktprint([("Critical:", "critical"), (" Failed to get node information; do you have a running cluster? Aborting.", "default")], stderr = True)
			sys.exit(errno.ENXIO)

		iktprint([(node, "hostname")])
		_message, status = kh.taint_node(node, full_taints, (taint_key, taint_value, None, taint_new_effect), overwrite = overwrite)
		if status == 304:
			iktprint([("  Not modified", "none")])
		elif status == 42304:
			iktprint([("  Warning:", "warning"), (" Ignoring request; node already has taint(s) with matching effect; use “", "default"), ("--overwrite", "option"), ("“ to override", "default")])
		elif status == 200:
			iktprint([("  Tainted", "success")])
		else:
			iktprint([("  Failed to modify taint", "error"), (f"; HTTP error {status}; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)

def untaint_nodes(options, args):
	"""
	Untaint nodes

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	include_control_planes = False
	header = True

	for opt, _optarg in options:
		if opt == "--include-control-planes":
			include_control_planes = True
		elif opt == "--no-header":
			header = False
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	selection = args[0].split(",")
	taint = args[1]

	if "=" in taint:
		taint, taint_old_effect = taint.split("=")
	else:
		taint_old_effect = None
	if ":" in taint:
		taint_key, taint_value = taint.split(":")
	else:
		taint_key = taint
		taint_value = None

	if taint_old_effect is not None and taint_old_effect not in ("NoSchedule", "PreferNoSchedule", "NoExecute"):
		iktprint([("Error: ", "error"), ("invalid effect; valid effects are: ", "default"), ("NoSchedule", "argument"), (", ", "default"), ("PreferNoSchedule", "argument"), (", and ", "default"), ("NoExecute", "argument"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# It's OK to specify control planes individually
	if "ALL" not in selection:
		include_control_planes = True

	_nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	nodes = []
	nodes += _nodes
	if include_control_planes == True:
		nodes += controlplanes

	if len(non_existing) > 0:
		iktprint([("Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if header == True:
		iktprint([("\n[Untainting nodes]", "phase")])

	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	for node in nodes:
		node_info = kh.get_ref_by_kind_name_namespace(("Node", ""), node, "")
		status, _status_group, _taints, full_taints = get_node_status(node_info)
		if status == "Unknown":
			iktprint([("Critical:", "critical"), (" Failed to get node information; do you have a running cluster? Aborting.", "default")], stderr = True)
			sys.exit(errno.ENXIO)

		iktprint([(node, "hostname")])
		_message, status = kh.taint_node(node, full_taints, (taint_key, taint_value, taint_old_effect, None))
		if status == 304:
			iktprint([("  Not modified", "none")])
		elif status == 200:
			iktprint([("  Untainted", "success")])
		else:
			iktprint([("  Failed to modify taint", "error"), (f"; HTTP error {status}; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)

def prepare_hosts(options, args):
	"""
	Install and configure pre-requisites for use as a node

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	ignore_existing = False
	no_password = False
	from_file = False

	for opt, optarg in options:
		if opt == "--ignore-existing":
			ignore_existing = True
		elif opt == "--no-password":
			no_password = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--forks":
			ansible_configuration["forks"] = optarg
		elif opt == "--from-file":
			from_file = True
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	if from_file == True:
		hostfile = args[0]
		if not os.path.exists(hostfile):
			iktprint([("Error: ", "error"), (f"{hostfile}", "path"), (" does not exist; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		elif not os.path.isfile(hostfile):
			iktprint([("Error: ", "error"), (f"{hostfile}", "path"), (" is not a file; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			hosts_raw = None
			with open(hostfile, "r", encoding = "utf-8") as f:
				hosts_raw = f.readlines()

			if hosts_raw is None:
				iktprint([("Error: ", "error"), ("failed to read hostnames from ", "default"), (f"{hostfile}", "path"), ("; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

			# strip newlines
			hosts_raw = [s.strip() for s in hosts_raw]

			if len(hosts_raw) == 1 and "," in hosts_raw[0]:
				selection = hosts_raw[0].split(",")
			else:
				selection = hosts_raw
	else:
		selection = args[0].split(",")

		if "ALL" in selection:
			iktprint([("Error: ", "error"), ("ALL", "hostname"), (" cannot be used with ", "default"), ("prepare", "command"), ("; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)

	# Correlate the list of hosts with the nodes in the cluster
	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(nodes) > 0 or len(controlplanes) > 0:
		if ignore_existing == False:
			iktprint([("Error: ", "error")] + join_tuple_list(nodes + controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are already part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(errno.EEXIST)
		else:
			iktprint([("Warning: ", "warning")] + join_tuple_list(nodes + controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are already part of the cluster; ignoring them since “", "description"), ("--ignore-existing", "option"), ("“ was specified.", "default")], stderr = True)

	if len(non_existing) == 0:
		iktprint([("Error: ", "error"), (" no valid hosts specified; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# Check if the hosts are part of the inventory
	inventory = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")
	not_in_inventory = []
	for host in non_existing:
		if host not in inventory:
			not_in_inventory.append(host)

	if len(not_in_inventory) > 0:
		retval = iktinput([("\nWarning: ", "warning")] + join_tuple_list(not_in_inventory, _tuple = "hostname", separator = (",", "separator")) + [(" are not defined in the inventory; do you want to add them now? (No will abort the installation) [y/", "default"), ("N", "emphasis"), ("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([("\nAborting: ", "error"), ("Nodes not added to the inventory.", "default")], stderr = True)
			sys.exit(errno.EINTR)
		else:
			ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = not_in_inventory, skip_all = False)

	show_configuration(non_existing)

	confirm = True
	if confirm == True:
		retval = iktinput([("\nStart host preparation? [y/", "default"), ("N", "emphasis"), ("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([("\nAborting: ", "error"), ("User stopped host preparation.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	iktprint([("\n[Preparing host(s)]", "phase")])

	scan_and_add_ssh_keys(non_existing)

	# We most likely won't be able to connect to the remote host without a password
	if no_password == False:
		request_ansible_password()

	prepare_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/prepare_node.yaml",
	]
	playbooks = populate_playbooks_from_paths(prepare_playbooks)

	extra_values = {
		"ansible_become_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
		"ansible_ssh_pass": deep_get(ansible_configuration, DictPath("ansible_password")),
	}

	retval = run_playbooks(playbooks = playbooks, hosts = non_existing, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	iktprint([("\nHosts successfully prepared", "success")])

def add_nodes(options, args):
	"""
	Add nodes to the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	ignore_existing = False
	ignore_non_existing = False
	from_file = False
	ca_cert_path = ""
	cri = None

	for opt, optarg in options:
		if opt == "--ignore-existing":
			ignore_existing = True
		elif opt == "--ignore-non-existing":
			ignore_non_existing = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--ca-cert-path":
			ca_cert_path = optarg
		elif opt == "--forks":
			ansible_configuration["forks"] = optarg
		elif opt == "--cri":
			if optarg in ("dockershim", "containerd", "manual"):
				cri = optarg
			else:
				iktprint([("Error: ", "error"), ("Unknown CRI “", "default"), (optarg, "argument"), ("“ specified; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)
		elif opt == "--from-file":
			from_file = True
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	if from_file == True:
		hostfile = args[0]
		if not os.path.exists(hostfile):
			iktprint([("Error: ", "error"), (f"{hostfile}", "path"), (" does not exist; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		elif not os.path.isfile(hostfile):
			iktprint([("Error: ", "error"), (f"{hostfile}", "path"), (" is not a file; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			hosts_raw = None
			with open(hostfile, "r", encoding = "utf-8") as f:
				hosts_raw = f.readlines()

			if hosts_raw is None:
				iktprint([("Error: ", "error"), ("failed to read hostnames from ", "default"), (f"{hostfile}", "path"), ("; aborting.", "default")], stderr = True)
				sys.exit(errno.EINVAL)

			# strip newlines
			hosts_raw = [s.strip() for s in hosts_raw]

			if len(hosts_raw) == 1 and "," in hosts_raw[0]:
				selection = hosts_raw[0].split(",")
			else:
				selection = hosts_raw
	else:
		selection = args[0].split(",")

	if "ALL" in selection:
		iktprint([("Error: ", "error"), ("ALL", "hostname"), (" cannot be used with ", "default"), ("add-node", "command"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	# Correlate the list of hosts with the nodes in the cluster
	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(nodes) > 0 or len(controlplanes) > 0:
		if ignore_existing == False:
			iktprint([("Error: ", "error")] + join_tuple_list(controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are already part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(errno.EEXIST)
		else:
			iktprint([("Warning: ", "warning")] + join_tuple_list(nodes + controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are already part of the cluster; ignoring them since “", "description"), ("--ignore-existing", "option"), ("“ was specified.", "default")], stderr = True)

	if len(non_existing) == 0:
		iktprint([("Error: ", "error"), (" no valid hosts specified; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# Check if the hosts are part of the inventory
	inventory = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")
	not_in_inventory = []
	for host in non_existing:
		if host not in inventory:
			not_in_inventory.append(host)

	if len(not_in_inventory) > 0:
		if ignore_non_existing == False:
			iktprint([("Error: ", "error")] + join_tuple_list(not_in_inventory, _tuple = "hostname", separator = (",", "separator")) + [(" are not defined in the inventory; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			iktprint([("Warning: ", "warning")] + join_tuple_list(not_in_inventory, _tuple = "hostname", separator = (",", "separator")) + [(" are not defined in the invetory; ignoring them since “", "description"), ("--ignore-non-existing", "option"), ("“ was specified.", "default")], stderr = True)

	show_configuration(non_existing)

	confirm = True
	if confirm == True:
		retval = iktinput([("\nStart node setup? [y/", "default"), ("N", "emphasis"), ("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([("\nAborting: ", "error"), ("User stopped node setup.", "default")], stderr = True)
			sys.exit(errno.EINTR)

	# Time to setup and add the hosts to the cluster
	iktprint([("\n[Adding nodes]", "phase")])

	# Get variables that need to be available when setting up nodes
	from kubernetes_helper import KubernetesHelper # pylint: disable=import-outside-toplevel
	kh = KubernetesHelper(about.PROGRAM_SUITE_NAME, about.PROGRAM_SUITE_VERSION, None)

	join_token = kh.get_join_token()
	if len(join_token) == 0:
		retval = iktinput([("Error: ", "error"), ("No join token found; create a one now? (No will abort the installation) [y/", "default"), ("N", "emphasis"), ("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([("\nAborting: ", "error"), ("No join token available.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			create_join_token_playbooks = [
				f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_create_join_token.yaml",
			]
			playbooks = populate_playbooks_from_paths(create_join_token_playbooks)
			retval = run_playbooks(playbooks = playbooks, hosts = controlplanes)
			join_token = kh.get_join_token()
			if len(join_token) == 0:
				iktprint([("Critical: ", "critical"), ("failed to create join token; aborting", "default")], stderr = True)
				sys.exit(errno.EINVAL)

	ca_cert_hash = ""
	if len(ca_cert_path) == 0:
		ca_cert_hash = kh.get_ca_cert_hash()
	if len(ca_cert_hash) == 0:
		if len(ca_cert_path) == 0:
			ca_cert_path = "/etc/kubernetes/pki/ca.crt"
		retval = iktinput([("Warning: ", "warning"), ("Could not find ", "default"), ("ca.crt", "path"), (" or a certificate-controller-token secret; try to use ", "default"), (ca_cert_path, "path"), ("? No will abort the installation) [y/", "default"), ("N", "emphasis"), ("]: ", "default")])
		if retval.lower() not in ("y", "yes"):
			iktprint([("\nAborting: ", "error"), ("No CA certificate available.", "default")], stderr = True)
			sys.exit(errno.EINTR)
		else:
			ca_cert = ""
			with open(ca_cert_path, encoding = "utf-8") as f:
				ca_cert = f.read()
			ca_cert_hash = ""
			if len(ca_cert) > 0:
				x509obj = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, ca_cert)
				pubkey = x509obj.get_pubkey()
				pubkeyasn1 = OpenSSL.crypto.dump_publickey(OpenSSL.crypto.FILETYPE_ASN1, pubkey)
				ca_cert_hash = hashlib.sha256(pubkeyasn1).hexdigest()

			if len(ca_cert_hash) == 0:
				iktprint([("\nAborting: ", "error"), ("No CA certificate available.", "default")], stderr = True)
				sys.exit(errno.EINTR)

	control_plane_ip, control_plane_port = kh.get_control_plane_address()
	# Now that we have the IP address of the API-server we can use that to get the package
	# version for kubeadm
	retval, ansible_results = ansible_run_playbook_on_selection(f"{ANSIBLE_PLAYBOOK_DIR}/get_versions.yaml", selection = [control_plane_ip])
	if len(ansible_results) == 0:
		iktprint([("Error: ", "error"), ("Failed to get package versions from control-plane at {control_plane_ip} (retval: {retval}); aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	tmp = []

	for result in deep_get(ansible_results, DictPath(control_plane_ip), []):
		if deep_get(result, DictPath("task"), "") == "package versions":
			tmp = deep_get(result, DictPath("msg_lines"), [])
			break

	if len(tmp) == 0:
		iktprint([("Error: ", "error"), ("Failed to get package versions from control-plane at {control_plane_ip} (playbook returned no valid data); aborting.", "default")], stderr = True)
		sys.exit(errno.EBADMSG)

	kubeadm_version = ""
	# Safe
	kubeadm_version_regex = re.compile(r"^(.*?): (.*)")

	for line in tmp:
		tmp = kubeadm_version_regex.match(line)
		if tmp is None:
			continue
		if tmp[1] == "kubeadm":
			kubeadm_version = tmp[2]
			break

	if len(kubeadm_version) == 0:
		iktprint([("Error: ", "error"), ("Failed to get ", "default"), ("kubeadm", "programname"), (" package version from control-plane at {control_plane_ip}; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	# 1.24.2-00
	_version = kubeadm_version.split(".")
	if int(_version[1]) >= 24:
		if cri == "dockershim":
			iktprint([("Error: ", "error"), ("CRI cannot be “", "default"), ("dockershim", "argument"), ("“ for ", "default"), ("Kubernetes ", "programname"), (">= ", "default"), ("1.24", "version"), ("; aborting.", "default")], stderr = True)
			sys.exit(errno.EINVAL)
		elif cri is None:
			cri = "containerd"
	else:
		if cri is None:
			cri = "dockershim"

	add_playbooks = [
		# ikt doesn't use run_before/run_after/add_to_groups/remove_from_groups,
		# so we have to do all of that explicitly
		f"{ANSIBLE_PLAYBOOK_DIR}/add_kubernetes_repo.yaml",
		f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_setup_node.yaml",
	]
	playbooks = populate_playbooks_from_paths(add_playbooks)

	extra_values = {
		"control_plane_ip": control_plane_ip,
		"control_plane_port": control_plane_port,
		"join_token": join_token,
		"ca_cert_hash": ca_cert_hash,
		"control_plane_k8s_version": kubeadm_version,
		"cri": cri,
	}
	retval = run_playbooks(playbooks = playbooks, hosts = non_existing, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = non_existing, group = "nodes", skip_all = True)
	# XXX: We need to get the cluster name to do this
	#ansible_add_hosts(inventory = ANSIBLE_INVENTORY, hosts = non_existing, group = cluster_name, skip_all = True)
	iktprint([("\nNodes successfully added", "success")])

def remove_nodes(options, args):
	"""
	Remove nodes from the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	force = False
	purge = False

	for opt, optarg in options:
		if opt == "--force":
			force = True
		elif opt == "--purge":
			purge = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--forks":
			ansible_configuration["forks"] = optarg
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0 and args[0] != "ALL":
		iktprint([("Error: ", "error")] + join_tuple_list(controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are control-plane(s) and should be removed using ", "default"), (f"{about.ADMIN_PROGRAM_NAME}", "programname"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(non_existing) > 0:
		if force == False:
			iktprint([("Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			iktprint([("Warning: ", "warning")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; attempting to purge them anyway since “", "description"), ("--force", "option"), ("“ was specified.", "default")], stderr = True)
			nodes += non_existing

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	iktprint([("\n[Removing nodes]", "phase")])
	iktprint([("\n• ", "separator"), ("Deleting nodes from the cluster", "action")])
	delete_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/delete_node.yaml",
	]
	playbooks = populate_playbooks_from_paths(delete_playbooks)

	extra_values = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	elif force == True:
		iktprint([("NOT OK", "warning"), ("; ignoring since “", "description"), ("--force", "option"), ("“ was specified.", "default")], stderr = True)
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	iktprint([("\n• ", "separator"), ("Tearing down Kubernetes on the nodes", "action")])
	teardown_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_teardown_node.yaml",
		f"{ANSIBLE_PLAYBOOK_DIR}/teardown_cni.yaml",
	]
	playbooks = populate_playbooks_from_paths(teardown_playbooks)

	extra_values = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	iktprint([("\nNodes successfully removed from cluster", "success")])

	if purge == True:
		purge_hosts(options = [("--ignore-non-existing", None)], args = [",".join(nodes)])

	iktprint([("\n• ", "separator"), ("Removing nodes from the inventory", "action")])
	ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = nodes, group = "nodes")
	# XXX: We need to get the cluster name to do this
	#ansible_remove_hosts(inventory = ANSIBLE_INVENTORY, hosts = nodes, group = cluster_name)

def purge_hosts(options, args):
	"""
	Purge nodes from the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	ignore_non_existing = False

	selection = args[0].split(",")

	if "ALL" in selection:
		iktprint([("Error: ", "error"), ("ALL", "hostname"), (" cannot be used with ", "default"), ("purge", "command"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	for opt, optarg in options:
		if opt == "--ignore-non-existing":
			ignore_non_existing = True
		elif opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--forks":
			ansible_configuration["forks"] = optarg
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	nodes, _non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0:
		iktprint([("Error: ", "error")] + join_tuple_list(controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are control-plane(s) and should be removed using ", "default"), (f"{about.ADMIN_PROGRAM_NAME}", "programname"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(nodes) > 0:
		iktprint([("Error: ", "error")] + join_tuple_list(nodes, _tuple = "hostname", separator = (",", "separator")) + [(" are still node(s) in the cluster; please run ", "default"), (f"{about.TOOL_PROGRAM_NAME}", "programname"), (" remove-node", "command"), (" first to remove them from the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.EBUSY)

	hosts = ansible_get_hosts_by_group(ANSIBLE_INVENTORY, "all")

	not_in_inventory = []
	for host in selection:
		if host not in hosts:
			not_in_inventory.append(host)
			selection.remove(host)

	if len(not_in_inventory) > 0:
		if ignore_non_existing == False:
			iktprint([("Error: ", "error")] + join_tuple_list(not_in_inventory, _tuple = "hostname", separator = (",", "separator")) + [(" are not in the inventory; aborting.", "default")], stderr = True)
			sys.exit(errno.ENOENT)
		else:
			iktprint([("Warning: ", "warning")] + join_tuple_list(not_in_inventory, _tuple = "hostname", separator = (",", "separator")) + [(" are not in the inventory; ignoring them since “", "description"), ("--ignore-non-existing", "option"), ("“ was specified.", "default")], stderr = True)

	if len(selection) == 0:
		iktprint([("Error: ", "error"), (" none of the specified hosts are part of the inventory; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	iktprint([("\n• ", "separator"), ("Purging Kubernetes from the hosts", "action")])
	purge_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_purge.yaml",
	]
	playbooks = populate_playbooks_from_paths(purge_playbooks)

	hosts = selection

	extra_values = {
		"packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
			"kubernetes-cni",
		],
		"held_packages": [
			"kubeadm",
			"kubectl",
			"kubelet",
		]
	}
	retval = run_playbooks(playbooks = playbooks, hosts = hosts, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	iktprint([("\nHosts successfully purged", "success")])
	return 0

def upgrade_nodes(options, args):
	"""
	Upgrade nodes in the cluster

		Parameters:
			options (list[(opt, optarg)]): Options to use when executing this action
			args (list[str]): Options to use when executing this action
	"""

	for opt, optarg in options:
		if opt == "--save-ansible-logs":
			ansible_configuration["save_logs"] = True
		elif opt == "--forks":
			ansible_configuration["forks"] = optarg
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	nodes, non_existing, controlplanes = get_selection(args[0].split(","), kind = ("Node", ""))

	if len(controlplanes) > 0 and args[0] != "ALL":
		iktprint([("Error: ", "error")] + join_tuple_list(controlplanes, _tuple = "hostname", separator = (",", "separator")) + [(" are control-plane(s) and should be upgraded using ", "default"), (f"{about.ADMIN_PROGRAM_NAME}", "programname"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	if len(non_existing) > 0:
		iktprint([("Error: ", "error")] + join_tuple_list(non_existing, _tuple = "hostname", separator = (",", "separator")) + [(" are not part of the cluster; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	if len(nodes) == 0:
		iktprint([("Error: ", "error"), ("No nodes available; aborting.", "default")], stderr = True)
		sys.exit(errno.ENOENT)

	iktprint([("\n[Upgrading nodes]", "phase")])
	iktprint([("\n• ", "separator"), ("Drain nodes", "action")])
	drain_options = {
		("--delete-emptydir-data", None),
		("--disable-eviction", None),
		("--ignore-daemonsets", None),
		("--no-header", None),
	}
	drain_nodes(options = drain_options, args = [",".join(nodes)])

	iktprint([("\n• ", "separator"), ("Run upgrade playbooks on nodes", "action")])
	upgrade_playbooks = [
		f"{ANSIBLE_PLAYBOOK_DIR}/kubeadm_upgrade_node.yaml",
	]
	playbooks = populate_playbooks_from_paths(upgrade_playbooks)

	extra_values = {}
	retval = run_playbooks(playbooks = playbooks, hosts = nodes, extra_values = extra_values)
	if retval == True:
		iktprint([("OK", "ok")])
	else:
		iktprint([("NOT OK", "notok"), ("; aborting.", "default")], stderr = True)
		sys.exit(errno.EINVAL)

	iktprint([("\n• ", "separator"), ("Uncordon nodes", "action")])
	uncordon_nodes(options = [], args = [",".join(nodes)])

	iktprint([("\nNode upgrade successful", "success")])
	return 0

# pylint: disable-next=pointless-string-statement
"""
def get_resource(options, args):
	namespaces = ["default"]

	for opt, optarg in options:
		# This is a tuple option, so the easiest way is to check this way
		if "--all-namespaces" in opt:
			namespaces = None
		elif "--namespace" in opt:
			namespaces = optarg.split(",")
		else:
			raise Exception(f"Programming error; invalid option {opt}")

	# We might have to get the resources across multiple namespaces, so we need to do multiple requests
	return
"""

ikt_commandline = {
	"Cordon Node": {
		"command": ["cordon"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Cordon ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"options": {
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": cordon_nodes,
	},
	"Drain Node": {
		"command": ["drain"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Drain ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"options": {
			"--delete-emptydir-data": {
				"description": [("Drain nodes even if this would cause ", "description"), ("emptyDir", "emphasis"), (" data to be deleted", "description")],
			},
			"--delete-local-data": {
				"description": [("This is an alias for “", "description"), ("--delete-emptydir-data", "option"), ("“", "description")],
			},
			"--disable-eviction": {
				"description": [("Delete pods instead of using evict; this bypasses ", "description"), ("PodDisruptionBudget", "emphasis")],
			},
			"--ignore-daemonsets": {
				"description": [("Ignore pods managed by daemonsets; by default ", "description"), ("drain ", "command"), ("will abort if there are such pods running on the node", "description")],
			},
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": drain_nodes,
	},
	"Drain Node (Force)": {
		"command": ["force-drain"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Force-drain ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"extended_description": [
			[("When a node is force-drained, pods belonging to daemonsets are ignored, and ", "description"), ("emptyDir", "emphasis"), (" data is deleted", "description")],
		],
		"options": {
			"--disable-eviction": {
				"description": [("Delete pods instead of using evict; this bypasses ", "description"), ("PodDisruptionBudget", "emphasis")],
			},
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
		"implicit_options": [
			("--delete-emptydir-data", None),
			("--ignore-daemonsets", None),
		],
		"min_args": 1,
		"max_args": 1,
		"callback": drain_nodes,
	},
	"Uncordon Node": {
		"command": ["uncordon"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Uncordon ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"options": {
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": uncordon_nodes,
	},
	"Taint Node": {
		"command": ["taint"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL ", "argument"), ("KEY", "argument"), ("[:", "separator"), ("VALUE", "argument"), ("]=", "separator"), ("EFFECT", "argument")],
		"description": [("Add the taint ", "description"), ("KEY", "argument"), ("[:", "separator"), ("VALUE", "argument"), ("]", "separator"), (" with the effect ", "description"), ("EFFECT", "argument"), (" to ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"extended_description": [
			[("Valid values for ", "description"), ("EFFECT", "argument"), (" are: ", "description"), ("NoSchedule", "argument"), (", ", "separator"), ("PreferNoSchedule", "argument"), (",", "separator"), (" and ", "description"), ("NoExecute", "argument")],
		],
		"options": {
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
			"--overwrite": {
				"description": [("Allow taints to be overwritten (by default conflicting taints are ignored)", "description")],
			}
		},
		"min_args": 2,
		"max_args": 2,
		"callback": taint_nodes,
	},
	"Untaint Node": {
		"command": ["untaint"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL ", "argument"), ("KEY", "argument"), ("[:", "separator"), ("VALUE", "argument"), ("][=", "separator"), ("EFFECT", "argument"), ("]", "separator")],
		"description": [("Remove the taint ", "description"), ("KEY", "argument"), ("[:", "separator"), ("VALUE", "argument"), ("]", "separator"), (" with the effect ", "description"), ("EFFECT", "argument"), (" from ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"extended_description": [
			[("If ", "description"), ("EFFECT", "argument"), (" is not specified, all taints matching ", "description"), ("KEY", "argument"), ("[:", "separator"), ("VALUE", "argument"), ("]", "separator"), (" will be removed", "description")],
		],
		"options": {
			"--include-control-planes": {
				"description": [("Include control planes when ALL is used", "description")],
			},
		},
		"min_args": 2,
		"max_args": 2,
		"callback": untaint_nodes,
	},
	"Prepare Host": {
		"command": ["prepare"],
		"values": [("HOST", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("PATH", "argument")],
		"description": [("Prepare ", "description"), ("HOST", "argument"), (",", "separator"), ("...", "argument"), (" for use as a node in a Kubernetes cluster", "description")],
		"extended_description": [
			[("Note: ", "note"), ("HOST", "argument"), (" should be a resolvable hostname; using IP-addresses may cause issues.", "description")],
			[("If the hosts intended for use as nodes in the cluster do not have a resolvable", "description")],
			[("hostnames it's recommended to use ", "description"), ("/etc/hosts", "path"), (" for this purpose.", "description")],
		],
		"options": {
			"--ignore-existing": {
				"description": [("Ignore hosts that are already part of the cluster", "description")],
			},
			"--forks": {
				"values": [("FORKS", "argument")],
				"description": [("Max number of parallel connections when running Ansible playbooks (overrides ", "description"), ("ikt.yaml", "argument"), ("; default: ", "description"), ("5", "argument"), (")", "description")],
				"requires_arg": True,
			},
			"--from-file": {
				"description": [("Treat the argument to ", "description"), ("prepare", "command"), (" as the path to a file with hostnames instead of a list of hostnames.", "description")],
			},
			"--no-password": {
				"description": [("Do not prompt for a password; use this if the hosts you're preparing are already configured for login using an SSH key", "description")],
			},
			"--save-ansible-logs": {
				"description": [("Save logs from Ansible runs; the logs can be viewed using “", "description"), ("iku", "programname"), (" logs", "command"), ("“", "description")]
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": prepare_hosts,
	},
	"Add Node": {
		"command": ["add-node", "add-nodes"],
		"values": [("HOST", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Add ", "description"), ("HOST", "argument"), (",", "separator"), ("...", "argument"), (" as Kubernetes nodes to a cluster", "description")],
		"extended_description": [
			[("Note: ", "note"), ("HOST", "argument"), (" should be a resolvable hostname; using IP-addresses may cause issues.", "description")],
			[("If the hosts intended for use as nodes in the cluster do not have a resolvable", "description")],
			[("hostnames it's recommended to use ", "description"), ("/etc/hosts", "path"), (" for this purpose.", "description")],
		],
		"options": {
			"--ca-cert-file": {
				"values": [("PATH", "argument")],
				"description": [("Use ", "description"), ("PATH", "argument"), (" as token CA certificate", "description")],
				"requires_arg": True,
			},
			"--cri": {
				"values": [("CRI", "argument")],
				"description": [("Use ", "description"), ("CRI", "argument"), (" instead of the default CRI", "description")],
				"extended_description": [
					[("Valid options for CRI (Container Runtime Interface) are:", "description")],
					[
						("dockershim", "argument"), (" (", "description"), ("Kubernetes", "programname"), (" < ", "description"), ("1.24", "version"), (")", "description"), (", ", "separator"),
						("containerd", "argument"), (", ", "separator"),
					],
					[
						("manual", "argument"), (" (do not install a CRI; this requires you to manually install and configure the CRI)", "description"),
					],
					[("The default CRI is ", "description"), ("dockershim", "argument"), (" for ", "description"), ("Kubernetes", "programname"), (" < ", "description"), ("1.24", "version")],
					[("and ", "description"), ("containerd", "argument"), (" for ", "description"), ("Kubernetes", "programname"), (" >= ", "description"), ("1.24", "version")],
				],
				"requires_arg": True,
			},
			"--forks": {
				"values": [("FORKS", "argument")],
				"description": [("Max number of parallel connections when running Ansible playbooks (overrides ", "description"), ("ikt.yaml", "argument"), ("; default: ", "description"), ("5", "argument"), (")", "description")],
				"requires_arg": True,
			},
			"--from-file": {
				"description": [("Treat the argument to ", "description"), ("prepare", "command"), (" as the path to a file with hostnames instead of a list of hostnames.", "description")],
			},
			"--ignore-existing": {
				"description": [("Ignore hosts that are already part of the cluster", "description")],
			},
			"--ignore-non-existing": {
				"description": [("Ignore hosts that are not part of the inventory", "description")],
			},
			"--save-ansible-logs": {
				"description": [("Save logs from Ansible runs; the logs can be viewed using “", "description"), ("iku", "programname"), (" logs", "command"), ("“", "description")]
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": add_nodes,
	},
	"Remove Node": {
		"command": ["remove-node", "remove-nodes"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Remove ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument"), (" from a Kubernetes cluster", "description")],
		"options": {
			"--force": {
				"description": [("Attempt to teardown Kubernetes nodes that are no longer in the cluster", "description")],
			},
			"--forks": {
				"values": [("FORKS", "argument")],
				"description": [("Max number of parallel connections when running Ansible playbooks (overrides ", "description"), ("ikt.yaml", "argument"), ("; default: ", "description"), ("5", "argument"), (")", "description")],
				"requires_arg": True,
			},
			"--purge": {
				"description": [("Purge hosts if teardown completes successfully", "description")],
			},
			"--save-ansible-logs": {
				"description": [("Save logs from Ansible runs; the logs can be viewed using “", "description"), ("iku", "programname"), (" logs", "command"), ("“", "description")]
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": remove_nodes,
	},
	"Purge": {
		"command": ["purge"],
		"values": [("HOST", "argument"), (",", "separator"), ("...", "argument")],
		"description": [("Remove Kubernetes configuration and packages from ", "description"), ("HOST", "argument")],
		"options": {
			"--ignore-non-existing": {
				"description": [("Ignore hosts that cannot be found in the inventory", "description")],
			},
			"--forks": {
				"values": [("FORKS", "argument")],
				"description": [("Max number of parallel connections when running Ansible playbooks (overrides ", "description"), ("ikt.yaml", "argument"), ("; default: ", "description"), ("5", "argument"), (")", "description")],
				"requires_arg": True,
			},
			"--save-ansible-logs": {
				"description": [("Save logs from Ansible runs; the logs can be viewed using “", "description"), ("iku", "programname"), (" logs", "command"), ("“", "description")]
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": purge_hosts,
	},
	"Upgrade Node": {
		"command": ["upgrade-node", "upgrade-nodes"],
		"values": [("NODE", "argument"), (",", "separator"), ("...", "argument"), ("|", "separator"), ("ALL", "argument")],
		"description": [("Upgrade Kubernetes on ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument")],
		"extended_description": [
			[("Upgrade Kubernetes on ", "description"), ("NODE", "argument"), (",", "separator"), ("...", "argument"), (" to the version in use on the control-plane(s);", "description")],
			[("run this on all nodes after running “", "description"), (f"{about.ADMIN_PROGRAM_NAME}", "programname"), (" upgrade-control-plane", "command"), ("“", "description")],
		],
		"options": {
			"--forks": {
				"values": [("FORKS", "argument")],
				"description": [("Max number of parallel connections when running Ansible playbooks (overrides ", "description"), ("ikt.yaml", "argument"), ("; default: ", "description"), ("5", "argument"), (")", "description")],
				"requires_arg": True,
			},
			"--save-ansible-logs": {
				"description": [("Save logs from Ansible runs; the logs can be viewed using “", "description"), ("iku", "programname"), (" logs", "command"), ("“", "description")]
			},
		},
		"min_args": 1,
		"max_args": 1,
		"callback": upgrade_nodes,
	},
	"spacer1": {
		"command": [""],
		"description": [("", "default")],
	},
#	"Get": {
#		"command": ["get", "l", "list"],
#		"values": [("RESOURCE", "argument"), (",", "separator"), ("...", "argument")],
#		"description": [("List information about ", "description"), ("RESOURCE", "argument"), (",", "separator"), ("...", "argument")],
#		"options": {
#			("-N", "--namespace"): {
#				"values": [("NAMESPACE", "argument"), (",", "separator"), ("...", "argument")],
#				"description": [("Only show resources belonging to ", "description"), ("NAMESPACE", "argument"), (",", "separator"), ("...", "argument")],
#				"requires_arg": True,
#			},
#			("-A", "--all-namespaces"): {
#				"description": [("Show resources across all namespaces", "description")],
#			},
#		},
#		"min_args": 1,
#		"max_args": 1,
#		"callback": get_resource,
#	},
	"extended_description": [
		[("You can use “", "description"), ("ALL", "emphasis"), ("“ as a substitute for all resources in most cases;", "description")],
		[("for instance “", "description"), (f"{about.TOOL_PROGRAM_NAME}", "programname"), (" upgrade-node ", "command"), ("ALL", "emphasis"), ("“ will upgrade Kubernetes on all nodes", "description")],
		[("", "default")],
		[("Note that “", "description"), ("ALL", "emphasis"), ("“ excludes control planes when used on nodes; to include control planes", "description")],
		[("you need to pass the “", "description"), ("--include-control-planes", "option"), ("“ option (where available)", "description")],
	]
}

def get_programname(callname):
	"""
	Return the name that the program was called with;
	the eventual intention here is that the behaviour can be different
	depending on by what name the program was invoked

		Parameters:
			callname (str): The name that the program was invoked with
		Returns:
			(callname (str), commandline (list[str]))
	"""

	callnames = {
		"ikt": ikt_commandline,		# main name
		#"iktdep": dep_commandline,	# deployment shortcut
		#"iktds": ds_commandline,	# daemon set shortcut
		#"iktrs": rs_commandline,	# replica set shortcut
		#"iktjob": job_commandline,	# job shortcut
		#"iktnode": node_commandline,	# node shortcut
		#"iktpod": pod_commandline,	# pod shortcut
	}

	if callname not in callnames:
		sys.exit(f"{about.TOOL_PROGRAM_NAME} called with unknown name {callname}; aborting.")

	return callname, callnames[callname]

def main() -> int:
	"""
	Main function for the program
	"""

	# Before doing anything else, make sure that the user isn't running as root
	if os.geteuid() == 0:
		sys.exit("CRITICAL: This program should not be run as the root user; aborting.")

	argv = sys.argv

	programname, commandline = get_programname(os.path.basename(argv[0]))

	command, options, args = parse_commandline(programname, about.TOOL_PROGRAM_VERSION, PROGRAMDESCRIPTION, PROGRAMAUTHORS, argv, commandline, theme = DEFAULT_THEME_FILE)

	# Used by the ansible module
	ansible_configuration["ansible_forks"] = deep_get(iktconfig, DictPath("Ansible#forks"), 5)
	ansible_user = deep_get(iktconfig, DictPath("Ansible#ansible_user"))
	if ansible_user is None or len(ansible_user) == 0:
		ansible_user = getuser()
	ansible_configuration["ansible_user"] = ansible_user
	ansible_password = deep_get(iktconfig, DictPath("Ansible#ansible_password"))
	if ansible_password is not None and len(ansible_password) > 0:
		ansible_configuration["ansible_password"] = ansible_password
	ansible_configuration["disable_strict_host_key_checking"] = deep_get(iktconfig, DictPath("Nodes#disablestricthostkeychecking"), False)
	ansible_configuration["save_logs"] = deep_get(iktconfig, DictPath("Ansible#save_logs"), False)

	return command(options, args)

if __name__ == "__main__":
	main()
