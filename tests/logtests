#! /bin/sh
# vim: filetype=python
# pylint: disable-next=anomalous-backslash-in-string,line-too-long
''''eval version=$( ls /usr/bin/python3.* | grep '.*[0-9]$' | sort -nr -k2 -t. | head -n1 ) && version=${version##/usr/bin/python3.} && [ ${version} ] && [ ${version} -ge 8 ] && exec /usr/bin/python3.${version} "$0" "$@" || exec /usr/bin/env python3 "$0" "$@"' #'''
__doc__ = "The above hack is to handle distros that don't have /usr/bin/python3 point to the latest version of python3 they provide"
# Requires: python3 (>= 3.8)

# unit-tests for logparser.py

import sys
from typing import Callable, Dict, Tuple

from cmtio import execute_command, execute_command_with_response, expand_path, secure_read_string, secure_which, secure_write_string
from cmtio_yaml import secure_read_yaml, secure_read_yaml_all
from cmttypes import LogLevel, loglevel_mappings
import logparser as logparsers

def test_get_loglevel_names_and_name_to_loglevel(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True
	loglevels = []

	fun = logparsers.get_loglevel_names
	fun_str = "logparsers.get_loglevel_names"
	tmp = fun()
	if verbose:
		print(f"  loglevel_names: {tmp}")

	if tmp is None:
		message = f"{fun_str}() returned None"
		result = False
	elif not isinstance(tmp, list):
		message = f"{fun_str}() returned wrong type ({type(tmp)}), expected list"
		result = False
	elif len(tmp) == 0:
		message = "{fun_str}() returned an empty list"
		result = False
	else:
		loglevels = tmp
		fun_str = "logparsers.name_to_loglevel"
		fun = logparsers.name_to_loglevel
		for indata in loglevels:
			tmp = fun(indata)
			if tmp is None:
				message = f"{fun_str}() returned None for valid indata {indata}"
			elif not isinstance(tmp, LogLevel):
				message = f"{fun_str}() returned wrong type ({type(tmp)}) with valid indata {indata}, expected LogLevel"
				result = False
				break
			if verbose:
				print(f"  <{tmp}>: {indata}")

	if result:
		try:
			indata = "NOT A LOGLEVEL"
			fun(indata)
			message = f"{fun_str}() silently accepted invalid indata {indata}"
			result = False
		except ValueError:
			pass

	return message, result

def test_month_to_numerical(verbose: bool = False) -> Tuple[str, bool]:
	verbose = False
	message = ""
	result = True

	for indata in ("jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"):
		fun = logparsers.month_to_numerical
		fun_str = "logparsers.month_to_numerical"
		tmp = fun(indata)
		if tmp is None:
			message = f"{fun_str}() returned None with valid indata {indata}"
			result = False
		elif not isinstance(tmp, str):
			message = f"{fun_str}() returned wrong type ({type(tmp)}) with valid indata {indata}, expected str"
			result = False
		else:
			if verbose:
				print(f"{tmp}: {indata.capitalize()}")

	if result:
		try:
			indata = "NOT A MONTH"
			fun(indata)
			message = f"{fun_str}() silently accepted invalid indata ({indata})"
			result = False
		except ValueError:
			pass

	return message, result

def generic_str_to_severity(valid_indata: Tuple[str], fun: Callable, fun_str: str, verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	for indata in valid_indata:
		tmp = fun(indata)
		if tmp is None:
			message = f"{fun_str}() returned None with valid indata {indata}"
			result = False
		elif not isinstance(tmp, LogLevel):
			message = f"{fun_str}() returned wrong type ({type(tmp)}) for valid indata {indata}, expected LogLevel"
			result = False
		else:
			if verbose:
				print(f"<{indata}>: {fun(indata)}")

	if result:
		# If we don't pass a default we should get None
		indata = "#"
		tmp = fun(indata)
		if tmp is not None:
			message = f"{fun_str}(default = None) returned {tmp} with invalid indata ({indata}), expected None"
			result = False

	if result:
		# If we pass a default we should get that default back if the severity is invalid
		tmp = fun(indata, default = LogLevel.NOTICE)
		if tmp is None:
			message = f"{fun_str}(default = LogLevel.NOTICE) returned None with invalid indata ({indata}), expected LogLevel.NOTICE"
			result = False
		elif not isinstance(tmp, LogLevel):
			message = f"{fun_str}(default = LogLevel.NOTICE) returned wrong type ({type(tmp)}) with invalid indata {indata} with default = LogLevel.NOTICE, expected LogLevel"
			result = False
		elif tmp != LogLevel.NOTICE:
			message = f"{fun_str}(default = LogLevel.NOTICE) returned value ({repr(tmp)}) with invalid indata {indata} with default = LogLevel.NOTICE, expected LogLevel.NOTICE"
			result = False

	return message, result

def test_letter_to_severity(verbose: bool = False) -> Tuple[str, bool]:
	return generic_str_to_severity(valid_indata = ("F", "E", "W", "N", "C", "I", "D"), fun = logparsers.letter_to_severity, fun_str = "logparsers.letter_to_severity")

def test_str_3letter_to_severity(verbose: bool = False) -> Tuple[str, bool]:
	return generic_str_to_severity(valid_indata = ("ERR", "WRN", "INF"), fun = logparsers.str_3letter_to_severity, fun_str = "logparsers.str_3letter_to_severity")

def test_str_4letter_to_severity(verbose: bool = False) -> Tuple[str, bool]:
	return generic_str_to_severity(valid_indata = ("CRIT", "FATA", "ERRO", "WARN", "NOTI", "SUCC", "INFO", "DEBU"), fun = logparsers.str_4letter_to_severity, fun_str = "logparsers.str_4letter_to_severity")

def test_str_to_severity(verbose: bool = False) -> Tuple[str, bool]:
	return generic_str_to_severity(valid_indata = ("fatal", "error", "eror", "warning", "warn", "notice", "noti", "info", "debug", "debu"), fun = logparsers.str_to_severity, fun_str = "logparsers.str_to_severity")

def generic_lvl_to_severity(valid_indata: Tuple[LogLevel], fun: Callable, fun_str: str, verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	for indata in valid_indata:
		tmp = fun(indata)
		if tmp is None:
			message = f"{fun_str}() returned None with valid indata {indata}"
			result = False
		elif not isinstance(tmp, str):
			message = f"{fun_str}() returned wrong type ({type(tmp)}) for valid indata {indata}, expected str"
			result = False
		else:
			if verbose:
				print(f"<{indata}>: {fun(indata)}")

	if result:
		indata = -42
		tmp = fun(indata)
		if tmp is None:
			message = f"{fun_str}() returned None for invalid indata {indata}, expected !ERROR IN LOGPARSER!"
			result = False
		elif tmp != "!ERROR IN LOGPARSER!":
			message = f"{fun_str}() returned {tmp} for invalid indata {indata}, expected !ERROR IN LOGPARSER!"
			result = False

	return message, result

def test_lvl_to_letter_severity(verbose: bool = False) -> Tuple[str, bool]:
	return generic_lvl_to_severity(valid_indata = (LogLevel.CRIT, LogLevel.ERR, LogLevel.WARNING, LogLevel.NOTICE, LogLevel.INFO, LogLevel.DEBUG), fun = logparsers.lvl_to_letter_severity, fun_str = "logparsers.lvl_to_letter_severity")

def test_lvl_to_4letter_severity(verbose: bool = False) -> Tuple[str, bool]:
	return generic_lvl_to_severity(valid_indata = (LogLevel.CRIT, LogLevel.ERR, LogLevel.WARNING, LogLevel.NOTICE, LogLevel.INFO, LogLevel.DEBUG), fun = logparsers.lvl_to_4letter_severity, fun_str = "logparsers.lvl_to_4letter_severity")

def test_lvl_to_word_severity(verbose: bool = False) -> Tuple[str, bool]:
	return generic_lvl_to_severity(valid_indata = (LogLevel.CRIT, LogLevel.ERR, LogLevel.WARNING, LogLevel.NOTICE, LogLevel.INFO, LogLevel.DEBUG), fun = logparsers.lvl_to_word_severity, fun_str = "logparsers.lvl_to_word_severity")

def generic_split_severity(valid_indata: Tuple[str], fun: Callable, fun_str: str, verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True
	default = LogLevel.INFO

	for indata in valid_indata:
		# indata is just a prefix; we want to test with a string prefixed by that prefix"
		indata = f"{indata} something or another"
		tmp = fun(message, default = default)
		if tmp is None:
			message = f"{fun_str}() returned None with valid indata {indata}"
			result = False
		elif not isinstance(tmp, tuple):
			message = f"{fun_str}() returned wrong type ({type(tmp)}) for valid indata {indata}, expected (str, LogLevel)"
			result = False
		elif len(tmp) != 2:
			message = f"{fun_str}() return-value has length {len(tmp)} for valid indata {indata}, expected 2"
			result = False
		elif not isinstance(tmp[0], str) or not isinstance(tmp[1], LogLevel):
			message = f"{fun_str}() returned wrong type ({type(tmp[0])}, {type(tmp[1])}) for valid indata {indata}, expected (str, LogLevel)"
			result = False
		else:
			if verbose:
				print(f"<{indata}, default = {default}>: {fun(indata, default = default)}")

	if result:
		indata = "NOT A VALID PREFIX"
		tmp = fun(indata, default = default)
		if tmp is None:
			message = f"{fun_str}() returned None for invalid indata {indata}, expected ({indata}, {default})"
			result = False
		elif not isinstance(tmp, tuple):
			message = f"{fun_str}() returned wrong type ({type(tmp)}) for invalid indata {indata}, expected tuple"
			result = False
		elif len(tmp) != 2:
			message = f"{fun_str}() return-value has length {len(tmp)} for invalid indata {indata}, expected 2"
			result = False
		elif not isinstance(tmp[0], str) or not isinstance(tmp[1], LogLevel):
			message = f"{fun_str}() returned wrong type ({type(tmp[0])}, {type(tmp[1])}) for invalid indata {indata}, expected (str, LogLevel)"
			result = False
		elif tmp[0] != indata or tmp[1] != default:
			message = f"{fun_str}() returned wrong result ({tmp}) for invalid indata {indata}, expected ({indata}, {default})"
			result = False

	return message, result

def test_split_bracketed_severity(verbose: bool = False) -> Tuple[str, bool]:
	return generic_split_severity(valid_indata = ("[fatal]", "[alert]", "[error]", "[err]", "[warning]", "[warn]", "[notice]", "[info]", "[system]", "[note]", "[debug]"),
				      fun = logparsers.split_bracketed_severity, fun_str = "logparsers.split_bracketed_severity", verbose = verbose)

def test_split_colon_severity(verbose: bool = False) -> Tuple[str, bool]:
	return generic_split_severity(valid_indata = ("CRITICAL:", "ERROR:", "WARNING:", "NOTICE:", "NOTE:", "INFO:", "DEBUG:"),
				      fun = logparsers.split_colon_severity, fun_str = "logparsers.split_colon_severity", verbose = verbose)

tests: Dict = {
	("get_loglevel_names()", "name_to_loglevel()"): {
		"callable": test_get_loglevel_names_and_name_to_loglevel,
		"result": None,
	},
	("month_to_numerical()", ): {
		"callable": test_month_to_numerical,
		"result": None,
	},
	("letter_to_severity", ): {
		"callable": test_letter_to_severity,
		"result": None,
	},
	("str_3letter_to_severity", ): {
		"callable": test_str_3letter_to_severity,
		"result": None,
	},
	("str_4letter_to_severity", ): {
		"callable": test_str_4letter_to_severity,
		"result": None,
	},
	("str_to_severity", ): {
		"callable": test_str_to_severity,
		"result": None,
	},
	("lvl_to_letter_severity", ): {
		"callable": test_lvl_to_letter_severity,
		"result": None,
	},
	("lvl_to_4letter_severity", ): {
		"callable": test_lvl_to_4letter_severity,
		"result": None,
	},
	("lvl_to_word_severity", ): {
		"callable": test_lvl_to_word_severity,
		"result": None,
	},
	("split_bracketed_severity", ): {
		"callable": test_split_bracketed_severity,
		"result": None,
	},
	("split_colon_severity", ): {
		"callable": test_split_colon_severity,
		"result": None,
	},
}

def main() -> int:
	fail = 0
	verbose = False

	for i, test in enumerate(tests):
		print(f"[{i:03}/{len(tests) - 1:03}] {', '.join(test)}:")
		message, result = tests[test]["callable"](verbose = verbose)
		if len(message) > 0:
			print(f"  \033[1;31mFAIL\033[0m: {message}")
		else:
			print("  \033[1;32mPASS\033[0m")
		tests[test]["result"] = result
		if not result:
			fail += 1

	return fail

if __name__ == "__main__":
	main()
