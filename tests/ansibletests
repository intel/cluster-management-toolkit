#! /bin/sh
# vim: filetype=python
# pylint: disable-next=anomalous-backslash-in-string,line-too-long
''''eval version=$( ls /usr/bin/python3.* | grep '.*[0-9]$' | sort -nr -k2 -t. | head -n1 ) && version=${version##/usr/bin/python3.} && [ ${version} ] && [ ${version} -ge 8 ] && exec /usr/bin/python3.${version} "$0" "$@" || exec /usr/bin/env python3 "$0" "$@"' #'''
__doc__ = "The above hack is to handle distros that don't have /usr/bin/python3 point to the latest version of python3 they provide"
# Requires: python3 (>= 3.8)
#
# Copyright the Cluster Management Toolkit for Kubernetes contributors.
# SPDX-License-Identifier: MIT

import copy
from datetime import datetime, timezone
import os
from pathlib import PurePath
import sys
import tempfile
from typing import Dict, Tuple
import yaml

import cmtlib
from cmtio_yaml import secure_read_yaml, secure_write_yaml
from cmtpaths import ANSIBLE_PLAYBOOK_DIR, ANSIBLE_INVENTORY
from cmttypes import deep_get, deep_set, DictPath, FilePath, ArgumentValidationError, FilePathAuditError
from ansithemeprint import ANSIThemeString, ansithemeprint, init_ansithemeprint, ansithemestring_join_tuple_list
import ansible_helper

TEST_PLAYBOOKS_DIR = FilePath(str(PurePath(__file__).parent.joinpath("testplaybooks")))

# unit-tests for ansible_helper.py

def yaml_dump(data: Dict, base_indent: int = 4) -> str:
	result = ""
	dump = yaml.dump(data)
	for line in dump.splitlines():
		result += f"{' '.ljust(base_indent)}{line}\n"
	return result

def test_get_playbook_path(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.get_playbook_path
	fun_str = "ansible_helper.get_playbook_path"

	# Add non-existing local paths to cmtconfig
	deep_set(cmtlib.cmtconfig, DictPath("Ansible#local_playbooks"),
		 ["/NONEXISTINGPATH", "{HOME}/NONEXISTINGPATH2", "/etc/hosts", ANSIBLE_PLAYBOOK_DIR], create_path = True)

	if result:
		ansithemeprint([ANSIThemeString("  Note", "note"), ANSIThemeString(": These testcases only works correctly if the playbooks have not been overridden:\n", "default")])

		# Indata format:
		# (playbook, expected_result, expected_exception)
		testdata = (
			("get_versions.yaml", os.path.join(ANSIBLE_PLAYBOOK_DIR, "get_versions.yaml"), None),
			("NONEXISTINGPLAYBOOK.yaml", os.path.join(ANSIBLE_PLAYBOOK_DIR, "NONEXISTINGPLAYBOOK.yaml"), None),
			("", None, ValueError),
			(None, None, TypeError),
			(1, None, TypeError),
		)
		for indata, expected_result, expected_exception in testdata:
			try:
				if (tmp := fun(indata)) != expected_result:
					message = f"{fun_str}() did not yield expected result:\n" \
						  f"          input: {indata}\n" \
						  f"         output: {tmp}\n" \
						  f"       expected: {expected_result}"
					result = False
					break
			except Exception as e:
				if expected_exception is not None:
					if isinstance(e, expected_exception):
						pass
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"          input: {indata}\n" \
							  f"      exception: {type(e)}\n" \
							  f"       expected: {expected_exception}"
						result = False
						break
				else:
					message = f"{fun_str}() did not yield expected result:\n" \
						  f"          input: {indata}\n" \
						  f"      exception: {type(e)}\n" \
						  f"       expected: {expected_result}"
					result = False
					break
	return message, result

def test_populate_playbooks_from_paths(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.populate_playbooks_from_paths
	fun_str = "ansible_helper.populate_playbooks_from_paths"

	if result:
		ansithemeprint([ANSIThemeString("  Note", "note"), ANSIThemeString(": These testcases only works correctly if the playbooks have not been overridden:\n", "default")])

		# Indata format:
		# (playbook, expected_result, expected_exception)
		testdata = (
			([os.path.join(ANSIBLE_PLAYBOOK_DIR, "get_versions.yaml")],
			 [([ANSIThemeString(string="  • ", themeref="separator"),
			    ANSIThemeString(string="Get package versions", themeref="play")],
			   os.path.join(ANSIBLE_PLAYBOOK_DIR, "get_versions.yaml"))], None),
			([os.path.join(ANSIBLE_PLAYBOOK_DIR, "NONEXISTINGPLAYBOOK.yml")], None, FilePathAuditError),
			([os.path.join(TEST_PLAYBOOKS_DIR, "hostname.yml")],
			 [([ANSIThemeString(string="  • ", themeref="separator"),
			   ANSIThemeString(string="Hostname test playbook; local, lacks summary", themeref="play")],
			   os.path.join(TEST_PLAYBOOKS_DIR, "hostname.yml"))], None),
			([os.path.join(TEST_PLAYBOOKS_DIR, ".hostname.yml")], [], None),
			([os.path.join(TEST_PLAYBOOKS_DIR, "uptime.yaml")],
			 [([ANSIThemeString(string="  • ", themeref="separator"),
			    ANSIThemeString(string="Running “", themeref="play"),
			    ANSIThemeString(string="uptime", themeref="programname"),
			    ANSIThemeString(string="“", themeref="play")],
			   os.path.join(TEST_PLAYBOOKS_DIR, "uptime.yaml"))], None),
			([os.path.join(TEST_PLAYBOOKS_DIR, "~uptime.yaml")], [], None),
			([os.path.join(TEST_PLAYBOOKS_DIR, "uptime.json")], None, ValueError),
			([os.path.join(TEST_PLAYBOOKS_DIR, "uptime.yaml", "NonExistingFile.yaml")], None, FilePathAuditError),
			([""], None, ValueError),
			(None, None, TypeError),
			(1, None, TypeError),
		)
		for indata, expected_result, expected_exception in testdata:
			try:
				if (tmp := fun(indata)) != expected_result:
					message = f"{fun_str}() did not yield expected result:\n" \
						  f"          input: {indata}\n" \
						  f"         output: {tmp}\n" \
						  f"       expected: {expected_result}"
					result = False
					break
			except Exception as e:
				if expected_exception is not None:
					if isinstance(e, expected_exception):
						pass
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"          input: {indata}\n" \
							  f"      exception: {type(e)}\n" \
							  f"       expected: {expected_exception}"
						result = False
						break
				else:
					message = f"{fun_str}() did not yield expected result:\n" \
						  f"          input: {indata}\n" \
						  f"      exception: {type(e)}\n" \
						  f"       expected: {expected_result}"
					result = False
					break
	return message, result

def test_ansible_print_action_summary(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_print_action_summary
	fun_str = "ansible_helper.ansible_print_action_summary"

	if result:
		ansithemeprint([ANSIThemeString("  Note", "note"), ANSIThemeString(": These testcases only works correctly if the playbooks have not been overridden.", "default")])
		ansithemeprint([ANSIThemeString("      ", "note"), ANSIThemeString("  Manual sanity checking is necessary for these test results.\n", "default")])

		# Indata format:
		# (playbook, expected_result, expected_exception)
		testdata = (
			(ansible_helper.populate_playbooks_from_paths([os.path.join(ANSIBLE_PLAYBOOK_DIR, "get_versions.yaml")]), None),
			(ansible_helper.populate_playbooks_from_paths([os.path.join(TEST_PLAYBOOKS_DIR, "uptime.yaml")]), None),
			([], ValueError),
			([1], TypeError),
			(None, TypeError),
			(1, TypeError),
		)
		for indata, expected_exception in testdata:
			try:
				tmp = fun(indata)
			except Exception as e:
				if expected_exception is not None:
					if isinstance(e, expected_exception):
						pass
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"          input: {indata}\n" \
							  f"      exception: {type(e)}\n" \
							  f"       expected: {expected_exception}"
						result = False
						break
				else:
					message = f"{fun_str}() did not yield expected result:\n" \
						  f"          input: {indata}\n" \
						  f"      exception: {type(e)}\n"
					result = False
					break
	return message, result

def test_ansible_get_inventory_dict(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_get_inventory_dict
	fun_str = "ansible_helper.ansible_get_inventory_dict"

	if result:
		ansithemeprint([ANSIThemeString("  Note", "note"), ANSIThemeString(": These testcases only works correctly if there is a valid inventory.", "default")])
		ansithemeprint([ANSIThemeString("      ", "note"), ANSIThemeString("  Manual sanity checking is necessary for these test results.\n", "default")])
		try:
			tmp = fun()
			if not (isinstance(tmp, dict) and len(tmp) > 0):
				message = f"{fun_str}() did not yield expected result:\n" \
					  f"         output: {tmp} (type: {type(tmp)}\n" \
					  f"       expected: {dict}"
				result = False
			print(yaml_dump(tmp, base_indent = 17))
		except Exception as e:
			message = f"{fun_str}() did not yield expected result:\n" \
				  f"      exception: {type(e)}\n"
			result = False
	return message, result

def test_ansible_get_inventory_pretty(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_get_inventory_pretty
	fun_str = "ansible_helper.ansible_get_inventory_pretty"

	if result:
		# Indata format:
		# (groups, highlight, include_groupvars, include_hostvars, include_hosts, expected_exception)
		testdata = (
			(["all"], False, False, False, False, None),
			(["all"], False, False, False, True, None),
			(["all"], True, True, True, True, None),
			([], True, True, True, True, None),
			([], True, True, False, True, None),
			([], True, True, False, True, None),
			(["NotAnExistingGroup"], False, False, False, True, None),
			(["NotAnExistingGroup"], True, True, True, True, None),
			("a", True, True, False, True, TypeError),
			(1, True, True, False, True, TypeError),
			(None, False, False, False, False, None),
		)
		for indata in testdata:
			groups, highlight, include_groupvars, include_hostvars, include_hosts, expected_exception = indata
			try:
				tmp = fun(groups, highlight, include_groupvars, include_hostvars, include_hosts)
				if not (isinstance(tmp, list) and len(tmp) > 0 and (isinstance(tmp[0], str) or len(tmp[0]) > 0 and isinstance(tmp[0], list) and isinstance(tmp[0][0], ANSIThemeString))):
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"          input: {yaml_dump(indata, base_indent = 17)}\n" \
							  f"      exception: {type(e)}\n" \
							  f"  expected type: [str|[ANSIThemeString]]"
						result = False
						break
			except Exception as e:
				if expected_exception is not None:
					if isinstance(e, expected_exception):
						pass
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"          input: {yaml_dump(indata, base_indent = 17)}\n" \
							  f"      exception: {type(e)}\n" \
							  f"       expected: {expected_exception}"
						result = False
						break
				else:
					message = f"{fun_str}() did not yield expected result:\n" \
						  f"          input: {indata}\n" \
						  f"      exception: {type(e)}\n"
					result = False
					break
	return message, result

def test_ansible_get_hosts_by_group(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_get_hosts_by_group
	fun_str = "ansible_helper.ansible_get_hosts_by_group"

	if result:
		# Indata format:
		# (inventory, group)
		testdata = (
			(ANSIBLE_INVENTORY, "all", None),
			(ANSIBLE_INVENTORY, "NonExistingGroup", None),
			("NonExistingPath", "all", None),
			(ANSIBLE_INVENTORY, 1, TypeError),
			(ANSIBLE_INVENTORY, None, TypeError),
			(None, "all", TypeError),
			(1, "all", TypeError),
		)
		for indata in testdata:
			inventory_path, group, expected_exception = indata
			try:
				tmp = fun(inventory_path, group)
				if not (isinstance(tmp, list) and (len(tmp) == 0 or isinstance(tmp[0], str))):
						message = f"{fun_str}() did not yield expected result:\n" \
							  f" inventory path: {inventory_path}\n" \
							  f"          group: {group}\n" \
							  f"      exception: {type(e)}\n" \
							  f"  expected type: [str]"
						result = False
						break
			except Exception as e:
				if expected_exception is not None:
					if isinstance(e, expected_exception):
						pass
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f" inventory path: {inventory_path}\n" \
							  f"          group: {group}\n" \
							  f"      exception: {type(e)}\n" \
							  f"       expected: {expected_exception}"
						result = False
						break
				else:
					message = f"{fun_str}() did not yield expected result:\n" \
						  f" inventory path: {inventory_path}\n" \
						  f"          group: {group}\n" \
						  f"      exception: {type(e)}\n"
					result = False
					break
	return message, result

def test_ansible_get_groups(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_get_groups
	fun_str = "ansible_helper.ansible_get_groups"

	if result:
		# Indata format:
		# (inventory, group)
		testdata = (
			(ANSIBLE_INVENTORY, None),
			("NonExistingPath", None),
			(None, TypeError),
			(1, TypeError),
		)
		for indata in testdata:
			inventory_path, expected_exception = indata
			try:
				tmp = fun(inventory_path)
				if not (isinstance(tmp, list) and (len(tmp) == 0 or isinstance(tmp[0], str))):
						message = f"{fun_str}() did not yield expected result:\n" \
							  f" inventory path: {inventory_path}\n" \
							  f"      exception: {type(e)}\n" \
							  f"  expected type: [str]"
						result = False
						break
			except Exception as e:
				if expected_exception is not None:
					if isinstance(e, expected_exception):
						pass
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f" inventory path: {inventory_path}\n" \
							  f"      exception: {type(e)}\n" \
							  f"       expected: {expected_exception}"
						result = False
						break
				else:
					message = f"{fun_str}() did not yield expected result:\n" \
						  f" inventory path: {inventory_path}\n" \
						  f"      exception: {type(e)}\n"
					result = False
					break
	return message, result

def test_ansible_get_groups_by_host(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_get_groups_by_host
	fun_str = "ansible_helper.ansible_get_groups_by_host"

	if result:
		d = {
			"all": {
				"hosts": {
					"foo": {},
				},
			},
			"group1": {
				"hosts": {
					"foo": {},
				},
			}
		}
		# Indata format:
		# (inventory, group)
		testdata = (
			(d, "foo", ["all", "group1"], None),
			(d, "NonExistingHost", [], None),
			(d, 1, None, ArgumentValidationError),
			(d, None, None, ArgumentValidationError),
			(None, "localhost", None, ArgumentValidationError),
			(1, "localhost", None, ArgumentValidationError),
		)
		for indata in testdata:
			inventory_dict, host, expected_result, expected_exception = indata
			try:
				tmp = fun(inventory_dict, host)
				if tmp != expected_result:
						message = f"{fun_str}() did not yield expected result:\n" \
							   " inventory dict:\n" \
							  f"{yaml_dump(inventory_dict, base_indent = 17)}\n" \
							  f"          group: {host}\n" \
							  f"         output: {tmp}\n" \
							  f"      exception: {type(e)}\n" \
							  f"       expected: {expected_result}"
						result = False
						break
			except Exception as e:
				if expected_exception is not None:
					if isinstance(e, expected_exception):
						pass
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							   " inventory dict:\n" \
							  f"{yaml_dump(inventory_dict, base_indent = 17)}\n" \
							  f"          group: {host}\n" \
							  f"      exception: {type(e)}\n" \
							  f"       expected: {expected_exception}"
						result = False
						break
				else:
					message = f"{fun_str}() did not yield expected result:\n" \
						   " inventory dict:\n" \
						  f"{yaml_dump(inventory_dict, base_indent = 17)}\n" \
						  f"          group: {host}\n" \
						  f"      exception: {type(e)}\n"
					result = False
					break
	return message, result

def test___ansible_create_inventory(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.__ansible_create_inventory
	fun_str = "ansible_helper.__ansible_create_inventory"

	if result:
		real_ansible_user = deep_get(ansible_helper.ansible_configuration, DictPath("ansible_user"))
		real_ansible_password = deep_get(ansible_helper.ansible_configuration, DictPath("ansible_password"))
		real_ansible_disable_strict_host_key_checking = deep_get(ansible_helper.ansible_configuration, DictPath("disable_strict_host_key_checking"))

		with tempfile.TemporaryDirectory() as td, tempfile.NamedTemporaryFile(delete = False) as tf:
			# __ansible_create_inventory() will open the file
			tf.close()

			d = {
				"all": {
					"hosts": {},
					"vars": {
						"ansible_python_interpreter": "/usr/bin/python3",
					},
				}
			}
			d2 = {
				"all": {
					"hosts": {},
					"vars": {
						"ansible_python_interpreter": "/usr/bin/python3",
						"ansible_ssh_pass": "bar",
						"ansible_user": "foo",
					},
				},
				"ansible_ssh_common_args": "-o StrictHostKeyChecking=no",
			}

			if (ansible_user := deep_get(ansible_helper.ansible_configuration, DictPath("ansible_user"))) is not None:
				deep_set(d, DictPath("all#vars#ansible_user"), ansible_user, create_path = True)
			if (ansible_password := deep_get(ansible_helper.ansible_configuration, DictPath("ansible_password"))) is not None:
				deep_set(d, DictPath("all#vars#ansible_ssh_pass"), ansible_user, create_path = True)
			if (disable_strict_host_key_checking := deep_get(ansible_helper.ansible_configuration, DictPath("disable_strict_host_key_checking"), False)):
				deep_set(d, DictPath("ansible_ssh_common_args"), "-o StrictHostKeyChecking=no", create_path = True)
			# Indata format:
			# (path, overwrite, override_ansible_configuration, expected_result, expected_content, expected_exception)
			testdata = (
				(f"{td}/TemporaryFile", False, False, True, d, None),
				# The file should exist now; so write should fail
				(tf.name, False, False, False, None, None),
				# The file should exist now; write should succeed
				(tf.name, True, False, True, d, None),
				(None, True, False, None, None, TypeError),
				(1, True, False, None, None, TypeError),
				(tf.name, None, False, None, None, TypeError),
				(tf.name, 1, False, None, None, TypeError),
				# The file should exist now; write should succeed; override ansible_configuration
				(tf.name, True, True, True, d2, None),
			)
			for indata in testdata:
				path, overwrite, override_ansible_configuration, expected_result, expected_content, expected_exception = indata
				try:
					if override_ansible_configuration:
						deep_set(ansible_helper.ansible_configuration, DictPath("ansible_user"), "foo")
						deep_set(ansible_helper.ansible_configuration, DictPath("ansible_password"), "bar")
						deep_set(ansible_helper.ansible_configuration, DictPath("disable_strict_host_key_checking"), True)
					if (tmp := fun(path, overwrite, temporary = True)) != expected_result:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path}\n" \
							  f"      overwrite: {overwrite}\n" \
							  f"         output: {tmp}\n" \
							  f"       expected: {expected_result}"
						result = False
						break
					# We expect not to write anything, we didn't, so we continue
					if not expected_result:
						continue
					output_d = secure_read_yaml(path, temporary = True)
					if not (output_d is not None and output_d.items() == expected_content.items()):
						message = f"{fun_str}() did not yield expected result:\n" \
							   " inventory dict:\n" \
							  f"{yaml_dump(output_d, base_indent = 17)}\n" \
							  f"       expected:\n" \
							  f"{yaml_dump(expected_content, base_indent = 17)}"
						result = False
						break
				except Exception as e:
					if expected_exception is not None:
						if isinstance(e, expected_exception):
							pass
						else:
							message = f"{fun_str}() did not yield expected result:\n" \
								  f"           path: {path}\n" \
								  f"      overwrite: {overwrite}\n" \
								  f"         output: {tmp}\n" \
								  f"       expected: {expected_exception}"
							result = False
							break
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path}\n" \
							  f"      overwrite: {overwrite}\n" \
							  f"      exception: {type(e)}\n"
						result = False
						break
			deep_set(ansible_helper.ansible_configuration, DictPath("ansible_user"), real_ansible_user)
			deep_set(ansible_helper.ansible_configuration, DictPath("ansible_password"), real_ansible_password)
			deep_set(ansible_helper.ansible_configuration, DictPath("disable_strict_host_key_checking"), real_ansible_disable_strict_host_key_checking)
			os.unlink(tf.name)
	return message, result

def test_ansible_create_groups(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_create_groups
	fun_str = "ansible_helper.ansible_create_groups"

	if result:
		with tempfile.TemporaryDirectory() as td, tempfile.NamedTemporaryFile(delete = False) as tf:
			# __ansible_create_inventory() will open the file
			tf.close()
			tmp = ansible_helper.__ansible_create_inventory(tf.name, overwrite = True, temporary = True)
			d = secure_read_yaml(tf.name, temporary = True)

			# Indata format:
			# (path, groups, expected_content, expected_result, expected_exception)
			testdata = (
				(f"{td}/TemporaryFile", ["group1", "group2", "group3"], ["group1", "group2", "group3"], True, None),
				# Pre-existing groups are ignored
				(tf.name, ["group1", "group2", "group2", "group3"], ["group1", "group2", "group3"], True, None),
				(tf.name, ["group1", "group2", "group2", "group3"], ["group1", "group2", "group3"], True, None),
				# Empty lists are ignored
				(tf.name, [], None, True, None),
				# None is ignored
				(tf.name, None, None, True, None),
				(tf.name, [1], None, None, TypeError),
				(tf.name, [None], None, None, TypeError),
			)
			for indata in testdata:
				path, groups, expected_content, expected_result, expected_exception = indata
				try:
					if (tmp := fun(path, groups, temporary = True)) != expected_result:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"         output: {tmp}\n" \
							  f"       expected: {expected_result}"
						result = False
						break
					# We expect not to write anything, we didn't, so we continue
					if not expected_result or groups is None or len(groups) == 0:
						continue
					output_d = secure_read_yaml(path, temporary = True)
					for group in expected_content:
						if group not in output_d:
							message = f"{fun_str}() did not yield expected result:\n" \
								   "      inventory:\n" \
								  f"{yaml_dump(output_d, base_indent = 17)}\n" \
								  f" should include: {expected_content}"
							result = False
							break
				except Exception as e:
					if expected_exception is not None:
						if isinstance(e, expected_exception):
							pass
						else:
							message = f"{fun_str}() did not yield expected result:\n" \
								  f"           path: {path} (tempfile)\n" \
								  f"         output: {tmp}\n" \
								  f"       expected: {expected_exception}"
							result = False
							break
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"      exception: {type(e)}\n"
						result = False
						break
			os.unlink(tf.name)
	return message, result

def test_ansible_set_vars(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_set_vars
	fun_str = "ansible_helper.ansible_set_vars"

	if result:
		with tempfile.TemporaryDirectory() as td, tempfile.NamedTemporaryFile(delete = False) as tf:
			# __ansible_create_inventory() will open the file
			tf.close()
			tmp = ansible_helper.__ansible_create_inventory(tf.name, overwrite = True, temporary = True)
			ansible_helper.ansible_create_groups(tf.name, ["foo", "bar"], temporary = True)
			d = secure_read_yaml(tf.name, temporary = True)

			# Indata format:
			# (path, group, values, expected_content, expected_result, expected_exception)
			testdata = (
				(f"{td}/TemporaryFile", "foo", { "bar": 1, "baz": "text"}, {"foo": { "bar": 1, "baz": "text"}}, True, None),
				(tf.name, "foo", { "bar": 1, "baz": "text"}, {"foo": { "bar": 1, "baz": "text"}}, True, None),
				(tf.name, "foo", { "bar": 1, "baz": "text"}, {"foo": { "bar": 1, "baz": "text"}}, True, None),
				("", "foo", { "bar": 1, "baz": "text"}, {"foo": { "bar": 1, "baz": "text"}}, None, ArgumentValidationError),
				(None, "foo", { "bar": 1, "baz": "text"}, {"foo": { "bar": 1, "baz": "text"}}, True, ArgumentValidationError),
			)
			for indata in testdata:
				path, group, values, expected_content, expected_result, expected_exception = indata
				try:
					if (tmp := fun(path, group, values, temporary = True)) != expected_result:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"         output: {tmp}\n" \
							  f"       expected: {expected_result}"
						result = False
						break
					# We expect not to write anything, we didn't, so we continue
					if not expected_result or group is None or len(group) == 0 or values is None or len(values) == 0:
						continue
					output_d = secure_read_yaml(path, temporary = True)
					for group in expected_content:
						if group not in output_d:
							message = f"{fun_str}() did not yield expected result:\n" \
								   "      inventory:\n" \
								  f"{yaml_dump(output_d, base_indent = 17)}\n" \
								  f" should include: {expected_content}"
							result = False
							break
				except Exception as e:
					if expected_exception is not None:
						if isinstance(e, expected_exception):
							pass
						else:
							message = f"{fun_str}() did not yield expected result:\n" \
								  f"           path: {path} (tempfile)\n" \
								  f"         output: {tmp}\n" \
								  f"       expected: {expected_exception}\n" \
								  f"      exception: {e}"
							result = False
							break
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"      exception: {type(e)}\n"
						result = False
						break
	os.unlink(tf.name)
	return message, result

def test_ansible_set_groupvars(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_set_groupvars
	fun_str = "ansible_helper.ansible_set_groupvars"

	if result:
		with tempfile.TemporaryDirectory() as td, tempfile.NamedTemporaryFile(delete = False) as tf:
			# __ansible_create_inventory() will open the file
			tf.close()
			d = {
				"foo": {
					"hosts": {
					},
					"vars": {
					},
				},
				"bar": None,
			}
			secure_write_yaml(tf.name, d, temporary = True)

			# Indata format:
			# (path, groups, values, expected_content, expected_result, expected_exception)
			testdata = (
				(tf.name, ["foo"], [("bar", 1), ("baz", "text")],
				 {"foo": {"hosts": {}, "vars": {"bar": 1, "baz": "text"}}}, True, None),
				(tf.name, ["foo"], [("bar", 1), ("baz", "text")],
				 {"foo": {"hosts": {}, "vars": {"bar": 1, "baz": "text"}}}, True, None),
				(tf.name, ["bar"], [("meaning", 42)],
				 {"foo": {"hosts": {}, "vars": {}}, "bar": {"vars": {"meaning": 42}}}, True, None),
				(tf.name, ["nonexisting"], [("bar", 1), ("baz", "text")],
				 {}, True, None),
				(f"{td}/TemporaryFile", ["foo", "bar"], [("bar", 1), ("baz", "text")],
				 {"foo": {"hosts": {}, "vars": {"bar": 1, "baz": "text"}}, "bar": {"hosts": {}, "vars": {"bar": 1, "baz": "text"}}}, None, FilePathAuditError),
				("", ["foo"], [("bar", 1), ("baz", "text")], None, None, ArgumentValidationError),
				(None, ["foo"], [("bar", 1), ("baz", "text")], None, True, ArgumentValidationError),
			)
			for indata in testdata:
				secure_write_yaml(tf.name, copy.deepcopy(d), temporary = True)
				path, groups, values, expected_content, expected_result, expected_exception = indata
				try:
					if (tmp := fun(path, groups, values, temporary = True)) != expected_result:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"         output: {tmp}\n" \
							  f"       expected: {expected_result}"
						result = False
						break
					# We expect not to write anything, we didn't, so we continue
					if not expected_result or groups is None or len(groups) == 0 or values is None or len(values) == 0:
						continue
					output_d = secure_read_yaml(path, temporary = True)
					found = True
					for key, value in expected_content.items():
						if key not in output_d:
							found = False
							break
						if output_d[key] != value:
							found = False
					if expected_content in output_d.items():
						found = True
					if not found:
						message = f"{fun_str}() did not yield expected result:\n" \
							   "      inventory:\n" \
							  f"{yaml_dump(output_d, base_indent = 17)}\n" \
							  f" should include: {expected_content}"
						result = False
						break
				except Exception as e:
					if expected_exception is not None:
						if isinstance(e, expected_exception):
							pass
						else:
							message = f"{fun_str}() did not yield expected result:\n" \
								  f"           path: {path} (tempfile)\n" \
								  f"         output: {tmp}\n" \
								  f"       expected: {expected_exception}\n" \
								  f"      exception: {e}"
							result = False
							break
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"      exception: {type(e)}\n"
						result = False
						break
	os.unlink(tf.name)
	return message, result

def test_ansible_set_hostvars(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_set_hostvars
	fun_str = "ansible_helper.ansible_set_hostvars"

	if result:
		with tempfile.TemporaryDirectory() as td, tempfile.NamedTemporaryFile(delete = False) as tf:
			# secure_write_yaml() will open the file
			tf.close()
			# Create an artificial inventory that meets all the requirements we have for these tests
			d = {
				"all": {
					"hosts": {
						"foo": {},
						"bar": None,
					},
				},
			}
			secure_write_yaml(tf.name, d, temporary = True)

			# Indata format:
			# (path, hosts, values, expected_content, expected_result, expected_exception)
			testdata = (
				(tf.name, ["foo"], [("bar", 1), ("baz", "text")],
				 {"foo": {"bar": 1, "baz": "text"}}, True, None),
				(tf.name, ["foo"], [("bar", 1), ("baz", "text")],
				 {"foo": {"bar": 1, "baz": "text"}}, True, None),
				(None, ["foo"], [("bar", 1), ("baz", "text")],
				 {"foo": {"bar": 1, "baz": "text"}}, True, ArgumentValidationError),
				("DoesNotExist", ["foo"], [("bar", 1), ("baz", "text")],
				 {"foo": {"bar": 1, "baz": "text"}}, True, FilePathAuditError),
				(tf.name, ["nonexistinghost"], [("bar", 1), ("baz", "text")],
				 {}, True, None),
				(tf.name, ["bar"], [("value", 42)],
				 {"bar": {"value": 42}}, True, None),
			)
			for indata in testdata:
				path, hosts, values, expected_content, expected_result, expected_exception = indata
				try:
					if (tmp := fun(path, hosts, values, temporary = True)) != expected_result:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"         output: {tmp}\n" \
							  f"       expected: {expected_result}"
						result = False
						break
					# We expect not to write anything, we didn't, so we continue
					if not expected_result or hosts is None or len(hosts) == 0 or values is None or len(values) == 0:
						continue
					output_d = secure_read_yaml(path, temporary = True)
					output_d2 = copy.deepcopy(deep_get(output_d, DictPath("all#hosts"), {}))
					found = True
					for key, value in expected_content.items():
						if key not in output_d:
							found = False
							break
						if output_d[key] != value:
							found = False
					found = True
					for key, value in expected_content.items():
						if not (key in output_d2 and output_d2[key] == value):
							found = False
					if not found:
						message = f"{fun_str}() did not yield expected result:\n" \
							   "      inventory (subset):\n" \
							  f"{yaml_dump(output_d2, base_indent = 17)}\n" \
							  f" should include: {expected_content}"
						result = False
						break
				except Exception as e:
					if expected_exception is not None:
						if isinstance(e, expected_exception):
							pass
						else:
							message = f"{fun_str}() did not yield expected result:\n" \
								  f"           path: {path} (tempfile)\n" \
								  f"         output: {tmp}\n" \
								  f"       expected: {expected_exception}\n" \
								  f"      exception: {e}"
							result = False
							break
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"      exception: {type(e)}\n"
						result = False
						break
	os.unlink(tf.name)
	return message, result

def test_ansible_unset_groupvars(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_unset_groupvars
	fun_str = "ansible_helper.ansible_unset_groupvars"

	if result:
		with tempfile.TemporaryDirectory() as td, tempfile.NamedTemporaryFile(delete = False) as tf:
			# secure_write_yaml() will open the file
			tf.close()
			# Create an artificial inventory that meets all the requirements we have for these tests
			d = {
				"all": {
					"hosts": {
						"foo": {
							"value1": "a string",
							"value2": 42,
						},
						"bar": None,
					},
					"vars": {
						"value3": "another string",
						"value4": 2077,
					},
				},
				"foo": {
					"hosts": {
						"foo": {},
					},
					"vars": {
						"value5": "yet another string",
						"value6": 11945,
					},
				},
				"foobar": {
					"vars": {
						"onlyvar": True,
					},
				},
				"bar": {
					"vars": None,
				},
				"baz": None,
			}
			secure_write_yaml(tf.name, d, temporary = True)


			# Indata format:
			# (path, groups, values, expected_content, expected_result, expected_exception)
			testdata = (
				(tf.name, ["foo"], ["value5"],
				 {"foo": {"hosts": {"foo": {}}, "vars": {"value6": 11945}}}, True, None),
				(tf.name, ["nonexisting"], ["value5"],
				 {}, True, None),
				(tf.name, ["foobar"], ["onlyvar"],
				 {}, True, None),
				(tf.name, ["bar"], ["value5"],
				 {}, True, None),
				(tf.name, ["baz"], ["value5"],
				 {}, True, None),
				(None, ["foo"], ["value5"],
				 None, None, ArgumentValidationError),
			)
			for indata in testdata:
				path, groups, values, expected_content, expected_result, expected_exception = indata
				try:
					if (tmp := fun(path, groups, values, temporary = True)) != expected_result:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"         output: {tmp}\n" \
							  f"       expected: {expected_result}"
						result = False
						break
					# We expect not to write anything, we didn't, so we continue
					if not expected_result or groups is None or len(groups) == 0 or values is None or len(values) == 0:
						continue
					output_d = secure_read_yaml(path, temporary = True)
					found = True
					for key, value in expected_content.items():
						if key not in output_d:
							found = False
							break
						if output_d[key] != value:
							found = False
					if expected_content in output_d.items():
						found = True
					if not found:
						message = f"{fun_str}() did not yield expected result:\n" \
							   "      inventory:\n" \
							  f"{yaml_dump(output_d, base_indent = 17)}\n" \
							  f" should include: {expected_content}"
						result = False
						break
				except Exception as e:
					if expected_exception is not None:
						if isinstance(e, expected_exception):
							pass
						else:
							message = f"{fun_str}() did not yield expected result:\n" \
								  f"           path: {path} (tempfile)\n" \
								  f"         output: {tmp}\n" \
								  f"       expected: {expected_exception}\n" \
								  f"      exception: {e}"
							result = False
							break
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"      exception: {type(e)}\n"
						result = False
						break
	os.unlink(tf.name)
	return message, result

def test_ansible_unset_hostvars(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_unset_hostvars
	fun_str = "ansible_helper.ansible_unset_hostvars"

	if result:
		with tempfile.TemporaryDirectory() as td, tempfile.NamedTemporaryFile(delete = False) as tf:
			# secure_write_yaml() will open the file
			tf.close()
			# Create an artificial inventory that meets all the requirements we have for these tests
			d = {
				"all": {
					"hosts": {
						"foo": {
							"value1": "a string",
							"value2": 42,
						},
						"foobar": {
							"onlyvar": True,
						},
						"bar": None,
					},
					"vars": {
						"value3": "another string",
						"value4": 2077,
					},
				},
				"foo": {
					"hosts": {
						"foo": {},
					},
					"vars": {
						"value5": "yet another string",
						"value6": 11945,
					},
				},
			}
			secure_write_yaml(tf.name, d, temporary = True)


			# Indata format:
			# (path, hosts, values, expected_content, expected_result, expected_exception)
			testdata = (
				(tf.name, ["foo"], ["value1"],
				 {"all": {"hosts": {"foo": {"value2": 42}, "bar": None, "foobar": {"onlyvar": True}}, "vars": {"value3": "another string", "value4": 2077}}}, True, None),
				(tf.name, ["foo"], ["value1"],
				 {"all": {"hosts": {"foo": {"value2": 42}, "bar": None, "foobar": {"onlyvar": True}}, "vars": {"value3": "another string", "value4": 2077}}}, True, None),
				(tf.name, ["nonexisting"], ["onlyvar"],
				 {}, True, None),
				(tf.name, ["foobar"], ["onlyvar"],
				 {}, True, None),
				(None, ["foobar"], ["onlyvar"],
				 {}, False, ArgumentValidationError),
			)
			for indata in testdata:
				path, groups, values, expected_content, expected_result, expected_exception = indata
				try:
					if (tmp := fun(path, groups, values, temporary = True)) != expected_result:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"         output: {tmp}\n" \
							  f"       expected: {expected_result}"
						result = False
						break
					# We expect not to write anything, we didn't, so we continue
					if not expected_result or groups is None or len(groups) == 0 or values is None or len(values) == 0:
						continue
					output_d = secure_read_yaml(path, temporary = True)
					found = True
					for key, value in expected_content.items():
						if key not in output_d:
							found = False
							break
						if output_d[key] != value:
							found = False
					if expected_content in output_d.items():
						found = True
					if not found:
						message = f"{fun_str}() did not yield expected result:\n" \
							   "      inventory:\n" \
							  f"{yaml_dump(output_d, base_indent = 17)}\n" \
							  f" should include: {expected_content}"
						result = False
						break
				except Exception as e:
					if expected_exception is not None:
						if isinstance(e, expected_exception):
							pass
						else:
							message = f"{fun_str}() did not yield expected result:\n" \
								  f"           path: {path} (tempfile)\n" \
								  f"         output: {tmp}\n" \
								  f"       expected: {expected_exception}\n" \
								  f"      exception: {e}"
							result = False
							break
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"      exception: {type(e)}\n"
						result = False
						break
	os.unlink(tf.name)
	return message, result

def test_ansible_add_hosts(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_add_hosts
	fun_str = "ansible_helper.ansible_add_hosts"

	if result:
		with tempfile.TemporaryDirectory() as td, tempfile.NamedTemporaryFile(delete = False) as tf:
			# secure_write_yaml() will open the file
			tf.close()
			# Create inventories that meets all the requirements we have for these tests
			d1 = {
				"all": {
					"hosts": {
						"existing": {},
					},
				},
				"group1": {
				},
			}
			d2 = {
				"all": {
					"hosts": None,
				},
			}

			# Indata format:
			# (path, template, hosts, group, skip_all, expected_content, expected_result, expected_exception)
			testdata = (
				(tf.name, d1, ["host1"], "group1", False,
				 {"all": {"hosts": {"existing": {}, "host1": {}}}, "group1": {"hosts": {"host1": {}}}}, True, None),
				(tf.name, d2, ["host1"], "group1", False,
				 {"all": {"hosts": {"host1": {}}}, "group1": {"hosts": {"host1": {}}}}, True, None),
				(tf.name, d1, ["host1", "host1"], "group2", False,
				 {"all": {"hosts": {"existing": {}, "host1": {}}}, "group1": {}, "group2": {"hosts": {"host1": {}}}}, True, None),
				(tf.name, d1, ["host1", "host1"], "", False,
				 {"all": {"hosts": {"existing": {}, "host1": {}}}, "group1": {}}, True, None),
				(tf.name, d1, ["existing"], "", False,
				 {"all": {"hosts": {"existing": {}}}, "group1": {}}, True, None),
				(tf.name, d1, ["existing"], "group1", True,
				 {"all": {"hosts": {"existing": {}}}, "group1": {"hosts": {"existing": {}}}}, True, None),
				(f"{td}/newinventory.yaml", None, ["host1"], "group1", False,
				 {"all": {"hosts": {"host1": {}}, "vars": {"ansible_python_interpreter": "/usr/bin/python3"}}, "group1": {"hosts": {"host1": {}}}}, True, None),
				(f"{td}/newinventory2.yaml", None, ["host1"], "group1", True,
				 {"group1": {"hosts": {"host1": {}}}}, True, None),
				(None, d1, ["host1"], "group1", False,
				 {"all": {"hosts": {"existing": {}, "host1": {}}}, "group1": {"hosts": {"host1": {}}}}, True, ArgumentValidationError),
			)
			for indata in testdata:
				path, template, hosts, group, skip_all, expected_content, expected_result, expected_exception = indata
				if template:
					secure_write_yaml(tf.name, copy.deepcopy(template), temporary = True)
				try:
					if (tmp := fun(inventory = path, hosts = hosts, group = group, skip_all = skip_all, temporary = True)) != expected_result:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"         output: {tmp}\n" \
							  f"       expected: {expected_result}"
						result = False
						break
					# We expect not to write anything, we didn't, so we continue
					if not expected_result or hosts is None or not hosts:
						continue
					output_d = secure_read_yaml(path, temporary = True)
					found = True
					for key, value in expected_content.items():
						if key not in output_d:
							found = False
							break
						if output_d[key] != value:
							found = False
					if expected_content in output_d.items():
						found = True
					if not found:
						message = f"{fun_str}() did not yield expected result:\n" \
							   "      inventory:\n" \
							  f"{yaml_dump(output_d, base_indent = 17)}\n" \
							  f" should include: {expected_content}"
						result = False
						break
				except Exception as e:
					if expected_exception is not None:
						if isinstance(e, expected_exception):
							pass
						else:
							message = f"{fun_str}() did not yield expected result:\n" \
								  f"           path: {path} (tempfile)\n" \
								  f"         output: {tmp}\n" \
								  f"       expected: {expected_exception}\n" \
								  f"      exception: {e}"
							result = False
							break
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"      exception: {type(e)}\n"
						result = False
						break
	os.unlink(tf.name)
	return message, result

def test_ansible_remove_hosts(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_remove_hosts
	fun_str = "ansible_helper.ansible_remove_hosts"

	if result:
		with tempfile.TemporaryDirectory() as td, tempfile.NamedTemporaryFile(delete = False) as tf:
			# secure_write_yaml() will open the file
			tf.close()
			# Create an artificial inventory that meets all the requirements we have for these tests
			d = {
				"all": {
					"hosts": {
						"host1": {},
					},
				},
				"group1": {
					"hosts": {
						"host1": {},
					},
				},
				"group2": {},
			}

			# Indata format:
			# (path, hosts, group, expected_content, expected_result, expected_exception)
			testdata = (
				(tf.name, ["host1"], "group1",
				 {"all": {"hosts": {"host1": {}}}, "group1": {"hosts": {}}}, True, None),
				(tf.name, ["host2"], "group1",
				 {"all": {"hosts": {"host1": {}}}, "group1": {"hosts": {"host1": {}}}}, True, None),
				(tf.name, ["host1"], "group2",
				 {"all": {"hosts": {"host1": {}}}, "group1": {"hosts": {"host1": {}}}, "group2": {}}, True, None),
				(None, ["host1"], "group1",
				 {"all": {"hosts": {}}, "group1": {}}, True, ArgumentValidationError),
			)
			for indata in testdata:
				secure_write_yaml(tf.name, copy.deepcopy(d), temporary = True)
				path, hosts, group, expected_content, expected_result, expected_exception = indata
				try:
					if (tmp := fun(inventory = path, hosts = hosts, group = group, temporary = True)) != expected_result:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"         output: {tmp}\n" \
							  f"       expected: {expected_result}"
						result = False
						break
					# We expect not to write anything, we didn't, so we continue
					if not expected_result or hosts is None or not hosts:
						continue
					output_d = secure_read_yaml(path, temporary = True)
					found = True
					for key, value in expected_content.items():
						if key not in output_d:
							found = False
							break
						if output_d[key] != value:
							found = False
					if expected_content in output_d.items():
						found = True
					if not found:
						message = f"{fun_str}() did not yield expected result:\n" \
							   "      inventory:\n" \
							  f"{yaml_dump(output_d, base_indent = 17)}\n" \
							  f" should include:\n" \
							  f"{yaml_dump(expected_content, base_indent = 17)}"
						result = False
						break
				except Exception as e:
					if expected_exception is not None:
						if isinstance(e, expected_exception):
							pass
						else:
							message = f"{fun_str}() did not yield expected result:\n" \
								  f"           path: {path} (tempfile)\n" \
								  f"         output: {tmp}\n" \
								  f"       expected: {expected_exception}\n" \
								  f"      exception: {e}"
							result = False
							break
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"      exception: {type(e)}\n"
						result = False
						break
	os.unlink(tf.name)
	return message, result

def test_ansible_remove_groups(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_remove_groups
	fun_str = "ansible_helper.ansible_remove_groups"

	if result:
		with tempfile.TemporaryDirectory() as td, tempfile.NamedTemporaryFile(delete = False) as tf:
			# secure_write_yaml() will open the file
			tf.close()
			# Create an artificial inventory that meets all the requirements we have for these tests
			d = {
				"all": {
					"hosts": {
						"host1": {},
					},
				},
				"group1": {
					"hosts": {
						"host1": {},
					},
				},
				"group2": {
				},
			}

			# Indata format:
			# (path, groups, force, expected_content, expected_result, expected_exception)
			testdata = (
				(tf.name, ["group1"], False,
				 {"all": {"hosts": {"host1": {}}}, "group1": {"hosts": {"host1": {}}}, "group2": {}}, True, None),
				(tf.name, ["group2"], False,
				 {"all": {"hosts": {"host1": {}}}, "group1": {"hosts": {"host1": {}}}}, True, None),
				(td, ["group1"], True,
				 {"all": {"hosts": {"host1": {}}}, "group2": {}}, False, None),
				(tf.name, ["group1"], True,
				 {"all": {"hosts": {"host1": {}}}, "group2": {}}, True, None),
				(tf.name, ["group3"], True,
				 {"all": {"hosts": {"host1": {}}}, "group2": {}}, True, None),
				(None, ["group1"], True,
				 {"all": {"hosts": {"host1": {}}}, "group2": {}}, True, ArgumentValidationError),
			)
			for indata in testdata:
				secure_write_yaml(tf.name, copy.deepcopy(d), temporary = True)
				path, groups, force, expected_content, expected_result, expected_exception = indata
				try:
					if (tmp := fun(inventory = path, groups = groups, force = force, temporary = True)) != expected_result:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"         output: {tmp}\n" \
							  f"       expected: {expected_result}"
						result = False
						break
					# We expect not to write anything, we didn't, so we continue
					if not expected_result or groups is None or not groups:
						continue
					output_d = secure_read_yaml(path, temporary = True)
					found = True
					for key, value in expected_content.items():
						if key not in output_d:
							found = False
							break
						if output_d[key] != value:
							found = False
					if expected_content in output_d.items():
						found = True
					if not found:
						message = f"{fun_str}() did not yield expected result:\n" \
							   "      inventory:\n" \
							  f"{yaml_dump(output_d, base_indent = 17)}\n" \
							  f" should include:\n" \
							  f"{yaml_dump(expected_content, base_indent = 17)}"
						result = False
						break
				except Exception as e:
					if expected_exception is not None:
						if isinstance(e, expected_exception):
							pass
						else:
							message = f"{fun_str}() did not yield expected result:\n" \
								  f"           path: {path} (tempfile)\n" \
								  f"         output: {tmp}\n" \
								  f"       expected: {expected_exception}\n" \
								  f"      exception: {e}"
							result = False
							break
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"           path: {path} (tempfile)\n" \
							  f"      exception: {type(e)}\n"
						result = False
						break
	os.unlink(tf.name)
	return message, result

def test_ansible_get_logs(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_get_logs
	fun_str = "ansible_helper.ansible_get_logs"

	# We're not quite sure whether there are any logs or what they contain,
	# so we just make sure that the return types are acceptable
	if result:
		tmp = fun()
		if not isinstance(tmp, list):
			message = f"{fun_str}() did not yield expected result:\n" \
				  f"           type: {type(tmp)}\n" \
				  f"       expected: {repr(list)}\n"
			result = False
		elif len(tmp) > 0:
			if len(tmp[0]) != 4:
				message = f"{fun_str}() did not yield expected result:\n" \
					  f"       len([0]): {len(tmp[0])}\n" \
					  f"       expected: 4\n"
				result = False
			else:
				filename, name, path, timestamp = tmp[0]
				if not (isinstance(filename, str) and isinstance(name, str) and isinstance(path, str) and isinstance(timestamp, datetime)):
					message = f"{fun_str}() did not yield expected result:\n" \
						  f"          types: [({type(filename)}, {type(name)}, {type(path)}, {type(timestamp)})]" \
						  f"       expected: [({repr(str)}, {repr(str)}, {repr(FilePath)}, {repr(datetime)}]"
					result = False

	return message, result

def test_ansible_extract_failure(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansible_helper.ansible_extract_failure
	fun_str = "ansible_helper.ansible_extract_failure"

	if result:
		# Indata format:
		# (retval, stderr_lines, skipped, unreachable, expected_result, expected_exception)
		testdata = (
			(0, [], False, False, "SUCCESS", None),
			(0, [], True, False, "SKIPPED", None),
			(-1, [], False, True, "UNREACHABLE (unknown reason)", None),
			(-1, ["Failed to connect to the host via ssh: ssh: connect to host host1 port 22: No route to host"], False, True, "NO ROUTE TO HOST", None),
			(-1, ["Failed to connect to the host via ssh: ssh: Could not resolve hostname host2: Name or service not known"], False, True, "COULD NOT RESOLVE", None),
			(-1, ["Failed to connect to the host via ssh: foobar@host3: Permission denied (publickey,password)."], False, True, "PERMISSION DENIED", None),
			(-1, ["Failed to connect to the host via ssh: Some other reason."], False, True, "UNREACHABLE (unknown error)", None),
			# Not sure what the exact timeout message is; this one is artificial.
			(-1, ["Failed to connect to the host via ssh: Connection timed out."], False, True, "CONNECTION TIMED OUT", None),
			(-1, ["The module failed to execute correctly, you probably need to set the interpreter.", "See stdout/stderr for the exact error"], False, False, "MISSING INTERPRETER?", None),
			(-1, ["Some random error we don't know about."], False, False, "FAILED (unknown error)", None),
			(-1, [], False, False, "FAILED (unknown reason)", None),
		)
		for indata in testdata:
			retval, stderr_lines, skipped, unreachable, expected_result, expected_exception = indata
			try:
				if (tmp := fun(retval, stderr_lines, skipped = skipped, unreachable = unreachable)) != expected_result:
					message = f"{fun_str}() did not yield expected result:\n" \
						  f"         retval: {retval}\n" \
						  f"        skipped: {skipped}\n" \
						  f"    unreachable: {unreachable}\n" \
						   "   stderr_lines:\n" \
						  f"{yaml_dump(stderr_lines, base_indent = 17)}\n" \
						  f"         output: {tmp}\n" \
						  f"       expected: {expected_result}\n"
					result = False
					break
			except Exception as e:
				if expected_exception is not None:
					if isinstance(e, expected_exception):
						pass
					else:
						message = f"{fun_str}() did not yield expected result:\n" \
							  f"         retval: {path} (tempfile)\n" \
							  f"        skipped: {path} (tempfile)\n" \
							  f"    unreachable: {path} (tempfile)\n" \
							   "   stderr_lines:\n" \
							  f"{yaml_dump(stderr_lines, base_indent = 17)}\n" \
							  f"      exception: {e}"
						result = False
						break
				else:
					message = f"{fun_str}() did not yield expected result:\n" \
						  f"         retval: {path} (tempfile)\n" \
						  f"        skipped: {path} (tempfile)\n" \
						  f"    unreachable: {path} (tempfile)\n" \
						   "   stderr_lines:\n" \
						  f"{yaml_dump(stderr_lines, base_indent = 17)}\n" \
						  f"      exception: {e}"
					result = False
					break
	return message, result

tests: Dict = {
	("get_playbook_path()",): {
		"callable": test_get_playbook_path,
		"result": None,
	},
	("populate_playbooks_from_paths()",): {
		"callable": test_populate_playbooks_from_paths,
		"result": None,
	},
	("ansible_print_action_summary()",): {
		"callable": test_ansible_print_action_summary,
		"result": None,
	},
	("ansible_get_inventory_dict()",): {
		"callable": test_ansible_get_inventory_dict,
		"result": None,
	},
	("ansible_get_inventory_pretty()",): {
		"callable": test_ansible_get_inventory_pretty,
		"result": None,
	},
	("ansible_get_hosts_by_group()",): {
		"callable": test_ansible_get_hosts_by_group,
		"result": None,
	},
	("ansible_get_groups()",): {
		"callable": test_ansible_get_groups,
		"result": None,
	},
	("ansible_get_groups_by_host()",): {
		"callable": test_ansible_get_groups_by_host,
		"result": None,
	},
	("__ansible_create_inventory()",): {
		"callable": test___ansible_create_inventory,
		"result": None,
	},
	("ansible_create_groups()",): {
		"callable": test_ansible_create_groups,
		"result": None,
	},
	("ansible_set_vars()",): {
		"callable": test_ansible_set_vars,
		"result": None,
	},
	("ansible_set_groupvars()",): {
		"callable": test_ansible_set_groupvars,
		"result": None,
	},
	("ansible_set_hostvars()",): {
		"callable": test_ansible_set_hostvars,
		"result": None,
	},
	("ansible_unset_groupvars()",): {
		"callable": test_ansible_unset_groupvars,
		"result": None,
	},
	("ansible_unset_hostvars()",): {
		"callable": test_ansible_unset_hostvars,
		"result": None,
	},
	("ansible_add_hosts()",): {
		"callable": test_ansible_add_hosts,
		"result": None,
	},
	("ansible_remove_hosts()",): {
		"callable": test_ansible_remove_hosts,
		"result": None,
	},
	("ansible_remove_groups()",): {
		"callable": test_ansible_remove_groups,
		"result": None,
	},
	("ansible_get_logs()",): {
		"callable": test_ansible_get_logs,
		"result": None,
	},
	("ansible_extract_failure()",): {
		"callable": test_ansible_extract_failure,
		"result": None,
	},
}

def main() -> int:
	global tests

	fail = 0
	success = 0
	verbose = False
	failed_testcases = []

	init_ansithemeprint(themefile = None)
	cmtlib.read_cmtconfig()
	deep_set(cmtlib.cmtconfig, DictPath("Ansible#local_playbooks"), TEST_PLAYBOOKS_DIR)

	# How many non-prepare testcases do we have?
	testcount = sum(1 for i in tests if not deep_get(tests[i], DictPath("prepare"), False))
	start_at_task = 0

	i = 1

	while i < len(sys.argv):
		opt = sys.argv[i]
		optarg = None
		if i + 1 < len(sys.argv):
			optarg = sys.argv[i + 1]
		if opt == "--start-at":
			if not (isinstance(optarg, str) and optarg.isnumeric()):
				raise ValueError(f"--start-at TASK requires an integer in the range [0,{testcount}]")
			start_at_task = int(optarg)
			i += 1
		else:
			sys.exit(f"Unknown argument: {opt}")
		i += 1

	for i, test in enumerate(tests):
		if i < start_at_task:
			continue
		ansithemeprint([ANSIThemeString(f"[{i:03}/{testcount - 1:03}]", "emphasis"),
				ANSIThemeString(f" {', '.join(test)}:", "default")])
		message, result = tests[test]["callable"](verbose = verbose)
		if len(message) > 0:
			ansithemeprint([ANSIThemeString("  FAIL", "error"),
					ANSIThemeString(f": {message}", "default")])
		else:
			ansithemeprint([ANSIThemeString("  PASS", "success")])
			success += 1
		tests[test]["result"] = result
		if not result:
			fail += 1
			failed_testcases.append(f"{i}: {', '.join(test)}")

	ansithemeprint([ANSIThemeString("\nSummary:", "header")])
	if fail > 0:
		ansithemeprint([ANSIThemeString(f"  FAIL: {fail}", "error")])
	else:
		ansithemeprint([ANSIThemeString(f"  FAIL: {fail}", "unknown")])
	ansithemeprint([ANSIThemeString(f"  PASS: {success}", "success")])

	if fail > 0:
		ansithemeprint([ANSIThemeString("\nFailed testcases:", "header")])
		for testcase in failed_testcases:
			ansithemeprint([ANSIThemeString("  • ", "separator"),
					ANSIThemeString(testcase, "default")], stderr = True)

	return fail

if __name__ == "__main__":
	main()
