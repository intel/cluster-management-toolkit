#! /bin/sh
# vim: filetype=python
# pylint: disable-next=anomalous-backslash-in-string,line-too-long
''''eval version=$( ls /usr/bin/python3.* | grep '.*[0-9]$' | sort -nr -k2 -t. | head -n1 ) && version=${version##/usr/bin/python3.} && [ ${version} ] && [ ${version} -ge 8 ] && exec /usr/bin/python3.${version} "$0" "$@" || exec /usr/bin/env python3 "$0" "$@"' #'''
__doc__ = "The above hack is to handle distros that don't have /usr/bin/python3 point to the latest version of python3 they provide"
# Requires: python3 (>= 3.8)
#
# Copyright the Cluster Management Toolkit for Kubernetes contributors.
# SPDX-License-Identifier: MIT

import os
import sys
from typing import Dict, Tuple
from unittest import mock

import ansithemeprint
from ansithemeprint import ANSIThemeString

from cmtpaths import DEFAULT_THEME_FILE, THEME_DIR
from cmttypes import FilePath, FilePathAuditError, ProgrammingError

def test_uninitialized_ansithemeprint_functions(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansithemeprint.ansithemearray_to_str

	try:
		fun([ANSIThemeString("foo", "default")])
		message = f"{fun.__name__} did not raise an exception even though theme or themepath are uninitialized"
		result = False
	except ProgrammingError:
		pass

	if result:
		fun = ansithemeprint.ansithemeprint

		try:
			fun([ANSIThemeString("foo", "default")], stderr = False, color = "auto")
			message = f"{fun.__name__} did not raise an exception even though theme or themepath are uninitialized"
			result = False
		except ProgrammingError:
			pass

	return message, result

def test_init_ansithemeprint(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansithemeprint.init_ansithemeprint

	try:
		fun()
	except (FilePathAuditError, FileNotFoundError):
		message = f"{fun.__name__} did not use the fallback theme when no themepath was passed"
		result = False

	if result:
		themepath = FilePath(os.path.join(THEME_DIR, "/etc/passwd/nonexistingtheme.yaml"))
		try:
			fun(themefile = themepath)
			message = f"{fun.__name__} did not raise an exception for invalid path"
			result = False
		except FilePathAuditError as e:
			pass
		except Exception as e:
			message = f"{fun.__name__} raised unexpected exception {e}"
			result = False

	if result:
		themepath = FilePath(os.path.join(THEME_DIR, "nonexistingtheme.yaml"))
		try:
			fun(themefile = themepath)
		except FilePathAuditError as e:
			if "SecurityStatus.DOES_NOT_EXIST" in str(e):
				message = f"{fun.__name__} did not fallback to for a non-existing path"
				result = False
		except Exception as e:
			message = f"{fun.__name__} raised unexpected exception {e}"
			result = False

	if result:
		themepath = DEFAULT_THEME_FILE
		try:
			fun(themefile = themepath)
		except FilePathAuditError:
			message = f"{fun.__name__} raised FilePathAuditError for a valid path"
			result = False

	return message, result

def test_format_error_msg(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ANSIThemeString.format_error_msg

	if result:
		testdata = (
			# Indata format:
			# (indata, expected_result, expected_exception)
			([[("This", "error"), (" is ", "warning"), ("a", "note")], [("new line", "default")]],
			 ("This is a\nnew line",
			  [[ANSIThemeString("This", "error"), ANSIThemeString(" is ", "warning"), ANSIThemeString("a", "note")],
			   [ANSIThemeString("new line", "default")]]),
			 None),
			(1, None, ProgrammingError),
			([1], None, ProgrammingError),
			([[1]], None, ProgrammingError),
			([[("1", "s", "foo")]], None, ProgrammingError),
		)

		for indata, expected_result, expected_exception in testdata:
			try:
				if (tmp := fun(indata)) != expected_result:
					message = f"{fun.__name__}() did not yield expected result:\n" \
						  f"          input: {indata}\n" \
						  f"         output: {tmp}\n" \
						  f"       expected: {expected_result}"
					result = False
					break
			except Exception as e:
				if expected_exception is not None:
					if isinstance(e, expected_exception):
						pass
					else:
						message = f"{fun.__name__}() did not yield expected result:\n" \
							  f"          input: {indata}\n" \
							  f"      exception: {type(e)}\n" \
							  f"       expected: {expected_exception}"
						result = False
						break
				else:
					message = f"{fun.__name__}() did not yield expected result:\n" \
						  f"          input: {indata}\n" \
						  f"      exception: {type(e)}\n" \
						  f"       expected: {expected_result}"
					result = False
					break

	return message, result

def test_ansithemeprint(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansithemeprint.ansithemeprint

	try:
		indata = [ANSIThemeString("  Formatted message (theme: path, color: always)", "path")]
		fun(indata, stderr = False, color = "auto")
	except ProgrammingError:
		message = f"{fun.__name__} raised an exception even though theme and themepath are initialized"
		result = False

	try:
		indata = [ANSIThemeString("  Formatted message (theme: argument, color: always)", "argument")]
		fun(indata, stderr = True, color = "always")
	except ProgrammingError:
		message = f"{fun.__name__} raised an exception even though theme and themepath are initialized"
		result = False

	try:
		indata = [ANSIThemeString("  Formatted message (theme: error, color: never)", "option")]
		fun(indata, stderr = False, color = "never")
	except ProgrammingError:
		message = f"{fun.__name__} raised an exception even though theme and themepath are initialized"
		result = False

	try:
		indata = [ANSIThemeString("  Formatted message (theme: error, color: never)", "ok")]
		fun(indata, stderr = False, color = "incorrect value")
		message = f"{fun.__name__} did not raise an exception for invalid input for color:\n    input: {repr(indata)}"
		result = False
	except ValueError:
		pass

	return message, result

def test_ansithemestring_join_tuple_list(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansithemeprint.ansithemestring_join_tuple_list

	indata = ["one", ANSIThemeString("two", "warning"), "three"]
	formatting = "error"

	tmp = fun(indata, formatting = formatting)
	expected_result = [ANSIThemeString(string="one", themeref="error"), ANSIThemeString(string=", ", themeref="separator"), ANSIThemeString(string="two", themeref="warning"), ANSIThemeString(string=", ", themeref="separator"), ANSIThemeString(string="three", themeref="error")]

	for i, item in enumerate(tmp):
		if tmp[i] != expected_result[i]:
			message = f"{fun.__name__} did not yield a correctly formatted string from valid indata:\n    input: {repr(indata)}"
			result = False

	if result:
		tmp = fun(indata, formatting = formatting, separator = None)
		expected_result = [ANSIThemeString(string="one", themeref="error"), ANSIThemeString(string="two", themeref="warning"), ANSIThemeString(string="three", themeref="error")]
		for i, item in enumerate(tmp):
			if tmp[i] != expected_result[i]:
				message = f"{fun.__name__} did not yield a correctly formatted string from valid indata:\n    input: {repr(indata)}"
				result = False

	return message, result

def test_ansithemestring_basic_operations(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	# Initialise ANSIThemeStrings with invalid string type
	try:
		indata = 1
		tmp = ANSIThemeString(indata, "warning")
		message = f"{fun.__name__}() silently accepted wrong type for themeref:\n       input: {repr(indata)}\n      output: {repr(tmp)}\n    expected: TypeError"
		return message, result
	except TypeError:
		pass

	# Initialise ANSIThemeStrings with invalid themeref type
	try:
		indata = 1
		tmp = ANSIThemeString("test", indata)
		message = f"{fun.__name__}().__init__() silently accepted wrong type for themeref:\n       input: {repr(indata)}\n      output: {repr(tmp)}\n    expected: TypeError"
		return message, result
	except TypeError:
		pass

	indata = ANSIThemeString("mIxEd CAse", "warning")
	expected_result_upper = ANSIThemeString("MIXED CASE", "warning")
	expected_result_lower = ANSIThemeString("mixed case", "warning")
	expected_result_capitalize = ANSIThemeString("Mixed case", "warning")

	if (tmp := indata.upper()) != expected_result_upper:
		message = f"{fun.__name__}.upper() did not yield expected result:\n       input: {repr(indata)}\n      output: {repr(tmp)}\n    expected: {repr(expected_result_upper)}"
		result = False
	if result:
		if (tmp := indata.lower()) != expected_result_lower:
			message = f"{fun.__name__}.lower() did not yield expected result:\n       input: {repr(indata)}\n      output: {repr(tmp)}\n    expected: {repr(expected_result_lower)}"
			result = False
	if result:
		if (tmp := indata.capitalize()) != expected_result_capitalize:
			message = f"{fun.__name__}.capitalize() did not yield expected result:\n       input: {repr(indata)}\n      output: {repr(tmp)}\n    expected: {repr(expected_result_capitalize)}"
			result = False
	if result:
		indata = ANSIThemeString("12345", "warning")
		expected_result_len = 5
		if (tmp := len(indata)) != expected_result_len:
			message = f"{fun.__name__}.len() did not yield expected result:\n       input: {repr(indata)}\n      output: {repr(tmp)}\n    expected: {repr(expected_result_len)}"
			result = False
	if result:
		indata = ANSIThemeString("12345", "warning")
		expected_result = "warning"
		if (tmp := indata.get_themeref()) != expected_result:
			message = f"{fun.__name__}.get_themeref() did not yield expected result:\n       input: {repr(indata)}\n      output: {repr(tmp)}\n    expected: {repr(expected_result_len)}"
			result = False

	return message, result

def test_themearray_ljust(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	indata = [ANSIThemeString("1", "default"), ANSIThemeString("2", "ok"), ANSIThemeString("3", "ok")]
	expected_result = [ANSIThemeString("1", "default"), ANSIThemeString("2", "ok"), ANSIThemeString("3", "ok"), ANSIThemeString("   ", "default")]

	fun = ansithemeprint.themearray_ljust

	if (tmp := fun(indata, 6)) != expected_result:
		message = f"{fun.__name__}(width = 6) returned incorrect output:\n       input: {indata})\n      output: {tmp}\n    expected: {expected_result}"
		result = False

	if (tmp := fun(indata, 2)) != indata:
		message = f"{fun.__name__}(width = 2) returned incorrect output:\n       input: {indata})\n      output: {tmp}\n    expected: {indata}"
		result = False

	return message, result

def test_themearray_len(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	indata = [ANSIThemeString("1", "default"), ANSIThemeString("2", "ok"), ANSIThemeString("3", "ok")]
	expected_result = 3

	fun = ansithemeprint.themearray_len

	if (tmp := fun(indata)) != expected_result:
		message = f"{fun.__name__} returned incorrect output:\n       input: {indata})\n      output: {tmp}\n    expected: {expected_result}"
		result = False

	return message, result

def test_themearray_override_formatting(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	indata = [ANSIThemeString("1", "default"), ANSIThemeString("2", "ok"), ANSIThemeString("3", "ok")]
	formatting = "warning"
	expected_result = [ANSIThemeString("1", "warning"), ANSIThemeString("2", "warning"), ANSIThemeString("3", "warning")]

	fun = ansithemeprint.themearray_override_formatting

	if (tmp := fun(indata, formatting = formatting)) != expected_result:
		message = f"{fun.__name__} returned incorrect output:\n       input: {indata})\n      output: {tmp}\n    expected: {expected_result}"
		result = False

	if result:
		expected_result = [ANSIThemeString("1", "default"), ANSIThemeString("2", "ok"), ANSIThemeString("3", "ok")]
		if (tmp := fun(indata, formatting = None)) != expected_result:
			message = f"{fun.__name__} returned incorrect output:\n       input: {indata})\n      output: {tmp}\n    expected: {expected_result}"
			result = False

	return message, result

def test___themearray_to_raw_string(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	indata = [ANSIThemeString("1", "default"), ANSIThemeString("2", "ok"), ANSIThemeString("3", "ok")]
	expected_result = "123"

	fun = ansithemeprint.__themearray_to_raw_string

	if (tmp := fun(indata)) != expected_result:
		message = f"{fun.__name__} returned incorrect output:\n       input: {indata})\n      output: {tmp}\n    expected: {expected_result}"
		result = False

	if result:
		indata = ["1", ANSIThemeString("2", "ok"), ANSIThemeString("3", "ok")]
		try:
			tmp = fun(indata)
			message = f"{fun.__name__}() silently accepted invalid indata:\n       input: {repr(indata)}\n      output: {repr(tmp)}\n    expected: TypeError"
			result = False
		except TypeError:
			pass

	return message, result

def test_ansithemearray_to_str(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	indata = [ANSIThemeString("1", "default"), ANSIThemeString("2", "ok"), ANSIThemeString("3", "ok")]

	fun = ansithemeprint.ansithemearray_to_str

	# When color in ("always", "auto") we cannot predict the expected outcome since the the output is themed
	try:
		tmp = fun(indata, color = True)
	except TypeError:
		message = f"{fun.__name__}(color = \"always\") failed with valid indata (TypeError):\n    input: {indata}"
		result = False
	except KeyError:
		message = f"{fun.__name__}(color = \"always\") failed with valid indata (KeyError):\n    input: {indata}"
		result = False

	# When color == "never" we know the expected output
	if result:
		expected_result = "123"
		try:
			if (tmp := fun(indata, color = False)) != expected_result:
				message = f"{fun.__name__}(color = \"never\") returned incorrect output:\n       input: {indata})\n      output: {repr(tmp)}\n    expected: {repr(expected_result)}"
				result = False
		except TypeError:
			message = f"{fun.__name__}(color = \"never\") failed with valid indata (TypeError):\n    input: {indata}"
			result = False
		except KeyError:
			message = f"{fun.__name__}(color = \"never\") failed with valid indata (KeyError):\n    input: {indata}"
			result = False

	if result:
		indata = ["1", ANSIThemeString("2", "ok"), ANSIThemeString("3", "ok")]
		try:
			tmp = fun(indata, color = True)
			message = f"{fun.__name__} silently accepted invalid indata:\n    input: {repr(indata)}"
			message = f"{fun.__name__} silently accepted invalid indata:\n       input: {repr(indata)}\n    expected: TypeError"
			result = False
		except TypeError:
			pass

	if result:
		indata = [ANSIThemeString("1", "nonexistingkey"), ANSIThemeString("2", "ok"), ANSIThemeString("3", "ok")]
		try:
			tmp = fun(indata, color = True)
			message = f"{fun.__name__} silently accepted invalid indata:\n       input: {repr(indata)}\n    expected: KeyError"
			result = False
		except KeyError:
			pass

	# This is for coverage only
	if result:
		indata = [ANSIThemeString("", "ok")]
		tmp = fun(indata, color = False)

	return message, result

def test_ansithemeinput(verbose: bool = False, mock_input: bool = True) -> Tuple[str, bool]:
	message = ""
	result = True

	if result:
		# Indata format:
		# (fun, mocked_fun, prompt, mocked_input, color, expected_result, expected_exception)
		testdata = (
			(ansithemeprint.ansithemeinput, "builtins.input",
			 [ANSIThemeString("  Please input the string \"test1\": ", "option")],
			 "always", "test1", "test1", None),
			(ansithemeprint.ansithemeinput, "builtins.input",
			 [ANSIThemeString("  Please input the string \"test2\": ", "option")],
			 "auto", "test2", "test2", None),
			(ansithemeprint.ansithemeinput, "builtins.input",
			 [ANSIThemeString("  Please input the string \"test3\": ", "option")],
			 "never", "test3", "test3", None),
			(ansithemeprint.ansithemeinput, "builtins.input",
			 [ANSIThemeString("  Please input the string \"test3\": ", "option")],
			 "invalid value", "test3", None, ValueError),
			(ansithemeprint.ansithemeinput_password, "getpass.getpass",
			 [ANSIThemeString("  Please input the string \"test4\": ", "option")],
			 "always", "test4", "test4", None),
			(ansithemeprint.ansithemeinput_password, "getpass.getpass",
			 [ANSIThemeString("  Please input the string \"test5\": ", "option")],
			 "auto", "test5", "test5", None),
			(ansithemeprint.ansithemeinput_password, "getpass.getpass",
			 [ANSIThemeString("  Please input the string \"test6\": ", "option")],
			 "never", "test6", "test6", None),
			(ansithemeprint.ansithemeinput_password, "getpass.getpass",
			 [ANSIThemeString("  Please input the string \"test6\": ", "option")],
			 "invalid value", "test6", None, ValueError),
		)

		for indata in testdata:
			fun, mocked_fun, prompt, color, mocked_input, expected_result, expected_exception = indata
			try:
				if mock_input:
					with mock.patch(mocked_fun, return_value = mocked_input):
						tmp = fun(prompt, color = color)
					if tmp != expected_result:
						message = f"{fun.__name__}() returned incorrect result:\n" \
							  f"           prompt: {prompt}\n" \
							  f"     mocked input: {mocked_input}\n" \
							  f"            color: {color}\n" \
							  f"  expected result: {expected_result}"
						result = False
						break
				else:
					tmp = fun(prompt, color = color)
					if tmp != expected_result:
						message = f"{fun.__name__}() returned incorrect result (did you type the correct string?):\n" \
							  f"           prompt: {prompt}\n" \
							  f"            input: {tmp}\n" \
							  f"            color: {color}\n" \
							  f"  expected result: {expected_result}"
						result = False
						break

				if expected_exception is not None:
					message = f"{fun.__name__}() did not yield expected result:\n" \
						  f"           prompt: {prompt}\n" \
						  f"            color: {color}\n" \
						  f"         expected: {expected_exception}\n"
					result = False
					break
			except Exception as e:
				if expected_exception is not None:
					if isinstance(e, expected_exception):
						pass
					else:
						message = f"{fun.__name__}() did not yield expected result:\n" \
							  f"           prompt: {prompt}\n" \
							  f"            color: {color}\n" \
							  f"         expected: {expected_exception}\n"
						result = False
						break
				else:
					message = f"{fun.__name__}() did not yield expected result:\n" \
						  f"           prompt: {prompt}\n" \
						  f"            color: {color}\n" \
						  f"         expected: {expected_result}\n" \
						  f"        exception: {repr(e).split('(')[0]}\n"
					result = False
					break

	return message, result

def test_clear_screen(verbose: bool = False) -> Tuple[str, bool]:
	message = ""
	result = True

	fun = ansithemeprint.clear_screen

	if (tmp := fun()) != 0:
		message = f"{fun.__name__} failed (error code: {tmp}"
		result = False

	return message, result

tests: Dict = {
	("uninitialized ansithemeprint functions", ): {
		"callable": test_uninitialized_ansithemeprint_functions,
		"result": None,
	},
	("init_ansithemeprint", ): {
		"callable": test_init_ansithemeprint,
		"result": None,
	},
	("format_error_msg", ): {
		"callable": test_format_error_msg,
		"result": None,
	},
	("ansithemeprint", ): {
		"callable": test_ansithemeprint,
		"result": None,
	},
	("ansithemestring_join_tuple_list", ): {
		"callable": test_ansithemestring_join_tuple_list,
		"result": None,
	},
	("ansithemestring basic methods", ): {
		"callable": test_ansithemestring_basic_operations,
		"result": None,
	},
	("themearray_ljust", ): {
		"callable": test_themearray_ljust,
		"result": None,
	},
	("themearray_len", ): {
		"callable": test_themearray_len,
		"result": None,
	},
	("themearray_override_formatting", ): {
		"callable": test_themearray_override_formatting,
		"result": None,
	},
	("themearray_to_string", ): {
		"callable": test_ansithemearray_to_str,
		"result": None,
	},
	("__themearray_to_raw_string", ): {
		"callable": test___themearray_to_raw_string,
		"result": None,
	},
	("ansithemeinput", "ansithemeinput_password"): {
		"callable": test_ansithemeinput,
		"result": None,
		"kwargs": {
			"mock_input": True,
		},
	},
}

def main() -> int:
	fail = 0
	success = 0
	verbose = False
	failed_testcases = []

	if len(sys.argv) > 1:
		if "--include-clear" in sys.argv:
			tests[("clear_screen",)] = {
				"callable": test_clear_screen,
				"result": None,
			}
		if "--include-input" in sys.argv:
			tests[("ansithemeinput", "ansithemeinput_password")]["kwargs"]["mock_input"] = False

	for i, test in enumerate(tests):
		print(f"\033[1;37m[{i:03}/{len(tests) - 1:03}]\033[0m {', '.join(test)}:")
		kwargs = tests[test].get("kwargs", {})
		kwargs["verbose"] = verbose
		message, result = tests[test]["callable"](**kwargs)
		if len(message) > 0:
			print(f"  \033[1;31mFAIL\033[0m: {message}")
		else:
			print("  \033[1;32mPASS\033[0m")
			success += 1
		tests[test]["result"] = result
		tests[test]["message"] = message
		if not result:
			failed_testcases.append(f"{i}: {', '.join(test)}")
			fail += 1

	print("\n\033[0;4;37mSummary:\033[0m")
	if fail > 0:
		print(f"\033[1;31m  FAIL: {fail}\033[0m")
	else:
		print(f"\033[0;31m  FAIL: {fail}\033[0m")
	print(f"\033[1;32m  PASS: {success}\033[0m")

	if fail > 0:
		print("\n\033[0;4;37mFailed testcases:\033[0m")
		for testcase in failed_testcases:
			print(f"\033[38;5;240m  â€¢ \033[0m{testcase}", file = sys.stderr)

	return fail

if __name__ == "__main__":
	main()
