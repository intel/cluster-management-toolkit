#! /bin/sh
# vim: ts=4 filetype=python expandtab shiftwidth=4 softtabstop=4 syntax=python
# pylint: disable-next=anomalous-backslash-in-string
''''eval version=$( ls /usr/bin/python3.* | \
    grep '.*[0-9]$' | sort -nr -k2 -t. | head -n1 ) && \
    version=${version##/usr/bin/python3.} && [ ${version} ] && \
    [ ${version} -ge 9 ] && exec /usr/bin/python3.${version} "$0" "$@" || \
    exec /usr/bin/env python3 "$0" "$@"' #'''
# The above hack is to handle distros where /usr/bin/python3
# doesn't point to the latest version of python3 they provide
# Requires: python3 (>= 3.9)
#
# Copyright the Cluster Management Toolkit for Kubernetes contributors.
# SPDX-License-Identifier: MIT

from pathlib import Path, PurePath
import re
import sys
from types import GeneratorType
from typing import Any, cast
try:
    import ruyaml
    ryaml = ruyaml.YAML()
    sryaml = ruyaml.YAML(typ="safe")
    CustomParserError = ruyaml.scanner.ScannerError
except ModuleNotFoundError:  # pragma: no cover
    try:
        import ruamel.yaml as ruyaml
        ryaml = ruyaml.YAML()
        sryaml = ruyaml.YAML(typ="safe")
        CustomParserError = ruyaml.parser.ParserError
    except ModuleNotFoundError:  # pragma: no cover
        sys.exit("ModuleNotFoundError: Could not import ruyaml/ruamel.yaml; "
                 "you may need to (re-)run `cmt-install` or `pip3 install ruyaml/ruamel.yaml`; "
                 "aborting.")

from clustermanagementtoolkit.cmtio import check_path, expand_path, join_securitystatus_set
from clustermanagementtoolkit.cmtio import execute_command, execute_command_with_response
from clustermanagementtoolkit.cmtio import secure_copy, secure_mkdir
from clustermanagementtoolkit.cmtio import secure_read, secure_read_string
from clustermanagementtoolkit.cmtio import secure_rm, secure_rmdir, secure_symlink
from clustermanagementtoolkit.cmtio import secure_which, secure_write_string

from clustermanagementtoolkit.cmtio_yaml import secure_read_yaml, secure_read_yaml_all
from clustermanagementtoolkit.cmtio_yaml import secure_write_yaml

from clustermanagementtoolkit.networkio import verify_checksum

from clustermanagementtoolkit.ansithemeprint import ANSIThemeStr
from clustermanagementtoolkit.ansithemeprint import ansithemeprint, init_ansithemeprint

from clustermanagementtoolkit.cmttypes import deep_get, DictPath, FilePath, FilePathAuditError
from clustermanagementtoolkit.cmttypes import SecurityChecks, SecurityPolicy, SecurityStatus

# from clustermanagementtoolkit.cmtpaths import HOMEDIR

"""
A checker that validates cmtio, cmtio_yaml, and networkio

Usage: ./tests/iotests
"""

CHECKSUMS_DIR = FilePath(PurePath(__file__).parent).joinpath("checksums")
TEST_DIR = FilePath(PurePath(__file__).parent).joinpath("testpaths")


def test_check_path(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.check_path() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    checks = deep_get(checkdata, DictPath("checks"), None)
    message_on_error = deep_get(checkdata, DictPath("verbose"), False)
    expect = deep_get(checkdata, DictPath("expect"))
    expect_exception = deep_get(checkdata, DictPath("expect_exception"), None)
    owner_allowlist = deep_get(checkdata, DictPath("owner_allowlist"))
    parent_owner_allowlist = deep_get(checkdata, DictPath("parent_owner_allowlist"))

    kwargs = {
        "checks": checks,
        "exit_on_critical": False,
        "message_on_error": message_on_error,
    }
    if owner_allowlist is not None:
        kwargs["owner_allowlist"] = owner_allowlist
    if parent_owner_allowlist is not None:
        kwargs["parent_owner_allowlist"] = parent_owner_allowlist
    try:
        result = check_path(path, **kwargs)
        if result != expect:
            return 1, f"expected {expect}, got {result}"
        if expect_exception is not None:
            return 1, f"expected exception {expect_exception}, got {result}"
    except Exception as e:  # pylint: disable=broad-except
        if expect_exception is not None:
            if type(e) != expect_exception:  # noqa: E721 pylint: disable=unidiomatic-typecheck
                return 1, f"expected exception {expect_exception}, got {e}"
        else:
            return 1, f"expected {expect}, got {e}"
    return 0, ""


def test_execute_command(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_read_string() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    command = deep_get(checkdata, DictPath("command"), None)
    env = deep_get(checkdata, DictPath("env"), None)
    comparison = deep_get(checkdata, DictPath("comparison"), 0)
    expect = deep_get(checkdata, DictPath("expect"))
    expect_exception = deep_get(checkdata, DictPath("expect_exception"), None)

    try:
        result = execute_command(command, env=env, comparison=comparison)
        if result != expect:
            return 1, f"expected {expect}, got {result}"
        if expect_exception is not None:
            return 1, f"expected exception {expect_exception}, got {result}"
    except Exception as e:  # pylint: disable=broad-except
        if expect_exception is not None:
            if type(e) != expect_exception:  # noqa: E721 pylint: disable=unidiomatic-typecheck
                return 1, f"expected exception {expect_exception}, got {e}"
        else:
            return 1, f"expected {expect}, got {e}"
    return 0, ""


def test_execute_command_with_response(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_read_string() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    command = deep_get(checkdata, DictPath("command"), None)
    env = deep_get(checkdata, DictPath("env"), None)
    expect = deep_get(checkdata, DictPath("expect"))
    expect_exception = deep_get(checkdata, DictPath("expect_exception"), None)

    try:
        result = execute_command_with_response(command, env=env)
        if result != expect:
            return 1, f"expected {expect}, got {result}"
        if expect_exception is not None:
            return 1, f"expected exception {expect_exception}, got {result}"
    except Exception as e:  # pylint: disable=broad-except
        if expect_exception is not None:
            if type(e) != expect_exception:  # noqa: E721 pylint: disable=unidiomatic-typecheck
                return 1, f"expected exception {expect_exception}, got {e}"
        else:
            return 1, f"expected {expect}, got {e}"
    return 0, ""


def test_secure_read(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_read() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    expect = deep_get(checkdata, DictPath("expect"))

    kwargs = {
        "directory_is_symlink": deep_get(checkdata, DictPath("directory_is_symlink"), False),
        "checks": deep_get(checkdata, DictPath("checks")),
        "read_mode": deep_get(checkdata, DictPath("read_mode"), "r"),
    }

    result = False

    try:
        string = secure_read(path, **kwargs)
        if expect == "string" and isinstance(string, str):
            result = True
        elif expect == "�" and isinstance(string, str) and "�" in string:
            result = True
    except Exception as e:  # pylint: disable=broad-except
        if type(e) == expect:  # noqa: E721 pylint: disable=unidiomatic-typecheck
            result = True
        else:
            string = f"{type(e)}"

    if not result:
        return 1, f"expected {expect}, got {string}"
    return 0, ""


def test_secure_read_string(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_read_string() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    expect = deep_get(checkdata, DictPath("expect"))

    kwargs = {
        "directory_is_symlink": deep_get(checkdata, DictPath("directory_is_symlink"), False),
        "checks": deep_get(checkdata, DictPath("checks")),
    }

    result = False

    try:
        string = secure_read_string(path, **kwargs)
        if expect == "string" and isinstance(string, str):
            result = True
        elif expect == "�" and isinstance(string, str) and "�" in string:
            result = True
    except Exception as e:  # pylint: disable=broad-except
        # pylint: disable-next=unidiomatic-typecheck
        if type(e) == expect:  # noqa: E721
            result = True
        else:
            string = f"{type(e)}"

    if not result:
        return 1, f"expected {expect}, got {string}"
    return 0, ""


def test_secure_read_yaml(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_read_yaml() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    expect = deep_get(checkdata, DictPath("expect"))

    result = False
    string = ""

    try:
        d = secure_read_yaml(path)

        if expect == "dict" and isinstance(d, dict):
            result = True
    except Exception as e:  # pylint: disable=broad-except
        # pylint: disable-next=unidiomatic-typecheck
        if type(e) == expect:  # noqa: E721
            result = True
        else:
            string = f"{type(e)}"

    if not result:
        return 1, f"expected {expect}, got {string}"
    return 0, ""


def test_secure_read_yaml_all(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_read_yaml_all() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    expect = deep_get(checkdata, DictPath("expect"))

    result = False
    string = ""

    try:
        ld = secure_read_yaml_all(path)
        if expect == "generator" and isinstance(ld, GeneratorType):
            result = True
    except Exception as e:  # pylint: disable=broad-except
        # pylint: disable-next=unidiomatic-typecheck
        if type(e) == expect:  # noqa: E721
            result = True
        else:
            string = f"{type(e)}"

    if not result:
        return 1, f"expected {expect}, got {string}"
    return 0, ""


def test_secure_which(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_which() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    expect = deep_get(checkdata, DictPath("expect"))
    executable = deep_get(checkdata, DictPath("executable"), True)
    fallback_allowlist = deep_get(checkdata, DictPath("fallback_allowlist"))
    security_policy = deep_get(checkdata, DictPath("security_policy"))

    result = False

    try:
        string = str(secure_which(path, fallback_allowlist=fallback_allowlist,
                     security_policy=security_policy, executable=executable))
        if expect == "string" and isinstance(string, str):
            result = True
    except Exception as e:  # pylint: disable=broad-except
        # pylint: disable-next=unidiomatic-typecheck
        if type(e) == expect:  # noqa: E721
            result = True
        else:
            string = f"{type(e)}"

    if not result:
        return 1, f"expected {expect}, got {string}"
    return 0, ""


def test_secure_rm(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_rm() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    expect = deep_get(checkdata, DictPath("expect"))

    ignore_non_existing = expect is None

    try:
        secure_rm(path, ignore_non_existing=ignore_non_existing)
        fail = expect
    except FileNotFoundError:
        fail = True
    except FilePathAuditError as e:
        tmp = re.match(r".*Violated rules: (.*)", str(e))
        if tmp is None:
            raise FilePathAuditError("Failed to extract FilePathAuditError violations; "
                                     "this is a programming error.") from e
        violations_string = tmp[1]
        fail = set(violations_string.split(","))

    if fail != expect and expect is not None:
        return 1, f"expected {expect}, got {violations_string}"

    # Even when expect is None it's still a FAIL if the directory stays behind
    if (expect is None or fail != expect) and Path(path).is_file():
        return 1, f"failed to delete file {path}; following testcases are likely to fail."
    return 0, ""


def test_secure_rmdir(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_rmdir() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    expect = deep_get(checkdata, DictPath("expect"))

    ignore_non_existing = expect is None

    try:
        secure_rmdir(path, ignore_non_existing=ignore_non_existing)
        fail = expect
    except FileNotFoundError:
        fail = True
    except FilePathAuditError as e:
        tmp = re.match(r".*Violated rules: (.*)", str(e))
        if tmp is None:
            raise FilePathAuditError("Failed to extract FilePathAuditError violations; "
                                     "this is a programming error.") from e
        violations_string = tmp[1]
        fail = set(violations_string.split(","))

    if fail != expect and expect is not None:
        return 1, f"expected {expect} (type: {type(expect)}), got {fail} (type: {type(fail)})"

    # Even when expect is None it's still a FAIL if the directory stays behind
    if (expect is None or fail != expect) and Path(path).is_dir():
        return 1, f"failed to delete directory {path}; following testcases are likely to fail."
    return 0, ""


def test_secure_mkdir(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_mkdir() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    permissions = deep_get(checkdata, DictPath("permissions"))
    exist_ok = deep_get(checkdata, DictPath("exist_ok"))
    expect = deep_get(checkdata, DictPath("expect"))
    verbose = deep_get(checkdata, DictPath("verbose"), False)

    violations = secure_mkdir(path, permissions=permissions, exist_ok=exist_ok, verbose=verbose)
    violations_set = set(violations)

    if SecurityStatus.PERMISSIONS not in violations_set \
            and SecurityStatus.PARENT_IS_NOT_DIR not in violations_set \
            and SecurityStatus.PARENT_DOES_NOT_EXIST not in violations_set:
        if not Path(path).is_dir():
            violations_set.add(SecurityStatus.DOES_NOT_EXIST)
        else:
            path_stat = Path(path).stat()
            if path_stat.st_mode & 0o777 != permissions:
                violations_set.add(SecurityStatus.PERMISSIONS)

    if violations_set != expect:
        return 1, f"expected {join_securitystatus_set(', ', expect)}, " \
                  f"got {join_securitystatus_set(', ', violations_set)}"
    return 0, ""


def test_secure_copy(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_copy() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    src = deep_get(checkdata, DictPath("src"), "")
    path = deep_get(checkdata, DictPath("path"), "")
    permissions = deep_get(checkdata, DictPath("permissions"))
    expect = deep_get(checkdata, DictPath("expect"))
    verbose = deep_get(checkdata, DictPath("verbose"), False)

    violations = secure_copy(src, path, permissions=permissions, verbose=verbose)
    violations_set = set(violations)

    if SecurityStatus.PERMISSIONS not in violations_set \
            and SecurityStatus.EXISTS not in violations_set \
            and SecurityStatus.PARENT_IS_NOT_DIR not in violations_set \
            and SecurityStatus.PARENT_DOES_NOT_EXIST not in violations_set:
        if not Path(path).is_file():
            violations_set.add(SecurityStatus.DOES_NOT_EXIST)
            violations_set.discard(SecurityStatus.OK)
        else:
            path_stat = Path(path).stat()
            if permissions is not None and path_stat.st_mode & 0o777 != permissions:
                violations_set.add(SecurityStatus.PERMISSIONS)
                violations_set.discard(SecurityStatus.OK)

    if violations_set != expect:
        return 1, f"expected {join_securitystatus_set(', ', expect)}, " \
                  f"got {join_securitystatus_set(', ', violations_set)}"
    return 0, ""


def test_secure_symlink(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_symlink() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    src = deep_get(checkdata, DictPath("src"), "")
    path = deep_get(checkdata, DictPath("path"), "")
    expect = deep_get(checkdata, DictPath("expect"))
    verbose = deep_get(checkdata, DictPath("verbose"), False)

    kwargs = {
        "replace_existing": deep_get(checkdata, DictPath("replace")),
        "verbose": verbose,
    }

    violations = secure_symlink(src, path, **kwargs)
    violations_set = set(violations)

    if violations == [SecurityStatus.OK] and not Path(path).is_symlink():
        violations_set.add(SecurityStatus.DOES_NOT_EXIST)
        violations_set.discard(SecurityStatus.OK)

    if violations_set != expect:
        return 1, f"expected {join_securitystatus_set(', ', expect)}, " \
                  f"got {join_securitystatus_set(', ', violations_set)}"
    return 0, ""


def test_expand_path(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.expand_path() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    search_paths = deep_get(checkdata, DictPath("search_paths"), None)
    fallback = deep_get(checkdata, DictPath("fallback"), "")
    suffixes = deep_get(checkdata, DictPath("suffixes"), None)
    expect = deep_get(checkdata, DictPath("expect"))

    result, status = expand_path(path, fallback=fallback,
                                 search_paths=search_paths, suffixes=suffixes)

    if (result, status) != expect:
        return 1, f"expected {expect}, got ({result}, {status})"
    return 0, ""


def test_secure_write_string(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio.secure_write_string() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    permissions = deep_get(checkdata, DictPath("permissions"))
    expect = deep_get(checkdata, DictPath("expect"))
    write_mode = deep_get(checkdata, DictPath("write_mode"), "w")

    try:
        secure_write_string(path, string="Random text",
                            permissions=permissions, write_mode=write_mode)
        violations_set = {repr(SecurityStatus.OK)}
    except ValueError as e:
        if expect == type(e):
            return 0, ""
        return 1, f"expected {expect}, got {e}"
    except FilePathAuditError as e:
        tmp = re.match(r".*Violated rules: (.*)", str(e))
        if tmp is None:
            raise FilePathAuditError("Failed to extract FilePathAuditError violations; "
                                     "this is a programming error.") from e
        violations_string = tmp[1]
        violations_set = set(violations_string.split(","))

    if violations_set == {repr(SecurityStatus.OK)}:
        if not Path(path).is_file():
            violations_set.add(repr(SecurityStatus.DOES_NOT_EXIST))
        else:
            path_stat = Path(path).stat()
            if path_stat.st_mode & 0o777 != permissions:
                violations_set.add(repr(SecurityStatus.PERMISSIONS))

    if expect is not None and violations_set != expect:
        return 1, f"expected {', '.join(expect)}, got {', '.join(violations_set)}"
    return 0, ""


def test_secure_write_yaml(checkdata: dict) -> tuple[int, str]:
    """
    Test whether cmtio_yaml.secure_write_yaml() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    permissions = deep_get(checkdata, DictPath("permissions"))
    replace_empty = deep_get(checkdata, DictPath("replace_empty"), False)
    replace_null = deep_get(checkdata, DictPath("replace_null"), False)
    expect = deep_get(checkdata, DictPath("expect"))
    write_mode = deep_get(checkdata, DictPath("write_mode"), "w")

    try:
        data = {
            "valid_yaml": True,
        }
        secure_write_yaml(path, data=data, permissions=permissions, write_mode=write_mode,
                          replace_empty=replace_empty, replace_null=replace_null)
        violations_set = {repr(SecurityStatus.OK)}
    except ValueError as e:
        if expect == type(e):
            return 0, ""
        return 1, f"expected {expect}, got {e}"
    except FilePathAuditError as e:
        tmp = re.match(r".*Violated rules: (.*)", str(e))
        if tmp is None:
            raise FilePathAuditError("Failed to extract FilePathAuditError violations; "
                                     "this is a programming error.") from e
        violations_string = tmp[1]
        violations_set = set(violations_string.split(","))

    if violations_set == {repr(SecurityStatus.OK)}:
        if not Path(path).is_file():
            violations_set.add(repr(SecurityStatus.DOES_NOT_EXIST))
        else:
            path_stat = Path(path).stat()
            if path_stat.st_mode & 0o777 != permissions:
                violations_set.add(repr(SecurityStatus.PERMISSIONS))

    if expect is not None and violations_set != expect:
        return 1, f"expected {', '.join(expect)}, got {', '.join(violations_set)}"
    return 0, ""


def test_verify_checksum(checkdata: dict) -> tuple[int, str]:
    """
    Test whether networkio.verify_checksum() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    path = deep_get(checkdata, DictPath("path"), "")
    filename = deep_get(checkdata, DictPath("filename"))
    checksum_type = deep_get(checkdata, DictPath("hash"))
    expect = deep_get(checkdata, DictPath("expect"))

    data = cast(bytearray, secure_read(path, read_mode="rb"))
    if checksum_type is not None:
        csum = cast(bytes, secure_read(FilePath(f"{path}.{checksum_type}"), read_mode="rb"))
    else:
        csum = cast(bytes, secure_read(FilePath(f"{path}.md5"), read_mode="rb"))
    result = verify_checksum(checksum=csum, checksum_type=checksum_type,
                             data=data, filename=filename)

    if result != expect:
        return 1, f"expected {expect}, got {result}"
    return 0, ""


def test_join_securitystatus_set(checkdata: dict) -> tuple[int, str]:
    """
    Test whether join_securitystatus_set() works correctly

        Parameters:
            testcase (str): The name of the testcase
            checkdata (dict): Parameters used by the test
        Returns:
            retval (int): 0 on success, 1 on failure
    """
    status_set = deep_get(checkdata, DictPath("status_set"), set())
    separator = deep_get(checkdata, DictPath("separator"), ", ")
    expect = deep_get(checkdata, DictPath("expect"), "")

    result = join_securitystatus_set(separator=separator, securitystatuses=status_set)

    if result != expect:
        return 1, f"expected {expect}, got {result}"
    return 0, ""


testcases: dict[str, dict[str, Any]] = {
    # Valid paths
    "Correct type (Expected file)": {
        "path": FilePath(f"{TEST_DIR}/05-not_executable.sh"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_NOT_EXECUTABLE,
            SecurityChecks.IS_FILE,
        ],
        "expect": [SecurityStatus.OK],
    },
    "Correct type (Expected directory)": {
        "path": FilePath(f"{TEST_DIR}/13-correct_directory"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_DIR,
        ],
        "expect": [SecurityStatus.OK],
    },
    "Correct type (Expected symlink)": {
        "path": FilePath(f"{TEST_DIR}/02-symlink"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_SYMLINK,
        ],
        "expect": [SecurityStatus.OK],
    },
    "Valid path": {
        "path": FilePath(f"{TEST_DIR}/13-correct_directory/"
                         "16-correct_file_in_correct_permission_directory"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_NOT_EXECUTABLE,
            SecurityChecks.IS_FILE,
        ],
        "expect": [SecurityStatus.OK],
    },
    # Invalid paths
    "File permissions (default checks)": {
        "path": FilePath(f"{TEST_DIR}/01-wrong_permissions"),
        "test": test_check_path,
        "checks": None,
        "expect": [SecurityStatus.PERMISSIONS],
    },
    "File permissions": {
        "path": FilePath(f"{TEST_DIR}/01-wrong_permissions"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_NOT_EXECUTABLE,
            SecurityChecks.IS_FILE,
        ],
        "expect": [SecurityStatus.PERMISSIONS],
    },
    "File path resolution": {
        "path": FilePath(f"{TEST_DIR}/02-symlink"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_NOT_EXECUTABLE,
            SecurityChecks.IS_FILE,
        ],
        "expect": [SecurityStatus.PATH_NOT_RESOLVING_TO_SELF],
    },
    "Directory permissions": {
        "path": FilePath(f"{TEST_DIR}/03-wrong_dir_permissions"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_DIR,
        ],
        "expect": [SecurityStatus.PERMISSIONS],
    },
    "Directory path resolution and destination permissions": {
        "path": FilePath(f"{TEST_DIR}/04-dir_symlink"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_DIR,
        ],
        "expect": [SecurityStatus.PATH_NOT_RESOLVING_TO_SELF, SecurityStatus.PERMISSIONS],
    },
    "Wrong type (Expected file)": {
        "path": FilePath(f"{TEST_DIR}/13-correct_directory"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_NOT_EXECUTABLE,
            SecurityChecks.IS_FILE,
        ],
        "expect": [SecurityStatus.IS_NOT_FILE],
    },
    "Wrong type (Expected directory)": {
        "path": FilePath(f"{TEST_DIR}/05-not_executable.sh"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_DIR,
        ],
        "expect": [SecurityStatus.IS_NOT_DIR],
    },
    "Wrong parent type (Expected directory)": {
        "path": FilePath(f"{TEST_DIR}/05-not_executable.sh/NonExistingFile"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_DIR,
        ],
        "expect": [SecurityStatus.PARENT_IS_NOT_DIR],
    },
    "Wrong type (Expected symlink)": {
        "path": FilePath(f"{TEST_DIR}/08-not_utf8.txt"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_SYMLINK,
        ],
        "expect": [SecurityStatus.IS_NOT_SYMLINK],
    },
    "Not executable (should be)": {
        "path": FilePath(f"{TEST_DIR}/05-not_executable.sh"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_EXECUTABLE,
            SecurityChecks.IS_FILE,
        ],
        "expect": [SecurityStatus.IS_NOT_EXECUTABLE],
    },
    "Executable (shouldn't be)": {
        "path": FilePath(f"{TEST_DIR}/06-executable.sh"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_NOT_EXECUTABLE,
            SecurityChecks.IS_FILE,
        ],
        "expect": [SecurityStatus.IS_EXECUTABLE],
    },
    "Dangling symlink": {
        "path": FilePath(f"{TEST_DIR}/07-dangling_symlink"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
        ],
        "expect": [SecurityStatus.DOES_NOT_EXIST],
    },
    "Non-existing path": {
        "path": FilePath(f"{TEST_DIR}/this path does not exist/not this either"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_NOT_EXECUTABLE,
            SecurityChecks.IS_FILE,
        ],
        "expect": [SecurityStatus.PARENT_DOES_NOT_EXIST],
    },
    "Parent has incorrect permissions": {
        "path": FilePath(f"{TEST_DIR}/03-wrong_dir_permissions/"
                         "14-correct_file_in_wrong_permission_directory"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_FILE,
        ],
        "expect": [SecurityStatus.PARENT_PERMISSIONS],
    },
    "Owner not in allowlist": {
        "path": FilePath("/etc/passwd"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_FILE,
        ],
        "owner_allowlist": [],
        "expect": [SecurityStatus.OWNER_NOT_IN_ALLOWLIST],
    },
    "Parent owner not in allowlist": {
        "path": FilePath("/etc/passwd"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_FILE,
        ],
        "parent_owner_allowlist": [],
        "expect": [SecurityStatus.PARENT_OWNER_NOT_IN_ALLOWLIST],
    },
    "File not readable": {
        "path": FilePath("/etc/shadow"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_FILE,
        ],
        "expect": [SecurityStatus.PERMISSIONS],
    },
    "Parent directory is symlink": {
        "path": FilePath(f"{TEST_DIR}/15-symlink_directory/"
                         "16-correct_file_in_correct_permission_directory"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_NOT_EXECUTABLE,
            SecurityChecks.IS_FILE,
        ],
        "expect": [SecurityStatus.PARENT_PATH_NOT_RESOLVING_TO_SELF],
    },
    "Invalid path (embedded <NUL>)": {
        "path": FilePath(f"{TEST_DIR}/13-correct_directory/"
                         "16-correct_file_in_correct_permission_directory\x00"),
        "test": test_check_path,
        "checks": [
            SecurityChecks.PARENT_RESOLVES_TO_SELF,
            SecurityChecks.RESOLVES_TO_SELF,
            SecurityChecks.OWNER_IN_ALLOWLIST,
            SecurityChecks.PARENT_OWNER_IN_ALLOWLIST,
            SecurityChecks.PERMISSIONS,
            SecurityChecks.PARENT_PERMISSIONS,
            SecurityChecks.EXISTS,
            SecurityChecks.IS_NOT_EXECUTABLE,
            SecurityChecks.IS_FILE,
        ],
        "expect_exception": ValueError,
    },
    # Valid strings
    "Valid UTF-8": {
        "path": FilePath(f"{TEST_DIR}/11-valid_yaml_but_single.yaml"),
        "test": test_secure_read_string,
        "expect": "string",
    },
    "Valid Path, symlinked, directory_is_symlinked = True": {
        "path": FilePath(f"{TEST_DIR}/15-symlink_directory/"
                         "16-correct_file_in_correct_permission_directory"),
        "test": test_secure_read_string,
        "directory_is_symlink": True,
        "checks": None,
        "expect": "string",
    },
    # Invalid strings
    "Invalid UTF-8": {
        "path": FilePath(f"{TEST_DIR}/08-not_utf8.txt"),
        "test": test_secure_read_string,
        "expect": "�",
    },
    # Invalid read-mode
    "Valid Path, invalid read_mode": {
        "path": FilePath(f"{TEST_DIR}/11-valid_yaml_but_single.yaml"),
        "test": test_secure_read,
        "expect": ValueError,
        "read_mode": "z",
    },
    # Invalid paths
    "Non-readable path, directory_is_symlinked = True": {
        "path": FilePath("/var/lib/private/foobar"),
        "test": test_secure_read_string,
        "directory_is_symlink": True,
        "checks": None,
        "expect": FilePathAuditError,
    },
    "Readable path, directory_is_symlinked = True": {
        "path": FilePath("/var/lib/private/foobar"),
        "test": test_secure_read_string,
        "directory_is_symlink": True,
        "checks": None,
        "expect": FilePathAuditError,
    },
    # Valid YAML
    "Valid single YAML (secure_read_yaml)": {
        "path": FilePath(f"{TEST_DIR}/11-valid_yaml_but_single.yaml"),
        "test": test_secure_read_yaml,
        "expect": "dict",
    },
    "Valid multi YAML (secure_read_yaml_all)": {
        "path": FilePath(f"{TEST_DIR}/10-valid_yaml_for_load_all.yaml"),
        "test": test_secure_read_yaml_all,
        "expect": "generator",
    },
    # Invalid YAML
    "Invalid single YAML (secure_read_yaml)": {
        "path": FilePath(f"{TEST_DIR}/09-this_is_not_valid.yaml"),
        "test": test_secure_read_yaml,
        "expect": CustomParserError,
    },
    "Valid multi YAML (secure_read_yaml)": {
        "path": FilePath(f"{TEST_DIR}/10-valid_yaml_for_load_all.yaml"),
        "test": test_secure_read_yaml,
        "expect": ruyaml.composer.ComposerError,
    },
    "Valid single YAML (secure_read_yaml_all)": {
        "path": FilePath(f"{TEST_DIR}/11-valid_yaml_but_single.yaml"),
        "test": test_secure_read_yaml_all,
        "expect": "generator",
    },
    # Note: yaml.safe_load_all() yields a generator;
    # this means that the data is validated when iterated over,
    #       NOT when loaded
    "Invalid YAML (secure_read_yaml_all)": {
        "path": FilePath(f"{TEST_DIR}/12-valid_yaml_followed_by_invalid_yaml.yaml"),
        "test": test_secure_read_yaml_all,
        "expect": "generator",
    },
    "/bin/ssh [fallback=[], STRICT] (secure_which)": {
        "path": FilePath("/bin/ssh"),
        "test": test_secure_which,
        "fallback_allowlist": [],
        "security_policy": SecurityPolicy.STRICT,
        "expect": "string",
    },
    "/bin/ssh [fallback=[], STRICT], executable = False, executable (secure_which)": {
        "path": FilePath("/bin/ssh"),
        "test": test_secure_which,
        "executable": False,
        "fallback_allowlist": [],
        "security_policy": SecurityPolicy.STRICT,
        "expect": "string",
    },
    "/bin/ssh [fallback=[], STRICT], executable = True, non-executable (secure_which)": {
        "path": FilePath("/etc/hosts"),
        "test": test_secure_which,
        "executable": False,
        "fallback_allowlist": [],
        "security_policy": SecurityPolicy.STRICT,
        "expect": "string",
    },
    "/bin/ssh [fallback=[], STRICT], executable = False, non-executable (secure_which)": {
        "path": FilePath("/etc/hosts"),
        "test": test_secure_which,
        "executable": False,
        "fallback_allowlist": [],
        "security_policy": SecurityPolicy.STRICT,
        "expect": "string",
    },
    "/usr/local/bin/ssh [fallback=[], STRICT] (secure_which)": {
        "path": FilePath("/usr/local/bin/ssh"),
        "test": test_secure_which,
        "fallback_allowlist": [],
        "security_policy": SecurityPolicy.STRICT,
        "expect": FileNotFoundError,
    },
    "/usr/local/bin/ssh [fallback=[\"/bin\", \"/sbin\", \"/usr/bin\", \"/usr/sbin\"], "
    "ALLOWLIST_STRICT] (secure_which)": {
        "path": FilePath("/usr/local/bin/ssh"),
        "test": test_secure_which,
        "fallback_allowlist": ["/bin", "/sbin", "/usr/bin", "/usr/sbin"],
        "security_policy": SecurityPolicy.ALLOWLIST_STRICT,
        "expect": "string",
    },
    "/usr/local/bin/ssh [fallback=[\"testpaths/ssh\"], ALLOWLIST_RELAXED] (secure_which)": {
        "path": FilePath("/usr/local/bin/ssh"),
        "test": test_secure_which,
        "fallback_allowlist": [f"{TEST_DIR}/ssh"],
        "security_policy": SecurityPolicy.ALLOWLIST_RELAXED,
        "expect": FileNotFoundError,
    },
    "/usr/local/bin/ssh [fallback=[\"/bin\", \"/sbin\", \"/usr/bin\", \"/usr/sbin\", "
    "\"testpaths/ssh\"], ALLOWLIST_RELAXED] (secure_which)": {
        "path": FilePath("/usr/local/bin/ssh"),
        "test": test_secure_which,
        "fallback_allowlist": ["/bin", "/sbin", "/usr/bin", "/usr/sbin", f"{TEST_DIR}/ssh"],
        "security_policy": SecurityPolicy.ALLOWLIST_RELAXED,
        "expect": "string",
    },
    "/usr/local/bin/doesnotexist [fallback=[\"/bin\", \"/sbin\", \"/usr/bin\", "
    "\"/usr/sbin\", \"testpaths/ssh\"], ALLOWLIST_RELAXED] (secure_which)": {
        "path": FilePath("/usr/local/bin/doesnotexist"),
        "test": test_secure_which,
        "fallback_allowlist": ["/bin", "/sbin", "/usr/bin", "/usr/sbin", f"{TEST_DIR}/ssh"],
        "security_policy": SecurityPolicy.ALLOWLIST_RELAXED,
        "expect": FileNotFoundError,
    },
    # This is not meant as a test; it prepares for the next test
    "0. Deleting testdir as preparation (secure_rmdir)": {
        "prepare": True,
        "path": FilePath(f"{TEST_DIR}/testdir"),
        "test": test_secure_rmdir,
        "expect": None,
    },
    "Deleting non-empty directory (secure_rmdir)": {
        "path": FilePath(f"{TEST_DIR}/13-correct_directory"),
        "test": test_secure_rmdir,
        "expect": {repr(SecurityStatus.DIR_NOT_EMPTY)},
    },
    "Deleting non-directory (secure_rmdir)": {
        "path": FilePath(f"{TEST_DIR}/08-not_utf8.txt"),
        "test": test_secure_rmdir,
        "expect": {repr(SecurityStatus.IS_NOT_DIR)},
    },
    "Creating testdir; exist_ok = True (secure_mkdir)": {
        "path": FilePath(f"{TEST_DIR}/testdir"),
        "test": test_secure_mkdir,
        "exist_ok": True,
        "permissions": 0o700,
        "expect": {SecurityStatus.OK},
    },
    "Creating testdir; exist_ok = False (secure_mkdir)": {
        "path": FilePath(f"{TEST_DIR}/testdir"),
        "test": test_secure_mkdir,
        "exist_ok": False,
        "permissions": 0o700,
        "expect": {SecurityStatus.EXISTS},
    },
    "Creating testdir; parent is not dir (secure_mkdir)": {
        "path": FilePath(f"{TEST_DIR}/08-not_utf8.txt/testdir"),
        "test": test_secure_mkdir,
        "exist_ok": False,
        "permissions": 0o700,
        "expect": {SecurityStatus.PARENT_IS_NOT_DIR},
    },
    "Creating testdir; verbose = True, non-existing parent (secure_mkdir)": {
        "path": FilePath(f"{TEST_DIR}/nonexistingdir/testdir"),
        "test": test_secure_mkdir,
        "exist_ok": False,
        "permissions": 0o700,
        "expect": {SecurityStatus.PARENT_DOES_NOT_EXIST},
    },
    "Deleting testdir (secure_rmdir)": {
        "path": FilePath(f"{TEST_DIR}/testdir"),
        "test": test_secure_rmdir,
        "expect": None,
    },
    # This is not meant as a test; it prepares for the next test
    "1. Deleting testfile as preparation (secure_rm)": {
        "prepare": True,
        "path": FilePath(f"{TEST_DIR}/testfile.txt"),
        "test": test_secure_rm,
        "expect": None,
    },
    # This is not meant as a test; it prepares for the next test
    "2. Deleting testfile.yaml as preparation (secure_rm)": {
        "prepare": True,
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_rm,
        "expect": None,
    },
    "Deleting directory (secure_rm)": {
        "path": FilePath(f"{TEST_DIR}/13-correct_directory"),
        "test": test_secure_rm,
        "expect": {repr(SecurityStatus.IS_NOT_FILE)},
    },
    "Writing text to a file (secure_write_string)": {
        "path": FilePath(f"{TEST_DIR}/testfile.txt"),
        "test": test_secure_write_string,
        "permissions": 0o600,
        "expect": {repr(SecurityStatus.OK)},
    },
    "Writing text to a file, write_mode = \"x\", file exists (secure_write_string)": {
        "path": FilePath(f"{TEST_DIR}/testfile.txt"),
        "test": test_secure_write_string,
        "permissions": 0o600,
        "write_mode": "x",
        "expect": {repr(SecurityStatus.EXISTS)},
    },
    "Writing text to a file, write_mode = \"xb\", file exists (secure_write_string)": {
        "path": FilePath(f"{TEST_DIR}/testfile.txt"),
        "test": test_secure_write_string,
        "permissions": 0o600,
        "write_mode": "xb",
        "expect": {repr(SecurityStatus.EXISTS)},
    },
    "Appending text to a file (secure_write_string)": {
        "path": FilePath(f"{TEST_DIR}/testfile.txt"),
        "test": test_secure_write_string,
        "write_mode": "a",
        "permissions": 0o600,
        "expect": {repr(SecurityStatus.OK)},
    },
    "Writing string to existing file (secure_write_string)": {
        "path": FilePath(f"{TEST_DIR}/testfile.txt"),
        "test": test_secure_write_string,
        "write_mode": "x",
        "permissions": 0o600,
        "expect": {repr(SecurityStatus.EXISTS)},
    },
    "Writing string to a file, wrong write_mode (secure_write_string)": {
        "path": FilePath(f"{TEST_DIR}/testfile.txt"),
        "test": test_secure_write_string,
        "write_mode": "z",
        "permissions": 0o600,
        "expect": ValueError,
    },
    "Writing YAML to a file (secure_write_yaml)": {
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_write_yaml,
        "permissions": 0o600,
        "expect": {repr(SecurityStatus.OK)},
    },
    "Deleting testfile (secure_rm)": {
        "path": FilePath(f"{TEST_DIR}/testfile.txt"),
        "test": test_secure_rm,
        "expect": {SecurityStatus.OK},
    },
    "1. Deleting testfile.yaml (secure_rm)": {
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_rm,
        "expect": {SecurityStatus.OK},
    },
    "Writing YAML to a file, wrong write_mode (secure_write_yaml)": {
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_write_yaml,
        "permissions": 0o600,
        "write_mode": "z",
        "expect": ValueError,
    },
    "Writing YAML to a file, replace empty, replace null (secure_write_yaml)": {
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_write_yaml,
        "replace_empty": True,
        "replace_null": True,
        "permissions": 0o600,
        "expect": {repr(SecurityStatus.OK)},
    },
    "2. Deleting testfile.yaml (secure_rm)": {
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_rm,
        "expect": {SecurityStatus.OK},
    },
    "Copying valid file to valid destination (secure_copy)": {
        "src": FilePath(f"{TEST_DIR}/10-valid_yaml_for_load_all.yaml"),
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_copy,
        "permissions": 0o600,
        "expect": {SecurityStatus.OK},
    },
    "3. Deleting testfile.yaml (secure_rm)": {
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_rm,
        "expect": {SecurityStatus.OK},
    },
    "Copying valid file to valid destination, default permissions (secure_copy)": {
        "src": FilePath(f"{TEST_DIR}/10-valid_yaml_for_load_all.yaml"),
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_copy,
        "expect": {SecurityStatus.OK},
    },
    "Copying valid file to non-valid destination (secure_copy)": {
        "src": FilePath(f"{TEST_DIR}/10-valid_yaml_for_load_all.yaml"),
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_copy,
        "permissions": 0o600,
        "expect": {SecurityStatus.EXISTS},
    },
    "5. Deleting testfile.yaml (secure_rm)": {
        "prepare": True,
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_rm,
        "expect": None,
    },
    "Copying symlinked file (secure_copy)": {
        "src": FilePath(f"{TEST_DIR}/02-symlink"),
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_copy,
        "permissions": 0o600,
        "expect": {SecurityStatus.DOES_NOT_EXIST, SecurityStatus.PATH_NOT_RESOLVING_TO_SELF},
    },
    "Copying file to symlinked directory (secure_copy)": {
        "src": FilePath(f"{TEST_DIR}/15-symlink_directory/"
                        "16-correct_file_in_correct_permission_directory"),
        "path": FilePath(f"{TEST_DIR}/testfile.yaml"),
        "test": test_secure_copy,
        "permissions": 0o600,
        "expect": {SecurityStatus.DOES_NOT_EXIST, SecurityStatus.PARENT_PATH_NOT_RESOLVING_TO_SELF},
    },
    "verify_checksum() (None)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": None,
        "test": test_verify_checksum,
        # A warning about weak checksum is also expected
        "expect": True,
    },
    "verify_checksum() (MD5)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "md5",
        "test": test_verify_checksum,
        # A warning about weak checksum is also expected
        "expect": True,
    },
    "verify_checksum() (SHA)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "sha",
        "test": test_verify_checksum,
        # A warning about weak checksum is also expected
        "expect": True,
    },
    "verify_checksum() (SHA1)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "sha1",
        "test": test_verify_checksum,
        # A warning about weak checksum is also expected
        "expect": True,
    },
    "verify_checksum() (SHA224)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "sha224",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum() (SHA256)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "sha256",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum() (SHA384)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "sha384",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum() (SHA512)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "sha512",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum() without filename (SHA512)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "hash": "sha512",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum() wrong filename (SHA512)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "nonexistingentry",
        "hash": "sha512",
        "test": test_verify_checksum,
        "expect": False,
    },
    "verify_checksum() (Blake 2B)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "blake2b",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum() (Blake 2S)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "blake2s",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum() (SHA3-224)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "sha3_224",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum() (SHA3-256)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "sha3_256",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum() (SHA3-384)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "sha3_384",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum() (SHA3-512)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "sha3_512",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum() (Shake-128)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "shake_128",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum() (Shake-256)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase.txt"),
        "filename": "testcase.txt",
        "hash": "shake_256",
        "test": test_verify_checksum,
        "expect": True,
    },
    "verify_checksum()--invalid (MD5)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "md5",
        "test": test_verify_checksum,
        # A warning about weak checksum is also expected
        "expect": False,
    },
    "verify_checksum()--invalid (SHA)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "sha",
        "test": test_verify_checksum,
        # A warning about weak checksum is also expected
        "expect": False,
    },
    "verify_checksum()--invalid (SHA1)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "sha1",
        "test": test_verify_checksum,
        # A warning about weak checksum is also expected
        "expect": False,
    },
    "verify_checksum()--invalid (SHA224)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "sha224",
        "test": test_verify_checksum,
        "expect": False,
    },
    "verify_checksum()--invalid (SHA256)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "sha256",
        "test": test_verify_checksum,
        "expect": False,
    },
    "verify_checksum()--invalid (SHA384)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "sha384",
        "test": test_verify_checksum,
        "expect": False,
    },
    "verify_checksum()--invalid (SHA512)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "sha512",
        "test": test_verify_checksum,
        "expect": False,
    },
    "verify_checksum()--invalid (Blake 2B)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "blake2b",
        "test": test_verify_checksum,
        "expect": False,
    },
    "verify_checksum()--invalid (Blake 2S)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "blake2s",
        "test": test_verify_checksum,
        "expect": False,
    },
    "verify_checksum()--invalid (SHA3-224)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "sha3_224",
        "test": test_verify_checksum,
        "expect": False,
    },
    "verify_checksum()--invalid (SHA3-256)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "sha3_256",
        "test": test_verify_checksum,
        "expect": False,
    },
    "verify_checksum()--invalid (SHA3-384)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "sha3_384",
        "test": test_verify_checksum,
        "expect": False,
    },
    "verify_checksum()--invalid (SHA3-512)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "sha3_512",
        "test": test_verify_checksum,
        "expect": False,
    },
    "verify_checksum()--invalid (Shake-128)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "shake_128",
        "test": test_verify_checksum,
        "expect": False,
    },
    "verify_checksum()--invalid (Shake-256)": {
        "path": FilePath(f"{CHECKSUMS_DIR}/testcase2.txt"),
        "filename": "testcase.txt",
        "hash": "shake_256",
        "test": test_verify_checksum,
        "expect": False,
    },
    "Symlink valid source, valid destination, replace = True (secure_symlink)": {
        "src": FilePath(f"{TEST_DIR}/05-not_executable.sh"),
        "path": FilePath(f"{TEST_DIR}/test_symlink"),
        "replace": True,
        "test": test_secure_symlink,
        "expect": {SecurityStatus.OK},
    },
    "Symlink valid source, valid destination, replace = False (secure_symlink)": {
        "src": FilePath(f"{TEST_DIR}/05-not_executable.sh"),
        "path": FilePath(f"{TEST_DIR}/test_symlink"),
        "replace": False,
        "test": test_secure_symlink,
        "expect": {SecurityStatus.EXISTS},
    },
    "Symlink valid source, invalid destination (secure_symlink)": {
        "src": FilePath(f"{TEST_DIR}/05-not_executable.sh"),
        "path": FilePath(f"{TEST_DIR}/05-not_executable.sh/destination"),
        "replace": False,
        "test": test_secure_symlink,
        "expect": {SecurityStatus.PARENT_IS_NOT_DIR},
    },
    "Symlink non-existing source parent, valid destination (secure_symlink)": {
        "src": FilePath(f"{TEST_DIR}/this path does not exist/not this either"),
        "path": FilePath(f"{TEST_DIR}/test_symlink"),
        "replace": True,
        "test": test_secure_symlink,
        "expect": {SecurityStatus.PARENT_DOES_NOT_EXIST},
    },
    "Symlink source with parent path resolution issues, valid destination (secure_symlink)": {
        "src": FilePath(f"{TEST_DIR}/15-symlink_directory/"
                        "16-correct_file_in_correct_permission_directory"),
        "path": FilePath(f"{TEST_DIR}/test_symlink"),
        "replace": True,
        "test": test_secure_symlink,
        "expect": {SecurityStatus.PARENT_PATH_NOT_RESOLVING_TO_SELF},
    },
    "5. Writing text to a file as preparation (secure_write_string)": {
        "prepare": True,
        "path": FilePath(f"{TEST_DIR}/testfile.txt"),
        "test": test_secure_write_string,
        "permissions": 0o600,
        "expect": None,
    },
    "Symlink valid source, non-symlink destination, replace = True (secure_symlink)": {
        "src": FilePath(f"{TEST_DIR}/05-not_executable.sh"),
        "path": FilePath(f"{TEST_DIR}/testfile.txt"),
        "replace": True,
        "test": test_secure_symlink,
        "expect": {SecurityStatus.EXISTS},
    },
    "Symlink valid source, non-symlink destination, replace = False (secure_symlink)": {
        "src": FilePath(f"{TEST_DIR}/13-correct_directory/"
                        "16-correct_file_in_correct_permission_directory"),
        "path": FilePath(f"{TEST_DIR}/testfile.txt"),
        "replace": False,
        "test": test_secure_symlink,
        "expect": {SecurityStatus.EXISTS},
    },
    "Symlink valid path, no fallback (expand_path)": {
        "path": f"{TEST_DIR}/02-symlink",
        "fallback": "",
        "test": test_expand_path,
        "expect": (FilePath(f"{TEST_DIR}/02-symlink"), True),
    },
    "Valid path, no fallback (expand_path)": {
        "path": f"{TEST_DIR}/05-not_executable.sh",
        "fallback": "",
        "test": test_expand_path,
        "expect": (FilePath(f"{TEST_DIR}/05-not_executable.sh"), True),
    },
    "None path, no fallback (expand_path)": {
        "path": None,
        "fallback": "",
        "test": test_expand_path,
        "expect": (FilePath(""), False),
    },
    "Empty path, no fallback (expand_path)": {
        "path": "",
        "fallback": "",
        "test": test_expand_path,
        "expect": (FilePath(""), False),
    },
    "None path, fallback (expand_path)": {
        "path": None,
        "fallback": f"{TEST_DIR}/05-not_executable.sh",
        "test": test_expand_path,
        "expect": (FilePath(f"{TEST_DIR}/05-not_executable.sh"), False),
    },
    "Empty path, fallback (expand_path)": {
        "path": "",
        "fallback": f"{TEST_DIR}/05-not_executable.sh",
        "test": test_expand_path,
        "expect": (FilePath(f"{TEST_DIR}/05-not_executable.sh"), False),
    },
    # "Valid path, expand {HOME}/ (expand_path)": {
    #     "path": "{HOME}/.cmt/cmt.yaml",
    #     "fallback": "",
    #     "test": test_expand_path,
    #     "expect": (FilePath(f"{HOMEDIR}/.cmt/cmt.yaml"), True),
    # },
    # "Bare filename, expand {HOME}/ in search_paths (expand_path)": {
    #     "path": "cmt.yaml",
    #     "search_paths": ["{HOME}/.cmt/"],
    #     "fallback": "",
    #     "test": test_expand_path,
    #     "expect": (FilePath(f"{HOMEDIR}/.cmt/cmt.yaml"), True),
    # },
    "Bare filename, /bin in search_paths (expand_path)": {
        "path": "ls",
        "search_paths": ["/bin"],
        "fallback": "",
        "test": test_expand_path,
        "expect": (FilePath("/bin/ls"), True),
    },
    "Bare filename, empty search_paths (expand_path)": {
        "path": "cmt.yaml",
        "fallback": "",
        "test": test_expand_path,
        "expect": (FilePath(""), False),
    },
    # "Valid path, matching suffix (expand_path)": {
    #     "path": f"{HOMEDIR}/.cmt/cmt",
    #     "fallback": "",
    #     "suffixes": [".yaml"],
    #     "test": test_expand_path,
    #     "expect": (FilePath(f"{HOMEDIR}/.cmt/cmt.yaml"), True),
    # },
    # "Valid path, non-matching suffix (expand_path)": {
    #     "path": f"{HOMEDIR}/.cmt/cmt",
    #     "fallback": "",
    #     "suffixes": [".json"],
    #     "test": test_expand_path,
    #     "expect": (FilePath(""), False),
    # },
    # "Valid path, non suffix (expand_path)": {
    #     "path": f"{HOMEDIR}/.cmt/cmt",
    #     "fallback": "",
    #     "test": test_expand_path,
    #     "expect": (FilePath(""), False),
    # },
    "Valid command, no env (execute_command)": {
        "command": [FilePath("/bin/sleep"), "0"],
        "env": None,
        "comparison": 0,
        "test": test_execute_command,
        "expect": True,
    },
    "Non-existing command, no env (execute_command)": {
        "command": [FilePath("/bin/thiscommanddoesnotexist"), "0"],
        "env": None,
        "comparison": 0,
        "test": test_execute_command,
        "expect_exception": FileNotFoundError,
    },
    "Valid command, env (execute_command)": {
        "command": [FilePath("/bin/sleep"), "0"],
        "env": {"PATH": ""},
        "comparison": 0,
        "test": test_execute_command,
        "expect": True,
    },
    "Valid command, no env (execute_command_with_response)": {
        "command": [FilePath("/bin/echo"), "foo"],
        "env": None,
        "test": test_execute_command_with_response,
        "expect": "foo\n",
    },
    "Non-existing command, no env (execute_command_with_response)": {
        "command": [FilePath("/bin/thiscommanddoesnotexist"), "0"],
        "env": None,
        "test": test_execute_command_with_response,
        "expect_exception": FileNotFoundError,
    },
    "Valid command, env (execute_command_with_response)": {
        "command": [FilePath("/bin/echo"), "foo"],
        "env": {"PATH": ""},
        "test": test_execute_command_with_response,
        "expect": "foo\n",
    },
    "A valid set of SecurityStatus, separator \":\"": {
        "status_set": {SecurityStatus.PERMISSIONS, SecurityStatus.IS_NOT_FILE},
        "separator": ":",
        "test": test_join_securitystatus_set,
        "expect": f"<SecurityStatus.PERMISSIONS: {SecurityStatus.PERMISSIONS}>:"
                  f"<SecurityStatus.IS_NOT_FILE: {SecurityStatus.IS_NOT_FILE}>",
    },
}


def main() -> int:
    """
    Main function for the program

        Returns:
            retval (int): number of failed tests
    """
    fail = 0
    success = 0
    failed_testcases = []
    fast_fail = False

    init_ansithemeprint(themefile=None)

    if "--fast-fail" in sys.argv:
        fast_fail = True

    i = 0

    # How many non-prepare testcases do we have?
    # (multiply by 2 since we run with and without verbose)
    testcount = sum(1 for testcase, testcase_data in testcases.items()
                    if not deep_get(testcase_data, DictPath("prepare"), False)) * 2

    print("Running tests with verbose = False:")
    verbose = False
    for testcase, testcase_data in testcases.items():
        prepare = deep_get(testcase_data, DictPath("prepare"), False)
        if not prepare:
            ansithemeprint([ANSIThemeStr(f"[{i:03}/{testcount - 1:03}]", "emphasis"),
                            ANSIThemeStr(f" {testcase}:", "default")])
            testcase_data["index"] = i

        test = deep_get(testcase_data, DictPath("test"))
        testcase_data["verbose"] = verbose
        failed, msg = test(testcase_data)
        testcase_data["result"] = (failed, msg)
        if failed == 1:
            fail += 1
            failed_testcases.append(f"{i}: {testcase}")
            ansithemeprint([ANSIThemeStr("  FAIL", "error"),
                            ANSIThemeStr(f": {msg}", "default")])
            if fast_fail:
                sys.exit(fail)
        else:
            if not prepare:
                ansithemeprint([ANSIThemeStr("  PASS", "success")])
                success += 1

        if not prepare:
            i += 1

    print("\nRunning tests with verbose = True:")
    verbose = True
    for testcase, testcase_data in testcases.items():
        prepare = deep_get(testcase_data, DictPath("prepare"), False)
        if not prepare:
            ansithemeprint([ANSIThemeStr(f"[{i:03}/{testcount - 1:03}]", "emphasis"),
                            ANSIThemeStr(f" {testcase}:", "default")])
            testcase_data["index"] = i

        test = deep_get(testcase_data, DictPath("test"))
        testcase_data["verbose"] = verbose
        failed, msg = test(testcase_data)
        testcase_data["result"] = (failed, msg)
        if failed == 1:
            fail += 1
            failed_testcases.append(f"{i}: {testcase}")
            ansithemeprint([ANSIThemeStr("  FAIL", "error"),
                            ANSIThemeStr(f": {msg}", "default")])
        else:
            if not prepare:
                ansithemeprint([ANSIThemeStr("  PASS", "success")])
                success += 1

        if not prepare:
            i += 1

    ansithemeprint([ANSIThemeStr("\nSummary:", "header")])
    if fail:
        ansithemeprint([ANSIThemeStr(f"  FAIL: {fail}", "error")])
    else:
        ansithemeprint([ANSIThemeStr(f"  FAIL: {fail}", "unknown")])
    ansithemeprint([ANSIThemeStr(f"  PASS: {success}", "success")])

    if fail:
        ansithemeprint([ANSIThemeStr("\nFailed testcases:", "header")])
        for testcase in failed_testcases:
            ansithemeprint([ANSIThemeStr("  • ", "separator"),
                            ANSIThemeStr(testcase, "default")], stderr=True)
        sys.exit(fail)

    return 0


if __name__ == "__main__":
    main()
